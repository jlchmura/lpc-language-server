import { setCommentRange as setCommentRangeWorker, isStatic, visitEachChild as visitEachChildWorker, setTextRange as setTextRangeWorker, Type, Symbol, SymbolLinks, CancellationToken, createSymbolTable, Declaration, EmitTextWriter, ModifierFlags, Node, NodeFlags, objectAllocator, Scanner, Signature, SignatureKind, SymbolFlags, TypeChecker, TypeCheckerHost, TypeFormatFlags, TypeParameter, CheckFlags, TransientSymbol, TransientSymbolLinks, reduceLeft, bindSourceFile, SourceFile, Diagnostic, createDiagnosticCollection, concatenate, forEach, tracing, performance, NodeLinks, NodeCheckFlags, FlowNode, FlowType, clear, SyntaxKind, TracingNode, CallLikeExpression, CallExpression, isCallOrNewExpression, isBinaryExpression, Expression, SignatureDeclaration, SignatureFlags, emptyArray, TypeFlags, IntrinsicType, ObjectFlags, Debug, BinaryExpression, ObjectType, StructuredType, ResolvedType, SymbolTable, IndexInfo, Identifier, nodeIsMissing, createNameResolver, InternalSymbolName, SymbolId, some, DiagnosticMessage, DiagnosticArguments, createDiagnosticForNode, createCompilerDiagnostic, FunctionLikeDeclaration, PropertyDeclaration, isString, isIdentifier, Diagnostics, findLast, SymbolFormatFlags, isAccessExpression, isFunctionExpression, isAliasableExpression, PropertyAssignment, isVariableDeclarationInitializedToBareOrAccessedRequire, mapDefined, arrayFrom, getSpellingSuggestion, symbolName, startsWith, nodeIsSynthesized, declarationNameToString, getCanonicalDiagnostic, DiagnosticCategory, addRelatedInfo, ParameterDeclaration, BindingElement, isSourceFile, isExternalOrCommonJsModule, isBlockOrCatchScoped, length, every, isValidTypeOnlyAliasUseSite, isWriteOnlyAccess, getCombinedNodeFlags, DiagnosticWithLocation, getJSDocDeprecatedTag, findAncestor, isCallLikeExpression, isFunctionLike, ParenthesizedExpression, isAssignmentExpression, isVariableDeclaration, isBindingElement, PropertyAccessExpression, getEnclosingBlockScopeContainer, isPropertyDeclaration, nodeStartsNewLexicalEnvironment, isIterationStatement, isForStatement, getAncestor, ForStatement, pushIfUnique, isAssignmentTarget, PrefixUnaryExpression, PostfixUnaryExpression, isBlock, isExpressionNode, isPropertyAccessExpression, getAssignmentTargetKind, AssignmentKind, isInCompoundLikeAssignment, UnionType, TypeId, UnionReduction, getRootDeclaration, getImmediatelyInvokedFunctionExpression, isSpreadAssignment, isParameter, VariableDeclaration, isFunctionLikeDeclaration, isTypeNode, forEachChild, tryCast, canHaveFlowNode, ElementAccessExpression, RelationComparisonResult, LiteralType, FreshableType, getObjectFlags, DiagnosticMessageChain, setNodeFlags, isCallExpression, LazyNodeCheckFlags, getSourceFileOfNode, canIncludeBindAndCheckDiagnostics, forEachChildRecursively, isDeclarationName, EntityName, JSDocMemberName, canHaveSymbol, isLiteralTypeNode, isElementAccessExpression, isIndexedAccessTypeNode, TypeNode, canHaveJSDoc, FlowFlags, FlowArrayMutation, FlowAssignment, FlowCall, FlowCondition, FlowLabel, FlowReduceLabel, FlowSwitchClause, SwitchStatement, createFileDiagnostic, createDiagnosticForFileFromMessageChain, createDiagnosticForNodeFromMessageChain, VariableStatement, HasModifiers, VariableDeclarationList, Block, isFunctionOrModuleBlock, CaseBlock, ForEachStatement, IndexSignatureDeclaration, Path, HasLocals, BindingPattern, idText, isForEachStatement, getNameOfDeclaration, isArrayBindingPattern, first, BindingName, cast, containsParseError, FunctionDeclaration, getFunctionFlags, getEffectiveReturnTypeNode, FunctionFlags, nodeIsPresent, JSDocSignature, isJSDocSignature, getJSDocRoot, LiteralTypeNode, TypeNodeSyntaxKind, isStatement, UnionOrIntersectionType, getContainingFunction, hasSyntacticModifier, isBindingPattern, sameMap, flatMap, getCheckFlags, singleElementArray, getDeclarationModifierFlagsFromSymbol, Ternary, append, find, isNumericLiteralName, StringLiteralType, contains, isTransientSymbol, addRange, filter, IndexType, getParseTreeNode, isRightSideOfQualifiedNameOrPropertyAccess, isWriteAccess, isRightSideOfAccessExpression, hasEffectiveModifier, getCombinedModifierFlags, isEntityName, PropertyAccessEntityNameExpression, isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName, QualifiedName, getHostSignatureFromJSDoc, or, EntityNameOrEntityNameExpression, isInJSFile, getFirstIdentifier, isQualifiedName, entityNameToString, isCallChain, isEntityNameExpression, isLineBreak, skipTrivia, DiagnosticRelatedInformation, IntLiteralType, FloatLiteralType, createTextWriter, chainDiagnosticMessages, getErrorSpanForNode, ShorthandPropertyAssignment, NodeBuilderFlags, SymbolTracker, TrackedSymbol, ReverseMappedSymbol, TypeMapper, ModuleSpecifierResolutionHost, Program, maybeBind, setEmitFlags, createNodeFactory, NodeFactoryFlags, BaseNodeFactory, Mutable, firstDefined, isComputedPropertyName, isIdentifierText, escapeString, getEmitScriptTarget, factory, EmitFlags, isSingleOrDoubleQuote, canUsePropertyAccess, stripQuotes, DoWhileStatement, BinaryOperatorToken, isLogicalOrCoalescingBinaryOperator, isLogicalOrCoalescingBinaryExpression, isIfStatement, skipParentheses, Statement, PunctuationSyntaxKind, tokenToString, FreshableIntrinsicType, isLiteralExpressionOfObject, getAssignmentDeclarationKind, AssignmentDeclarationKind, ConditionalExpression, isAssignmentOperator, isJSDocTypedefTag, isIntLiteral, skipOuterExpressions, OuterExpressionKinds, isExpression, ObjectLiteralExpression, ArrayLiteralExpression, FunctionExpression, InlineClosureExpression, ObjectLiteralElementLike, hasContextSensitiveParameters, forEachReturnStatement, compareDiagnostics, Comparison, createBinaryExpressionTrampoline, IntLiteral, FloatLiteral, isShorthandPropertyAssignment, isPropertyAccessOrQualifiedName, isPrivateIdentifier, WideningContext, StringLiteral, ReturnStatement, ExpressionStatement, IfStatement, NewExpression, getMembersOfDeclaration, AccessExpression, isThisInitializedDeclaration, setValueDeclaration, comparePaths, getOrUpdate, usingSingleLineStringWriter, createPrinterWithRemoveCommentsNeverAsciiEscape, createPrinterWithRemoveComments, EmitHint, getEffectiveModifierFlags, getEffectiveTypeAnnotationNode, getAssignmentDeclarationPropertyAccessKind, isNamedDeclaration, map, PropertyName, isFloatLiteral, getPropertyNameForPropertyNameNode, isPartOfParameterDeclaration, hasOnlyExpressionInitializer, not, getEffectiveInitializer, isObjectLiteralExpression, isVariableLike, getSelectedEffectiveModifierFlags, AliasDeclarationNode, isBindingElementOfBareOrAccessedRequire, TypeReference, isFunctionExpressionOrInlineClosure, ContextFlags, indexOfNode, InferenceContext, isNodeDescendantOf, ObjectFlagsType, GenericType, ReverseMappedType, AnonymousType, DeferredTypeReference, InstantiationExpressionType, SingleSignatureType, MappedTypeNode, TypeParameterDeclaration, appendIfUnique, TypeMapKind, isPartOfTypeNode, TypeReferenceNode, MappedType, ArrayTypeNode, isParenthesizedTypeNode, isTypeAlias, IndexFlags, InferenceInfo, binarySearch, compareValues, hasInitializer, lastOrUndefined, HasExpressionInitializer, getContainingFunctionOrClassStaticBlock, getSpanOfTokenAtPosition, isJSDocParameterTag, hasRestParameter, isStringLiteral, walkUpBindingElementsAndPatterns, BindableObjectDefinePropertyCall, copyEntries, InterfaceType, isPropertyAssignment, DiagnosticAndArguments, FreshObjectLiteralType, BaseType, firstOrUndefined, SubstitutionType, createPrinterWithDefaults, noTruncationMaximumTruncationLength, defaultMaximumTruncationLength, arrayIsHomogeneous, isIdentifierTypeReference, createMultiMap, addSyntheticLeadingComment, NodeArray, getOriginalNode, getIdentifierTypeArguments, setIdentifierTypeArguments, IndexedAccessTypeNode, forEachEntry, ScriptTarget, SymbolAccessibility, canHaveLocals, getDeclarationOfKind, isClassLike, TypeElement, SymbolAccessibilityResult, SymbolVisibilityResult, LateVisibilityPaintedStatement, isVariableStatement, isLateVisibilityPaintedStatement, isTypeLiteralNode, PlusToken, MinusToken, walkUpParenthesizedTypes, setOriginalNode, countWhere, getNameFromIndexInfo, Modifier, notImplemented, isTypeParameterDeclaration, setParent, CallChain, isLiteralExpression, isStringOrNumericLiteralLike, FlowStart, getPropertyNameFromType, EvolvingArrayType, arrayIsEqualTo, isObjectLiteralMethod, isNonNullAccess, FlowSwitchClauseData, LiteralExpression, CaseClause, DefaultClause, findIndex, orderedRemoveItemAt, UnionTypeNode, ParenthesizedTypeNode, concatenateDiagnosticMessageChains, isDeclaration, InterfaceTypeWithDeclaredMembers, rangeEquals, InferenceFlags, minAndMax, last, IntersectionFlags, IntersectionType, flatten, createDiagnosticMessageChainFromDiagnostic, setTextRangePosEnd, createDiagnosticForNodeArrayFromMessageChain, createDiagnosticForNodeArray, isConstructorDeclaration, TypeComparer, InferencePriority, pathIsRelative, moduleSpecifiers, EmitResolver, isRestParameter, SpreadElement, ElementFlags, ModuleKind, ResolutionMode, ModuleResolutionKind, getResolutionDiagnostic, hasExtension, removeExtension, CloneObjectExpression, isCloneObjectExpression, PropertyAccessChain, OptionalChain, ExportDeclaration, getTextOfNode, InheritDeclaration, isCallLikeOrFunctionLikeExpression, isFunctionExpressionOrArrowFunction, CharacterCodes, Visitor, visitNodes, isGlobalSourceFile, isExternalModule, introducesArgumentsExoticObject, getCombinedLocalAndExportSymbolFlags, StructTypeNode, StructDeclaration, ClassLikeDeclaration, getEffectiveBaseTypeNode, ComputedPropertyName, TypeReferenceType, NodeWithTypeArguments, ClassDeclaration, ClassExpression, TypeLiteralNode, JSDocTypeLiteral, isJSDocTypeLiteral, isInJSDoc, isTypeDeclaration, JSDocTypeAssertion, AssertionExpression, isParenthesizedExpression, getJSDocTypeAssertionType, AccessFlags, NewStructExpression, isJSDocTypeAlias, isAssertionExpression, TypeAssertion, DeclarationName, isKnownSymbol, createEvaluator, EntityNameExpression, evaluatorResult, isStringLiteralLike, SyntheticExpression, ArrayBindingPattern, isTypeUsableAsPropertyName, isPropertyName, tryGetPropertyAccessOrIdentifierToString, IndexedAccessType, MappingLiteralExpression, isOmittedExpression, UnionOrIntersectionTypeNode, PropertySignature, isPropertySignature, LateBoundName, isClassExpression, LateBoundDeclaration, LateBoundBinaryExpressionDeclaration, ElementAccessChain, MappedSymbol, VariableLikeDeclaration, isComputedNonLiteralName, getElementOrPropertyAccessName, findLastIndex, hasAccessorModifier, emptyMap, BytesLiteral, BytesLiteralType, WhileStatement, hasType, getEnclosingContainer, isPropertyNameLiteral, getTextOfIdentifierOrLiteral, JSDocOverloadTag, JSDocCallbackTag, TypePredicate, isIdentifierTypePredicate, HasInitializer, resolvingEmptyArray, getClassLikeDeclarationOfSymbol, ExpressionWithTypeArguments, isNumericLiteral, isInfinityOrNaNString, getEffectiveConstraintOfTypeParameter, isTypeReferenceNode, JSDocParameterTag, canHaveModifiers, modifiersToFlags, JSDocPropertyTag, hasInferredType, isTypePredicateNode, isOptionalDeclaration, getModifiers, isJSDocTypeAssertion, getJSDocThisTag, FunctionTypeNode, createSyntacticTypeNodeBuilder, getJSDocHost, createPrinterWithRemoveCommentsOmitTrailingSemicolon, getTrailingSemicolonDeferringWriter, getThisContainer, JSDocTypeExpression, getEmitFlags, isJSDocTypeExpression, isModifier, visitNode, ConditionalTypeNode, isConditionalTypeNode, skipTypeParentheses, isThisTypeNode, isThisIdentifier, isJSDocAllType, isJSDocUnknownType, isJSDocVariadicType, isJSDocOptionalType, isExpressionWithTypeArguments, isJSDocIndexSignature, isJSDocFunctionType, hasDynamicName, HasIllegalModifiers, modifierToFlag, getJSDocTags, NamedDeclaration, MethodSignature, HasChildren, isInTypeQuery, getEnclosingLocalsContainer, BreakOrContinueStatement, isFunctionLikeOrClassStaticBlockDeclaration, LabeledStatement, JSDocFunctionType, JSDocTypeTag, CaseOrDefaultClause, IndexKind, getInvokedExpression, skipTypeChecking, getParameterSymbolFromJSDoc, isJSDocPropertyTag, TypePredicateNode, TypePredicateKind, createFlowNode, JSDocComment, isArray, isJSDocLinkLike, getJSDocTypeTag, JSDocReturnTag, InstantiableType, isDottedName, BinaryOperator, isLiteralLike, LiteralLikeNode, isJSDocNode, BindableStaticNameExpression, getEffectiveJSDocHost, isLeftHandSideExpression, TupleTypeReference, parseNodeFactory, NamedTupleMember, TupleType, isNewExpression, MappingEntryExpression, BindingElementGrandparent, hasJSDocNodes, thisObjectPragmaToStringLiteral, isSpreadElement, isFunctionDeclaration, createGetCanonicalFileName, getLibRootedFileName, isCommaExpression, RangeExpression, isInlineClosureExpression, isArrayTypeNode, LanguageVariant, VarianceFlags, firstOrUndefinedIterator, arrayOf, TypeVariable, StringMappingType, cartesianProduct, equateValues, replaceElement, JSDocTemplateTag, getTypeParameterFromJsDoc, getEffectiveTypeParameterDeclarations, DeclarationWithTypeParameterChildren, rangeOfNode, isJSDocTemplateTag, tryAddToSet, rangeOfTypeParameters, TypeAliasDeclaration, JSDocTypedefTag, JSDoc, getEffectiveContainerForJSDocTemplateTag, DynamicNamedDeclaration, ConditionalType, ConditionalRoot, TupleTypeNode, isJSDocPropertyLikeTag, JSDocPropertyLikeTag, getJSDocClassTag, InferTypeNode, JSDocThisTag, isValueSignatureDeclaration, getJSDocType, hasJSDocParameterTags, isJSDocThisTag, isSuperCall, getJSDocOverloadTags, DeclarationWithTypeParameters, getStrictOptionValue, isJSDocSatisfiesExpression, getJSDocSatisfiesExpressionType, walkUpParenthesizedExpressions, InterfaceDeclaration, walkUpParenthesizedTypesAndGetParentAndChild, isJSDocNameReference, isJSDocMemberName, isExportAssignment, isTypeReferenceType, isInterfaceDeclaration, isTypeAliasDeclaration, JSDocTypeReferencingNode, scanTokenAtPosition, isJSDocOptionalParameter, SuperAccessExpression, JSDocOptionalType, isSuperAccessExpression, JSDocVariableTag, tryGetJSDocSatisfiesTypeNode, IncludeDirective, isJSDocVariableTag, isIncludeDirective, getSourceFileOrIncludeOfNode, isInIncludeContext, getIncludeDirectiveFilename, isDefineDirective, DefineDirective, SourceFileBase, isThisObjectExpression, isObjectLiteralOrClassExpressionMethodOrAccessor, CatchStatement, IntersectionTypeNode, CatchExpression, NamedObjectTypeNode, isByRefParameterDeclaration, getDeprecatedModifierOrJSDocTag, JSDocLink, JSDocLinkCode, JSDocLinkPlain, isStructDeclaration, isStructTypeNode, isPropertyAccessEntityNameExpression, createPropertyNameNodeForIdentifierOrLiteral, getTextOfJSDocComment, setSyntheticLeadingComments, trimQuotes, JSDocVariadicType, isJSDocCallbackTag, isNewClassExpression, EvaluateExpression, isCatchStatement } from "./_namespaces/lpc";

let nextSymbolId = 1;
let nextNodeId = 1;
let nextMergeId = 1;
let nextFlowId = 1;

const anon = "(anonymous)";

const enum MappedTypeNameTypeKind {
    None,
    Filtering,
    Remapping,
}

const enum ReferenceHint {
    Unspecified,
    Identifier,
    Property,
    ExportAssignment,
    Jsx,
    AsyncFunction,
    ExportImportEquals,
    ExportSpecifier,
    Decorator,
}

/** @internal */
export const enum SignatureCheckMode {
    None = 0,
    BivariantCallback = 1 << 0,
    StrictCallback = 1 << 1,
    IgnoreReturnTypes = 1 << 2,
    StrictArity = 1 << 3,
    StrictTopSignature = 1 << 4,
    Callback = BivariantCallback | StrictCallback,
}

const enum MappedTypeModifiers {
    IncludeReadonly = 1 << 0,
    ExcludeReadonly = 1 << 1,
    IncludeOptional = 1 << 2,
    ExcludeOptional = 1 << 3,
}

type TypeSystemEntity = Node | Symbol | Type | Signature;

const enum TypeSystemPropertyName {
    Type,
    ResolvedBaseConstructorType,
    DeclaredType,
    ResolvedReturnType,
    ImmediateBaseConstraint,
    ResolvedTypeArguments,
    ResolvedBaseTypes,
    WriteType,
    ParameterInitializerContainsUndefined,
}

const enum IterationUse {
    AllowsSyncIterablesFlag = 1 << 0,
    AllowsAsyncIterablesFlag = 1 << 1,
    AllowsStringInputFlag = 1 << 2,
    ForOfFlag = 1 << 3,
    YieldStarFlag = 1 << 4,
    SpreadFlag = 1 << 5,
    DestructuringFlag = 1 << 6,
    PossiblyOutOfBounds = 1 << 7,

    // Spread, Destructuring, Array element assignment
    Element = AllowsSyncIterablesFlag,
    Spread = AllowsSyncIterablesFlag | SpreadFlag,
    Destructuring = AllowsSyncIterablesFlag | DestructuringFlag,

    ForOf = AllowsSyncIterablesFlag | AllowsStringInputFlag | ForOfFlag,
    ForAwaitOf = AllowsSyncIterablesFlag | AllowsAsyncIterablesFlag | AllowsStringInputFlag | ForOfFlag,

    YieldStar = AllowsSyncIterablesFlag | YieldStarFlag,
    AsyncYieldStar = AllowsSyncIterablesFlag | AllowsAsyncIterablesFlag | YieldStarFlag,

    GeneratorReturnType = AllowsSyncIterablesFlag,
    AsyncGeneratorReturnType = AllowsAsyncIterablesFlag,
}

const enum DeclarationMeaning {
    GetAccessor = 1,
    SetAccessor = 2,
    PropertyAssignment = 4,
    Method = 8,
    PrivateStatic = 16,
    GetOrSetAccessor = GetAccessor | SetAccessor,
    PropertyAssignmentOrMethod = PropertyAssignment | Method,
}

const enum IntrinsicTypeKind {
    Uppercase,
    Lowercase,
    Capitalize,
    Uncapitalize,
    NoInfer,
}

const intrinsicTypeKinds: ReadonlyMap<string, IntrinsicTypeKind> = new Map(Object.entries({
    Uppercase: IntrinsicTypeKind.Uppercase,
    Lowercase: IntrinsicTypeKind.Lowercase,
    Capitalize: IntrinsicTypeKind.Capitalize,
    Uncapitalize: IntrinsicTypeKind.Uncapitalize,
    NoInfer: IntrinsicTypeKind.NoInfer,
}));

/** @internal */
export function createTypeChecker(host: TypeCheckerHost): TypeChecker {        
    // Why var? It avoids TDZ checks in the runtime which can be costly.
    // See: https://github.com/microsoft/TypeScript/issues/52924
    /* eslint-disable no-var */
    var deferredDiagnosticsCallbacks: (() => void)[] = [];

    var addLazyDiagnostic = (arg: () => void) => {
        deferredDiagnosticsCallbacks.push(arg);
    };

    // Cancellation that controls whether or not we can cancel in the middle of type checking.
    // In general cancelling is *not* safe for the type checker.  We might be in the middle of
    // computing something, and we will leave our internals in an inconsistent state.  Callers
    // who set the cancellation token should catch if a cancellation exception occurs, and
    // should throw away and create a new TypeChecker.
    //
    // Currently we only support setting the cancellation token when getting diagnostics.  This
    // is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
    // they no longer need the information (for example, if the user started editing again).
    var cancellationToken: CancellationToken | undefined;

    var scanner: Scanner | undefined;

    var Symbol = objectAllocator.getSymbolConstructor();
    var Type = objectAllocator.getTypeConstructor();
    var Signature = objectAllocator.getSignatureConstructor();

    var typeCount = 0;
    var symbolCount = 0;
    var totalInstantiationCount = 0;
    var instantiationCount = 0;
    var instantiationDepth = 0;
    var inlineLevel = 0;
    var currentNode: Node | undefined;
    var varianceTypeParameter: TypeParameter | undefined;
    var isInferencePartiallyBlocked = false;    
    var outofbandVarianceMarkerHandler: ((onlyUnreliable: boolean) => void) | undefined;
    var fileNameMapper = createGetCanonicalFileName(host.useCaseSensitiveFileNames());
    var currentFile: SourceFile;

    var emptySymbols = createSymbolTable();    
    var arrayVariances = [VarianceFlags.Covariant];
    
    var resolutionTargets: TypeSystemEntity[] = [];
    var resolutionResults: boolean[] = [];
    var resolutionPropertyNames: TypeSystemPropertyName[] = [];
    var resolutionStart = 0;
    var inVarianceComputation = false;

    var compilerOptions = host.getCompilerOptions();            
    var languageVersion = getEmitScriptTarget(compilerOptions);
    var languageVariant = host.getDriverType();
    var exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes;
    
    var strictNullChecks = false; 
    var strictPropertyInitialization  = false;
    var strictFunctionTypes = getStrictOptionValue(compilerOptions, "strictFunctionTypes");
    var strickObjectTypes = getStrictOptionValue(compilerOptions, "strictObjectTypes");

    var checkBinaryExpression = createCheckBinaryExpression();
    var emitResolver = createResolver();
    var nodeBuilder = createNodeBuilder();
    var syntacticNodeBuilder = createSyntacticTypeNodeBuilder(compilerOptions, {
        isEntityNameVisible,
        isExpandoFunctionDeclaration,
        // getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,
        requiresAddingImplicitUndefined,
        isUndefinedIdentifierExpression(node: Identifier) {
            Debug.assert(isExpressionNode(node));
            return getSymbolAtLocation(node) === undefinedSymbol;
        },
        isDefinitelyReferenceToGlobalSymbolObject,
    });
    var noImplicitAny = false;
    var strictBindCallApply = false;

    interface DuplicateInfoForSymbol {
        readonly firstFileLocations: Declaration[];
        readonly secondFileLocations: Declaration[];
        readonly isBlockScoped: boolean;
    }
    interface DuplicateInfoForFiles {
        readonly firstFile: SourceFile;
        readonly secondFile: SourceFile;
        /** Key is symbol name. */
        readonly conflictingSymbols: Map<string, DuplicateInfoForSymbol>;
    }
    /** Key is "/path/to/a.ts|/path/to/b.ts". */
    var amalgamatedDuplicates: Map<string, DuplicateInfoForFiles> | undefined;
    var reverseMappedCache = new Map<string, Type | undefined>();
    var reverseHomomorphicMappedCache = new Map<string, Type | undefined>();
    var reverseExpandingFlags = ExpandingFlags.None;
    var ambientModulesCache: Symbol[] | undefined;
    
    var evaluate = createEvaluator({
        evaluateElementAccessExpression,
        evaluateEntityNameExpression,
    });
    
    var globals = createSymbolTable();
    var undefinedSymbol = createSymbol(SymbolFlags.Property, "undefined" as string);
    undefinedSymbol.declarations = [];

    var globalThisSymbol = createSymbol(SymbolFlags.Module, "globalThis" as string, CheckFlags.Readonly);
    globalThisSymbol.exports = globals;
    globalThisSymbol.declarations = [];
    globals.set(globalThisSymbol.name, globalThisSymbol);

    var argumentsSymbol = createSymbol(SymbolFlags.Property, "arguments" as string);
    var requireSymbol = createSymbol(SymbolFlags.Property, "require" as string);    

    /** This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided. */
    var apparentArgumentCount: number | undefined;

    var lastGetCombinedNodeFlagsNode: Node | undefined;
    var lastGetCombinedNodeFlagsResult = NodeFlags.None;
    var lastGetCombinedModifierFlagsNode: Declaration | undefined;
    var lastGetCombinedModifierFlagsResult = ModifierFlags.None;

    var diagnostics = createDiagnosticCollection();
    var suggestionDiagnostics = createDiagnosticCollection();

    var allPotentiallyUnusedIdentifiers = new Map<Path, PotentiallyUnusedIdentifier[]>(); // key is file name
    
    var suggestionCount = 0;
    var maximumSuggestionCount = 10;
    var mergedSymbols: Symbol[] = [];
    var symbolLinks: SymbolLinks[] = [];
    var nodeLinks: NodeLinks[] = [];
    var flowLoopCaches: Map<string, Type>[] = [];
    var flowLoopNodes: FlowNode[] = [];
    var flowLoopKeys: string[] = [];
    var flowLoopTypes: Type[][] = [];
    var sharedFlowNodes: FlowNode[] = [];
    var sharedFlowTypes: FlowType[] = [];
    var flowNodeReachable: (boolean | undefined)[] = [];
    var flowNodePostSuper: (boolean | undefined)[] = [];
    var potentialThisCollisions: Node[] = [];
    var potentialNewTargetCollisions: Node[] = [];
    var potentialWeakMapSetCollisions: Node[] = [];
    var potentialReflectCollisions: Node[] = [];
    //var potentialUnusedRenamedBindingElementsInTypes: BindingElement[] = [];
    var awaitedTypeStack: number[] = [];
    var reverseMappedSourceStack: Type[] = [];
    var reverseMappedTargetStack: Type[] = [];
    //var reverseExpandingFlags = ExpandingFlags.None;
    var cachedTypes = new Map<string, Type>();
    var evolvingArrayTypes: EvolvingArrayType[] = [];
    var undefinedProperties: SymbolTable = new Map();
    
    var flowLoopStart = 0;
    var flowLoopCount = 0;
    var sharedFlowCount = 0;
    var flowAnalysisDisabled = false;
    var flowInvocationCount = 0;
    var lastFlowNode: FlowNode | undefined;
    var lastFlowNodeReachable: boolean;
    var flowTypeCache: Type[] | undefined;
    
    var contextualTypeNodes: Node[] = [];
    var contextualTypes: (Type | undefined)[] = [];
    var contextualIsCache: boolean[] = [];
    var contextualTypeCount = 0;
    var contextualBindingPatterns: BindingPattern[] = [];

    var inferenceContextNodes: Node[] = [];
    var inferenceContexts: (InferenceContext | undefined)[] = [];
    var inferenceContextCount = 0;

    var seenIntrinsicNames = new Set<string>();
   
    var unionOfUnionTypes = new Map<string, Type>();

    var resolveName = createNameResolver({
        compilerOptions,
        requireSymbol,
        argumentsSymbol,
        globals,        
        getSymbolOfDeclaration,
        error,
        getRequiresScopeChangeCache,
        setRequiresScopeChangeCache,
        lookup: getSymbol,
        onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,
        onFailedToResolveSymbol,
        onSuccessfullyResolvedSymbol,
    });

    var resolveNameForSymbolSuggestion = createNameResolver({
        compilerOptions,
        requireSymbol,
        argumentsSymbol,
        globals,
        getSymbolOfDeclaration,
        error,
        getRequiresScopeChangeCache,
        setRequiresScopeChangeCache,
        lookup: getSuggestionForSymbolNameLookup,
    });
    
    const checker: TypeChecker = {
        getTypeOfSymbol,
        getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),
        getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),
        getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),
        getTypeCount: () => typeCount,
        getInstantiationCount: () => totalInstantiationCount,
        getStringType: () => stringType,
        getRelationCacheSizes: () => ({
            assignable: assignableRelation.size,
            identity: identityRelation.size,
            subtype: subtypeRelation.size,
            strictSubtype: strictSubtypeRelation.size,
        }),
        signatureToString,
        getDiagnostics,
        getAliasedSymbol: resolveAlias,
        runWithCurrentFile,
        getDeclaredTypeOfSymbol,
        getSymbolAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return runWithCurrentFile(node, ()=>{
                // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors
                return node ? getSymbolAtLocation(node, /*ignoreErrors*/ true) : undefined;
            });
        },
        getSignatureFromDeclaration: declarationIn => {
            const declaration = getParseTreeNode(declarationIn, isFunctionLike);
            return runWithCurrentFile(declaration, () => {
                return declaration ? getSignatureFromDeclaration(declaration) : undefined;
            });
        },
        evaluate,
        typeToTypeNode: nodeBuilder.typeToTypeNode,
        getAugmentedPropertiesOfType,
        getPropertiesOfType,
        getUnionType,
        getWidenedType,
        symbolToString,
        getRootSymbols,
        getEmitResolver,
        getTypeFromTypeNode,
        getPropertyOfType,
        getMergedSymbol,
        getAllPossiblePropertiesOfTypes,
        isArrayLikeType,
        isNullableType,
        getNullableType,
        getNonNullableType,
        getNonOptionalType: removeOptionalTypeMarker,
        getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),
        isTypeInvalidDueToUnionDiscriminant,
        typeHasCallOrConstructSignatures,
        getReturnTypeOfSignature,
        getTypeOfPropertyAccessExpr: (node: PropertyAccessExpression) => {
            return runWithCurrentFile(node, () => getTypeOfPropertyAccessExpr(node));            
        },
        getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {
            const node = getParseTreeNode(nodeIn, isExpression);
            if (!node) {
                return undefined;
            }
            return runWithCurrentFile(node, () => {
                if (contextFlags! & ContextFlags.Completions) {
                    return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));
                }
                return getContextualType(node, contextFlags);
            });
        },
        getSymbolsInScope: (locationIn, meaning) => {
            const location = getParseTreeNode(locationIn);
            return runWithCurrentFile(location, ()=>{
                return location ? getSymbolsInScope(location, meaning) : [];
            });
        },
        getTypeOfSymbolAtLocation: (symbol, locationIn) => {
            const location = getParseTreeNode(locationIn);
            return runWithCurrentFile(location, ()=>{            
                return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
            });
        },
        isDeclarationVisible,
        getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),
        getShorthandAssignmentValueSymbol: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return runWithCurrentFile(node, ()=>{
                return node ? getShorthandAssignmentValueSymbol(node) : undefined;
            });
        },
        getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {
            const node = getParseTreeNode(nodeIn, isCallLikeExpression);
            return runWithCurrentFile(node, ()=>{
                return node && getContextualTypeForArgumentAtIndex(node, argIndex);
            });
        },
        isUnknownSymbol: symbol => symbol === unknownSymbol,
        isUndefinedSymbol: symbol => symbol === undefinedSymbol,
        getTypeAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return runWithCurrentFile(node, ()=>{
                return node ? runWithCurrentFile(node, () => getTypeOfNode(node)) : errorType;
            });
        },
        getCandidateSignaturesForStringLiteralCompletions,
        runWithCancellationToken: (token, callback) => {
            try {
                cancellationToken = token;
                return callback(checker);
            }
            finally {
                cancellationToken = undefined;
            }
        },
        writeType: (type, enclosingDeclaration, flags, writer) => {
            return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);
        },
        writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {
            return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);
        },
        writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {
            return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);
        },
        symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
        tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {
            const node = getParseTreeNode(nodeIn);
            return runWithCurrentFile(node, () => {
                return node && tryGetThisTypeAt(node, includeGlobalThis, container);
            });
        },        
        getBaseConstraintOfType,
        getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,
        getSignaturesOfType,
        getGlobalDiagnostics,
        getFullyQualifiedName,
        getAccessibleSymbolChain,
        isValidPropertyAccessForCompletions: (nodeIn, type, property) => {
            const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);
            return runWithCurrentFile(node, () => {
                return !!node && isValidPropertyAccessForCompletions(node, type, property);
            });
        },
        isArgumentsSymbol: symbol => symbol === argumentsSymbol,
        resolveExternalModuleSymbol,
        resolveName(name, location, meaning, excludeGlobals) {
            return resolveName(location, (name), meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false, excludeGlobals);
        },
        resolveBaseTypesOfClass,
        getExportsOfModule: getExportsOfModuleAsArray,
        resolveExternalModuleName: moduleSpecifierIn => {
            const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);
            return runWithCurrentFile(moduleSpecifier, () => {
                const type = checkExpression(moduleSpecifier, CheckMode.TypeOnly);
                return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, type, /*ignoreErrors*/ true);
            });
        },
        getContextualTypeForObjectLiteralElement: nodeIn => {
            console.debug("todo - getContextualTypeForObjectLiteralElement");
            return undefined;
            // const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);
            // return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags*/ undefined) : undefined;
        },
        getExpandedParameters,
        getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
        getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),
        getTypePredicateOfSignature,
        hasEffectiveRestParameter,
        isOptionalParameter: nodeIn => {
            const node = getParseTreeNode(nodeIn, isParameter);
            return runWithCurrentFile(node, () => {
                return node ? isOptionalParameter(node) : false;
            });
        },
        symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
        typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
        writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {
            console.log("todo - writeTypePredicate");
            return "";
            // return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);
        },
        createSymbol,
        getSuggestionDiagnostics: (fileIn, ct) => {
            const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");
            if (skipTypeChecking(file, compilerOptions, host)) {
                return emptyArray;
            }

            let diagnostics: DiagnosticWithLocation[] | undefined;
            try {
                // Record the cancellation token so it can be checked later on during checkSourceElement.
                // Do this in a finally block so we can ensure that it gets reset back to nothing after
                // this call is done.
                cancellationToken = ct;

                // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused
                checkSourceFileWithEagerDiagnostics(file);
                Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));

                diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));                

                checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {
                    if (!isInIncludeContext(containingNode) && !containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {
                        (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });
                    }
                });

                return diagnostics || emptyArray;
            }
            finally {
                cancellationToken = undefined;
            }
        },
    };

    var uniqueLiteralType = createIntrinsicType(TypeFlags.Never, "never", /*objectFlags*/ undefined, "unique literal"); // `uniqueLiteralType` is a special `never` flagged by union reduction to behave as a literal
    var uniqueLiteralMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t, () => "(unique literal mapper)"); // replace all type parameters with the unique literal type (disregarding constraints)

    var tupleTypes = new Map<string, GenericType>();
    var unionTypes = new Map<string, UnionType>();
    var intersectionTypes = new Map<string, Type>();

    var anyType = createIntrinsicType(TypeFlags.Any, "mixed", undefined, "mixed");
    var mixedType = anyType;// createIntrinsicType(TypeFlags.Any, "mixed");
    var autoType = createIntrinsicType(TypeFlags.Any, "mixed", ObjectFlags.NonInferrableType, "auto");
    var objectType = createIntrinsicType(TypeFlags.Object, "object", ObjectFlags.NonInferrableType, "object");
    var wildcardType = createIntrinsicType(TypeFlags.Any, "any", /*objectFlags*/ undefined, "wildcard");
    var blockedStringType = createIntrinsicType(TypeFlags.Any, "any", /*objectFlags*/ undefined, "blocked string");
    var errorType = createIntrinsicType(TypeFlags.Any, "error");
    var silentNeverType = createIntrinsicType(TypeFlags.Never, "never", ObjectFlags.NonInferrableType, "silent");
    var stringType = createIntrinsicType(TypeFlags.String, "string");    
    var bytesType = createIntrinsicType(TypeFlags.Bytes, "bytes");
    var closureType = createIntrinsicType(TypeFlags.Object, "closure", ObjectFlags.NonInferrableType, "closure");
    var lwObjectType = createIntrinsicType(TypeFlags.Object, "lwobject", ObjectFlags.NonInferrableType, "lwobject");
    var nullWideningType = strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening");
    var intType = createIntrinsicType(TypeFlags.Number, "int");
    var floatType = createIntrinsicType(TypeFlags.Number, "float");
    var neverType = createIntrinsicType(TypeFlags.Never, "never");
    var missingType = createIntrinsicType(TypeFlags.Undefined, "undefined", /*objectFlags*/ undefined, "missing");
    var unknownType = createIntrinsicType(TypeFlags.Unknown, "unknown");
    var implicitNeverType = createIntrinsicType(TypeFlags.Never, "never", /*objectFlags*/ undefined, "implicit");
    var unresolvedType = createIntrinsicType(TypeFlags.Any, "unresolved");
    var nonInferrableAnyType = createIntrinsicType(TypeFlags.Any, "any", ObjectFlags.ContainsWideningType, "non-inferrable");
    var intrinsicMarkerType = createIntrinsicType(TypeFlags.Any, "intrinsic");
    var undefinedType = createIntrinsicType(TypeFlags.Undefined, "undefined");
    var undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening");
    var nullType = createIntrinsicType(TypeFlags.Null, "null");
    var nonPrimitiveType = createIntrinsicType(TypeFlags.NonPrimitive, "object");
    var voidType = createIntrinsicType(TypeFlags.Void, "void");
    var stringOrNumberType = getUnionType([stringType, intType]);
    var validArithmeticType; // assigned after globals are initialized
    var stringNumberSymbolType = getUnionType([stringType, intType, floatType]); // esSymbolType
    var numberType = getUnionType([intType, floatType]);
    var numberLiteralTypes = new Map<number, IntLiteralType>();
    var stringLiteralTypes = new Map<string, StringLiteralType>();
    var bytesLiteralTypes = new Map<string, BytesLiteralType>();
    var undefinedOrMissingType = /*exactOptionalPropertyTypes ? missingType :*/ undefinedType;
    var unreachableNeverType = createIntrinsicType(TypeFlags.Never, "never", /*objectFlags*/ undefined, "unreachable");

    var restrictiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t, () => "(restrictive mapper)");
    var permissiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags.TypeParameter ? wildcardType : t, () => "(permissive mapper)");

    var emptyTypeLiteralSymbol = createSymbol(SymbolFlags.TypeLiteral, InternalSymbolName.Type);
    emptyTypeLiteralSymbol.members = createSymbolTable();
    var emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray);
    var unknownEmptyObjectType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var unknownUnionType = strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType;
    var emptyGenericType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray) as ObjectType as GenericType;
    emptyGenericType.instantiations = new Map<string, TypeReference>();

    
    var falseType =  createIntrinsicType(TypeFlags.IntLiteral, "0", /*objectFlags*/ undefined, "fresh") as FreshableIntrinsicType;
    var regularFalseType = getNumberLiteralType(0);//createIntrinsicType(TypeFlags.IntLiteral, "0") as FreshableIntrinsicType;
    var trueType = createIntrinsicType(TypeFlags.IntLiteral, "1", /*objectFlags*/ undefined, "fresh") as FreshableIntrinsicType;
    var regularTrueType = getNumberLiteralType(1);//createIntrinsicType(TypeFlags.IntLiteral, "1") as FreshableIntrinsicType;
    trueType.regularType = regularTrueType;
    trueType.freshType = trueType;
    regularTrueType.regularType = regularTrueType;
    regularTrueType.freshType = trueType;
    falseType.regularType = regularFalseType;
    falseType.freshType = falseType;
    regularFalseType.regularType = regularFalseType;
    regularFalseType.freshType = falseType;
    var booleanType = getUnionType([regularFalseType, regularTrueType]);

    var emptyStringType = getStringLiteralType("");
    var zeroType = getNumberLiteralType(0);

    var globalObjectType: ObjectType;
    var globalFunctionType: ObjectType;
    var globalArrayType: GenericType;
    var globalMappingType: GenericType;    
    var globalReadonlyArrayType: GenericType;    
    var globalCallableFunctionType: ObjectType;
    var globalNewableFunctionType: ObjectType;
    var globalStringType: ObjectType;
    var globalIntType: ObjectType;
    var globalFloatType: ObjectType;
    var globalClosureType: ObjectType;
    var autoArrayType: Type;
    var anyArrayType: Type;
    var anyReadonlyArrayType: Type;
    var deferredGlobalNonNullableTypeAlias: Symbol;

    var emptyObjectType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);

    var noTypePredicate = createTypePredicate(TypePredicateKind.Identifier, "<<unresolved>>", 0, anyType);

    var anySignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, anyType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var unknownSignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, errorType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var resolvingSignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, anyType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var silentNeverSignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, silentNeverType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
    var enumNumberIndexInfo = createIndexInfo(numberType, stringType, /*isReadonly*/ true);
    var substitutionTypes = new Map<string, SubstitutionType>();
    var subtypeReductionCache = new Map<string, Type[]>();
    var markerTypes = new Set<number>();

    var noConstraintType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var unknownSymbol = createSymbol(SymbolFlags.Property, "unknown" as string);
    var unresolvedSymbols = new Map<string, TransientSymbol>();
    var errorTypes = new Map<string, Type>();

    var markerSuperType = createTypeParameter();
    var markerSubType = createTypeParameter();
    markerSubType.constraint = markerSuperType;
    var markerOtherType = createTypeParameter();

    var markerSuperTypeForCheck = createTypeParameter();
    var markerSubTypeForCheck = createTypeParameter();
    markerSubTypeForCheck.constraint = markerSuperTypeForCheck;

    var resolvingSymbol = createSymbol(0, InternalSymbolName.Resolving);
    var anyFunctionType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);

    var noConstraintType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var circularConstraintType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    var resolvingDefaultType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);

    var subtypeRelation = new Map<string, RelationComparisonResult>();
    var strictSubtypeRelation = new Map<string, RelationComparisonResult>();
    var assignableRelation = new Map<string, RelationComparisonResult>();
    var comparableRelation = new Map<string, RelationComparisonResult>();
    var identityRelation = new Map<string, RelationComparisonResult>();
    var reportUnreliableMapper = makeFunctionTypeMapper(t => {
        if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {
            outofbandVarianceMarkerHandler(/*onlyUnreliable*/ true);
        }
        return t;
    }, () => "(unmeasurable reporter)");
    var reportUnmeasurableMapper = makeFunctionTypeMapper(t => {
        if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {
            outofbandVarianceMarkerHandler(/*onlyUnreliable*/ false);
        }
        return t;
    }, () => "(unreliable reporter)");

    var markerSuperType = createTypeParameter();
    var markerSubType = createTypeParameter();
    markerSubType.constraint = markerSuperType;
    var markerOtherType = createTypeParameter();

    initializeTypeChecker();

    return checker;

    function initializeTypeChecker() {
        const sefunFile = host.getSourceFile(compilerOptions.sefunFile);

        // Bind all source files and propagate errors
        for (const file of host.getSourceFiles()) {                        
            if (file != sefunFile) {
                bindSourceFile(file, compilerOptions);
            }
        }
        
        // we'll use the globals concept to store driver efuns        
        for (const file of host.getSourceFiles()) {            
            // const isSefunFile = file.fileName === compilerOptions.sefunFile;
            if (file.isDefaultLib) {          
                // bindSourceFile(file, compilerOptions);

                // lib files (non sefun) can't have inherits, so don't bother checking those nodes
                mergeSymbolTable(globals, file.locals!);                
                // also add the efun symbols under a prefix
                const efunSymbol = createSymbol(SymbolFlags.Namespace, InternalSymbolName.EfunNamespace, CheckFlags.Readonly);
                efunSymbol.members = file.locals!;
                globals.set(InternalSymbolName.EfunNamespace, efunSymbol);
            }             
        }

        // now merge sefuns so that they override globals
        
        if (sefunFile) {
            bindSourceFile(sefunFile, compilerOptions);
            getMembersOfFileAndInherits(sefunFile, globals);            
        }

        addUndefinedToGlobalsOrErrorOnRedeclaration();

        getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
        getSymbolLinks(argumentsSymbol).type = anyType;// getGlobalType("IArguments" as string, /*arity*/ 0, /*reportErrors*/ true);
        getSymbolLinks(unknownSymbol).type = errorType;
        getSymbolLinks(globalThisSymbol).type = createObjectType(ObjectFlags.Anonymous, globalThisSymbol);

        // Initialize special types                        
        globalArrayType = getGlobalType("__LS__Array" as string, /*arity*/ 0, /*reportErrors*/ true) as GenericType;        
        globalMappingType = getGlobalType("__LS__Mapping", 0, true) as GenericType;
        globalObjectType = getGlobalType("__LS__Object", 0, true) as GenericType;
        globalFunctionType = getGlobalType("__LS__Function" as string, /*arity*/ 0, /*reportErrors*/ true);
        globalCallableFunctionType = strictBindCallApply && getGlobalType("__LS__CallableFunction" as string, /*arity*/ 0, /*reportErrors*/ true) || globalFunctionType;
        globalNewableFunctionType = strictBindCallApply && getGlobalType("__LS__NewableFunction" as string, /*arity*/ 0, /*reportErrors*/ true) || globalFunctionType;
        globalStringType = getGlobalType("__LS__String" as string, /*arity*/ 0, /*reportErrors*/ true);
        globalIntType = getGlobalType("__LS__Int" as string, /*arity*/ 0, /*reportErrors*/ true);
        globalClosureType = getGlobalType("__LS__Closure" as string, /*arity*/ 0, /*reportErrors*/ true);
        // globalBooleanType = getGlobalType("Boolean" as string, /*arity*/ 0, /*reportErrors*/ true);
        // globalRegExpType = getGlobalType("RegExp" as string, /*arity*/ 0, /*reportErrors*/ true);
        anyArrayType = createArrayType(anyType);

        autoArrayType = createArrayType(autoType);
        if (autoArrayType === emptyObjectType) {
            // autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
            autoArrayType = createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
        }

        globalReadonlyArrayType = getGlobalTypeOrUndefined("__LS__ReadonlyArray" as string, /*arity*/ 1) as GenericType;
        anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
        // globalThisType = getGlobalTypeOrUndefined("ThisType" as string, /*arity*/ 1) as GenericType;

        validArithmeticType = getUnionType([numberType, globalArrayType]); // valid lhs for arithmetic operations
    }        

    /**
     * Runs the callback with the current file set to the file of the given node.
     * @param node node to use for current file lookuop
     * @param callback function to execute
     * @returns result of the callback
     */
    function runWithCurrentFile<T>(node: Node, callback: () => T) {
        let hadCurrentFile = true;
        if (!currentFile) {
            hadCurrentFile = false;
            currentFile = getSourceFileOfNode(node);            
        }
        const result = callback();
        if (!hadCurrentFile) {
            currentFile = undefined!;
        }
        return result;
    }

    function getMembersOfFileAndInherits(file: SourceFile, symbolTable: SymbolTable) {
        const seenImports = new Set<string>();        
        const fileSymbol = getSymbolAtLocation(file, true);
        const fileType = getTypeOfSymbol(fileSymbol, CheckMode.TypeOnly) as InterfaceType;                
        const importStack = [fileType as InterfaceType];
        
        while (importStack.length) {                                                
            const currentType = importStack.shift() as InterfaceType;                        
            if (seenImports.has(currentType.symbol.name)) {
                continue;
            }
            seenImports.add(currentType.symbol.name);

            // resolve base types first, which will also populate members
            const baseTypes = getBaseTypes(currentType);            
            currentType.members.forEach((sefunSymbol, id) => {
                symbolTable.set(id, sefunSymbol);
            });
            importStack.push(...baseTypes as InterfaceType[]);
        }
    }

    function getGlobalType(name: string, arity: 0, reportErrors: true): ObjectType;
    function getGlobalType(name: string, arity: 0, reportErrors: boolean): ObjectType | undefined;
    function getGlobalType(name: string, arity: number, reportErrors: true): GenericType;
    function getGlobalType(name: string, arity: number, reportErrors: boolean): GenericType | undefined;
    function getGlobalType(name: string, arity: number, reportErrors: boolean): ObjectType | undefined {
        // LPC does not have interfaces like TS, so we need to create fake ones.
        // Without these, the type checker will not be able to tell that some types are different (e.g. string assigned to an array)
        
        // get the symbol from efun file
        const valueSymbol = getGlobalSymbol(name, SymbolFlags.Variable, reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined);
        if (!valueSymbol) {
            console.warn("Global symbol not found: " + name);
            return errorType;
        }

        // now rcreate a fake class symbol
        const symbol = createSymbol(SymbolFlags.Class | SymbolFlags.FakeGlobal, name);        
        symbol.valueDeclaration = valueSymbol.valueDeclaration;
        // add a "brand" property so that the type checker can tell these apart.
        symbol.members = createSymbolTable();
        const brandName = name;

        const propSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.FakeGlobal, brandName, CheckFlags.Readonly);
        propSymbol.valueDeclaration = valueSymbol.valueDeclaration;
        symbol.members.set(brandName, propSymbol);
        // finally get the type
        const type = getTypeOfGlobalSymbol(symbol, arity);
        return type;
    }

    function createArrayType(elementType: Type, readonly?: boolean): ObjectType {        
        return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
    }

    function createMappingType(keyType: Type, elementType: Type, readonly?: boolean): ObjectType {
        Debug.assert(readonly !== true, "readonly not supported");
        return createTypeFromGenericGlobalType(globalMappingType, [keyType, elementType]);
    }

    function addUndefinedToGlobalsOrErrorOnRedeclaration() {
        const name = undefinedSymbol.name;
        const targetSymbol = globals.get(name);
        if (targetSymbol) {
            forEach(targetSymbol.declarations, declaration => {
                // checkTypeNameIsReserved will have added better diagnostics for type declarations.
                if (!isTypeDeclaration(declaration)) {
                    diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, (name)));
                }
            });
        }
        else {
            globals.set(name, undefinedSymbol);
        }
    }

    function getGlobalTypeOrUndefined(name: string, arity = 0): ObjectType | undefined {
        const symbol = getGlobalSymbol(name, SymbolFlags.Type, /*diagnostic*/ undefined);
        return symbol && getTypeOfGlobalSymbol(symbol, arity) as GenericType;
    }

    /**
     * Instantiates a global type that is generic with some element type, and returns that instantiation.
     */
    function createTypeFromGenericGlobalType(genericGlobalType: GenericType, typeArguments: readonly Type[]): ObjectType {
        return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
    }

    function getGlobalTypeSymbol(name: string, reportErrors: boolean, symbolType = SymbolFlags.Variable): Symbol | undefined {
        return getGlobalSymbol(name, symbolType, reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined);
    }

    function getGlobalSymbol(name: string, meaning: SymbolFlags, diagnostic: DiagnosticMessage | undefined): Symbol | undefined {
        // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
        return resolveName(/*location*/ undefined, name, meaning, diagnostic, /*isUse*/ false, /*excludeGlobals*/ false);
    }

    function getTypeOfGlobalSymbol(symbol: Symbol | undefined, arity: number): ObjectType {
        function getTypeDeclaration(symbol: Symbol): Declaration | undefined {
            const declarations = symbol.declarations;            
            if (declarations) {
                for (const declaration of declarations) {
                    switch (declaration.kind) {                        
                        case SyntaxKind.ClassDeclaration:
                        case SyntaxKind.InterfaceDeclaration:
                        // case SyntaxKind.EnumDeclaration:
                            return declaration;
                    }
                }
            }
        }

        if (!symbol) {
            return arity ? emptyGenericType : emptyObjectType;
        }
        if (symbol.flags & (SymbolFlags.Variable|SymbolFlags.Function)) {
            const tt = getFakeGlobalInterfaceType(symbol);
            return tt;
        }
        const type = getDeclaredTypeOfSymbol(symbol);
        if (!(type.flags & TypeFlags.Object)) {            
            error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol));
            return arity ? emptyGenericType : emptyObjectType;
        }
        if (length((type as InterfaceType).typeParameters) !== arity) {
            error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity);
            return arity ? emptyGenericType : emptyObjectType;
        }
        
        return type as ObjectType;
    }

    function mergeSymbolTable(target: SymbolTable, source: SymbolTable, unidirectional = false) {
        source.forEach((sourceSymbol, id) => {
            const targetSymbol = target.get(id);
            target.set(id, targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol));
        });
    }

    function getGlobalDiagnostics(): Diagnostic[] {
        ensurePendingDiagnosticWorkComplete();
        return diagnostics.getGlobalDiagnostics();
    }
    
    function isInParameterInitializerBeforeContainingFunction(node: Node) {
        let inBindingInitializer = false;
        while (node.parent && !isFunctionLike(node.parent)) {
            if (isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {
                return true;
            }
            if (isBindingElement(node.parent) && node.parent.initializer === node) {
                inBindingInitializer = true;
            }

            node = node.parent;
        }

        return false;
    }

    function getThisTypeOfSignature(signature: Signature): Type | undefined {
        if (signature.thisParameter) {
            return getTypeOfSymbol(signature.thisParameter);
        }
    }

    function getThisTypeOfDeclaration(declaration: SignatureDeclaration): Type | undefined {
        return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
    }

    function getTypeForThisExpressionFromJSDoc(node: SignatureDeclaration) {
        const thisTag = getJSDocThisTag(node);
        if (thisTag && thisTag.typeExpression) {
            return getTypeFromTypeNode(thisTag.typeExpression);
        }
        const signature = getSignatureOfTypeTag(node);
        if (signature) {
            return getThisTypeOfSignature(signature);
        }
    }

    function tryGetThisTypeAt(node: Node, includeGlobalThis = true, container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false)): Type | undefined {
        const isInJS = isInJSFile(node);
        if (
            isFunctionLike(container) &&
            (!isInParameterInitializerBeforeContainingFunction(node))
        ) {
            let thisType = getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container);
            // Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
            // If this is a function in a JS file, it might be a class method.
            if (!thisType) {
                const className = undefined;// getClassNameFromPrototypeMethod(container);
                if (isInJS && className) {
                    const classSymbol = checkExpression(className).symbol;
                    if (classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlags.Function)) {
                        thisType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType;
                    }
                }                
                // thisType ||= getContextualThisParameterType(container);
            }

            if (thisType) {
                return getFlowTypeOfReference(node, thisType);
            }
        }

        if (isClassLike(container.parent)) {
            const symbol = getSymbolOfDeclaration(container.parent);
            const type = (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType!;
            return getFlowTypeOfReference(node, type);
        }

        if (isSourceFile(container)) {
            console.debug("todo - tryGetThisTypeAt");
            // look up in the source file's locals or exports

            // if (container.commonJsModuleIndicator) {
            //     const fileSymbol = getSymbolOfDeclaration(container);
            //     return fileSymbol && getTypeOfSymbol(fileSymbol);
            // }
            // else if (container.externalModuleIndicator) {
            //     // TODO: Maybe issue a better error than 'object is possibly undefined'
            //     return undefinedType;
            // }
            // else if (includeGlobalThis) {
            //     return getTypeOfSymbol(globalThisSymbol);
            // }
        }
    }
    
    function getExcludedSymbolFlags(flags: SymbolFlags): SymbolFlags {
        let result: SymbolFlags = 0;
        if (flags & SymbolFlags.BlockScopedVariable) result |= SymbolFlags.BlockScopedVariableExcludes;
        if (flags & SymbolFlags.FunctionScopedVariable) result |= SymbolFlags.FunctionScopedVariableExcludes;
        if (flags & SymbolFlags.Property) result |= SymbolFlags.PropertyExcludes;
        if (flags & SymbolFlags.EnumMember) result |= SymbolFlags.EnumMemberExcludes;
        if (flags & SymbolFlags.Function) result |= SymbolFlags.FunctionExcludes;
        if (flags & SymbolFlags.Class) result |= SymbolFlags.ClassExcludes;
        if (flags & SymbolFlags.Interface) result |= SymbolFlags.InterfaceExcludes;
        if (flags & SymbolFlags.RegularEnum) result |= SymbolFlags.RegularEnumExcludes;
        if (flags & SymbolFlags.ConstEnum) result |= SymbolFlags.ConstEnumExcludes;
        if (flags & SymbolFlags.ValueModule) result |= SymbolFlags.ValueModuleExcludes;
        if (flags & SymbolFlags.Method) result |= SymbolFlags.MethodExcludes;
        if (flags & SymbolFlags.GetAccessor) result |= SymbolFlags.GetAccessorExcludes;
        if (flags & SymbolFlags.SetAccessor) result |= SymbolFlags.SetAccessorExcludes;
        if (flags & SymbolFlags.TypeParameter) result |= SymbolFlags.TypeParameterExcludes;
        if (flags & SymbolFlags.TypeAlias) result |= SymbolFlags.TypeAliasExcludes;
        if (flags & SymbolFlags.Alias) result |= SymbolFlags.AliasExcludes;
        return result;
    }

    function recordMergedSymbol(target: Symbol, source: Symbol) {
        if (!source.mergeId) {
            source.mergeId = nextMergeId;
            nextMergeId++;
        }
        mergedSymbols[source.mergeId] = target;
    }
    
    function cloneSymbol(symbol: Symbol): TransientSymbol {
        const result = createSymbol(symbol.flags, symbol.name);
        result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        result.parent = symbol.parent;
        if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
        if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
        if (symbol.members) result.members = new Map(symbol.members);
        if (symbol.exports) result.exports = new Map(symbol.exports);
        recordMergedSymbol(result, symbol);
        return result;
    }

    /**
     * Note: if target is transient, then it is mutable, and mergeSymbol with both mutate and return it.
     * If target is not transient, mergeSymbol will produce a transient clone, mutate that and return it.
     */
    function mergeSymbol(target: Symbol, source: Symbol, unidirectional = false): Symbol {
        if (
            !(target.flags & getExcludedSymbolFlags(source.flags)) ||
            (source.flags | target.flags) & SymbolFlags.Assignment
        ) {
            if (source === target) {
                // This can happen when an export assigned namespace exports something also erroneously exported at the top level
                // See `declarationFileNoCrashOnExtraExportModifier` for an example
                return target;
            }
            if (!(target.flags & SymbolFlags.Transient)) {
                const resolvedTarget = resolveSymbol(target);
                if (resolvedTarget === unknownSymbol) {
                    return source;
                }
                if (
                    !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) ||
                    (source.flags | resolvedTarget.flags) & SymbolFlags.Assignment
                ) {
                    target = cloneSymbol(resolvedTarget);
                }
                else {
                    reportMergeSymbolError(target, source);
                    return source;
                }
            }
            // Javascript static-property-assignment declarations always merge, even though they are also values
            if (source.flags & SymbolFlags.ValueModule && target.flags & SymbolFlags.ValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                // reset flag when merging instantiated module into value module that has only const enums
                target.constEnumOnlyModule = false;
            }
            target.flags |= source.flags;
            if (source.valueDeclaration) {
                setValueDeclaration(target, source.valueDeclaration);
            }
            addRange(target.declarations, source.declarations);
            if (source.members) {
                if (!target.members) target.members = createSymbolTable();
                mergeSymbolTable(target.members, source.members, unidirectional);
            }
            if (source.exports) {
                if (!target.exports) target.exports = createSymbolTable();
                mergeSymbolTable(target.exports, source.exports, unidirectional);
            }
            if (!unidirectional) {
                recordMergedSymbol(target, source);
            }
        }
        // else if (target.flags & SymbolFlags.NamespaceModule) {
        //     // Do not report an error when merging `var globalThis` with the built-in `globalThis`,
        //     // as we will already report a "Declaration name conflicts..." error, and this error
        //     // won't make much sense.
        //     if (target !== globalThisSymbol) {
        //         error(
        //             source.declarations && getNameOfDeclaration(source.declarations[0]),
        //             Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity,
        //             symbolToString(target),
        //         );
        //     }
        // }
        else {
            reportMergeSymbolError(target, source);
        }
        return target;

        function reportMergeSymbolError(target: Symbol, source: Symbol) {
            const isEitherEnum = !!(target.flags & SymbolFlags.Enum || source.flags & SymbolFlags.Enum);
            const isEitherBlockScoped = !!(target.flags & SymbolFlags.BlockScopedVariable || source.flags & SymbolFlags.BlockScopedVariable);
            const message = //isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
                isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
            const sourceSymbolFile = source.declarations && getSourceFileOfNode(source.declarations[0]);
            const targetSymbolFile = target.declarations && getSourceFileOfNode(target.declarations[0]);

            const isSourcePlainJs = false;//isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs);
            const isTargetPlainJs = false;//isPlainJsFile(targetSymbolFile, compilerOptions.checkJs);
            const symbolName = symbolToString(source);

            // Collect top-level duplicate identifier errors into one mapping, so we can then merge their diagnostics if there are a bunch
            if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
                const firstFile = comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile;
                const secondFile = firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
                const filesDuplicates = getOrUpdate(amalgamatedDuplicates, `${firstFile.path}|${secondFile.path}`, (): DuplicateInfoForFiles => ({ firstFile, secondFile, conflictingSymbols: new Map() }));
                const conflictingSymbolInfo = getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, (): DuplicateInfoForSymbol => ({ isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] }));
                if (!isSourcePlainJs) addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source);
                if (!isTargetPlainJs) addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target);
            }
            else {
                if (!isSourcePlainJs) addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target);
                if (!isTargetPlainJs) addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source);
            }
        }

        function addDuplicateLocations(locs: Declaration[], symbol: Symbol): void {
            if (symbol.declarations) {
                for (const decl of symbol.declarations) {
                    pushIfUnique(locs, decl);
                }
            }
        }
    }

    function createIntrinsicType(kind: TypeFlags, intrinsicName: string, objectFlags = ObjectFlags.None, debugIntrinsicName?: string): IntrinsicType {
        checkIntrinsicName(intrinsicName, debugIntrinsicName);
        const type = createType(kind) as IntrinsicType;
        type.intrinsicName = intrinsicName;
        type.debugIntrinsicName = debugIntrinsicName;
        type.objectFlags = objectFlags | ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.IsGenericTypeComputed | ObjectFlags.IsUnknownLikeUnionComputed | ObjectFlags.IsNeverIntersectionComputed;
        return type;
    }

    function createType(flags: TypeFlags): Type {
        const result = new Type(checker, flags);
        typeCount++;
        result.id = typeCount;
        tracing?.recordType(result);
        return result;
    }
       

    function checkIntrinsicName(name: string, debug: string | undefined) {
        const key = `${name},${debug ?? ""}`;
        if (seenIntrinsicNames.has(key)) {
            Debug.fail(`Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.`);
        }
        seenIntrinsicNames.add(key);
    }

     
    function getMergedSymbol(symbol: Symbol): Symbol;
    function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined;
    function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined {
        let merged: Symbol;
        return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
    }

    function getRegularTypeOfExpression(expr: Expression): Type {
        if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
            expr = expr.parent as Expression;
        }
        return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
    }

    function symbolsToArray(symbols: SymbolTable): Symbol[] {
        const result: Symbol[] = [];
        symbols.forEach((symbol, id) => {
            if (!isReservedMemberName(id)) {
                result.push(symbol);
            }
        });
        return result;
    }
    
    function getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[] {
        // if (location.flags & NodeFlags.InWithStatement) {
        //     // We cannot answer semantic questions within a with block, do not proceed any further
        //     return [];
        // }

        const symbols = createSymbolTable();
        let isStaticSymbol = false;

        populateSymbols();

        symbols.delete(InternalSymbolName.This); // Not a symbol, a keyword
        return symbolsToArray(symbols);

        function populateSymbols() {
            while (location) {
                if (canHaveLocals(location) && location.locals) { // && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }

                switch (location.kind) {
                    case SyntaxKind.SourceFile:                        
                        copySymbols(getSymbolOfDeclaration(location as SourceFile).exports!, meaning & SymbolFlags.All);
                        break;
                        // if (!isExternalModule(location as SourceFile)) break;
                        // falls through
                    // case SyntaxKind.ModuleDeclaration:
                    //     copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location as ModuleDeclaration | SourceFile).exports!, meaning & SymbolFlags.ModuleMember);
                    //     break;
                    // case SyntaxKind.EnumDeclaration:
                    //     copySymbols(getSymbolOfDeclaration(location as EnumDeclaration).exports!, meaning & SymbolFlags.EnumMember);
                    //     break;
                    case SyntaxKind.ClassExpression:
                        // const className = (location as ClassExpression).name;
                        // if (className) {
                        //     copySymbol((location as ClassExpression).symbol, meaning);
                        // }

                    // this fall-through is necessary because we would like to handle
                    // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.
                    // falls through
                    // case SyntaxKind.ClassDeclaration:
                    // case SyntaxKind.InterfaceDeclaration:
                        // If we didn't come from static member of class or interface,
                        // add the type parameters into the symbol table
                        // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.
                        // Note: that the memberFlags come from previous iteration.
                        // if (!isStaticSymbol) {
                            copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location as ClassDeclaration | SourceFile)), meaning & SymbolFlags.Type);
                        // }
                        break;
                    case SyntaxKind.FunctionExpression:
                        const funcName = (location as FunctionExpression).name;
                        if (funcName) {
                            copySymbol((location as FunctionExpression).symbol, meaning);
                        }
                        break;
                }

                if (introducesArgumentsExoticObject(location)) {
                    copySymbol(argumentsSymbol, meaning);
                }

                isStaticSymbol = false;//isStatic(location);
                location = location.parent;
            }

            copySymbols(globals, meaning);
        }

        /**
         * Copy the given symbol into symbol tables if the symbol has the given meaning
         * and it doesn't already existed in the symbol table
         * @param key a key for storing in symbol table; if undefined, use symbol.name
         * @param symbol the symbol to be added into symbol table
         * @param meaning meaning of symbol to filter by before adding to symbol table
         */
        function copySymbol(symbol: Symbol, meaning: SymbolFlags): void {
            if (getCombinedLocalAndExportSymbolFlags(symbol) & meaning) {
                const id = symbol.name;
                // We will copy all symbol regardless of its reserved name because
                // symbolsToArray will check whether the key is a reserved name and
                // it will not copy symbol with reserved name to the array
                if (!symbols.has(id)) {
                    symbols.set(id, symbol);
                }
            }
        }

        function copySymbols(source: SymbolTable, meaning: SymbolFlags): void {
            if (meaning) {
                source.forEach(symbol => {
                    copySymbol(symbol, meaning);
                });
            }
        }

        // function copyLocallyVisibleExportSymbols(source: SymbolTable, meaning: SymbolFlags): void {
        //     if (meaning) {
        //         source.forEach(symbol => {
        //             // Similar condition as in `resolveNameHelper`
        //             if (!getDeclarationOfKind(symbol, SyntaxKind.ExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKind.NamespaceExport) && symbol.name !== InternalSymbolName.Default) {
        //                 copySymbol(symbol, meaning);
        //             }
        //         });
        //     }
        // }
    }

    function getExportsOfModuleAsArray(moduleSymbol: Symbol): Symbol[] {
        return symbolsToArray(getExportsOfModule(moduleSymbol));
    }

    function getTypeOfPropertyAccessExpr(node: PropertyAccessExpression): Type {
        return tryResolveExpressionToObject(node.expression, node, CheckMode.TypeOnly) ||
            checkNonNullExpression(node.expression, CheckMode.TypeOnly | CheckMode.StringLiteralAsObject) ||
            errorType;
    }

    function isTypeDeclarationName(name: Node): boolean {
        return name.kind === SyntaxKind.Identifier &&
            isTypeDeclaration(name.parent) &&
            getNameOfDeclaration(name.parent) === name;
    }

    function getTypeOfNode(node: Node): Type {
        if (isSourceFile(node)){// && !isExternalModule(node)) {
            return errorType;
        }

        // if (node.flags & NodeFlags.InWithStatement) {
        //     // We cannot answer semantic questions within a with block, do not proceed any further
        //     return errorType;
        // }

        // const classDecl = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
        // const classType = classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class));
        if (isPartOfTypeNode(node)) {
            const typeFromTypeNode = getTypeFromTypeNode(node as TypeNode);
            return typeFromTypeNode;// classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode;
        }

        if (isExpressionNode(node)) {
            return getRegularTypeOfExpression(node as Expression);
        }

        // if (classType && !classDecl.isImplements) {
        //     // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
        //     // extends clause of a class. We handle that case here.
        //     const baseType = firstOrUndefined(getBaseTypes(classType));
        //     return baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType;
        // }

        if (isTypeDeclaration(node)) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            const symbol = getSymbolOfDeclaration(node);
            return getDeclaredTypeOfSymbol(symbol);
        }

        if (isTypeDeclarationName(node)) {
            const symbol = getSymbolAtLocation(node);
            return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
        }

        if (isBindingElement(node)) {
            return getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ true, CheckMode.Normal) || errorType;
        }

        if (isDeclaration(node)) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            const symbol = getSymbolOfDeclaration(node);
            return symbol ? getTypeOfSymbol(symbol) : errorType;
        }

        if (isDeclarationNameOrImportPropertyName(node)) {
            const symbol = getSymbolAtLocation(node);
            if (symbol) {
                return getTypeOfSymbol(symbol);
            }
            return errorType;
        }

        if (isBindingPattern(node)) {
            return getTypeForVariableLikeDeclaration(node.parent, /*includeOptionality*/ true, CheckMode.Normal) || errorType;
        }

        // if (isInRightSideOfImportOrExportAssignment(node as Identifier)) {
        //     const symbol = getSymbolAtLocation(node);
        //     if (symbol) {
        //         const declaredType = getDeclaredTypeOfSymbol(symbol);
        //         return !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol);
        //     }
        // }

        // if (isMetaProperty(node.parent) && node.parent.keywordToken === node.kind) {
        //     return checkMetaPropertyKeyword(node.parent);
        // }

        // if (isImportAttributes(node)) {
        //     return getGlobalImportAttributesType(/*reportErrors*/ false);
        // }

        return errorType;
    }

    function getSymbolOfDeclaration(node: Declaration): Symbol {        
        return node && getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
    }

    /**
     * If a symbol is the dynamic name of the member of an object type, get the late-bound
     * symbol of the member.
     *
     * For a description of late-binding, see `lateBindMember`.
     */
    function getLateBoundSymbol(symbol: Symbol): Symbol {
        if (symbol.flags & SymbolFlags.Class && isSourceFile(symbol.valueDeclaration)) {
            // force sourcefile to resolve inherits
            const symbolType = getTypeOfSymbol(symbol, CheckMode.TypeOnly) as InterfaceType;
            if (!symbolType.resolvedBaseTypes) {
                resolveBaseTypesOfClass(symbolType as InterfaceType);
            }
        }
        if (symbol.flags & SymbolFlags.ClassMember && symbol.name === InternalSymbolName.Computed) {
            const links = getSymbolLinks(symbol);
            if (!links.lateSymbol && some(symbol.declarations, hasLateBindableName)) {
                // force late binding of members/exports. This will set the late-bound symbol
                const parent = getMergedSymbol(symbol.parent)!;
                // if (some(symbol.declarations, hasStaticModifier)) {
                //     getExportsOfSymbol(parent);
                // }
                // else {
                    getMembersOfSymbol(parent);
                // }
            }
            return links.lateSymbol || (links.lateSymbol = symbol);
        }
        return symbol;
    }

    function getSymbolLinks(symbol: Symbol): SymbolLinks {
        if (symbol.flags & SymbolFlags.Transient) return (symbol as TransientSymbol).links;
        const id = getSymbolId(symbol);
        return symbolLinks[id] ??= new SymbolLinks();
    }
    
    function createError(location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {        
        return location
            ? createDiagnosticForNode(location, message, ...args)
            : createCompilerDiagnostic(message, ...args);
    }
    
    function error(location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {
        const diagnostic = createError(location, message, ...args);        
        diagnostics.add(diagnostic);
        return diagnostic;
    }

    function getRootSymbols(symbol: Symbol): readonly Symbol[] {
        const roots = getImmediateRootSymbols(symbol);
        return roots ? flatMap(roots, getRootSymbols) : [symbol];
    }

    function getEmitResolver(sourceFile: SourceFile, cancellationToken: CancellationToken, skipDiagnostics?: boolean) {
        // Ensure we have all the type information in place for this file so that all the
        // emitter questions of this resolver will return the right information.
        if (!skipDiagnostics) getDiagnostics(sourceFile, cancellationToken);
        return emitResolver;
    }

    function compareTypesAssignable(source: Type, target: Type): Ternary {
        return isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False;
    }

    function getBestMatchingType(source: Type, target: UnionOrIntersectionType, isRelatedTo = compareTypesAssignable) {        
        return findMatchingDiscriminantType(source, target, isRelatedTo) ||
            findMatchingTypeReferenceOrTypeAliasReference(source, target) ||
            findBestTypeForObjectLiteral(source, target) ||
            findBestTypeForInvokable(source, target) ||
            findMostOverlappyType(source, target);
    }

    function findBestTypeForObjectLiteral(source: Type, unionTarget: UnionOrIntersectionType) {
        if (getObjectFlags(source) & ObjectFlags.ObjectLiteral && someType(unionTarget, isArrayLikeType)) {
            return find(unionTarget.types, t => !isArrayLikeType(t));
        }
    }

    function findBestTypeForInvokable(source: Type, unionTarget: UnionOrIntersectionType) {
        let signatureKind = SignatureKind.Call;
        const hasSignatures = getSignaturesOfType(source, signatureKind).length > 0 ||
            (signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0);
        if (hasSignatures) {
            return find(unionTarget.types, t => getSignaturesOfType(t, signatureKind).length > 0);
        }
    }

    function findMostOverlappyType(source: Type, unionTarget: UnionOrIntersectionType) {
        let bestMatch: Type | undefined;
        if (!(source.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive))) {
            let matchingCount = 0;
            for (const target of unionTarget.types) {
                if (!(target.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive))) {
                    const overlap = getIntersectionType([getIndexType(source), getIndexType(target)]);
                    if (overlap.flags & TypeFlags.Index) {
                        // perfect overlap of keys
                        return target;
                    }
                    else if (isUnitType(overlap) || overlap.flags & TypeFlags.Union) {
                        // We only want to account for literal types otherwise.
                        // If we have a union of index types, it seems likely that we
                        // needed to elaborate between two generic mapped types anyway.
                        const len = overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1;
                        if (len >= matchingCount) {
                            bestMatch = target;
                            matchingCount = len;
                        }
                    }
                }
            }
        }
        return bestMatch;
    }

    function findMatchingTypeReferenceOrTypeAliasReference(source: Type, unionTarget: UnionOrIntersectionType) {
        const sourceObjectFlags = getObjectFlags(source);
        if (sourceObjectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous) && unionTarget.flags & TypeFlags.Union) {
            return find(unionTarget.types, target => {
                if (target.flags & TypeFlags.Object) {
                    const overlapObjFlags = sourceObjectFlags & getObjectFlags(target);
                    if (overlapObjFlags & ObjectFlags.Reference) {
                        return (source as TypeReference).target === (target as TypeReference).target;
                    }
                    if (overlapObjFlags & ObjectFlags.Anonymous) {
                        return !!(source as AnonymousType).aliasSymbol && (source as AnonymousType).aliasSymbol === (target as AnonymousType).aliasSymbol;
                    }
                }
                return false;
            });
        }
    }

    function getImmediateRootSymbols(symbol: Symbol): readonly Symbol[] | undefined {
        if (getCheckFlags(symbol) & CheckFlags.Synthetic) {
            return mapDefined(getSymbolLinks(symbol).containingType!.types, type => getPropertyOfType(type, symbol.name));
        }
        else if (symbol.flags & SymbolFlags.Transient) {
            const { links: { leftSpread, rightSpread, syntheticOrigin } } = symbol as TransientSymbol;
            return leftSpread ? [leftSpread, rightSpread!]
                : syntheticOrigin ? [syntheticOrigin]
                : singleElementArray(tryGetTarget(symbol));
        }
        return undefined;
    }

    function tryGetTarget(symbol: Symbol): Symbol | undefined {
        let target: Symbol | undefined;
        let next: Symbol | undefined = symbol;
        while (next = getSymbolLinks(next).target) {
            target = next;
        }
        return target;
    }

    /**
     * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
     * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
     * Object and Function as appropriate.
     *
     * @param type a type to look up property from
     * @param name a name of property to look up in a given type
     */
    function getPropertyOfType(type: Type, name: string, skipObjectFunctionPropertyAugment?: boolean, includeTypeOnlyMembers?: boolean): Symbol | undefined {
        type = getReducedApparentType(type);
        if (isArrayType(type)) {
            // this handles the fluff array property access shortcut. 
            // e.g. users()->foo() where users is object*
            const firstTypeArg = firstOrUndefined(type.resolvedTypeArguments);
            if (firstTypeArg.flags & TypeFlags.Object) { 
                // pull out the type and then fall through to the rest of this function
                type = firstTypeArg;
            }
        }
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            const symbol = resolved.members?.get(name);
            // if (symbol && !includeTypeOnlyMembers && type.symbol?.flags & SymbolFlags.ValueModule && getSymbolLinks(type.symbol).typeOnlyExportStarMap?.has(name)) {
            //     // If this is the type of a module, `resolved.members.get(name)` might have effectively skipped over
            //     // an `export type * from './foo'`, leaving `symbolIsValue` unable to see that the symbol is being
            //     // viewed through a type-only export.
            //     return undefined;
            // }
            if (symbol && symbolIsValue(symbol, includeTypeOnlyMembers)) {
                return symbol;
            }
            if (skipObjectFunctionPropertyAugment) return undefined;
            const functionType = resolved === anyFunctionType ? globalFunctionType :
                resolved.callSignatures?.length ? globalCallableFunctionType :
                resolved.constructSignatures?.length ? globalNewableFunctionType :
                undefined;
            if (functionType) {
                const symbol = getPropertyOfObjectType(functionType, name);
                if (symbol) {
                    return symbol;
                }
            }
            return getPropertyOfObjectType(globalObjectType, name);
        }
        if (type.flags & TypeFlags.Intersection) {
            const prop = getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name, /*skipObjectFunctionPropertyAugment*/ true);
            if (prop) {
                return prop;
            }
            if (!skipObjectFunctionPropertyAugment) {
                return getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name, skipObjectFunctionPropertyAugment);
            }
            return undefined;
        }
        if (type.flags & TypeFlags.Union) {
            return getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name, skipObjectFunctionPropertyAugment);
        }
        return undefined;
    }

    function getPropertyOfUnionOrIntersectionType(type: UnionOrIntersectionType, name: string, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined {
        const property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
        // We need to filter out partial properties in union types
        return property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined;
    }

    // Return the symbol for a given property in a union or intersection type, or undefined if the property
    // does not exist in any constituent type. Note that the returned property may only be present in some
    // constituents, in which case the isPartial flag is set when the containing type is union type. We need
    // these partial properties when identifying discriminant properties, but otherwise they are filtered out
    // and do not appear to be present in the union type.
    function getUnionOrIntersectionProperty(type: UnionOrIntersectionType, name: string, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined {
        let property = skipObjectFunctionPropertyAugment ?
            type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) :
            type.propertyCache?.get(name);
        if (!property) {
            property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            if (property) {
                const properties = skipObjectFunctionPropertyAugment ?
                    type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() :
                    type.propertyCache ||= createSymbolTable();
                properties.set(name, property);
                // Propagate an entry from the non-augmented cache to the augmented cache unless the property is partial.
                if (skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlags.Partial) && !type.propertyCache?.get(name)) {
                    const properties = type.propertyCache ||= createSymbolTable();
                    properties.set(name, property);
                }
            }
        }
        return property;
    }

    function getBaseConstraintOfType(type: Type): Type | undefined {
        if (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral | TypeFlags.StringMapping)) {
            const constraint = getResolvedBaseConstraint(type as InstantiableType | UnionOrIntersectionType);
            return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;            
        }
        return type.flags & TypeFlags.Index ? stringNumberSymbolType : undefined;
    }

    function getApparentTypeOfIntersectionType(type: IntersectionType, thisArgument: Type) {
        if (type === thisArgument) {
            return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType*/ true));
        }
        const key = `I${getTypeId(type)},${getTypeId(thisArgument)}`;
        return getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType*/ true));
    }

    function getApparentTypeOfMappedType(type: MappedType) {
        return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
    }

    function getResolvedApparentTypeOfMappedType(type: MappedType): Type {
        const target = (type.target ?? type) as MappedType;
        const typeVariable = getHomomorphicTypeVariable(target);
        if (typeVariable && !target.declaration.nameType) {
            // We have a homomorphic mapped type or an instantiation of a homomorphic mapped type, i.e. a type
            // of the form { [P in keyof T]: X }. Obtain the modifiers type (the T of the keyof T), and if it is
            // another generic mapped type, recursively obtain its apparent type. Otherwise, obtain its base
            // constraint. Then, if every constituent of the base constraint is an array or tuple type, apply
            // this mapped type to the base constraint. It is safe to recurse when the modifiers type is a
            // mapped type because we protect again circular constraints in getTypeFromMappedTypeNode.
            const modifiersType = getModifiersTypeFromMappedType(type);
            const baseConstraint = isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType);
            if (baseConstraint && everyType(baseConstraint, t => isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t))) {
                return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type.mapper));
            }
        }
        return type;
    }

    function isArrayOrTupleOrIntersection(type: Type) {
        return !!(type.flags & TypeFlags.Intersection) && every((type as IntersectionType).types, isArrayOrTupleType);
    }

    /**
     * For a type parameter, return the base constraint of the type parameter. For the string, number,
     * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
     * type itself.
     */
    function getApparentType(type: Type): Type {
        const t = type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type;
        const objectFlags = getObjectFlags(t);
        return objectFlags & ObjectFlags.Mapped ? getApparentTypeOfMappedType(t as MappedType) :
            objectFlags & ObjectFlags.Reference && t !== type ? getTypeWithThisArgument(t, type) :
            t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(t as IntersectionType, type) :
            t.flags & TypeFlags.StringLike ? globalStringType :
            t.flags & TypeFlags.IntLiteral ? globalIntType :
            t.flags & TypeFlags.FloatLiteral ? globalFloatType :
            t.flags & TypeFlags.Object && (t as IntrinsicType).intrinsicName === "closure" ? globalClosureType :
            // t.flags & TypeFlags.BooleanLike ? globalBooleanType :
            // t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType() :
            t.flags & TypeFlags.NonPrimitive ? emptyObjectType :
            t.flags & TypeFlags.Index ? stringNumberSymbolType :
            t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType :
            t;
    }

    function getBaseTypeNodeOfClass(type: InterfaceType): ExpressionWithTypeArguments | undefined {
        const decl = getClassLikeDeclarationOfSymbol(type.symbol);
        return decl && getEffectiveBaseTypeNode(decl);
    }
    
    function resolveBaseTypeOfSourceFile(type: InterfaceType, node: SourceFile): BaseType[] {                        
        const sourceSymbol = type.symbol ?? getSymbolOfNode(node);

        Debug.assertIsDefined(sourceSymbol);

        forEach(node.heritageClauses, heritageNode => checkInheritDeclaration(heritageNode));

        let members = getExportsOfSymbol(sourceSymbol);
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, emptyArray);
        
        const baseType = getApparentType(type);
        if (!sourceSymbol?.inherits) return type.resolvedBaseTypes = emptyArray;
        
        const baseTypes: BaseType[] = [baseType];
        forEachEntry(sourceSymbol?.inherits, (inheritType, prefix) => {                        
            // resolve the base types
            getBaseTypes(inheritType as InterfaceType);
            const classBaseTypes = getApparentType(inheritType);
            // baseTypes.push(...getBaseTypes(inheritType as InterfaceType) ?? emptyArray);
            // const baseNode = classBaseTypes.symbol?.valueDeclaration;
            // const resolvedBaseType = resolveBaseTypeOfSourceFile(classBaseTypes as InterfaceType, baseNode as SourceFile);
            baseTypes.push(classBaseTypes);
        });        

        return type.resolvedBaseTypes = baseTypes;
    }

    function resolveBaseTypesOfClass(type: InterfaceType): Type[] {
        type.resolvedBaseTypes = resolvingEmptyArray;        
        const baseTypeNode = getClassLikeDeclarationOfSymbol(type.symbol);// getBaseTypeNodeOfClass(type)!;
        if (baseTypeNode && isSourceFile(baseTypeNode)) {
            return resolveBaseTypeOfSourceFile(type, baseTypeNode);
        }
        const baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
        if (!(baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Any))) {
            return type.resolvedBaseTypes = emptyArray;
        }        
        let baseType: Type;
        // if (
        //     baseConstructorType.symbol && baseConstructorType.symbol.flags & SymbolFlags.Class //&& areAllOuterTypeParametersApplied(originalBaseType!)
        // ) {
        //     // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
        //     // class and all return the instance type of the class. There is no need for further checks and we can apply the
        //     // type arguments in the same manner as a type reference to get the same error reporting experience.
        //     baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
        // } else 
        if (baseConstructorType.flags & TypeFlags.Any) {
            baseType = baseConstructorType;
        }
        else {
            // The class derives from a "class-like" constructor function, check that we have at least one construct signature
            // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
            // we check that all instantiated signatures return the same type.
            // const constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
            // if (!constructors.length) {
            //     error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
            //     return type.resolvedBaseTypes = emptyArray;
            // }
            // baseType = getReturnTypeOfSignature(constructors[0]);
            Debug.fail("todo - resolveBaseTypesOfClass");
        }

        if (isErrorType(baseType)) {
            return type.resolvedBaseTypes = emptyArray;
        }
        const reducedBaseType = getReducedType(baseType);
        if (!isValidBaseType(reducedBaseType)) {
            console.debug("todo - isValidBaseType");
            // const elaboration = elaborateNeverIntersection(/*errorInfo*/ undefined, baseType);
            // const diagnostic = chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
            // diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic));
            return type.resolvedBaseTypes = emptyArray;
        }
        if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
            error(type.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType));
            return type.resolvedBaseTypes = emptyArray;
        }
        if (type.resolvedBaseTypes === resolvingEmptyArray) {
            // Circular reference, likely through instantiation of default parameters
            // (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
            // as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
            // partial instantiation of the members without the base types fully resolved
            type.members = undefined;
        }
        return type.resolvedBaseTypes = [reducedBaseType];
    }
    
    function getBaseTypes(type: InterfaceType): BaseType[] {
        if (!type.baseTypesResolved) {
            if (pushTypeResolution(type, TypeSystemPropertyName.ResolvedBaseTypes)) {
                type.resolvedBaseTypes = [];
                // if (type.objectFlags & ObjectFlags.Tuple) {
                //     type.resolvedBaseTypes = [getTupleBaseType(type as TupleType)];
                // } else                
                if (type.symbol?.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
                    if (type.symbol.flags & SymbolFlags.Class) {
                        resolveBaseTypesOfClass(type);
                    }
                    // if (type.symbol.flags & SymbolFlags.Interface) {
                    //     resolveBaseTypesOfInterface(type);
                    // }
                }
                // else {
                //     Debug.fail("type must be class or interface");
                // }
                if (!popTypeResolution() && type.symbol?.declarations) {
                    for (const declaration of type.symbol.declarations) {
                        // if (declaration.kind === SyntaxKind.ClassDeclaration || declaration.kind === SyntaxKind.InterfaceDeclaration) {
                        //     reportCircularBaseType(declaration, type);
                        // }
                    }
                }
            }
            type.baseTypesResolved = true;
        }
        return type.resolvedBaseTypes;
    }


    function createUnionOrIntersectionProperty(containingType: UnionOrIntersectionType, name: string, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined {
        let singleProp: Symbol | undefined;
        let propSet: Map<SymbolId, Symbol> | undefined;
        let indexTypes: Type[] | undefined;
        const isUnion = containingType.flags & TypeFlags.Union;
        // Flags we want to propagate to the result if they exist in all source symbols
        let optionalFlag: SymbolFlags | undefined;
        let syntheticFlag = CheckFlags.SyntheticMethod;
        let checkFlags = isUnion ? 0 : CheckFlags.Readonly;
        let mergedInstantiations = false;
        for (const current of containingType.types) {
            const type = getApparentType(current);
            if (!(isErrorType(type) || type.flags & TypeFlags.Never)) {
                const prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                const modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;
                if (prop) {
                    if (prop.flags & SymbolFlags.ClassMember) {
                        optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional;
                        if (isUnion) {
                            optionalFlag |= prop.flags & SymbolFlags.Optional;
                        }
                        else {
                            optionalFlag &= prop.flags;
                        }
                    }
                    if (!singleProp) {
                        singleProp = prop;
                    }
                    else if (prop !== singleProp) {
                        const isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                        // If the symbols are instances of one another with identical types - consider the symbols
                        // equivalent and just use the first one, which thus allows us to avoid eliding private
                        // members when intersecting a (this-)instantiations of a class with its raw base or another instance
                        if (isInstantiation && compareProperties(singleProp, prop, (a, b) => a === b ? Ternary.True : Ternary.False) === Ternary.True) {
                            // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
                            // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
                            // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
                            mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                        }
                        else {
                            if (!propSet) {
                                propSet = new Map<SymbolId, Symbol>();
                                propSet.set(getSymbolId(singleProp), singleProp);
                            }
                            const id = getSymbolId(prop);
                            if (!propSet.has(id)) {
                                propSet.set(id, prop);
                            }
                        }
                    }
                    if (isUnion && isReadonlySymbol(prop)) {
                        checkFlags |= CheckFlags.Readonly;
                    }
                    else if (!isUnion && !isReadonlySymbol(prop)) {
                        checkFlags &= ~CheckFlags.Readonly;
                    }
                    checkFlags |= (!(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0) |
                        (modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0) |
                        (modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0) |
                        (modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0);
                    
                    syntheticFlag = CheckFlags.SyntheticProperty;                    
                }
                else if (isUnion) {
                    const indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                    if (indexInfo) {
                        checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0);
                        indexTypes = append(indexTypes, indexInfo.type);
                    }
                    else if (isObjectLiteralType(type) && !(getObjectFlags(type) & ObjectFlags.ContainsSpread)) {
                        checkFlags |= CheckFlags.WritePartial;
                        indexTypes = append(indexTypes, undefinedType);
                    }
                    else {
                        checkFlags |= CheckFlags.ReadPartial;
                    }
                }
            }
        }
        if (
            !singleProp ||
            isUnion &&
                (propSet || checkFlags & CheckFlags.Partial) &&
                checkFlags & (CheckFlags.ContainsPrivate | CheckFlags.ContainsProtected) &&
                !(propSet && getCommonDeclarationsOfSymbols(propSet.values()))
        ) {
            // No property was found, or, in a union, a property has a private or protected declaration in one
            // constituent, but is missing or has a different declaration in another constituent.
            return undefined;
        }
        if (!propSet && !(checkFlags & CheckFlags.ReadPartial) && !indexTypes) {
            if (mergedInstantiations) {
                // No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
                // Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
                // They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
                const links = tryCast(singleProp, isTransientSymbol)?.links;
                const clone = createSymbolWithType(singleProp, links?.type);
                clone.parent = singleProp.valueDeclaration?.symbol?.parent;
                clone.links.containingType = containingType;
                clone.links.mapper = links?.mapper;
                clone.links.writeType = getWriteTypeOfSymbol(singleProp);
                return clone;
            }
            else {
                return singleProp;
            }
        }
        const props = propSet ? arrayFrom(propSet.values()) : [singleProp];
        let declarations: Declaration[] | undefined;
        let firstType: Type | undefined;
        let nameType: Type | undefined;
        const propTypes: Type[] = [];
        let writeTypes: Type[] | undefined;
        let firstValueDeclaration: Declaration | undefined;
        let hasNonUniformValueDeclaration = false;
        for (const prop of props) {
            if (!firstValueDeclaration) {
                firstValueDeclaration = prop.valueDeclaration;
            }
            else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                hasNonUniformValueDeclaration = true;
            }
            declarations = addRange(declarations, prop.declarations);
            const type = getTypeOfSymbol(prop);
            if (!firstType) {
                firstType = type;
                nameType = getSymbolLinks(prop).nameType;
            }
            const writeType = getWriteTypeOfSymbol(prop);
            if (writeTypes || writeType !== type) {
                writeTypes = append(!writeTypes ? propTypes.slice() : writeTypes, writeType);
            }
            if (type !== firstType) {
                checkFlags |= CheckFlags.HasNonUniformType;
            }
            if (isLiteralType(type) /*|| isPatternLiteralType(type)*/) {
                checkFlags |= CheckFlags.HasLiteralType;
            }
            if (type.flags & TypeFlags.Never && type !== uniqueLiteralType) {
                checkFlags |= CheckFlags.HasNeverType;
            }
            propTypes.push(type);
        }
        addRange(propTypes, indexTypes);
        const result = createSymbol(SymbolFlags.Property | (optionalFlag ?? 0), name, syntheticFlag | checkFlags);
        result.links.containingType = containingType;
        if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
            result.valueDeclaration = firstValueDeclaration;

            // Inherit information about parent type.
            if (firstValueDeclaration.symbol.parent) {
                result.parent = firstValueDeclaration.symbol.parent;
            }
        }

        result.declarations = declarations;
        result.links.nameType = nameType;
        if (propTypes.length > 2) {
            // When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
            result.links.checkFlags |= CheckFlags.DeferredType;
            result.links.deferralParent = containingType;
            result.links.deferralConstituents = propTypes;
            result.links.deferralWriteConstituents = writeTypes;
        }
        else {
            result.links.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
            if (writeTypes) {
                result.links.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes);
            }
        }
        return result;
    }

    /** If the given type is an object type and that type has a property by the given name,
     * return the symbol for that property. Otherwise return undefined.
     */
    function getPropertyOfObjectType(type: Type, name: string): Symbol | undefined {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            const symbol = resolved.members.get(name);
            if (symbol && symbolIsValue(symbol)) {
                return symbol;
            }
        }
    }


    function getReducedApparentType(type: Type): Type {
        // Since getApparentType may return a non-reduced union or intersection type, we need to perform
        // type reduction both before and after obtaining the apparent type. For example, given a type parameter
        // 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
        // that type may need further reduction to remove empty intersections.
        return getReducedType(getApparentType(getReducedType(type)));
    }
    
    function getDiagnostics(sourceFile: SourceFile, ct: CancellationToken, nodesToCheck?: Node[]): Diagnostic[] {
        try {
            // Record the cancellation token so it can be checked later on during checkSourceElement.
            // Do this in a finally block so we can ensure that it gets reset back to nothing after
            // this call is done.
            cancellationToken = ct;
            return runWithCurrentFile(sourceFile, () => {
                return getDiagnosticsWorker(sourceFile, nodesToCheck);
            });
        }
        finally {
            cancellationToken = undefined;
        }
    }

    function getDiagnosticsWorker(sourceFile: SourceFile, nodesToCheck: Node[] | undefined): Diagnostic[] {
        if (sourceFile) {
            ensurePendingDiagnosticWorkComplete();
            // Some global diagnostics are deferred until they are needed and
            // may not be reported in the first call to getGlobalDiagnostics.
            // We should catch these changes and report them.
            const previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            const previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;

            checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck);
            const semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);

            // now loop through the files top-level include statements and add related diagnostics for each
            const includes = filter(sourceFile.statements, isIncludeDirective);
            forEach(includes, include => {
                const includeSemanticDiags = diagnostics.getDiagnostics(include.fileName);
                if (includeSemanticDiags.length) {                    
                    const d = createDiagnosticForNode(include, Diagnostics.Include_file_0_contains_one_or_more_errors, getIncludeDirectiveFilename(include));
                    addRelatedInfo(d, ...includeSemanticDiags);
                    semanticDiagnostics.push(d);
                }
            });

            if (nodesToCheck) {
                // No need to get global diagnostics.
                return semanticDiagnostics;
            }
            const currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
                // If the arrays are not the same reference, new diagnostics were added.
                // TODO:
                // const deferredGlobalDiagnostics = relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics);
                // return concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
            }
            else if (previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0) {
                // If the arrays are the same reference, but the length has changed, a single
                // new diagnostic was added as DiagnosticCollection attempts to reuse the
                // same array.
                return concatenate(currentGlobalDiagnostics, semanticDiagnostics);
            }

            return semanticDiagnostics;
        }

        // Global diagnostics are always added when a file is not provided to
        // getDiagnostics
        forEach(host.getSourceFiles(), file => checkSourceFileWithEagerDiagnostics(file));
        return diagnostics.getDiagnostics();
    }

    function checkSourceFile(node: SourceFile, nodesToCheck: Node[] | undefined) {
        tracing?.push(tracing.Phase.Check, nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile", { path: node.path }, /*separateBeginAndEnd*/ true);
        const beforeMark = nodesToCheck ? "beforeCheckNodes" : "beforeCheck";
        const afterMark = nodesToCheck ? "afterCheckNodes" : "afterCheck";
        performance.mark(beforeMark);
        currentFile = node;
        nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node);
        currentFile = undefined!;
        performance.mark(afterMark);
        performance.measure("Check", beforeMark, afterMark);
        tracing?.pop();
    }

    function getNodeLinks(node: Node): NodeLinks {
        const nodeId = getNodeId(node);
        return nodeLinks[nodeId] || (nodeLinks[nodeId] = new (NodeLinks as any)());
    }

    function getSymbol(symbols: SymbolTable, name: string, meaning: SymbolFlags): Symbol | undefined {
        if (meaning) {
            const symbol = getMergedSymbol(symbols.get(name));
            if (symbol) {
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & SymbolFlags.Alias) {
                    const targetFlags = getSymbolFlags(symbol);
                    // `targetFlags` will be `SymbolFlags.All` if an error occurred in alias resolution; this avoids cascading errors
                    if (targetFlags & meaning) {
                        return symbol;
                    }
                }
            }
        }
        // return undefined if we can't find a symbol.
    }

    function getRequiresScopeChangeCache(node: FunctionLikeDeclaration) {
        return getNodeLinks(node).declarationRequiresScopeChange;
    }

    function setRequiresScopeChangeCache(node: FunctionLikeDeclaration, value: boolean) {
        getNodeLinks(node).declarationRequiresScopeChange = value;
    }
    
    function checkGrammarSourceFile(node: SourceFile): boolean {
        return !!(node.flags & NodeFlags.Ambient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
    }

    function isErrorType(type: Type) {
        // The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
        // a reference to an unresolved symbol. We want those to behave like the errorType.
        return type === errorType || !!(type.flags & TypeFlags.Any && type.aliasSymbol);
    }

    function compareProperties(sourceProp: Symbol, targetProp: Symbol, compareTypes: (source: Type, target: Type) => Ternary): Ternary {
        // Two members are considered identical when
        // - they are public properties with identical names, optionality, and types,
        // - they are private or protected properties originating in the same declaration and having identical types
        if (sourceProp === targetProp) {
            return Ternary.True;
        }
        const sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlags.NonPublicAccessibilityModifier;
        const targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlags.NonPublicAccessibilityModifier;
        if (sourcePropAccessibility !== targetPropAccessibility) {
            return Ternary.False;
        }
        if (sourcePropAccessibility) {
            if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                return Ternary.False;
            }
        }
        else {
            if ((sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional)) {
                return Ternary.False;
            }
        }
        if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
            return Ternary.False;
        }
        return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
    }

    function findIndexInfo(indexInfos: readonly IndexInfo[], keyType: Type) {
        return find(indexInfos, info => info.keyType === keyType);
    }

    function getIndexInfosOfStructuredType(type: Type): readonly IndexInfo[] {
        if (type.flags & TypeFlags.StructuredType) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            return resolved.indexInfos ?? emptyArray;
        }
        return emptyArray;
    }

    function getIndexInfosOfType(type: Type): readonly IndexInfo[] {
        return getIndexInfosOfStructuredType(getReducedApparentType(type));
    }
    
    // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    function getIndexInfoOfType(type: Type, keyType: Type): IndexInfo | undefined {
        return findIndexInfo(getIndexInfosOfType(type), keyType);
    }
    
    function isObjectLiteralType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.ObjectLiteral);
    }

    // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    function getIndexTypeOfType(type: Type, keyType: Type): Type | undefined {
        return getIndexInfoOfType(type, keyType)?.type;
    }

    function isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression ): boolean {
        const list = obj.properties as NodeArray<ObjectLiteralElementLike >;
        return list.some(property => {
            const nameType = property.name && (getLiteralTypeFromPropertyName(property.name));
            const name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
            const expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
            return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
        });
    }

    function isApplicableIndexType(source: Type, target: Type): boolean {
        // A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
        // signature applies to types assignable to 'number', `${number}` and numeric string literal types.
        return isTypeAssignableTo(source, target) ||
            target === stringType && isTypeAssignableTo(source, numberType) ||
            target === numberType && (!!(source.flags & TypeFlags.StringLiteral) && isNumericLiteralName((source as StringLiteralType).value));
    }

    function getApplicableIndexInfos(type: Type, keyType: Type): IndexInfo[] {
        return getIndexInfosOfType(type).filter(info => isApplicableIndexType(keyType, info.keyType));
    }

    function findApplicableIndexInfo(indexInfos: readonly IndexInfo[], keyType: Type) {
        Debug.assertIsDefined(indexInfos);

        // Index signatures for type 'string' are considered only when no other index signatures apply.
        let stringIndexInfo: IndexInfo | undefined;
        let applicableInfo: IndexInfo | undefined;
        let applicableInfos: IndexInfo[] | undefined;
        for (const info of indexInfos) {
            if (info.keyType === stringType) {
                stringIndexInfo = info;
            }
            else if (isApplicableIndexType(keyType, info.keyType)) {
                if (!applicableInfo) {
                    applicableInfo = info;
                }
                else {
                    (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                }
            }
        }
        // When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
        // the intersected key type, we just use unknownType for the key type as nothing actually depends on the
        // keyType property of the returned IndexInfo.
        return applicableInfo ? applicableInfo :
            stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :
            undefined;
    }

    function getApplicableIndexInfo(type: Type, keyType: Type): IndexInfo | undefined {
        return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
    }

    function createLiteralType(flags: TypeFlags, value: string | number, symbol?: Symbol, regularType?: LiteralType) {
        const type = createTypeWithSymbol(flags, symbol!) as LiteralType;
        type.value = value;
        type.regularType = regularType || type;
        return type;
    }

    /**
     * @deprecated is this needed?
     * @param value 
     * @returns 
     */
    function getNumberLiteralType(value: number): IntLiteralType {
        let type;
        return numberLiteralTypes.get(value) || (numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.IntLiteral, value) as IntLiteralType), type);
    }
    
    function getStringLiteralType(value: string): StringLiteralType {
        let type;
        return stringLiteralTypes.get(value) || (stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type);
    }

    function getBytesLiteralType(value: string): BytesLiteralType {
        let type;
        return bytesLiteralTypes.get(value) || (bytesLiteralTypes.set(value, type = createLiteralType(TypeFlags.BytesLiteral, value) as BytesLiteralType), type);
    }
    
    function getApplicableIndexInfoForName(type: Type, name: string): IndexInfo | undefined {
        return getApplicableIndexInfo(type, /*isLateBoundName(name) ? esSymbolType :*/ getStringLiteralType(name));
    }
    
    function getCommonDeclarationsOfSymbols(symbols: Iterable<Symbol>) {
        let commonDeclarations: Set<Node> | undefined;
        for (const symbol of symbols) {
            if (!symbol.declarations) {
                return undefined;
            }
            if (!commonDeclarations) {
                commonDeclarations = new Set(symbol.declarations);
                continue;
            }
            commonDeclarations.forEach(declaration => {
                if (!contains(symbol.declarations, declaration)) {
                    commonDeclarations!.delete(declaration);
                }
            });
            if (commonDeclarations.size === 0) {
                return undefined;
            }
        }
        return commonDeclarations;
    }

    
    function filterType(type: Type, f: (t: Type) => boolean): Type {
        if (type.flags & TypeFlags.Union) {
            const types = (type as UnionType).types;
            const filtered = filter(types, f);
            if (filtered === types) {
                return type;
            }
            const origin = (type as UnionType).origin;
            let newOrigin: Type | undefined;
            if (origin && origin.flags & TypeFlags.Union) {
                // If the origin type is a (denormalized) union type, filter its non-union constituents. If that ends
                // up removing a smaller number of types than in the normalized constituent set (meaning some of the
                // filtered types are within nested unions in the origin), then we can't construct a new origin type.
                // Otherwise, if we have exactly one type left in the origin set, return that as the filtered type.
                // Otherwise, construct a new filtered origin type.
                const originTypes = (origin as UnionType).types;
                const originFiltered = filter(originTypes, t => !!(t.flags & TypeFlags.Union) || f(t));
                if (originTypes.length - originFiltered.length === types.length - filtered.length) {
                    if (originFiltered.length === 1) {
                        return originFiltered[0];
                    }
                    newOrigin = createOriginUnionOrIntersectionType(TypeFlags.Union, originFiltered);
                }
            }
            // filtering could remove intersections so `ContainsIntersections` might be forwarded "incorrectly"
            // it is purely an optimization hint so there is no harm in accidentally forwarding it
            return getUnionTypeFromSortedList(filtered, (type as UnionType).objectFlags & (ObjectFlags.PrimitiveUnion | ObjectFlags.ContainsIntersections), /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, newOrigin);
        }
        return type.flags & TypeFlags.Never || f(type) ? type : neverType;
    }

    function removeType(type: Type, targetType: Type) {
        return filterType(type, t => t !== targetType);
    }

    function removeMissingType(type: Type, isOptional: boolean) {
        return type;// TODO exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type;
    }
    
    /**
     * Distinct write types come only from set accessors, but synthetic union and intersection
     * properties deriving from set accessors will either pre-compute or defer the union or
     * intersection of the writeTypes of their constituents.
     */
    function getWriteTypeOfSymbol(symbol: Symbol): Type {
        const checkFlags = getCheckFlags(symbol);
        if (symbol.flags & SymbolFlags.Property) {
            // TODO: review this
            // return checkFlags & CheckFlags.SyntheticProperty ?
            //     checkFlags & CheckFlags.DeferredType ?
            //         getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :
            //         // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty
            //         (symbol as TransientSymbol).links.writeType || (symbol as TransientSymbol).links.type! :
            return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional));
        }
        // if (symbol.flags & SymbolFlags.Accessor) {
        //     return checkFlags & CheckFlags.Instantiated ?
        //         getWriteTypeOfInstantiatedSymbol(symbol) :
        //         getWriteTypeOfAccessors(symbol);
        // }
        return getTypeOfSymbol(symbol);
    }


    function createSymbolWithType(source: Symbol, type: Type | undefined) {
        const symbol = createSymbol(source.flags, source.name, getCheckFlags(source) & CheckFlags.Readonly);
        symbol.declarations = source.declarations;
        symbol.parent = source.parent;
        symbol.links.type = type;
        symbol.links.target = source;
        if (source.valueDeclaration) {
            symbol.valueDeclaration = source.valueDeclaration;
        }
        const nameType = getSymbolLinks(source).nameType;
        if (nameType) {
            symbol.links.nameType = nameType;
        }
        return symbol;
    }
    
    function isReadonlySymbol(symbol: Symbol): boolean {
        // The following symbols are considered read-only:
        // Properties with a 'readonly' modifier
        // Variables declared with 'const'
        // Get accessors without matching set accessors
        // Enum members
        // Object.defineProperty assignments with writable false or no setter
        // Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
        return !!(getCheckFlags(symbol) & CheckFlags.Readonly ||
            //symbol.flags & SymbolFlags.Property && getDeclarationModifierFlagsFromSymbol(symbol) & ModifierFlags.Readonly ||
            //symbol.flags & SymbolFlags.Variable && getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant ||
            symbol.flags & SymbolFlags.Accessor && !(symbol.flags & SymbolFlags.SetAccessor) ||
            symbol.flags & SymbolFlags.EnumMember ||
            some(symbol.declarations, isReadonlyAssignmentDeclaration));
    }

    function isStringLiteralType(type: Type): type is StringLiteralType {
        return !!(type.flags & TypeFlags.StringLiteral);
    }

    function isLiteralType(type: Type): boolean {
        return type.flags & TypeFlags.Boolean ? true :
            type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every((type as UnionType).types, isUnitType) :
            isUnitType(type);
    }

    function isLateBoundName(name: string): boolean {
        return (name as string).charCodeAt(0) === CharacterCodes._ &&
            (name as string).charCodeAt(1) === CharacterCodes._ &&
            (name as string).charCodeAt(2) === CharacterCodes.at;
    }

    // The local type parameters are the combined set of type parameters from all declarations of the class,
    // interface, or type alias.
    function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol: Symbol): TypeParameter[] | undefined {
        if (!symbol.declarations) {
            return;
        }
        let result: TypeParameter[] | undefined;
        for (const node of symbol.declarations) {
            if (
                node.kind === SyntaxKind.InterfaceDeclaration ||
                node.kind === SyntaxKind.ClassDeclaration ||
                node.kind === SyntaxKind.ClassExpression ||
                // isJSConstructor(node) ||
                isTypeAlias(node)
            ) {
                const declaration = node as TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag;
                result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration));
            }
        }
        return result;
    }

    function getTargetSymbol(s: Symbol) {
        // if symbol is instantiated its flags are not copied from the 'target'
        // so we'll need to get back original 'target' symbol to work with correct set of flags
        // NOTE: cast to TransientSymbol should be safe because only TransientSymbols have CheckFlags.Instantiated
        return getCheckFlags(s) & CheckFlags.Instantiated ? (s as TransientSymbol).links.target! : s;
    }
    
    function checkGrammarTopLevelElementsForRequiredDeclareModifier(file: SourceFile): boolean {
        for (const decl of file.statements) {
            // TODO
            console.warn("Implement me - grammar check");
            // if (isDeclaration(decl) || decl.kind === SyntaxKind.VariableStatement) {
            //     if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
            //         return true;
            //     }
            // }
        }
        return false;
    }

    // This function assumes the constituent type list is sorted and deduplicated.
    function getUnionTypeFromSortedList(types: Type[], precomputedObjectFlags: ObjectFlags, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[], origin?: Type): Type {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        const typeKey = !origin ? getTypeListId(types) :
            origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` :
            origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` :
            `#${(origin as IndexType).type.id}|${getTypeListId(types)}`; // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
        const id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
        let type = unionTypes.get(id);
        if (!type) {
            type = createType(TypeFlags.Union) as UnionType;
            type.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ TypeFlags.Nullable);
            type.types = types;
            type.origin = origin;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            if (types.length === 2 && types[0].flags & TypeFlags.BooleanLiteral && types[1].flags & TypeFlags.BooleanLiteral) {
                type.flags |= TypeFlags.Boolean;
                (type as UnionType & IntrinsicType).intrinsicName = "boolean";
            }
            unionTypes.set(id, type);
        }
        return type;
    }

    /** @deprecated no optional types in LPC */
    function removeOptionalTypeMarker(type: Type): Type {
        return type;//return strictNullChecks ? removeType(type, optionalType) : type;
    }

    function checkMappingEntry(node: MappingEntryExpression, checkMode: CheckMode | undefined, forceTuple: boolean | undefined): Type {
        if (node.name) checkExpression(node.name);       
         
        const elTypes = map(node.elements || emptyArray, checkExpression);
        // TODO - this should return a tuple type, not anyArray - but that wasn't working with check mapping literal code
        return elTypes.length === 1 ? elTypes[0] : anyArrayType;
    }

    function checkMappingLiteral(node: MappingLiteralExpression, checkMode: CheckMode | undefined, forceTuple: boolean | undefined): Type {
        const elements = node.elements;
        const elementCount = elements?.length || 0;
        const keyTypes: Type[] = [];
        const elementTypes: Type[][] = [];
        const elementFlags: ElementFlags[] = [];
        pushCachedContextualType(node);
        
        let hasOmittedExpression = false;
        for (let i = 0; i < elementCount; i++) {
            const e = elements[i];
            
            if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {
                hasOmittedExpression = true;
                elementTypes.push([undefinedOrMissingType]);
                elementFlags.push(ElementFlags.Optional);
            }
            else if (!isOmittedExpression(e)) {                
                const keyType = checkExpressionForMutableLocation(e.name, checkMode, forceTuple);
                keyTypes.push(keyType);
                
                // elementTypes.push(addOptionality(type, /*isProperty*/ true, hasOmittedExpression));
                elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);                
                
                forEach(e.elements, (me,idx) => {                    
                    const type = checkExpressionForMutableLocation(me, checkMode, forceTuple);                    
                    elementTypes[idx] = elementTypes[idx] || [];
                    elementTypes[idx].push(addOptionality(type, /*isProperty*/ true, hasOmittedExpression));
                    elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);                
                });
            }
        }
        popContextualType();     
        
        const finalKeyType = getReducedType(getUnionType(keyTypes, UnionReduction.Subtype));
        const finalElementTypes: Type = elementTypes.length > 1 ? createArrayType(getUnionType(elementTypes.map(types => getReducedType(getUnionType(types, UnionReduction.Subtype))))) :
            elementTypes.length === 1 ? getReducedType(getUnionType(elementTypes[0], UnionReduction.Subtype)) :
            strictNullChecks ? implicitNeverType : autoType;

        return createMappingLiteralType(createMappingType(
            finalKeyType,
            finalElementTypes,
            false,
        ));
    }

    function checkArrayLiteral(node: ArrayLiteralExpression, checkMode: CheckMode | undefined, forceTuple: boolean | undefined): Type {
        const elements = node.elements;
        const elementCount = elements.length;
        const elementTypes: Type[] = [];
        const elementFlags: ElementFlags[] = [];
        pushCachedContextualType(node);
        const inDestructuringPattern = isAssignmentTarget(node);
        const inConstContext = false;//isConstContext(node);
        const contextualType = getApparentTypeOfContextualType(node, /*contextFlags*/ undefined);
        const inTupleContext = false;//isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, t => isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target as MappedType || t));

        let hasOmittedExpression = false;
        for (let i = 0; i < elementCount; i++) {
            const e = elements[i];
            if (e.kind === SyntaxKind.SpreadElement) {
                // if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {
                //     checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);
                // }
                const spreadType = checkExpression((e as SpreadElement).expression, checkMode, forceTuple);
                if (isArrayLikeType(spreadType)) {
                    elementTypes.push(spreadType);
                    elementFlags.push(ElementFlags.Variadic);
                }
                else if (inDestructuringPattern) {
                    // Given the following situation:
                    //    var c: {};
                    //    [...c] = ["", 0];
                    //
                    // c is represented in the tree as a spread element in an array literal.
                    // But c really functions as a rest element, and its purpose is to provide
                    // a contextual type for the right hand side of the assignment. Therefore,
                    // instead of calling checkExpression on "...c", which will give an error
                    // if c is not iterable/array-like, we need to act as if we are trying to
                    // get the contextual element type from it. So we do something similar to
                    // getContextualTypeForElementExpression, which will crucially not error
                    // if there is no index type / iterated type.
                    const restElementType = getIndexTypeOfType(spreadType, numberType) ||
                        getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, /*errorNode*/ undefined, /*checkAssignability*/ false) ||
                        unknownType;
                    elementTypes.push(restElementType);
                    elementFlags.push(ElementFlags.Rest);
                }
                else {
                    elementTypes.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, (e as SpreadElement).expression));
                    elementFlags.push(ElementFlags.Rest);
                }
            }
            else if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {
                hasOmittedExpression = true;
                elementTypes.push(undefinedOrMissingType);
                elementFlags.push(ElementFlags.Optional);
            }
            else {
                const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);               
                elementTypes.push(addOptionality(type, /*isProperty*/ true, hasOmittedExpression));
                elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);
                if (inTupleContext && checkMode && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(e)) {
                    const inferenceContext = getInferenceContext(node);
                    Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                    addIntraExpressionInferenceSite(inferenceContext, e, type);
                }
            }
        }
        popContextualType();
        if (inDestructuringPattern) {
            return createTupleType(elementTypes, elementFlags);
        }
        if (forceTuple || inConstContext || inTupleContext) {
            return createArrayLiteralType(createTupleType(elementTypes, elementFlags, /*readonly*/ inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType))));
        }
        return createArrayLiteralType(createArrayType(
            elementTypes.length ?
                getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) :
                strictNullChecks ? implicitNeverType : undefinedWideningType,
            inConstContext,
        ));
    }

    function createArrayLiteralType(type: Type) {
        if (!(getObjectFlags(type) & ObjectFlags.Reference)) {
            return type;
        }
        let literalType = (type as TypeReference).literalType;
        if (!literalType) {
            literalType = (type as TypeReference).literalType = cloneTypeReference(type as TypeReference);
            literalType.objectFlags |= ObjectFlags.ArrayLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
        }
        return literalType;
    }

    function createMappingLiteralType(type: Type) {
        if (!(getObjectFlags(type) & ObjectFlags.Reference)) {
            return type;
        }
        let literalType = (type as TypeReference).literalType;
        if (!literalType) {
            literalType = (type as TypeReference).literalType = cloneTypeReference(type as TypeReference);
            literalType.objectFlags |= ObjectFlags.MappingLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
        }
        return literalType;
    }

    function cloneTypeReference(source: TypeReference): TypeReference {
        const type = createTypeWithSymbol(source.flags, source.symbol) as TypeReference;
        type.objectFlags = source.objectFlags;
        type.target = source.target;
        type.resolvedTypeArguments = source.resolvedTypeArguments;
        return type;
    }

    function reportTypeNotIterableError(errorNode: Node, type: Type, allowAsyncIterables: boolean): Diagnostic {
        const message = undefined;
        return errorAndMaybeSuggestAwait(errorNode, false, message, typeToString(type));
    }


    /**
     * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
     * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
     * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
     */
    function getIteratedTypeOrElementType(use: IterationUse, inputType: Type, sentType: Type, errorNode: Node | undefined, checkAssignability: boolean): Type | undefined {
        const allowAsyncIterables = (use & IterationUse.AllowsAsyncIterablesFlag) !== 0;
        if (inputType === neverType) {
            if (errorNode) {
                reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables);
            }
            return undefined;
        }

        const uplevelIteration = true;//languageVersion >= ScriptTarget.ES2015;
        const downlevelIteration = !uplevelIteration;// && compilerOptions.downlevelIteration;
        const possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUse.PossiblyOutOfBounds);

        // Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
        // or higher, when inside of an async generator or for-await-if, or when
        // downlevelIteration is requested.
        // if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
        //     // We only report errors for an invalid iterable type in ES2015 or higher.
        //     const iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : undefined);
        //     if (checkAssignability) {
        //         if (iterationTypes) {
        //             const diagnostic = use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :
        //                 use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :
        //                 use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :
        //                 use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :
        //                 undefined;
        //             if (diagnostic) {
        //                 checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
        //             }
        //         }
        //     }
        //     if (iterationTypes || uplevelIteration) {
        //         return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType);
        //     }
        // }

        let arrayType = inputType;
        let hasStringConstituent = false;

        // If strings are permitted, remove any string-like constituents from the array type.
        // This allows us to find other non-string element types from an array unioned with
        // a string.
        if (use & IterationUse.AllowsStringInputFlag) {
            if (arrayType.flags & TypeFlags.Union) {
                // After we remove all types that are StringLike, we will know if there was a string constituent
                // based on whether the result of filter is a new array.
                const arrayTypes = (inputType as UnionType).types;
                const filteredTypes = filter(arrayTypes, t => !(t.flags & TypeFlags.StringLike));
                if (filteredTypes !== arrayTypes) {
                    arrayType = getUnionType(filteredTypes, UnionReduction.Subtype);
                }
            }
            else if (arrayType.flags & TypeFlags.StringLike) {
                arrayType = neverType;
            }

            hasStringConstituent = arrayType !== inputType;
            if (hasStringConstituent) {
                // Now that we've removed all the StringLike types, if no constituents remain, then the entire
                // arrayOrStringType was a string.
                if (arrayType.flags & TypeFlags.Never) {
                    return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
                }
            }
        }

        if (!isArrayLikeType(arrayType) && !isMappingType(arrayType)) {
            if (errorNode) {
                // Which error we report depends on whether we allow strings or if there was a
                // string constituent. For example, if the input type is number | string, we
                // want to say that number is not an array type. But if the input was just
                // number and string input is allowed, we want to say that number is not an
                // array type or a string type.
                const allowsStrings = !!(use & IterationUse.AllowsStringInputFlag) && !hasStringConstituent;
                const [defaultDiagnostic, maybeMissingAwait] = getIterationDiagnosticDetails(allowsStrings, downlevelIteration);
                errorAndMaybeSuggestAwait(
                    errorNode,
                    false,//maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType),
                    defaultDiagnostic,
                    typeToString(arrayType),
                );
            }
            return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined;
        }

        const arrayElementType = isArrayType(arrayType) && arrayType.resolvedTypeArguments ? first(arrayType.resolvedTypeArguments) : getIndexTypeOfType(arrayType, numberType);
        if (hasStringConstituent && arrayElementType) {
            // This is just an optimization for the case where arrayOrStringType is string | string[]
            if (arrayElementType.flags & TypeFlags.StringLike && !compilerOptions.noUncheckedIndexedAccess) {
                return stringType;
            }

            return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], UnionReduction.Subtype);
        }

        if (isMappingType(arrayType)) {
            return arrayType.resolvedTypeArguments?.length ? getUnionType(arrayType.resolvedTypeArguments) : autoType;
        }

        return (use & IterationUse.PossiblyOutOfBounds) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType;

        function getIterationDiagnosticDetails(allowsStrings: boolean, downlevelIteration: boolean | undefined): [error: DiagnosticMessage, maybeMissingAwait: boolean] {
            if (downlevelIteration) {
                return allowsStrings
                    ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
                    : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
            }

            return allowsStrings
                ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]
                : [Diagnostics.Type_0_is_not_an_array_type, true];
        }
    }
    
    function checkPropertyAccessExpression(node: PropertyAccessExpression, checkMode: CheckMode | undefined, writeOnly?: boolean) {
        return node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(node as PropertyAccessChain, checkMode) :
            checkPropertyAccessExpressionOrQualifiedName(node, node.expression, tryResolveExpressionToObject(node.expression, node, checkMode) ?? checkNonNullExpression(node.expression, checkMode), node.name, checkMode, writeOnly);
    }
    
    function tryResolveExpressionToObject(expression: Expression, location?: Node | undefined, checkMode?: CheckMode | undefined): Type | undefined {
        if (expression.kind === SyntaxKind.StringLiteral) {
            return tryResolveStringToObject(expression as StringLiteral);  
        } else if (isIdentifier(expression)) {
            // shortcut a few types to avoid unnecessary work
            return undefined;
        } else {
            const type = checkExpression(expression, checkMode);            
            if (type.flags & (TypeFlags.String | TypeFlags.StringLiteral)) {
                const specifier = expression;
                const locationNode = location || expression;                                

                const moduleSymbol = resolveExternalModuleName(locationNode, specifier, type);
                if (moduleSymbol) {            
                    const objectSymbol = resolveExternalObjectSymbol(moduleSymbol, specifier, /*dontResolveAlias*/ true);
                    if (objectSymbol && isSourceFile(objectSymbol.valueDeclaration)) {                
                        const objectType = getTypeOfSymbol(objectSymbol);
                        return objectType;                
                    }           
                }
            }
        }

        return undefined;
    }

    function checkPropertyAccessChain(node: PropertyAccessChain, checkMode: CheckMode | undefined) {
        const leftType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
        return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType !== leftType);
    }    

    function getOptionalExpressionType(exprType: Type, expression: Expression) {
        console.debug("todo - getOptionalExpressionType");
        return exprType;
        // TODO: 
        // return isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :
        //     isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :
        //     exprType;
    }

    function propagateOptionalTypeMarker(type: Type, node: OptionalChain, wasOptional: boolean) {
        return type;// TODO return wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type;
    }
    
    function getNonNullableType(type: Type): Type {
        return type;// strictNullChecks ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
    }

    function getDeclarationContainer(node: Node): Node {
        return findAncestor(getRootDeclaration(node), node => {
            switch (node.kind) {
                case SyntaxKind.VariableDeclaration:
                case SyntaxKind.VariableDeclarationList:
                // case SyntaxKind.ImportSpecifier:
                // case SyntaxKind.NamedImports:
                // case SyntaxKind.NamespaceImport:
                // case SyntaxKind.ImportClause:
                    return false;
                default:
                    return true;
            }
        })!.parent;
    }

    function getCombinedModifierFlagsCached(node: Declaration) {
        // we hold onto the last node and result to speed up repeated lookups against the same node.
        if (lastGetCombinedModifierFlagsNode === node) {
            return lastGetCombinedModifierFlagsResult;
        }

        lastGetCombinedModifierFlagsNode = node;
        lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node);
        return lastGetCombinedModifierFlagsResult;
    }
    
    function isDeclarationVisible(node: Node): boolean {
        if (node) {
            const links = getNodeLinks(node);
            if (links.isVisible === undefined) {
                links.isVisible = !!determineIfDeclarationIsVisible();
            }
            return links.isVisible;
        }

        return false;

        function determineIfDeclarationIsVisible() {
            switch (node.kind) {
                case SyntaxKind.JSDocCallbackTag:
                case SyntaxKind.JSDocTypedefTag:
                case SyntaxKind.JSDocEnumTag:
                    // Top-level jsdoc type aliases are considered exported
                    // First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file
                    return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent));
                case SyntaxKind.BindingElement:
                    return isDeclarationVisible(node.parent.parent);
                case SyntaxKind.VariableDeclaration:
                    if (
                        isBindingPattern((node as VariableDeclaration).name) &&
                        !((node as VariableDeclaration).name as BindingPattern).elements.length
                    ) {
                        // If the binding pattern is empty, this variable declaration is not visible
                        return false;
                    }
                    // falls through
                // case SyntaxKind.ModuleDeclaration:
                // case SyntaxKind.ClassDeclaration:
                // case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.FunctionDeclaration:
                // case SyntaxKind.EnumDeclaration:
                // case SyntaxKind.ImportEqualsDeclaration:
                    // external module augmentation is always visible
                    // if (isExternalModuleAugmentation(node)) {
                    //     return true;
                    // }
                    const parent = getDeclarationContainer(node);
                    // If the node is not exported or it is not ambient module element (except import declaration)
                    if (
                        !(getCombinedModifierFlagsCached(node as Declaration) & ModifierFlags.Export) &&
                        !(/*node.kind !== SyntaxKind.ImportEqualsDeclaration &&*/ parent.kind !== SyntaxKind.SourceFile && parent.flags & NodeFlags.Ambient)
                    ) {
                        return true;// isGlobalSourceFile(parent);
                    }
                    // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                    return isDeclarationVisible(parent);

                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                // case SyntaxKind.GetAccessor:
                // case SyntaxKind.SetAccessor:
                // case SyntaxKind.MethodDeclaration:
                // case SyntaxKind.MethodSignature:
                    if (hasEffectiveModifier(node, ModifierFlags.Private | ModifierFlags.Protected)) {
                        // Private/protected properties/methods are not visible
                        return false;
                    }
                    // Public properties/methods are visible if its parents are visible, so:
                    // falls through

                // case SyntaxKind.Constructor:
                // case SyntaxKind.ConstructSignature:
                // case SyntaxKind.CallSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.Parameter:
                // case SyntaxKind.ModuleBlock:
                // case SyntaxKind.FunctionType:
                // case SyntaxKind.ConstructorType:
                case SyntaxKind.TypeLiteral:
                case SyntaxKind.TypeReference:
                case SyntaxKind.ArrayType:                
                // case SyntaxKind.TupleType:
                case SyntaxKind.UnionType:
                case SyntaxKind.IntersectionType:
                case SyntaxKind.ParenthesizedType:
                // case SyntaxKind.NamedTupleMember:
                    return isDeclarationVisible(node.parent);

                // Default binding, import specifier and namespace import is visible
                // only on demand so by default it is not visible
                // case SyntaxKind.ImportClause:
                // case SyntaxKind.NamespaceImport:
                // case SyntaxKind.ImportSpecifier:
                //     return false;

                // Type parameters are always visible
                case SyntaxKind.TypeParameter:

                // Source file and namespace export are always visible
                // falls through
                case SyntaxKind.SourceFile:
                // case SyntaxKind.NamespaceExportDeclaration:
                    return true;

                // Export assignments do not create name bindings outside the module
                // case SyntaxKind.ExportAssignment:
                //     return false;

                default:
                    return false;
            }
        }
    }

    function getTypeOfSymbolAtLocation(symbol: Symbol, location: Node) {
        symbol = getExportSymbolOfValueSymbolIfExported(symbol);

        // If we have an identifier or a property access at the given location, if the location is
        // an dotted name expression, and if the location is not an assignment target, obtain the type
        // of the expression (which will reflect control flow analysis). If the expression indeed
        // resolved to the given symbol, return the narrowed type.
        if (location.kind === SyntaxKind.Identifier /*|| location.kind === SyntaxKind.PrivateIdentifier*/) {
            if (isRightSideOfQualifiedNameOrPropertyAccess(location)) {
                location = location.parent;
            }
            if (isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location))) {
                const type = removeOptionalTypeMarker(
                    // isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ?
                    //     checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode*/ undefined, /*writeOnly*/ true) :
                        getTypeOfExpression(location as Expression),
                );
                if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) {
                    return type;
                }
            }
        }
        
        // The location isn't a reference to the given symbol, meaning we're being asked
        // a hypothetical question of what type the symbol would have if there was a reference
        // to it at the given location. Since we have no control flow information for the
        // hypothetical reference (control flow information is created and attached by the
        // binder), we simply return the declared type of the symbol.
        return isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) ? getWriteTypeOfSymbol(symbol) : getNonMissingTypeOfSymbol(symbol);
    }

    function getNonMissingTypeOfSymbol(symbol: Symbol) {
        return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional));
    }

    function isUnitType(type: Type): boolean {
        return !!(type.flags & TypeFlags.Unit);
    }
       
    function isReadonlyAssignmentDeclaration(d: Declaration) {
        if (!isCallExpression(d)) {
            return false;
        }
        console.warn("Implement me - isReadonlyAssignmentDeclaration");
        return false;
        // if (!isBindableObjectDefinePropertyCall(d)) {
        //     return false;
        // }        
        // const objectLitType = checkExpressionCached(d.arguments[2]);
        // const valueType = getTypeOfPropertyOfType(objectLitType, "value" as string);
        // if (valueType) {
        //     const writableProp = getPropertyOfType(objectLitType, "writable" as string);
        //     const writableType = writableProp && getTypeOfSymbol(writableProp);
        //     if (!writableType || writableType === falseType || writableType === regularFalseType) {
        //         return true;
        //     }
        //     // We include this definition whereupon we walk back and check the type at the declaration because
        //     // The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
        //     // argument types, should the type be contextualized by the call itself.
        //     if (writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration)) {
        //         const initializer = writableProp.valueDeclaration.initializer;
        //         const rawOriginalType = checkExpression(initializer);
        //         if (rawOriginalType === falseType || rawOriginalType === regularFalseType) {
        //             return true;
        //         }
        //     }
        //     return false;
        // }
        // const setProp = getPropertyOfType(objectLitType, "set" as string);
        // return !setProp;
    }

    function getDeclarationNodeFlagsFromSymbol(s: Symbol): NodeFlags {
        return s.valueDeclaration ? getCombinedNodeFlagsCached(s.valueDeclaration) : 0;
    }
        
    // This function is used to propagate certain flags when creating new object type references and union types.
    // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
    // of an object literal or a non-inferrable type. This is because there are operations in the type checker
    // that care about the presence of such types at arbitrary depth in a containing type.
    function getPropagatingFlagsOfTypes(types: readonly Type[], excludeKinds?: TypeFlags): ObjectFlags {
        let result: ObjectFlags = 0;
        for (const type of types) {
            if (excludeKinds === undefined || !(type.flags & excludeKinds)) {
                result |= getObjectFlags(type);
            }
        }
        return result & ObjectFlags.PropagatingFlags;
    }

    function createOriginType(flags: TypeFlags): Type {
        return new Type(checker, flags);
    }

    function createOriginUnionOrIntersectionType(flags: TypeFlags, types: Type[]) {
        const result = createOriginType(flags) as UnionOrIntersectionType;
        result.types = types;
        return result;
    }

    function checkSourceElement(node: Node | undefined): void {
        if (node) {
            const saveCurrentNode = currentNode;
            currentNode = node;
            instantiationCount = 0;
            checkSourceElementWorker(node);
            currentNode = saveCurrentNode;
        }
    }

    function checkSourceElementWorker(node: Node): void {
        if (getNodeCheckFlags(node) & NodeCheckFlags.PartiallyTypeChecked) {
            return;
        }

        if (canHaveJSDoc(node)) {            
            forEach(node.jsDoc, ({ comment, tags }) => {
                checkJSDocCommentWorker(comment);
                forEach(tags, tag => {
                    checkJSDocCommentWorker(tag.comment);
                    if (isInJSFile(node)) {
                        checkSourceElement(tag);
                    }
                });
            });
        }
        
        const kind = node.kind;
        if (cancellationToken) {
            // Only bother checking on a few construct kinds.  We don't want to be excessively
            // hitting the cancellation token on every node we check.
            switch (kind) {
                // case SyntaxKind.ModuleDeclaration:
                // case SyntaxKind.ClassDeclaration:
                // case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.FunctionDeclaration:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        if (kind >= SyntaxKind.FirstStatement && kind <= SyntaxKind.LastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode)) {
            errorOrSuggestion(compilerOptions.allowUnreachableCode === false, node, Diagnostics.Unreachable_code_detected);
        }

        // If editing this, keep `isSourceElement` in utilities up to date.
        switch (kind) {
            case SyntaxKind.TypeParameter:
                return checkTypeParameter(node as TypeParameterDeclaration);
            case SyntaxKind.Parameter:
                return checkParameter(node as ParameterDeclaration);            
            case SyntaxKind.InheritDeclaration:
                return checkInheritDeclaration(node as InheritDeclaration);
            case SyntaxKind.IncludeDirective:
                return checkIncludeDirective(node as IncludeDirective);
            case SyntaxKind.StructDeclaration:
                return checkStructDeclaration(node as StructDeclaration);
            case SyntaxKind.StructType:                
            case SyntaxKind.TypeReference:
                return checkTypeReferenceNode(node as TypeReferenceNode);
            case SyntaxKind.PropertyDeclaration:
                return checkPropertyDeclaration(node as PropertyDeclaration);
            case SyntaxKind.PropertySignature:
                return checkPropertySignature(node as PropertySignature);                        
            case SyntaxKind.FunctionType:
            case SyntaxKind.CallSignature:
            case SyntaxKind.IndexSignature:
                return checkSignatureDeclaration(node as SignatureDeclaration);            
            case SyntaxKind.TypeLiteral:                
                return checkTypeLiteral(node as TypeLiteralNode);
            case SyntaxKind.ArrayType:
                return checkArrayType(node as ArrayTypeNode);            
            case SyntaxKind.UnionType:            
            case SyntaxKind.IntersectionType:
                return checkUnionOrIntersectionType(node as UnionOrIntersectionTypeNode);
            case SyntaxKind.ParenthesizedType:
            // case SyntaxKind.OptionalType:
            case SyntaxKind.RestType:
                return checkSourceElement((node as ParenthesizedTypeNode).type);
            case SyntaxKind.TypePredicate:
                return checkTypePredicate(node as TypePredicateNode);
            // case SyntaxKind.ThisType:
            //     return checkThisType(node as ThisTypeNode);
            case SyntaxKind.TypeOperator:
                Debug.fail("type operator");
            //     return checkTypeOperator(node as TypeOperatorNode);                        
            case SyntaxKind.JSDocAugmentsTag:
                Debug.fail("augments");
            //     return checkJSDocAugmentsTag(node as JSDocAugmentsTag);
            case SyntaxKind.JSDocImplementsTag:
                Debug.fail("implements");
            //     return checkJSDocImplementsTag(node as JSDocImplementsTag);
            case SyntaxKind.JSDocTypedefTag:
            case SyntaxKind.JSDocCallbackTag:                
            // case SyntaxKind.JSDocEnumTag:
                return checkJSDocTypeAliasTag(node as JSDocTypedefTag);
            case SyntaxKind.JSDocVariableTag:
                return checkJSDocVariableTag(node as JSDocVariableTag);
            case SyntaxKind.JSDocTemplateTag:
                return checkJSDocTemplateTag(node as JSDocTemplateTag);
            case SyntaxKind.JSDocTypeTag:
                return checkJSDocTypeTag(node as JSDocTypeTag);
            case SyntaxKind.JSDocLink:
            case SyntaxKind.JSDocLinkCode:
            case SyntaxKind.JSDocLinkPlain:                
                return checkJSDocLinkLikeTag(node as JSDocLink | JSDocLinkCode | JSDocLinkPlain);
            case SyntaxKind.JSDocParameterTag:
                return checkJSDocParameterTag(node as JSDocParameterTag);
            case SyntaxKind.JSDocPropertyTag:
                return checkJSDocPropertyTag(node as JSDocPropertyTag);
            case SyntaxKind.JSDocReturnTag:
                return checkJSDocReturnTag(node as JSDocReturnTag);
            case SyntaxKind.JSDocFunctionType:
                checkJSDocFunctionType(node as JSDocFunctionType);
                // falls through
            case SyntaxKind.JSDocNonNullableType:
            case SyntaxKind.JSDocNullableType:
            case SyntaxKind.JSDocAllType:
            case SyntaxKind.JSDocUnknownType:
            case SyntaxKind.JSDocTypeLiteral:            
                forEachChild(node, checkSourceElement);
                return;
            case SyntaxKind.NamedObjectType:
                return checkSourceElement((node as NamedObjectTypeNode).name);
            case SyntaxKind.JSDocVariadicType:
                console.debug("todo - checkJSDocVariadicType");
                // checkJSDocVariadicType(node as JSDocVariadicType);
                return;
            case SyntaxKind.JSDocTypeExpression:
                return checkSourceElement((node as JSDocTypeExpression).type);
            case SyntaxKind.JSDocPublicTag:
            case SyntaxKind.JSDocProtectedTag:
            case SyntaxKind.JSDocPrivateTag:
                console.debug("todo - checkJSDocAccessibilityModifiers");
                return;
            //     return checkJSDocAccessibilityModifiers(node as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag);
            case SyntaxKind.JSDocSatisfiesTag:
                console.debug("todo - checkJSDocSatisfiesTag");
                return;
            //     return checkJSDocSatisfiesTag(node as JSDocSatisfiesTag);
            // case SyntaxKind.JSDocThisTag:
            //     return checkJSDocThisTag(node as JSDocThisTag);
            // case SyntaxKind.JSDocImportTag:
            //     return checkJSDocImportTag(node as JSDocImportTag);
            case SyntaxKind.IndexedAccessType:
                return checkIndexedAccessType(node as IndexedAccessTypeNode);
            case SyntaxKind.MappedType:
                return checkMappedType(node as MappedTypeNode);
            case SyntaxKind.FunctionDeclaration:
                return checkFunctionDeclaration(node as FunctionDeclaration);
            case SyntaxKind.Block:            
                return checkBlock(node as Block);
            case SyntaxKind.VariableStatement:
                return checkVariableStatement(node as VariableStatement);
            case SyntaxKind.ExpressionStatement:
                return checkExpressionStatement(node as ExpressionStatement);
            case SyntaxKind.IfStatement:
                return checkIfStatement(node as IfStatement);
            case SyntaxKind.DoWhileStatement:
                return checkDoWhileStatement(node as DoWhileStatement);
            case SyntaxKind.WhileStatement:
                return checkWhileStatement(node as WhileStatement);
            case SyntaxKind.ForStatement:
                return checkForStatement(node as ForStatement);
            case SyntaxKind.ForEachStatement:
                return checkForEachStatement(node as ForEachStatement);            
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.BreakStatement:
                return checkBreakOrContinueStatement(node as BreakOrContinueStatement);
            case SyntaxKind.ReturnStatement:
                return checkReturnStatement(node as ReturnStatement);
            // case SyntaxKind.WithStatement:
            //     return checkWithStatement(node as WithStatement);
            case SyntaxKind.SwitchStatement:
                return checkSwitchStatement(node as SwitchStatement);
            // case SyntaxKind.LabeledStatement:
            //     return checkLabeledStatement(node as LabeledStatement);
            // case SyntaxKind.ThrowStatement:
            //     return checkThrowStatement(node as ThrowStatement);
            // case SyntaxKind.TryStatement:
            //     return checkTryStatement(node as TryStatement);
            case SyntaxKind.VariableDeclaration:
                checkVariableDeclaration(node as VariableDeclaration);
                return;
            case SyntaxKind.BindingElement:
                checkBindingElement(node as BindingElement);
                return;
            case SyntaxKind.ClassDeclaration:
                Debug.fail("class declaration");
                // return checkClassDeclaration(node as ClassDeclaration);            
            case SyntaxKind.TypeAliasDeclaration:
                Debug.fail("type alias");
                // return checkTypeAliasDeclaration(node as TypeAliasDeclaration);            
            case SyntaxKind.MissingDeclaration:
                return checkMissingDeclaration(node);
            case SyntaxKind.CatchStatement:
                checkCatchExpression(node as CatchStatement);                
                return;
            // these types don't need any additional checking here
            case SyntaxKind.BinaryExpression:
            case SyntaxKind.IntKeyword:
            case SyntaxKind.StringKeyword:
            case SyntaxKind.ObjectKeyword:            
            case SyntaxKind.VoidKeyword:
            case SyntaxKind.FunctionKeyword:
            case SyntaxKind.MixedKeyword:
            case SyntaxKind.StatusKeyword:
                return;
            // don't typecheck define directives
            case SyntaxKind.DefineDirective:
                return;
            // some elements that don't need checking but we'll explicitly add
            // until the console.warn is removed
            case SyntaxKind.EndOfFileToken:
            case SyntaxKind.LiteralType:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.IntLiteral:
            case SyntaxKind.CallExpression:
            case SyntaxKind.MappingKeyword:            
            case SyntaxKind.Identifier:      
            case SyntaxKind.ConditionalExpression:          
            case SyntaxKind.FloatKeyword:
            case SyntaxKind.PragmaDirective:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.JSDocTag:
            case SyntaxKind.JSDocSeeTag:
            case SyntaxKind.EmptyStatement:            
            case SyntaxKind.JSDocClassTag:
            case SyntaxKind.JSDocSignature:
            case SyntaxKind.UndefDirective:
            case SyntaxKind.ParenthesizedExpression:
                return;
        }

        // TODO
        console.warn("Implement me - checkSourceElementWorker - " + Debug.formatSyntaxKind(node.kind));
    }

    function checkMissingDeclaration(node: Node) {
        // checkDecorators(node);
    }

    function checkExpressionStatement(node: ExpressionStatement) {
        // Grammar checking
        //checkGrammarStatementInAmbientContext(node);

        checkExpression(node.expression);
    }

    function checkIfStatement(node: IfStatement) {
        // Grammar checking
        //checkGrammarStatementInAmbientContext(node);
        const type = checkTruthinessExpression(node.expression);
        checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type, node.thenStatement);
        checkSourceElement(node.thenStatement);

        // this is allowed in LPC
        // if (node.thenStatement.kind === SyntaxKind.EmptyStatement) {
        //     error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
        // }

        checkSourceElement(node.elseStatement);
    }

    function grammarErrorOnFirstToken(node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const spanSourceFile = getSourceFileOrIncludeOfNode(node);
        const sourceFile = getSourceFileOfNode(node);

        if (!hasParseDiagnostics(sourceFile)) {
            const span = getSpanOfTokenAtPosition(spanSourceFile, node.pos);
            diagnostics.add(createFileDiagnostic(spanSourceFile, span.start, span.length, message, ...args));
            return true;
        }
        return false;
    }
    
    function checkPropertySignature(node: PropertySignature) {        
        return checkPropertyDeclaration(node);
    }

    function checkPropertyDeclaration(node: PropertyDeclaration | PropertySignature) {
        // Grammar checking
        if (!checkGrammarModifiers(node) && !checkGrammarProperty(node)) {}// checkGrammarComputedPropertyName(node.name);
        checkVariableLikeDeclaration(node);

        // setNodeLinksForPrivateIdentifierScope(node);

        // property signatures already report "initializer not allowed in ambient context" elsewhere
        // if (hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.PropertyDeclaration && node.initializer) {
        //     error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name));
        // }
    }
    
    function checkGrammarProperty(node: PropertyDeclaration | PropertySignature) {
        // if (isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind === SyntaxKind.InKeyword) {
        //     return grammarErrorOnNode(node.parent.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
        // }
        if (isClassLike(node.parent)) {
            // if (isStringLiteral(node.name) && node.name.text === "constructor") {
            //     return grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor);
            // }
            // if (checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type)) {
            //     return true;
            // }
            // if (languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(node.name)) {
            //     return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            // }
            // if (languageVersion < ScriptTarget.ES2015 && isAutoAccessorPropertyDeclaration(node)) {
            //     return grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            // }
            // if (isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional)) {
            //     return true;
            // }
        }
        // else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
        //     if (checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
        //         return true;
        //     }

        //     // Interfaces cannot contain property declarations
        //     Debug.assertNode(node, isPropertySignature);
        //     if (node.initializer) {
        //         return grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer);
        //     }
        // }
        else if (isTypeLiteralNode(node.parent)) {
            // if (checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
            //     return true;
            // }
            // Type literals cannot contain property declarations
            Debug.assertNode(node, isPropertySignature);
            if (node.initializer) {
                return grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer);
            }
        }

        // if (node.flags & NodeFlags.Ambient) {
        //     checkAmbientInitializer(node);
        // }        
    }

    function checkTypeReferenceNode(node: TypeReferenceNode) {
        checkGrammarTypeArguments(node, node.typeArguments);
        if (node.kind === SyntaxKind.TypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end !== node.typeArguments.pos) {
            // If there was a token between the type name and the type arguments, check if it was a DotToken
            const sourceFile = getSourceFileOfNode(node);
            if (scanTokenAtPosition(sourceFile, node.typeName.end) === SyntaxKind.DotToken) {
                grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
        }
        forEach(node.typeArguments, checkSourceElement);
        checkTypeReferenceOrImport(node);
    }    

    function getTypeParametersForTypeReferenceOrImport(node: TypeReferenceNode | ExpressionWithTypeArguments) {
        const type = getTypeFromTypeNode(node);
        if (!isErrorType(type)) {
            const symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                return getTypeParametersForTypeAndSymbol(type, symbol);
            }
        }
        return undefined;
    }

    function getTypeParametersForTypeAndSymbol(type: Type, symbol: Symbol) {
        if (!isErrorType(type)) {
            return symbol.flags & SymbolFlags.TypeAlias && getSymbolLinks(symbol).typeParameters ||
                (getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined);
        }
        return undefined;
    }

    function checkTypeArgumentConstraints(node: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments, typeParameters: readonly TypeParameter[]): boolean {
        let typeArguments: Type[] | undefined;
        let mapper: TypeMapper | undefined;
        let result = true;
        for (let i = 0; i < typeParameters.length; i++) {
            const constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                if (!typeArguments) {
                    typeArguments = getEffectiveTypeArguments(node, typeParameters);
                    mapper = createTypeMapper(typeParameters, typeArguments);
                }
                result = result && checkTypeAssignableTo(
                    typeArguments[i],
                    instantiateType(constraint, mapper),
                    node.typeArguments![i],
                    Diagnostics.Type_0_does_not_satisfy_the_constraint_1,
                );
            }
        }
        return result;
    }
    
    function checkTypeReferenceOrImport(node: TypeReferenceNode) {
        const type = getTypeFromTypeNode(node);
        if (!isErrorType(type)) {
            if (node.typeArguments) {
                addLazyDiagnostic(() => {
                    const typeParameters = getTypeParametersForTypeReferenceOrImport(node);
                    if (typeParameters) {
                        checkTypeArgumentConstraints(node, typeParameters);
                    }
                });
            }
            const symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                if (some(symbol.declarations, d => isTypeDeclaration(d) && !!(d.flags & NodeFlags.Deprecated))) {
                    addDeprecatedSuggestion(
                        getDeprecatedSuggestionNode(node),
                        symbol.declarations!,
                        symbol.name as string,
                    );
                }
            }
        }
    }

    function getDeprecatedSuggestionNode(node: Node): Node {
        node = skipParentheses(node);
        switch (node.kind) {
            case SyntaxKind.CallExpression:
            // case SyntaxKind.Decorator:
            case SyntaxKind.NewExpression:
                return getDeprecatedSuggestionNode((node as CallExpression | NewExpression).expression);
            // case SyntaxKind.TaggedTemplateExpression:
            //     return getDeprecatedSuggestionNode((node as TaggedTemplateExpression).tag);            
            case SyntaxKind.ElementAccessExpression:
                return (node as ElementAccessExpression).argumentExpression;
            case SyntaxKind.PropertyAccessExpression:
                return (node as PropertyAccessExpression).name;
            case SyntaxKind.TypeReference:
                const typeReference = node as TypeReferenceNode;
                return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;
            default:
                return node;
        }
    }

    function checkTypeLiteral(node: TypeLiteralNode) {
        forEach(node.members, checkSourceElement);
        addLazyDiagnostic(checkTypeLiteralDiagnostics);

        function checkTypeLiteralDiagnostics() {
            const type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
            checkIndexConstraints(type, type.symbol);
            checkTypeForDuplicateIndexSignatures(node);
            checkObjectTypeForDuplicateDeclarations(node);
        }
    }

    function checkIndexConstraints(type: Type, symbol: Symbol, isStaticIndex?: boolean) {
        const indexInfos = getIndexInfosOfType(type);
        if (indexInfos.length === 0) {
            return;
        }
        for (const prop of getPropertiesOfObjectType(type)) {
            if (!(isStaticIndex && prop.flags & SymbolFlags.Prototype)) {
                checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique, /*includeNonPublic*/ true), getNonMissingTypeOfSymbol(prop));
            }
        }
        const typeDeclaration = symbol.valueDeclaration;
        if (typeDeclaration && isClassLike(typeDeclaration)) {
            for (const member of typeDeclaration.members) {
                // Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,
                // and properties with literal names were already checked.
                if (!isStatic(member) && !hasBindableName(member)) {
                    const symbol = getSymbolOfDeclaration(member);
                    checkIndexConstraintForProperty(type, symbol, getTypeOfExpression((member as DynamicNamedDeclaration).name.expression), getNonMissingTypeOfSymbol(symbol));
                }
            }
        }
        if (indexInfos.length > 1) {
            for (const info of indexInfos) {
                checkIndexConstraintForIndexSignature(type, info);
            }
        }
    }

    function checkIndexConstraintForProperty(type: Type, prop: Symbol, propNameType: Type, propType: Type) {
        const declaration = prop.valueDeclaration;
        const name = getNameOfDeclaration(declaration);
        if (name && isPrivateIdentifier(name)) {
            return;
        }
        const indexInfos = getApplicableIndexInfos(type, propNameType);
        const interfaceDeclaration = getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined;
        const propDeclaration = declaration && declaration.kind === SyntaxKind.BinaryExpression ||
                name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined;
        const localPropDeclaration = getParentOfSymbol(prop) === type.symbol ? declaration : undefined;
        for (const info of indexInfos) {
            const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined;
            // We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
            // in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
            // the index signature (i.e. property and index signature are declared in separate inherited interfaces).
            const errorNode = localPropDeclaration || localIndexDeclaration ||
                (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.name) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined);
            if (errorNode && !isTypeAssignableTo(propType, info.type)) {
                const diagnostic = createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));
                if (propDeclaration && errorNode !== propDeclaration) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)));
                }
                diagnostics.add(diagnostic);
            }
        }
    }

    function checkIndexConstraintForIndexSignature(type: Type, checkInfo: IndexInfo) {
        const declaration = checkInfo.declaration;
        const indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
        const interfaceDeclaration = getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined;
        const localCheckDeclaration = declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined;
        for (const info of indexInfos) {
            if (info === checkInfo) continue;
            const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined;
            // We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
            // signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
            // both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
            const errorNode = localCheckDeclaration || localIndexDeclaration ||
                (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined);
            if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
                error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));
            }
        }
    }

    function checkObjectTypeForDuplicateDeclarations(node: TypeLiteralNode ) {
        const names = new Map<string, boolean>();
        for (const member of node.members) {
            if (member.kind === SyntaxKind.PropertySignature) {
                let memberName: string;
                const name = member.name!;
                switch (name.kind) {
                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.IntLiteral:
                        memberName = name.text;
                        break;
                    case SyntaxKind.Identifier:
                        memberName = idText(name);
                        break;
                    default:
                        continue;
                }

                if (names.get(memberName)) {
                    error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName);
                    error(member.name, Diagnostics.Duplicate_identifier_0, memberName);
                }
                else {
                    names.set(memberName, true);
                }
            }
        }
    }

    function checkTypeForDuplicateIndexSignatures(node: ClassLikeDeclaration |  TypeLiteralNode) {
        // if (node.kind === SyntaxKind.InterfaceDeclaration) {
        //     const nodeSymbol = getSymbolOfDeclaration(node);
        //     // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
        //     // to prevent this run check only for the first declaration of a given kind
        //     if (nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
        //         return;
        //     }
        // }

        // TypeScript 1.0 spec (April 2014)
        // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
        // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
        const indexSymbol = getIndexSymbol(getSymbolOfDeclaration(node));
        if (indexSymbol?.declarations) {
            const indexSignatureMap = new Map<TypeId, { type: Type; declarations: IndexSignatureDeclaration[]; }>();
            for (const declaration of (indexSymbol.declarations as IndexSignatureDeclaration[])) {
                if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                    forEachType(getTypeFromTypeNode(declaration.parameters[0].type), type => {
                        const entry = indexSignatureMap.get(getTypeId(type));
                        if (entry) {
                            entry.declarations.push(declaration);
                        }
                        else {
                            indexSignatureMap.set(getTypeId(type), { type, declarations: [declaration] });
                        }
                    });
                }
            }
            indexSignatureMap.forEach(entry => {
                if (entry.declarations.length > 1) {
                    for (const declaration of entry.declarations) {
                        error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));
                    }
                }
            });
        }
    }

    function getTypeFromInferTypeNode(node: InferTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter));
        }
        return links.resolvedType;
    }
    
    function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node: TypeLiteralNode | /*FunctionOrConstructorTypeNode |*/ JSDocTypeLiteral | /*JSDocFunctionType |*/ JSDocSignature): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // Deferred resolution of members is handled by resolveObjectTypeMembers
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
                links.resolvedType = emptyTypeLiteralType;
            }
            else {
                let type = createObjectType(ObjectFlags.Anonymous, node.symbol);
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                if (isJSDocTypeLiteral(node) && node.isArrayType) {
                    type = createArrayType(type);
                }
                links.resolvedType = type;
            }
        }
        return links.resolvedType;
    }

    function checkUnionOrIntersectionType(node: UnionOrIntersectionTypeNode) {
        forEach(node.types, checkSourceElement);
        getTypeFromTypeNode(node);
    }
    
    function checkArrayType(node: ArrayTypeNode) {
        checkSourceElement(node.elementType);
    }

    function checkSwitchStatement(node: SwitchStatement) {
        // Grammar checking        
        let firstDefaultClause: CaseOrDefaultClause;
        let hasDuplicateDefaultClause = false;

        const expressionType = checkExpression(node.expression);

        forEach(node.caseBlock.clauses, clause => {
            // Grammar check for duplicate default clauses, skip if we already report duplicate default clause
            if (clause.kind === SyntaxKind.DefaultClause && !hasDuplicateDefaultClause) {
                if (firstDefaultClause === undefined) {
                    firstDefaultClause = clause;
                }
                else {
                    grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                    hasDuplicateDefaultClause = true;
                }
            }

            if (clause.kind === SyntaxKind.CaseClause) {
                addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));
            }
            forEach(clause.statements, checkSourceElement);
            if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {
                error(clause, Diagnostics.Fallthrough_case_in_switch);
            }

            function createLazyCaseClauseDiagnostics(clause: CaseClause) {
                return () => {
                    // TypeScript 1.0 spec (April 2014): 5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is comparable
                    // to or from the type of the 'switch' expression.
                    const caseType = checkExpression(clause.expression);

                    if (!isTypeEqualityComparableTo(expressionType, caseType)) {
                        // expressionType is not comparable to caseType, try the reversed check and report errors if it fails
                        checkTypeComparableTo(caseType, expressionType, clause.expression, /*headMessage*/ undefined);
                    }
                };
            }
        });
        if (node.caseBlock.locals) {
            registerForUnusedIdentifiersCheck(node.caseBlock);
        }
    }

    function checkReturnStatement(node: ReturnStatement) {        
        // Grammar checking
        // if (checkGrammarStatementInAmbientContext(node)) {
        //     return;
        // }

        const container = getContainingFunctionOrClassStaticBlock(node);
        // if (container && isClassStaticBlockDeclaration(container)) {
        //     grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block);
        //     return;
        // }

        if (!container) {
            grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            return;
        }

        const signature = getSignatureFromDeclaration(container);
        Debug.assertIsDefined(signature, "Container should have a signature");
        const returnType = getReturnTypeOfSignature(signature);
        const functionFlags = getFunctionFlags(container);
        if (strictNullChecks || node.expression || returnType.flags & TypeFlags.Never) {
            const exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;            
            if (getReturnTypeFromAnnotation(container)) {
                const unwrappedReturnType = unwrapReturnType(returnType, functionFlags) ?? returnType;
                // const unwrappedExprType = functionFlags & FunctionFlags.Async
                //     ? checkAwaitedType(exprType, /*withAlias*/ false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                //     : exprType;
                const unwrappedExprType = exprType;
                if (unwrappedReturnType) {
                    // If the function has a return type, but promisedType is
                    // undefined, an error will be reported in checkAsyncFunctionReturnType
                    // so we don't need to report one here.
                    checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression);
                }
            }
        }
        else if (compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType)) {
            // The function has a return type, but the return statement doesn't have an expression.
            error(node, Diagnostics.Not_all_code_paths_return_a_value);
        }
    }
    
    function checkInlineClosureExpression(node: InlineClosureExpression, checkMode: CheckMode) {
        checkNodeDeferred(node);

        // The identityMapper object is used to indicate that function expressions are wildcards
        if (checkMode && checkMode & CheckMode.SkipContextSensitive && isContextSensitive(node)) {
            // Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
            if (!getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node)) {
                // Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
                const contextualSignature = getContextualSignature(node);
                if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                    const links = getNodeLinks(node);
                    if (links.contextFreeType) {
                        return links.contextFreeType;
                    }
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    const returnOnlySignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, returnType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.IsNonInferrable);
                    const returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], emptyArray, emptyArray);
                    returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType;
                    return links.contextFreeType = returnOnlyType;
                }
            }
            return anyFunctionType;
        }

        // Grammar checking
        const hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
        // if (!hasGrammarError && node.kind === SyntaxKind.FunctionExpression) {
        //     checkGrammarForGenerator(node);
        // }

        contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);

        return getTypeOfSymbol(getSymbolOfDeclaration(node));
    }

    function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node: FunctionExpression | InlineClosureExpression, checkMode?: CheckMode) {
        const links = getNodeLinks(node);
        // Check if function expression is contextually typed and assign parameter types if so.
        if (!(links.flags & NodeCheckFlags.ContextChecked)) {
            const contextualSignature = getContextualSignature(node);
            // If a type check is started at a function expression that is an argument of a function call, obtaining the
            // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
            // already assigned contextual types.
            if (!(links.flags & NodeCheckFlags.ContextChecked)) {
                links.flags |= NodeCheckFlags.ContextChecked;
                const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKind.Call));
                if (!signature) {
                    return;
                }
                if (isContextSensitive(node)) {
                    console.debug("todo - contextuallyCheckFunctionExpressionOrObjectLiteralMethod");
                    // if (contextualSignature) {                        
                    //     const inferenceContext = getInferenceContext(node);
                    //     let instantiatedContextualSignature: Signature | undefined;
                    //     if (checkMode && checkMode & CheckMode.Inferential) {                            
                    //         inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext!);
                    //         const restType = getEffectiveRestType(contextualSignature);
                    //         if (restType && restType.flags & TypeFlags.TypeParameter) {
                    //             instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext!.nonFixingMapper);
                    //         }
                    //     }
                    //     instantiatedContextualSignature ||= inferenceContext ?
                    //         instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature;
                    //     assignContextualParameterTypes(signature, instantiatedContextualSignature);
                    // }
                    // else {
                    //     // Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
                    //     assignNonContextualParameterTypes(signature);
                    // }
                }
                else if (contextualSignature && !node.typeParameters && contextualSignature.parameters?.length > node.parameters?.length) {
                    console.debug("todo - contextuallyCheckFunctionExpressionOrObjectLiteralMethod");
                    // const inferenceContext = getInferenceContext(node);
                    // if (checkMode && checkMode & CheckMode.Inferential) {
                    //     inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext!);
                    // }
                }
                if (contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType) {
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    if (!signature.resolvedReturnType) {
                        signature.resolvedReturnType = returnType;
                    }
                }
                checkSignatureDeclaration(node);
            }
        }
    }

    function checkSpreadExpression(node: SpreadElement, checkMode?: CheckMode): Type {
        // if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {
        //     checkExternalEmitHelpers(node, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);
        // }

        const arrayOrIterableType = checkExpression(node.expression, checkMode);
        return checkIteratedTypeOrElementType(IterationUse.Spread, arrayOrIterableType, undefinedType, node.expression);
    }

    function checkVariableDeclaration(node: VariableDeclaration) {
        tracing?.push(tracing.Phase.Check, "checkVariableDeclaration", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath });
        checkGrammarVariableDeclaration(node);        
        const type = checkVariableLikeDeclaration(node);
        tracing?.pop();
        return type;
    }

    function checkBindingElement(node: BindingElement) {
        // checkGrammarBindingElement(node);
        return checkVariableLikeDeclaration(node);
    }

    function checkDoWhileStatement(node: DoWhileStatement) {
        // Grammar checking
        //checkGrammarStatementInAmbientContext(node);

        checkSourceElement(node.statement);
        checkTruthinessExpression(node.expression);
    }

    function checkWhileStatement(node: WhileStatement) {
        // Grammar checking        

        checkTruthinessExpression(node.expression);
        checkSourceElement(node.statement);
    }

    function checkGrammarVariableDeclaration(node: VariableDeclaration) {
        const nodeFlags = getCombinedNodeFlagsCached(node);
        const blockScopeKind = nodeFlags & NodeFlags.BlockScoped;
        // if (isBindingPattern(node.name)) {
        //     switch (blockScopeKind) {
        //         case NodeFlags.AwaitUsing:
        //             return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using");
        //         case NodeFlags.Using:
        //             return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using");
        //     }
        // }

        if (node.parent.parent.kind !== SyntaxKind.ForEachStatement && node.parent.parent.kind !== SyntaxKind.ForStatement) {
            // if (nodeFlags & NodeFlags.Ambient) {
            //     checkAmbientInitializer(node);
            // } else
            if (!node.initializer) {
                // if (isBindingPattern(node.name) && !isBindingPattern(node.parent)) {
                //     return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                // }
                // switch (blockScopeKind) {
                //     case NodeFlags.AwaitUsing:
                //         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using");
                //     case NodeFlags.Using:
                //         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using");
                //     case NodeFlags.Const:
                //         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const");
                // }
            }
        }

        // if (node.exclamationToken && (node.parent.parent.kind !== SyntaxKind.VariableStatement || !node.type || node.initializer || nodeFlags & NodeFlags.Ambient)) {
        //     const message = node.initializer
        //         ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
        //         : !node.type
        //         ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
        //         : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
        //     return grammarErrorOnNode(node.exclamationToken, message);
        // }        

        // 1. LexicalDeclaration : LetOrConst BindingList ;
        // It is a Syntax Error if the BoundNames of BindingList contains "let".
        // 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
        // It is a Syntax Error if the BoundNames of ForDeclaration contains "let".

        // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
        // and its Identifier is eval or arguments
        return !!blockScopeKind;// && checkGrammarNameInLetOrConstDeclarations(node.name);
    }

    function checkGrammarForInOrForOfStatement(forInOrOfStatement: ForEachStatement): boolean {            
        if (forInOrOfStatement.initializer.kind === SyntaxKind.VariableDeclarationList) {
            const variableList = forInOrOfStatement.initializer as VariableDeclarationList;
            if (!checkGrammarVariableDeclarationList(variableList)) {
                const declarations = variableList.declarations;

                // declarations.length can be zero if there is an error in variable declaration in for-of or for-in
                // See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
                // For example:
                //      var let = 10;
                //      for (let of [1,2,3]) {} // this is invalid ES6 syntax
                //      for (let in [1,2,3]) {} // this is invalid ES6 syntax
                // We will then want to skip on grammar checking on variableList declaration
                if (!declarations.length) {
                    return false;
                }

                const decWithInitializer = forEach(declarations, declaration => declaration.initializer);
                if (decWithInitializer) {            
                    const diagnostic = Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer;
                    return grammarErrorOnNode((decWithInitializer.parent as VariableDeclaration).name, diagnostic);
                }                                
            }
        }

        return false;
    }

    function checkForStatement(node: ForStatement) {
        // Grammar checking
        if (node.initializer) {
            if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
                checkVariableDeclarationList(node.initializer as VariableDeclarationList);
            }
            else {
                checkExpression(node.initializer);
            }
        }

        if (node.condition) checkTruthinessExpression(node.condition);
        if (node.incrementor) checkExpression(node.incrementor);
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }


    function checkForEachStatement(node: ForEachStatement) {
        // Grammar checking
        checkGrammarForInOrForOfStatement(node);
        
        // TypeScript 1.0 spec (April 2014): 5.4
        // In a 'for-in' statement of the form
        // for (let VarDecl in Expr) Statement
        //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
        //   and Expr must be an expression of type Any, an object type, or a type parameter type.
        if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {
            const variable = (node.initializer as VariableDeclarationList).declarations[0];
            if (variable && isBindingPattern(variable.name)) {
                error(variable.name, Diagnostics.The_left_hand_side_of_a_for_each_statement_cannot_be_a_destructuring_pattern);
            }
            checkVariableDeclarationList(node.initializer as VariableDeclarationList);
        }
        else {
            // In a 'for-in' statement of the form
            // for (Var in Expr) Statement
            //   Var must be an expression classified as a reference of type Any or the String primitive type,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            const varExpr = node.initializer;
            const iteratedType = checkRightHandSideOfForOf(node);
            let leftType = checkExpression(varExpr);
            let commaRightType: Type;
            const rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));

            if (varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression) {
                error(varExpr, Diagnostics.The_left_hand_side_of_a_for_each_statement_cannot_be_a_destructuring_pattern);
            }
            else if (isCommaExpression(varExpr)) {
                checkReferenceExpression(varExpr.left, Diagnostics.The_left_hand_side_of_a_for_each_mapping_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access);
                checkReferenceExpression(varExpr.right, Diagnostics.The_left_hand_side_of_a_for_each_mapping_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access);
                
                // expand the types on each side of the comma expr
                leftType = checkExpression(varExpr.left);
                commaRightType = checkExpression(varExpr.right);
                if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                    error(varExpr, Diagnostics.The_left_hand_side_of_the_foreach_statement_0_is_not_compatible_with_type_1, typeToString(leftType), typeToString(rightType));
                }
            } 
            else if (isArrayType(rightType)) {
                if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                    error(varExpr, Diagnostics.The_left_hand_side_of_the_foreach_statement_0_is_not_compatible_with_type_1, typeToString(leftType), typeToString(rightType));
                }
            }
            // else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
            else if (!isTypeAssignableTo(rightType, leftType)) {
                error(varExpr, Diagnostics.The_left_hand_side_of_the_foreach_statement_0_is_not_compatible_with_type_1, typeToString(leftType), typeToString(rightType));
            }
            else {            
                checkReferenceExpression(
                    varExpr,
                    Diagnostics.The_left_hand_side_of_a_for_each_mapping_statement_must_be_a_variable_or_a_property_access,
                    Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access
                );
            }
            if (iteratedType) {            
                // iteratedType will be undefined if the rightType was missing properties/signatures
                // required to get its iteratedType (like [Symbol.iterator] or next). This may be
                // because we accessed properties from anyType, or it may have led to an error inside
                // getElementTypeOfIterable.
                if (isCommaExpression(varExpr) && iteratedType.flags & TypeFlags.Union) {
                    const iteratedUnionType = iteratedType as UnionType;
                    // check each type in the union against the type in the comma expr
                    checkTypeAssignableToAndOptionallyElaborate(iteratedUnionType.types.at(0) ?? errorType, leftType, varExpr.left, node.expression);
                    checkTypeAssignableToAndOptionallyElaborate(iteratedUnionType.types.at(1) ?? errorType, commaRightType, varExpr.right, node.expression);
                } else {
                    checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
                }
                return;                
            }
            else if (!isVariableDeclaration(varExpr) && !isCommaExpression(varExpr)) {
                // run check only former check succeeded to avoid cascading errors
                checkReferenceExpression(
                    varExpr,
                    Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access,
                    Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access,
                );
            }
            
            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (rightType === neverType || !isTypeAssignableToKind(rightType, TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive | TypeFlags.String)) {
                error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
            }
        }
        
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }

    function getIndexTypeOrString(type: Type): Type {
        const indexType = getExtractStringType(getIndexType(type));
        return indexType.flags & TypeFlags.Never ? stringType : indexType;
    }

    function checkTruthinessOfType(type: Type, node: Node) {
        if (type.flags & TypeFlags.Void) {
            error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness);
        }
        return type;
    }

    function checkTruthinessExpression(node: Expression, checkMode?: CheckMode) {
        return checkTruthinessOfType(checkExpression(node, checkMode), node);
    }

    function checkStructDeclaration(node: StructDeclaration) {
        // Grammar checking
        checkGrammarModifiers(node);
        // checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
        checkExportsOnMergedDeclarations(node);
                        
        checkSourceElement(node.type);        
    }

    function checkGrammarClassDeclarationHeritageClauses(node: ClassLikeDeclaration) {
        let seenExtendsClause = false;
        let seenImplementsClause = false;

        console.info("todo - checkGrammarClassDeclarationHeritageClauses");
        return true;
        // if (!checkGrammarModifiers(node) && node.heritageClauses) {
        //     for (const heritageClause of node.heritageClauses) {
        //         if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
        //             if (seenExtendsClause) {
        //                 return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);
        //             }

        //             if (seenImplementsClause) {
        //                 return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause);
        //             }

        //             if (heritageClause.types.length > 1) {
        //                 return grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class);
        //             }

        //             seenExtendsClause = true;
        //         }
        //         else {
        //             Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);
        //             if (seenImplementsClause) {
        //                 return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen);
        //             }

        //             seenImplementsClause = true;
        //         }

        //         // Grammar checking heritageClause inside class declaration
        //         checkGrammarHeritageClause(heritageClause);
        //     }
        // }        
    }

    function checkGrammarClassLikeDeclaration(node: ClassLikeDeclaration): boolean {
        const file = getSourceFileOfNode(node);
        return checkGrammarClassDeclarationHeritageClauses(node);
    }

    function checkClassLikeDeclaration(node: ClassLikeDeclaration) {
        checkGrammarClassLikeDeclaration(node);
        
        if (!isSourceFile(node)) checkCollisionsForDeclarationName(node, node.name);
        
        checkExportsOnMergedDeclarations(node);
        const symbol = getSymbolOfDeclaration(node);
        const type = getDeclaredTypeOfSymbol(symbol) as InterfaceType;        
        const staticType = getTypeOfSymbol(symbol) as ObjectType;        
        checkFunctionOrConstructorSymbol(symbol);
        checkClassForDuplicateDeclarations(node);

        // Only check for reserved static identifiers on non-ambient context.
        const baseTypeNode = getEffectiveBaseTypeNode(node);
        console.debug("todo - checkClassLikeDeclaration");
        // if (baseTypeNode) {
        //     forEach(baseTypeNode.typeArguments, checkSourceElement);
        //     if (languageVersion < LanguageFeatureMinimumTarget.Classes) {
        //         checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpers.Extends);
        //     }
        //     // check both @extends and extends if both are specified.
        //     const extendsNode = getClassExtendsHeritageElement(node);
        //     if (extendsNode && extendsNode !== baseTypeNode) {
        //         checkExpression(extendsNode.expression);
        //     }

        //     const baseTypes = getBaseTypes(type);
        //     if (baseTypes.length) {
        //         addLazyDiagnostic(() => {
        //             const baseType = baseTypes[0];
        //             const baseConstructorType = getBaseConstructorTypeOfClass(type);
        //             const staticBaseType = getApparentType(baseConstructorType);
        //             checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
        //             checkSourceElement(baseTypeNode.expression);
        //             if (some(baseTypeNode.typeArguments)) {
        //                 forEach(baseTypeNode.typeArguments, checkSourceElement);
        //                 for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {
        //                     if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters!)) {
        //                         break;
        //                     }
        //                 }
        //             }
        //             const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);
        //             if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
        //                 issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1);
        //             }
        //             else {
        //                 // Report static side error only when instance type is assignable
        //                 checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
        //             }
        //             if (baseConstructorType.flags & TypeFlags.TypeVariable) {
        //                 if (!isMixinConstructorType(staticType)) {
        //                     error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
        //                 }
        //                 else {
        //                     const constructSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);
        //                     if (constructSignatures.some(signature => signature.flags & SignatureFlags.Abstract) && !hasSyntacticModifier(node, ModifierFlags.Abstract)) {
        //                         error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);
        //                     }
        //                 }
        //             }

        //             if (!(staticBaseType.symbol && staticBaseType.symbol.flags & SymbolFlags.Class) && !(baseConstructorType.flags & TypeFlags.TypeVariable)) {
        //                 // When the static base type is a "class-like" constructor function (but not actually a class), we verify
        //                 // that all instantiated base constructor signatures return the same type.
        //                 const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
        //                 if (forEach(constructors, sig => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType))) {
        //                     error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);
        //                 }
        //             }
        //             checkKindsOfPropertyMemberOverrides(type, baseType);
        //         });
        //     }
        // }
                
        // addLazyDiagnostic(() => {
        //     checkIndexConstraints(type, symbol);
        //     checkIndexConstraints(staticType, symbol, /*isStaticIndex*/ true);
        //     checkTypeForDuplicateIndexSignatures(node);
        //     checkPropertyInitialization(node);
        // });

        // function createImplementsDiagnostics(typeRefNode: ExpressionWithTypeArguments) {
        //     return () => {
        //         const t = getReducedType(getTypeFromTypeNode(typeRefNode));
        //         if (!isErrorType(t)) {
        //             if (isValidBaseType(t)) {
        //                 const genericDiag = t.symbol && t.symbol.flags & SymbolFlags.Class ?
        //                     Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :
        //                     Diagnostics.Class_0_incorrectly_implements_interface_1;
        //                 const baseWithThis = getTypeWithThisArgument(t, type.thisType);
        //                 if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
        //                     issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
        //                 }
        //             }
        //             else {
        //                 error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
        //             }
        //         }
        //     };
        // }
    }

    // A valid base type is `any`, an object type or intersection of object types.
    function isValidBaseType(type: Type): type is BaseType {
        if (type.flags & TypeFlags.TypeParameter) {
            const constraint = getBaseConstraintOfType(type);
            if (constraint) {
                return isValidBaseType(constraint);
            }
        }
        // TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
        // There's no reason a `T` should be allowed while a `Readonly<T>` should not.
        return !!(type.flags & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.Any) && !isGenericMappedType(type) ||
            type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isValidBaseType));
    }


    function checkClassForDuplicateDeclarations(node: ClassLikeDeclaration) {
        const instanceNames = new Map<string, DeclarationMeaning>();
        const staticNames = new Map<string, DeclarationMeaning>();
        // instance and static private identifiers share the same scope
        const privateIdentifiers = new Map<string, DeclarationMeaning>();

        if (isSourceFile(node)) return;

        for (const member of node.members) {            
            const name = member.name;
            if (!name) {
                continue;
            }            
            const names = instanceNames;

            const memberName = name && getEffectivePropertyNameForPropertyNameNode(name);
            if (memberName) {
                switch (member.kind) {                    
                    case SyntaxKind.PropertyDeclaration:
                        addName(names, name, memberName, DeclarationMeaning.GetOrSetAccessor );
                        break;

                    case SyntaxKind.MethodDeclaration:
                        addName(names, name, memberName, DeclarationMeaning.Method );
                        break;
                }
            }
        
        }

        function addName(names: Map<string, DeclarationMeaning>, location: Node, name: string, meaning: DeclarationMeaning) {
            const prev = names.get(name);
            if (prev) {
                // For private identifiers, do not allow mixing of static and instance members with the same name
            
                const prevIsMethod = !!(prev & DeclarationMeaning.Method);
                const isMethod = !!(meaning & DeclarationMeaning.Method);
                if (prevIsMethod || isMethod) {
                    if (prevIsMethod !== isMethod) {
                        error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
                    }
                    // If this is a method/method duplication is might be an overload, so this will be handled when overloads are considered
                }
                else if (prev & meaning & ~DeclarationMeaning.PrivateStatic) {
                    error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
                }
                else {
                    names.set(name, prev | meaning);
                }                
            }
            else {
                names.set(name, meaning);
            }
        }
    }

    function getEffectivePropertyNameForPropertyNameNode(node: PropertyName) {
        const name = getPropertyNameForPropertyNameNode(node);
        return name ? name : isComputedPropertyName(node) ? tryGetNameFromType(getTypeOfExpression((node as ComputedPropertyName).expression)) : undefined;
    }

    function tryGetNameFromType(type: Type) {
        return type.flags & TypeFlags.StringOrNumberLiteral ? ("" + (type as StringLiteralType | IntLiteralType).value) : undefined;
    }

    function checkVariableDeclarationList(node: VariableDeclarationList) {
        const blockScopeKind = getCombinedNodeFlags(node) & NodeFlags.BlockScoped;
        
        forEach(node.declarations, checkSourceElement);
    }

    function checkIncludeDirective(node: IncludeDirective) {
        // Grammar checking
        if (node.flags & NodeFlags.Synthesized) {
            // don't check global includes
            return;
        }
        if (!node.text) {
            error(node, Diagnostics.Cannot_find_include_file_0, getIncludeDirectiveFilename(node));
        } 

        // The include sourcefile is no longer needed, because the include node acts
        // as a sourcefile itself.  However, if we ever did need it - the better way to
        // acomplish this would be to add it to NodeLinks
       
        forEach(node.statements, checkSourceElement);
        checkSourceElement(node.endOfFileToken);        
    }

    function checkInheritDeclaration(node: InheritDeclaration) {
        // TODO: should this use node links? 
        const sourceFile = getSourceFileOfNode(node);
        const sourceSymbol = getSymbolOfNode(sourceFile);
        // init the inherits/symboltable map
        sourceSymbol.inherits ??= new Map<string, Type>();

        // get the source object for this inherit
        const specifier = node.inheritClause;
        const specifierType = checkExpression(specifier);
        const inheritSourceObject = resolveExternalModuleName(node, specifier, specifierType);

        if (inheritSourceObject) {
            const inheritObjectSymbol = resolveExternalObjectSymbol(inheritSourceObject, specifier, /*dontResolveAlis*/ true);
            if (inheritObjectSymbol) {
                const inheritType = getTypeOfSymbol(inheritObjectSymbol);                
                // store type by prefix
                sourceSymbol.inherits.set(inheritSourceObject.name, inheritType);
            }
        }
    }

    function checkMappedType(node: MappedTypeNode) {
        checkGrammarMappedType(node);
        checkSourceElement(node.typeParameter);
        checkSourceElement(node.nameType);
        checkSourceElement(node.type);

        if (!node.type) {
            reportImplicitAny(node, anyType);
        }

        const type = getTypeFromMappedTypeNode(node) as MappedType;
        const nameType = getNameTypeFromMappedType(type);
        if (nameType) {
            checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType);
        }
        else {            
            const constraintType = getConstraintTypeFromMappedType(type);
            checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter));
        }
    }

    function getNameTypeFromMappedType(type: MappedType) {
        return type.declaration.nameType ?
            type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :
            undefined;
    }

    function getTypeFromConditionalTypeNode(node: ConditionalTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const checkType = getTypeFromTypeNode(node.checkType);
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            const aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
            const allOuterTypeParameters = getOuterTypeParameters(node, /*includeThisTypes*/ true);
            const outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node));
            const root: ConditionalRoot = {
                node,
                checkType,
                extendsType: getTypeFromTypeNode(node.extendsType),
                isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),
                inferTypeParameters: getInferTypeParameters(node),
                outerTypeParameters,
                instantiations: undefined,
                aliasSymbol,
                aliasTypeArguments,
            };
            links.resolvedType = getConditionalType(root, /*mapper*/ undefined, /*forConstraint*/ false);
            if (outerTypeParameters) {
                root.instantiations = new Map<string, Type>();
                root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
            }
        }
        return links.resolvedType;
    }

    function getTypeFromMappedTypeNode(node: MappedTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const type = createObjectType(ObjectFlags.Mapped, node.symbol) as MappedType;
            type.declaration = node;
            type.aliasSymbol = getAliasSymbolForTypeNode(node);
            type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
            links.resolvedType = type;
            // Eagerly resolve the constraint type which forces an error if the constraint type circularly
            // references itself through one or more type aliases.
            getConstraintTypeFromMappedType(type);
        }
        return links.resolvedType;
    }

    function checkGrammarMappedType(node: MappedTypeNode) {
        if (node.members?.length) {
            return grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
        }
    }

    function checkIndexedAccessType(node: IndexedAccessTypeNode) {
        checkSourceElement(node.objectType);
        checkSourceElement(node.indexType);
        checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
    }

    function getTypeFromIndexedAccessTypeNode(node: IndexedAccessTypeNode) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const objectType = getTypeFromTypeNode(node.objectType);
            const indexType = getTypeFromTypeNode(node.indexType);
            const potentialAlias = getAliasSymbolForTypeNode(node);
            links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlags.None, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
        }
        return links.resolvedType;
    }

    function checkIndexedAccessIndexType(type: Type, accessNode: IndexedAccessTypeNode | ElementAccessExpression) {
        if (!(type.flags & TypeFlags.IndexedAccess)) {
            return type;
        }
        // Check if the index type is assignable to 'keyof T' for the object type.
        const objectType = (type as IndexedAccessType).objectType;
        const indexType = (type as IndexedAccessType).indexType;
        // skip index type deferral on remapping mapped types
        const objectIndexType = isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping
            ? getIndexTypeForMappedType(objectType, IndexFlags.None)
            : getIndexType(objectType, IndexFlags.None);
        const hasNumberIndexInfo = !!getIndexInfoOfType(objectType, numberType);
        if (everyType(indexType, t => isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType))) {
            if (
                accessNode.kind === SyntaxKind.ElementAccessExpression && isAssignmentTarget(accessNode) &&
                getObjectFlags(objectType) & ObjectFlags.Mapped && getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.IncludeReadonly
            ) {
                error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
            return type;
        }
        if (isGenericObjectType(objectType)) {
            const propertyName = getPropertyNameFromIndex(indexType, accessNode);
            if (propertyName) {
                const propertySymbol = forEachType(getApparentType(objectType), t => getPropertyOfType(t, propertyName));
                if (propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & ModifierFlags.NonPublicAccessibilityModifier) {
                    error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, (propertyName));
                    return errorType;
                }
            }
        }
        error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
        return errorType;
    }

    function getMappedTypeModifiers(type: MappedType): MappedTypeModifiers {
        const declaration = type.declaration;
        return (declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0) | 0;
    }
    
    function checkFunctionDeclaration(node: FunctionDeclaration): void {
        // Grammar checking
        checkGrammarModifiers(node);

        addLazyDiagnostic(checkFunctionDeclarationDiagnostics);

        function checkFunctionDeclarationDiagnostics() {
            checkFunctionOrMethodDeclaration(node);            
            checkCollisionsForDeclarationName(node, node.name);
        }
    }

    /**
     * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
     */
    function hasBindableName(node: Declaration) {
        return true;// !hasDynamicName(node) || hasLateBindableName(node);
    }
    
    function checkFunctionOrConstructorSymbol(symbol: Symbol): void {
        addLazyDiagnostic(() => checkFunctionOrConstructorSymbolWorker(symbol));
    }

    function checkFunctionOrMethodDeclaration(node: FunctionDeclaration /*| MethodDeclaration | MethodSignature*/): void {        
        checkSignatureDeclaration(node);
        const functionFlags = getFunctionFlags(node);

        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        // if (node.name && node.name.kind === SyntaxKind.ComputedPropertyName) {
        //     // This check will account for methods in class/interface declarations,
        //     // as well as accessors in classes/object literals
        //     checkComputedPropertyName(node.name);
        // }

        if (hasBindableName(node)) {
            // first we want to check the local symbol that contain this declaration
            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
            const symbol = getSymbolOfDeclaration(node);
            const localSymbol = node.localSymbol || symbol;

            // Since the javascript won't do semantic analysis like typescript,
            // if the javascript file comes before the typescript file and both contain same name functions,
            // checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
            const firstDeclaration = localSymbol.declarations?.find(
                // Get first non javascript function declaration
                declaration => declaration.kind === node.kind,// && !(declaration.flags & NodeFlags.JavaScriptFile),
            );

            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }

            if (symbol.parent) {
                // run check on export symbol to check that modifiers agree across all exported declarations
                checkFunctionOrConstructorSymbol(symbol);
            }
        }

        const body = node.body;// TODO: node.kind === SyntaxKind.MethodSignature ? undefined : node.body;
        checkSourceElement(body);
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));

        addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics);

        // A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
        // if (isInJSFile(node)) {
            const typeTag = getJSDocTypeTag(node);
            if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node)) {
                error(typeTag.typeExpression.type, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature);
            }
        // }

        function checkFunctionOrMethodDeclarationDiagnostics() {
            if (!getEffectiveReturnTypeNode(node)) {
                // Report an implicit any error if there is no body, no explicit return type, and node is not a private method
                // in an ambient context
                if (nodeIsMissing(body)) {// && !isPrivateWithinAmbient(node)) {
                    reportImplicitAny(node, anyType);
                }

                if (functionFlags & FunctionFlags.Generator && nodeIsPresent(body)) {
                    // A generator with a body and no type annotation can still cause errors. It can error if the
                    // yielded values have no common supertype, or it can give an implicit any error if it has no
                    // yielded values. The only way to trigger these errors is to try checking its return type.
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
            }
        }
    }

    // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
    // type checking functions).
    function getTypeParametersFromDeclaration(declaration: DeclarationWithTypeParameters): readonly TypeParameter[] | undefined {
        let result: TypeParameter[] | undefined;
        for (const node of getEffectiveTypeParameterDeclarations(declaration)) {
            result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
        }
        return result?.length ? result
            : isFunctionDeclaration(declaration) ? getSignatureOfTypeTag(declaration)?.typeParameters
            : undefined;
    }
    
    function getSignatureFromDeclaration(declaration: SignatureDeclaration | JSDocSignature): Signature {        
        const links = getNodeLinks(declaration);
        if (!links.resolvedSignature) {
            const parameters: Symbol[] = [];
            let flags = SignatureFlags.None;
            let minArgumentCount = 0;
            let thisParameter: Symbol | undefined;
            let thisTag: JSDocThisTag | undefined = isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined;
            let hasThisParameter = false;
            const iife = getImmediatelyInvokedFunctionExpression(declaration);
            const isJSConstructSignature = false;//isJSDocConstructSignature(declaration);
            const isUntypedSignatureInJSFile = !iife &&
                isInJSFile(declaration) &&
                isValueSignatureDeclaration(declaration) &&
                !hasJSDocParameterTags(declaration) &&
                !getJSDocType(declaration);
            if (isUntypedSignatureInJSFile) {
                flags |= SignatureFlags.IsUntypedSignatureInJSFile;
            }
             
            const declFlags = getCombinedModifierFlagsCached(declaration);
            if (declFlags & ModifierFlags.VarArgs) {
                flags |= SignatureFlags.IsVarArgs;
            }

            if (hasJSDocNodes(declaration)) {
                flags |= SignatureFlags.HasJsDoc;
            }

            // If this is a JSDoc construct signature, then skip the first parameter in the
            // parameter list.  The first parameter represents the return type of the construct
            // signature.
            for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters?.length; i++) {
                const param = declaration.parameters[i];
                if (isInJSFile(param) && isJSDocThisTag(param)) {
                    thisTag = param;
                    continue;
                }

                let paramSymbol = param.symbol;
                const type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
                // Include parameter symbol instead of property symbol in the signature
                if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(param.name)) {
                    const resolvedSymbol = resolveName(param, paramSymbol.name, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
                    paramSymbol = resolvedSymbol!;
                }
                if (i === 0 && paramSymbol.name === InternalSymbolName.This) {
                    hasThisParameter = true;
                    thisParameter = param.symbol;
                }
                else {
                    parameters.push(paramSymbol);
                }

                if (type && type.kind === SyntaxKind.LiteralType) {
                    flags |= SignatureFlags.HasLiteralTypes;
                }

                // Record a new minimum argument count if this is not an optional parameter                
                minArgumentCount = parameters.length;                
            }

            if (thisTag && thisTag.typeExpression) {
                thisParameter = createSymbolWithType(createSymbol(SymbolFlags.FunctionScopedVariable, InternalSymbolName.This), getTypeFromTypeNode(thisTag.typeExpression));
            }

            const hostDeclaration = isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration;
            const classType = hostDeclaration && isConstructorDeclaration(hostDeclaration) ?
                getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol))
                : undefined;
            const typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
            if (hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                flags |= SignatureFlags.HasRestParameter;
            }
            // if (
            //     isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlags.Abstract) ||
            //     isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlags.Abstract)
            // ) {
            //     flags |= SignatureFlags.Abstract;
            // }
            
            links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, minArgumentCount, flags);
        }
        return links.resolvedSignature;
    }

    /**
     * A JS function gets a synthetic rest parameter if it references `arguments` AND:
     * 1. It has no parameters but at least one `@param` with a type that starts with `...`
     * OR
     * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
     */
    function maybeAddJsSyntheticRestParameter(declaration: SignatureDeclaration | JSDocSignature, parameters: Symbol[]): boolean {
        return false;
        console.warn("Implement me - maybeAddJsSyntheticRestParameter");
        // if (isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
        //     return false;
        // }
        // const lastParam = lastOrUndefined(declaration.parameters);
        // const lastParamTags = lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag);
        // const lastParamVariadicType = firstDefined(lastParamTags, p => p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined);

        // const syntheticArgsSymbol = createSymbol(SymbolFlags.Variable, "args" as string, CheckFlags.RestParameter);
        // if (lastParamVariadicType) {
        //     // Parameter has effective annotation, lock in type
        //     syntheticArgsSymbol.links.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type));
        // }
        // else {
        //     // Parameter has no annotation
        //     // By using a `DeferredType` symbol, we allow the type of this rest arg to be overriden by contextual type assignment so long as its type hasn't been
        //     // cached by `getTypeOfSymbol` yet.
        //     syntheticArgsSymbol.links.checkFlags |= CheckFlags.DeferredType;
        //     syntheticArgsSymbol.links.deferralParent = neverType;
        //     syntheticArgsSymbol.links.deferralConstituents = [anyArrayType];
        //     syntheticArgsSymbol.links.deferralWriteConstituents = [anyArrayType];
        // }
        // if (lastParamVariadicType) {
        //     // Replace the last parameter with a rest parameter.
        //     parameters.pop();
        // }
        // parameters.push(syntheticArgsSymbol);
        // return true;
    }
    
    function reportImplicitAny(declaration: Declaration, type: Type, wideningKind?: WideningKind) {
        console.warn("Implement me - reportImplicitAny");
    }

    function getReturnTypeFromAnnotation(declaration: SignatureDeclaration | JSDocSignature) {        
        const typeNode = getEffectiveReturnTypeNode(declaration);
        if (isJSDocSignature(declaration)) {
            const root = getJSDocRoot(declaration);
            if (root && isConstructorDeclaration(root.parent) && !typeNode) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol((root.parent.parent as ClassDeclaration).symbol));
            }
        }        
        if (typeNode) {
            // LPC - in this special case, don't use regular boolean. the true type should be 
            // the function's declared return type
            if (isTypePredicateNode(typeNode) && declaration.type) {
                return getUnionType([falseType, getTypeFromTypeNode(declaration.type as TypeNode)]);
            }            
            return getTypeFromTypeNode(typeNode);
        }        
        return getReturnTypeOfTypeTag(declaration);
    }

    function getReturnTypeOfTypeTag(node: SignatureDeclaration | JSDocSignature) {
        const signature = getSignatureOfTypeTag(node);
        return signature && getReturnTypeOfSignature(signature);
    }

    function getSignatureOfTypeTag(node: SignatureDeclaration | JSDocSignature) {
        // should be attached to a function declaration or expression
        if (!isFunctionLikeDeclaration(node)) return undefined;        
        const typeTag = getJSDocTypeTag(node);
        return typeTag?.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
    }

    function getTypeFromTypeNode(node: TypeNode): Type {
        return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
    }

    function getRegularTypeOfLiteralType(type: Type): Type {
        return type.flags & TypeFlags.Freshable ? (type as FreshableType).regularType :
            type.flags & TypeFlags.Union ? ((type as UnionType).regularType || ((type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType)) :
            type;
    }

    /**
     * LDMud named type, e.g.:
     *    object "/std/player.c" foo;
     * @param node 
     * @returns 
     */
    function getTypeFromNamedObjectTypeNode(node: NamedObjectTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {            
            const specifier = node.name;
            const moduleSymbol = resolveExternalModuleName(node, specifier, undefined);
            const objectSymbol = resolveExternalObjectSymbol(moduleSymbol, specifier, /*dontResolveAlias*/ true);
            if (objectSymbol && isSourceFile(objectSymbol.valueDeclaration)) {                
                const resolvedType = getTypeOfSymbol(objectSymbol);
                links.resolvedType = resolvedType;
            } else {
                // fall back to plain object type
                links.resolvedType = objectType;
            }             
        }        
        return links.resolvedType;
    }

    function getTypeFromLiteralTypeNode(node: LiteralTypeNode): Type {
        // if (node.literal.kind === SyntaxKind.NullKeyword) {
        //     return nullType;
        // }
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // any string literal inside a jsdoc type or a type predicate is probably a filename that we need to resolve
            if (node.parent && (hasJsDocAncestor(node) || isTypePredicateNode(node.parent)) 
                && (isStringLiteral(node.literal) || isBinaryExpression(node.literal))) {                
                const specifier = node.literal;
                const moduleSymbol = resolveExternalModuleName(node, specifier, undefined);
                const objectSymbol = resolveExternalObjectSymbol(moduleSymbol, specifier, /*dontResolveAlias*/ true);
                if (objectSymbol && isSourceFile(objectSymbol.valueDeclaration)) {                
                    const objectType = getTypeOfSymbol(objectSymbol);
                    links.resolvedType = objectType;
                } 
            }

            if (!links.resolvedType) {
                links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
            }
        }
        
        if (links.resolvedType && node.parent && isJSDocVariableTag(node.parent.parent)) {
            links.resolvedType.flags |= TypeFlags.LpcDocVariable;
        }

        return links.resolvedType;

        function hasJsDocAncestor(node: Node) {
            // the jsdoc parent can be up to three levels up, in the case 
            // of a string literal type in an array type in a union type
            return isJSDocTypeExpression(node) || 
                (node.parent && isJSDocTypeExpression(node.parent)) || 
                (node.parent.parent && isJSDocTypeExpression(node.parent.parent)) ||
                (node.parent.parent.parent && isJSDocTypeExpression(node.parent.parent.parent));
        }
    }
    
    function getTypeReferenceName(node: TypeReferenceType): EntityNameOrEntityNameExpression | undefined {
        switch (node.kind) {
            case SyntaxKind.StructType:
            case SyntaxKind.TypeReference:
                return node.typeName;            
            case SyntaxKind.ExpressionWithTypeArguments:
                // We only support expressions that are simple qualified names. For other
                // expressions this produces undefined.
                const expr = node.expression;
                if (isEntityNameExpression(expr)) {
                    return expr;
                }
                // fall through;
        }

        return undefined;
    }
    
    function resolveTypeReferenceName(typeReference: TypeReferenceType, meaning: SymbolFlags, ignoreErrors?: boolean) {
        const name = getTypeReferenceName(typeReference);
        if (!name) {
            return unknownSymbol;
        }
        const symbol = resolveEntityName(name, meaning, ignoreErrors);
        return symbol && symbol !== unknownSymbol ? symbol :
            ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name);
    }
    
    function getUnresolvedSymbolForEntityName(name: EntityNameOrEntityNameExpression) {
        const identifier = name.kind === SyntaxKind.QualifiedName ? name.right :
            name.kind === SyntaxKind.PropertyAccessExpression ? name.name :
            name;
        const text = identifier.text;
        if (text) {
            const parentSymbol = name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :
                name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :
                undefined;
            const path = parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string;
            let result = unresolvedSymbols.get(path);
            if (!result) {
                unresolvedSymbols.set(path, result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved));
                result.parent = parentSymbol;
                result.links.declaredType = unresolvedType;
            }
            return result;
        }
        return unknownSymbol;
    }

    function getSymbolPath(symbol: Symbol): string {
        return symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.name}` : symbol.name as string;
    }

    /**
     * Get type from type-reference that reference to class or interface
     */
    function getTypeFromClassOrInterfaceReference(node: NodeWithTypeArguments, symbol: Symbol): Type {
        console.debug("getTypeFromClassOrInterfaceReference?");
        const type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol)) as InterfaceType;
        return type;
        // const typeParameters = type.localTypeParameters;
        // if (typeParameters) {
        //     const numTypeArguments = length(node.typeArguments);
        //     const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
        //     const isJs = isInJSFile(node);
        //     const isJsImplicitAny = !noImplicitAny && isJs;
        //     // if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
        //     //     const missingAugmentsTag = isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent);
        //     //     const diag = minTypeArgumentCount === typeParameters.length ?
        //     //         missingAugmentsTag ?
        //     //             Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
        //     //             Diagnostics.Generic_type_0_requires_1_type_argument_s :
        //     //         missingAugmentsTag ?
        //     //         Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
        //     //         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;

        //     //     const typeStr = typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType);
        //     //     error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
        //     //     if (!isJs) {
        //     //         // TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
        //     //         return errorType;
        //     //     }
        //     // }
        //     // if (node.kind === SyntaxKind.TypeReference && isDeferredTypeReferenceNode(node as TypeReferenceNode, length(node.typeArguments) !== typeParameters.length)) {
        //     //     return createDeferredTypeReference(type as GenericType, node as TypeReferenceNode, /*mapper*/ undefined);
        //     // }
        //     // In a type reference, the outer type parameters of the referenced class or interface are automatically
        //     // supplied as type arguments and the type reference only specifies arguments for the local type parameters
        //     // of the class or interface.
        //     const typeArguments = undefined;//concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
        //     return createTypeReference(type as GenericType, typeArguments);
        // }
        return type;//return checkNoTypeArguments(node, symbol) ? type : errorType;
    }

    /**
     * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
     * Example: import('./b').ConstructorFunction
     */
    function getTypeFromJSDocValueReference(node: NodeWithTypeArguments, symbol: Symbol): Type | undefined {
        const links = getNodeLinks(node);
        if (!links.resolvedJSDocType) {
            const valueType = getTypeOfSymbol(symbol);
            let typeType = valueType;
            if (symbol.valueDeclaration) {
                // const isImportTypeWithQualifier = node.kind === SyntaxKind.ImportType && (node as ImportTypeNode).qualifier;
                // // valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
                // if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                //     typeType = getTypeReferenceType(node, valueType.symbol);
                // }
            }
            links.resolvedJSDocType = typeType;
        }
        return links.resolvedJSDocType;
    }

    function getTypeReferenceType(node: NodeWithTypeArguments, symbol: Symbol): Type {
        if (symbol === unknownSymbol) {
            return errorType;
        }        
        // symbol = getExpandoSymbol(symbol) || symbol;
        if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
            return getTypeFromClassOrInterfaceReference(node, symbol);
        }
        if (symbol.flags & SymbolFlags.TypeAlias) {
            return getTypeFromTypeAliasReference(node, symbol);
        }
        // Get type from reference to named type that cannot be generic (enum or type parameter)
        const res = tryGetDeclaredTypeOfSymbol(symbol);
        if (res) {
            return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
        }
        if (symbol.flags & SymbolFlags.Value && isJSDocTypeReference(node)) {
            const jsdocType = getTypeFromJSDocValueReference(node, symbol);
            if (jsdocType) {
                return jsdocType;
            }
            else {
                // Resolve the type reference as a Type for the purpose of reporting errors.
                resolveTypeReferenceName(node, SymbolFlags.Type);
                return getTypeOfSymbol(symbol);
            }
        }
        return errorType;
    }

    function isLocalTypeAlias(symbol: Symbol) {
        const declaration = symbol.declarations?.find(isTypeAlias);
        return !!(declaration && getContainingFunction(declaration));
    }
    
    /**
     * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
     * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
     * declared type. Instantiations are cached using the type identities of the type arguments as the key.
     */
    function getTypeFromTypeAliasReference(node: NodeWithTypeArguments, symbol: Symbol): Type {
        if (getCheckFlags(symbol) & CheckFlags.Unresolved) {            
            const typeArguments = [];
            const id = getAliasId(symbol, typeArguments);
            let errorType = errorTypes.get(id);
            if (!errorType) {
                errorType = createIntrinsicType(TypeFlags.Any, "error", /*objectFlags*/ undefined, `alias ${id}`);
                errorType.aliasSymbol = symbol;
                errorType.aliasTypeArguments = typeArguments;
                errorTypes.set(id, errorType);
            }
            return errorType;
        }
        const type = getDeclaredTypeOfSymbol(symbol);        
        const typeParameters = getSymbolLinks(symbol).typeParameters;
        if (typeParameters) {
            const numTypeArguments = length(node.typeArguments);
            const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                error(
                    node,
                    minTypeArgumentCount === typeParameters.length ?
                        Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments,
                    symbolToString(symbol),
                    minTypeArgumentCount,
                    typeParameters.length,
                );
                return errorType;
            }
            // We refrain from associating a local type alias with an instantiation of a top-level type alias
            // because the local alias may end up being referenced in an inferred return type where it is not
            // accessible--which in turn may lead to a large structural expansion of the type when generating
            // a .d.ts file. See #43622 for an example.
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            let newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined;
            let aliasTypeArguments: Type[] | undefined;
            if (newAliasSymbol) {
                aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol);
            }
            else if (isTypeReferenceType(node)) {
                const aliasSymbol = resolveTypeReferenceName(node, SymbolFlags.Alias, /*ignoreErrors*/ true);
                // refers to an alias import/export/reexport - by making sure we use the target as an aliasSymbol,
                // we ensure the exported symbol is used to refer to the type when it's reserialized later
                if (aliasSymbol && aliasSymbol !== unknownSymbol) {
                    const resolved = resolveAlias(aliasSymbol);
                    if (resolved && resolved.flags & SymbolFlags.TypeAlias) {
                        newAliasSymbol = resolved;
                        aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || (typeParameters ? [] : undefined);
                    }
                }
            }
            return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments);
        }
        return checkNoTypeArguments(node, symbol) ? type : errorType;
    }

    function getTypeFromIntersectionTypeNode(node: IntersectionTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            const types = map(node.types, getTypeFromTypeNode);
            // We perform no supertype reduction for X & {} or {} & X, where X is one of string, number, bigint,
            // or a pattern literal template type. This enables union types like "a" | "b" | string & {} or
            // "aa" | "ab" | `a${string}` which preserve the literal types for purposes of statement completion.
            const emptyIndex = types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1;
            const t = emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType;
            const noSupertypeReduction = !!(t.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.Float));
            links.resolvedType = getIntersectionType(types, noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
        }
        return links.resolvedType;
    }

    
    function getTypeFromUnionTypeNode(node: UnionTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            links.resolvedType = getUnionType(map(node.types, getTypeFromTypeNode), UnionReduction.Literal, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
        }
        return links.resolvedType;
    }

    function isReadonlyTypeOperator(node: Node) {
        return false;//return isTypeOperatorNode(node) && node.operator === SyntaxKind.ReadonlyKeyword;
    }

    function getArrayElementTypeNode(node: TypeNode): TypeNode | undefined {
        switch (node.kind) {
            case SyntaxKind.ParenthesizedType:
                return getArrayElementTypeNode((node as ParenthesizedTypeNode).type);
            case SyntaxKind.TupleType:
                if ((node as TupleTypeNode).elements.length === 1) {
                    node = (node as TupleTypeNode).elements[0];
                    console.debug("todo - array element");
                    // if (node.kind === SyntaxKind.RestType || node.kind === SyntaxKind.NamedTupleMember && (node as NamedTupleMember).dotDotDotToken) {
                    //     return getArrayElementTypeNode((node as RestTypeNode | NamedTupleMember).type);
                    // }
                }
                break;
            case SyntaxKind.ArrayType:
                return (node as ArrayTypeNode).elementType;
        }
        return undefined;
    }

    function getArrayOrTupleTargetType(node: ArrayTypeNode | TupleTypeNode): GenericType {
        const readonly = isReadonlyTypeOperator(node.parent);
        const elementType = getArrayElementTypeNode(node);
        if (elementType) {
            return readonly ? globalReadonlyArrayType : globalArrayType;
        }
        const elementFlags = map((node as TupleTypeNode).elements, getTupleElementFlags) || emptyArray;
        return getTupleTargetType(elementFlags, readonly, map((node as TupleTypeNode).elements, memberIfLabeledElementDeclaration));
    }

    function memberIfLabeledElementDeclaration(member: Node): NamedTupleMember | ParameterDeclaration | undefined {
        console.debug("todo - memberIfLabeledElementDeclaration");;
        return undefined;
        // return isNamedTupleMember(member) || isParameter(member) ? member : undefined;
    }

    function getTupleElementFlags(node: TypeNode) {
        console.debug("todo - getTupleElementFlags");
        return ElementFlags.Required;
        // switch (node.kind) {
        //     // case SyntaxKind.OptionalType:
        //     //     return ElementFlags.Optional;
        //     // case SyntaxKind.RestType:
        //     //     return getRestTypeElementFlags(node as RestTypeNode);
        //     case SyntaxKind.NamedTupleMember:
        //         return (node as NamedTupleMember).questionToken ? ElementFlags.Optional :
        //             (node as NamedTupleMember).dotDotDotToken ? getRestTypeElementFlags(node as NamedTupleMember) :
        //             ElementFlags.Required;
        //     default:
        //         return ElementFlags.Required;
        // }
    }

    function getTypeFromClosureTypeNode(node: TypeNode): Type {
        Debug.assert(node.kind === SyntaxKind.FunctionKeyword || node.kind === SyntaxKind.ClosureKeyword);
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = globalClosureType;
        }
        return links.resolvedType;
    }

    function getTypeFromArrayOrTupleTypeNode(node: ArrayTypeNode | TupleTypeNode): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const target = getArrayOrTupleTargetType(node);
            if (target === emptyGenericType) {
                links.resolvedType = emptyObjectType;
            }
            else if (!(node.kind === SyntaxKind.TupleType && some(node.elements, e => !!(getTupleElementFlags(e) & ElementFlags.Variadic))) && isDeferredTypeReferenceNode(node)) {
                links.resolvedType = node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target :
                    createDeferredTypeReference(target, node, /*mapper*/ undefined);
            }
            else if (node.kind === SyntaxKind.ArrayType) {
                if (!node.elementType) {
                    links.resolvedType = autoArrayType;
                } else {
                    links.resolvedType = createNormalizedTypeReference(target, [getTypeFromTypeNode(node.elementType)]);
                }
            } else {                                   
                links.resolvedType = createNormalizedTypeReference(target, map(node.elements, getTypeFromTypeNode));
            }
        }
        return links.resolvedType;
    }

    // Return true if the given type reference node is directly aliased or if it needs to be deferred
    // because it is possibly contained in a circular chain of eagerly resolved types.
    function isDeferredTypeReferenceNode(node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode, hasDefaultTypeArguments?: boolean) {
        return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (
                    node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) :
                        node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) :
                        hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias)
                );
    }

    // Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
    // of a type alias.
    function mayResolveTypeAlias(node: Node): boolean {
        switch (node.kind) {
            case SyntaxKind.TypeReference:
                return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node as TypeReferenceNode, SymbolFlags.Type).flags & SymbolFlags.TypeAlias);
            case SyntaxKind.TypeQuery:
                return true;
            case SyntaxKind.TypeOperator:
                console.debug("todo - mayResolveTypeAlias");
                return false;
                // return (node as TypeOperatorNode).operator !== SyntaxKind.UniqueKeyword && mayResolveTypeAlias((node as TypeOperatorNode).type);
            case SyntaxKind.ParenthesizedType:
            // case SyntaxKind.OptionalType:
            case SyntaxKind.NamedTupleMember:
            case SyntaxKind.JSDocOptionalType:
            case SyntaxKind.JSDocNullableType:
            case SyntaxKind.JSDocNonNullableType:
            case SyntaxKind.JSDocTypeExpression:
                return mayResolveTypeAlias((node as ParenthesizedTypeNode | /*OptionalTypeNode |*/ JSDocTypeReferencingNode | NamedTupleMember).type);
            case SyntaxKind.RestType:
                console.debug("todo - mayResolveTypeAlias");
                return false;
                // return (node as RestTypeNode).type.kind !== SyntaxKind.ArrayType || mayResolveTypeAlias(((node as RestTypeNode).type as ArrayTypeNode).elementType);
            case SyntaxKind.UnionType:
            case SyntaxKind.IntersectionType:
                return some((node as UnionOrIntersectionTypeNode).types, mayResolveTypeAlias);
            case SyntaxKind.IndexedAccessType:
                return mayResolveTypeAlias((node as IndexedAccessTypeNode).objectType) || mayResolveTypeAlias((node as IndexedAccessTypeNode).indexType);
            case SyntaxKind.ConditionalType:
                return mayResolveTypeAlias((node as ConditionalTypeNode).checkType) || mayResolveTypeAlias((node as ConditionalTypeNode).extendsType) ||
                    mayResolveTypeAlias((node as ConditionalTypeNode).trueType) || mayResolveTypeAlias((node as ConditionalTypeNode).falseType);
        }
        return false;
    }

    // Return true when the given node is transitively contained in type constructs that eagerly
    // resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
    // of type aliases are eagerly resolved.
    function isResolvedByTypeAlias(node: Node): boolean {
        const parent = node.parent;
        switch (parent.kind) {
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.NamedTupleMember:
            case SyntaxKind.TypeReference:
            case SyntaxKind.UnionType:
            case SyntaxKind.IntersectionType:
            case SyntaxKind.IndexedAccessType:
            case SyntaxKind.ConditionalType:
            case SyntaxKind.TypeOperator:
            case SyntaxKind.ArrayType:
            case SyntaxKind.TupleType:
                return isResolvedByTypeAlias(parent);
            case SyntaxKind.TypeAliasDeclaration:
                return true;
        }
        return false;
    }

    function getTypeFromTypeNodeWorker(node: TypeNode): Type {
        Debug.assertIsDefined(node);
        switch (node.kind) {
            case SyntaxKind.AnyKeyword:                
            case SyntaxKind.JSDocAllType:
            case SyntaxKind.JSDocUnknownType:
                return anyType;
            case SyntaxKind.UnknownKeyword:
                return unknownType;
            case SyntaxKind.StringKeyword:
                return stringType;
            case SyntaxKind.StatusKeyword:
            case SyntaxKind.IntKeyword:
                return intType;
            case SyntaxKind.FloatKeyword:
                return floatType;
            case SyntaxKind.MappingKeyword:
                return globalMappingType;
            case SyntaxKind.BytesKeyword:
            case SyntaxKind.BufferKeyword:
                return bytesType;
            // case SyntaxKind.BooleanKeyword:
            //     return booleanType;            
            case SyntaxKind.VoidKeyword:
                return voidType;
            // case SyntaxKind.UndefinedKeyword:
            //     return undefinedType;
            // case SyntaxKind.NullKeyword as TypeNodeSyntaxKind:
            //     // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.
            //     return nullType;            
            case SyntaxKind.MixedKeyword:
                return mixedType;
            case SyntaxKind.LwObjectKeyword:
                return lwObjectType;
            case SyntaxKind.FunctionKeyword:
            case SyntaxKind.ClosureKeyword:
                return getTypeFromClosureTypeNode(node);
            case SyntaxKind.ObjectKeyword:
                // in LPC, return undefined (not error or any) so that the type checker can continue
                // to determine the type from the flow node
                // return objectType;  // !noImplicitAny ? anyType : nonPrimitiveType;            
                return objectType;
            case SyntaxKind.NamedObjectType:
                return getTypeFromNamedObjectTypeNode(node as NamedObjectTypeNode);
            // case SyntaxKind.IntrinsicKeyword:
            //     return intrinsicMarkerType;
            // case SyntaxKind.ThisType:
            // case SyntaxKind.ThisKeyword as TypeNodeSyntaxKind:
            //     // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.
            //     return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode);
            case SyntaxKind.LiteralType:
                return getTypeFromLiteralTypeNode(node as LiteralTypeNode);
            case SyntaxKind.ArrayType:            
                return getTypeFromArrayOrTupleTypeNode(node as ArrayTypeNode);// | TupleTypeNode);            
            case SyntaxKind.UnionType:
                return getTypeFromUnionTypeNode(node as UnionTypeNode);            
            case SyntaxKind.IntersectionType:
                return getTypeFromIntersectionTypeNode(node as IntersectionTypeNode);
            case SyntaxKind.StructType:            
            case SyntaxKind.TypeReference:
                return getTypeFromTypeReference(node as TypeReferenceType);
            case SyntaxKind.TypePredicate:
                return booleanType;
            // case SyntaxKind.JSDocNullableType:
            //     return getTypeFromJSDocNullableTypeNode(node as JSDocNullableType);
            case SyntaxKind.JSDocOptionalType:
                return addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type));            
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.JSDocNonNullableType:
            case SyntaxKind.JSDocTypeExpression:
                return getTypeFromTypeNode((node as ParenthesizedTypeNode | /*JSDocTypeReferencingNode |*/ JSDocTypeExpression /*| NamedTupleMember*/).type);            
            case SyntaxKind.JSDocVariadicType:
                return getTypeFromJSDocVariadicType(node as JSDocVariadicType);
            // case SyntaxKind.FunctionType:            
            case SyntaxKind.TypeLiteral:
            case SyntaxKind.JSDocTypeLiteral:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
                return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node as TypeLiteralNode | JSDocTypeLiteral | JSDocSignature);// FunctionOrConstructorTypeNode | JSDocFunctionType | );
            // case SyntaxKind.TypeOperator:
            //     return getTypeFromTypeOperatorNode(node as TypeOperatorNode);
            case SyntaxKind.IndexedAccessType:
                return getTypeFromIndexedAccessTypeNode(node as IndexedAccessTypeNode);
            case SyntaxKind.MappedType:
                return getTypeFromMappedTypeNode(node as MappedTypeNode);
            case SyntaxKind.ConditionalType:
                return getTypeFromConditionalTypeNode(node as ConditionalTypeNode);
            case SyntaxKind.InferType:
                return getTypeFromInferTypeNode(node as InferTypeNode);            
            // case SyntaxKind.ImportType:
            //     return getTypeFromImportTypeNode(node as ImportTypeNode);
            // This function assumes that an identifier, qualified name, or property access expression is a type expression
            // Callers should first ensure this by calling `isPartOfTypeNode`
            // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
            case SyntaxKind.Identifier as TypeNodeSyntaxKind:
            //case SyntaxKind.QualifiedName as TypeNodeSyntaxKind:
            case SyntaxKind.PropertyAccessExpression as TypeNodeSyntaxKind:
                const symbol = getSymbolAtLocation(node);
                return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;                        
            default:
                console.warn("Implement me - getTypeFromTypeNodeWorker " + Debug.formatSyntaxKind(node.kind));
                return errorType;
        }
    }

    function getTypeFromJSDocVariadicType(node: JSDocVariadicType): Type {
        const type = getTypeFromTypeNode(node.type);
        const { parent } = node;
        const paramTag = node.parent.parent;
        if (isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag)) {
            // Else we will add a diagnostic, see `checkJSDocVariadicType`.
            const host = getHostSignatureFromJSDoc(paramTag);
            const isCallbackTag = isJSDocCallbackTag(paramTag.parent.parent);
            if (host || isCallbackTag) {
                /*
                Only return an array type if the corresponding parameter is marked as a rest parameter, or if there are no parameters.
                So in the following situation we will not create an array type:
                    /** @param {...number} a * /
                    function f(a) {}
                Because `a` will just be of type `number | undefined`. A synthetic `...args` will also be added, which *will* get an array type.
                */
                const lastParamDeclaration = isCallbackTag
                    ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters)
                    : lastOrUndefined(host!.parameters);
                const symbol = getParameterSymbolFromJSDoc(paramTag);
                if (
                    !lastParamDeclaration ||
                    symbol && lastParamDeclaration.symbol === symbol && isRestParameter(lastParamDeclaration)
                ) {
                    return createArrayType(type);
                }
            }
        }
        if (isParameter(parent) && isJSDocFunctionType(parent.parent)) {
            return createArrayType(type);
        }
        return addOptionality(type);
    }
    
    function isJSDocTypeReference(node: Node): node is TypeReferenceNode {
        return !!(node.flags & NodeFlags.JSDoc) && (node.kind === SyntaxKind.TypeReference);
    }

    function checkNoTypeArguments(node: NodeWithTypeArguments, symbol?: Symbol) {
        if (node.typeArguments) {
            error(node, Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon);
            return false;
        }
        return true;
    }

    function removeConstrainedTypeVariables(types: Type[]) {
        const typeVariables: TypeVariable[] = [];
        // First collect a list of the type variables occurring in constraining intersections.
        for (const type of types) {
            if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {
                const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;
                pushIfUnique(typeVariables, (type as IntersectionType).types[index]);
            }
        }
        // For each type variable, check if the constraining intersections for that type variable fully
        // cover the constraint of the type variable; if so, remove the constraining intersections and
        // substitute the type variable.
        for (const typeVariable of typeVariables) {
            const primitives: Type[] = [];
            // First collect the primitive types from the constraining intersections.
            for (const type of types) {
                if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {
                    const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;
                    if ((type as IntersectionType).types[index] === typeVariable) {
                        insertType(primitives, (type as IntersectionType).types[1 - index]);
                    }
                }
            }
            // If every constituent in the type variable's constraint is covered by an intersection of the type
            // variable and that constituent, remove those intersections and substitute the type variable.
            const constraint = getBaseConstraintOfType(typeVariable)!;
            if (everyType(constraint, t => containsType(primitives, t))) {
                let i = types.length;
                while (i > 0) {
                    i--;
                    const type = types[i];
                    if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {
                        const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;
                        if ((type as IntersectionType).types[index] === typeVariable && containsType(primitives, (type as IntersectionType).types[1 - index])) {
                            orderedRemoveItemAt(types, i);
                        }
                    }
                }
                insertType(types, typeVariable);
            }
        }
    }

    function getIntendedTypeFromJSDocTypeReference(node: TypeReferenceNode): Type | undefined {
        if (isIdentifier(node.typeName)) {
            const typeArgs = node.typeArguments;
            switch (node.typeName.text) {
                case "string":
                    checkNoTypeArguments(node);
                    return stringType;
                case "int":
                    checkNoTypeArguments(node);
                    return intType;
                case "float":
                    checkNoTypeArguments(node);
                    return floatType;
                case "mixed":
                    checkNoTypeArguments(node);
                    return anyType;
                case "void":
                    checkNoTypeArguments(node);
                    return voidType;
                case "undefined":
                    checkNoTypeArguments(node);
                    return undefinedType;
                case "null":
                    checkNoTypeArguments(node);
                    return nullType;
                case "Function":
                case "function":
                    checkNoTypeArguments(node);
                    return globalFunctionType;                
                case "array":
                    return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
                // case "promise":
                //     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
                case "object":
                    if (typeArgs && typeArgs.length === 2) {
                        if (isJSDocIndexSignature(node)) {
                            const indexed = getTypeFromTypeNode(typeArgs[0]);
                            const target = getTypeFromTypeNode(typeArgs[1]);
                            const indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly*/ false)] : emptyArray;
                            return createAnonymousType(/*symbol*/ undefined, emptySymbols, emptyArray, emptyArray, indexInfo);
                        }
                        return anyType;
                    }
                    checkNoTypeArguments(node);
                    return !noImplicitAny ? anyType : undefined;
                // default:
                //     console.debug("todo - unhandled jsdoc type ref name " + node.typeName.text);
            }
        }
    }

    function getTypeFromTypeReference(node: TypeReferenceType): Type {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {            
            // handle LS queries on the `const` in `x as const` by resolving to the type of `x`
            // if (isConstTypeReference(node) && isAssertionExpression(node.parent)) {
            //     links.resolvedSymbol = unknownSymbol;
            //     return links.resolvedType = checkExpressionCached(node.parent.expression);
            // }
            let symbol: Symbol | undefined;
            let type: Type | undefined;
            const meaning = SymbolFlags.Type;
            if (isJSDocTypeReference(node)) {
                type = getIntendedTypeFromJSDocTypeReference(node);
                if (!type) {
                    symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors*/ true);
                    if (symbol === unknownSymbol) {
                        symbol = resolveTypeReferenceName(node, meaning | SymbolFlags.Value);
                    }
                    else {
                        resolveTypeReferenceName(node, meaning); // Resolve again to mark errors, if any
                    }
                    type = getTypeReferenceType(node, symbol);
                }
            }
            if (!type) {
                symbol = resolveTypeReferenceName(node, meaning);
                type = getTypeReferenceType(node, symbol);
            }
            // Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
            // type reference in checkTypeReferenceNode.
            links.resolvedSymbol = symbol;
            links.resolvedType = type;
        }
        return links.resolvedType;
    }

    function getDeclaredTypeOfSymbol(symbol: Symbol): Type {
        return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
    }    

    function tryGetDeclaredTypeOfSymbol(symbol: Symbol): Type | undefined {
        if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
            return getDeclaredTypeOfClassOrInterface(symbol);
        }
        if (symbol.flags & SymbolFlags.TypeAlias) {
            return getDeclaredTypeOfTypeAlias(symbol);
        }
        if (symbol.flags & SymbolFlags.TypeParameter) {
            return getDeclaredTypeOfTypeParameter(symbol);
        }        
        if (symbol.flags & SymbolFlags.Alias) {
            return getDeclaredTypeOfAlias(symbol);
        }
        return undefined;
    }

    function getDeclaredTypeOfTypeAlias(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            // Note that we use the links object as the target here because the symbol object is used as the unique
            // identity for resolution of the 'type' property in SymbolLinks.
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.DeclaredType)) {
                return errorType;
            }

            const declaration = Debug.checkDefined(symbol.declarations?.find(isTypeAlias), "Type alias symbol with no valid declaration found");
            const typeNode = isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
            // If typeNode is missing, we will error in checkJSDocTypedefTag.
            let type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;

            if (popTypeResolution()) {
                const typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                if (typeParameters) {
                    // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                    // an instantiation of the type alias with the type parameters supplied as type arguments.
                    links.typeParameters = typeParameters;
                    links.instantiations = new Map<string, Type>();
                    links.instantiations.set(getTypeListId(typeParameters), type);
                }
            }
            else {
                type = errorType;
                
                error(isNamedDeclaration(declaration) ? declaration.name || declaration : declaration, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));                
            }
            links.declaredType ??= type;
        }
        return links.declaredType;
    }
    
    function getDeclaredTypeOfAlias(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)));
    }

    function getActualTypeVariable(type: Type): Type {
        if (type.flags & TypeFlags.Substitution) {
            return getActualTypeVariable((type as SubstitutionType).baseType);
        }
        if (
            type.flags & TypeFlags.IndexedAccess && (
                (type as IndexedAccessType).objectType.flags & TypeFlags.Substitution ||
                (type as IndexedAccessType).indexType.flags & TypeFlags.Substitution
            )
        ) {
            return getIndexedAccessType(getActualTypeVariable((type as IndexedAccessType).objectType), getActualTypeVariable((type as IndexedAccessType).indexType));
        }
        return type;
    }

    
    function getImpliedConstraint(type: Type, checkNode: TypeNode, extendsNode: TypeNode): Type | undefined {
        // return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, (checkNode as TupleTypeNode).elements[0], (extendsNode as TupleTypeNode).elements[0]) :
        return getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :
            undefined;
    }

    function getConditionalFlowTypeOfType(type: Type, node: Node) {
        let constraints: Type[] | undefined;
        let covariant = true;
        while (node && !isStatement(node) && node.kind !== SyntaxKind.JSDoc) {
            const parent = node.parent;
            // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
            // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax            
            if (parent.kind === SyntaxKind.Parameter) {
                covariant = !covariant;
            }
            // Always substitute on type parameters, regardless of variance, since even
            // in contravariant positions, they may rely on substituted constraints to be valid
            if ((covariant || type.flags & TypeFlags.TypeVariable) && parent.kind === SyntaxKind.ConditionalType && node === (parent as ConditionalTypeNode).trueType) {
                const constraint = getImpliedConstraint(type, (parent as ConditionalTypeNode).checkType, (parent as ConditionalTypeNode).extendsType);
                if (constraint) {
                    constraints = append(constraints, constraint);
                }
            }
            // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the
            // template type XXX, K has an added constraint of number | `${number}`.
            else if (type.flags & TypeFlags.TypeParameter && parent.kind === SyntaxKind.MappedType && !(parent as MappedTypeNode).nameType && node === (parent as MappedTypeNode).type) {
                const mappedType = getTypeFromTypeNode(parent as TypeNode) as MappedType;
                if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {
                    const typeParameter = getHomomorphicTypeVariable(mappedType);
                    if (typeParameter) {
                        const constraint = getConstraintOfTypeParameter(typeParameter);
                        if (constraint && everyType(constraint, isArrayOrTupleType)) {
                            console.debug("todo - getConditionalFlowTypeOfType - homomorphic mapped type");
                            // constraints = append(constraints, getUnionType([numberType, numericStringType]));
                        }
                    }
                }
            }
            node = parent;
        }
        return type;
    }

    function unwrapReturnType(returnType: Type, functionFlags: FunctionFlags) {        
        const isAsync = !!(functionFlags & FunctionFlags.Async);        
        return isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType;
    }

    function getAwaitedTypeNoAlias(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments): Type | undefined {
        console.warn("Implement me - getAwaitedTypeNoAlias");
        return type;
    }
    
    // Return true if type might be of the given kind. A union or intersection type might be of a given
    // kind if at least one constituent type is of the given kind.
    function maybeTypeOfKind(type: Type, kind: TypeFlags): boolean {
        if (type.flags & kind) {
            return true;
        }
        if (type.flags & TypeFlags.UnionOrIntersection) {
            const types = (type as UnionOrIntersectionType).types;
            for (const t of types) {
                if (maybeTypeOfKind(t, kind)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    function functionHasImplicitReturn(func: FunctionLikeDeclaration) {
        return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
    }

    /**
     * TypeScript Specification 1.0 (6.3) - July 2014
     *   An explicitly typed function whose return type isn't the Void type,
     *   the Any type, or a union type containing the Void or Any type as a constituent
     *   must have at least one return statement somewhere in its body.
     *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
     *
     * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
     */
    function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func: FunctionLikeDeclaration /*| MethodSignature*/, returnType: Type | undefined) {
        addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics);
        return;

        function checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics(): void {
            const functionFlags = getFunctionFlags(func);
            const type = returnType && unwrapReturnType(returnType, functionFlags);

            // Functions with an explicitly specified return type that includes `void` or is exactly `any` or `undefined` don't
            // need any return statements.
            if (type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined))) {
                return;
            }

            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            // also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
            if (/*func.kind === SyntaxKind.MethodSignature ||*/ nodeIsMissing(func.body) || func.body!.kind !== SyntaxKind.Block || !functionHasImplicitReturn(func)) {
                return;
            }

            const hasExplicitReturn = func.flags & NodeFlags.HasExplicitReturn;
            const errorNode = getEffectiveReturnTypeNode(func) || func;

            if (type && type.flags & TypeFlags.Never) {
                error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
            }
            else if (type && !hasExplicitReturn) {
                // minimal check: function has syntactic return type annotation and no explicit return statements in the body
                // this function does not conform to the specification.
                error(errorNode, Diagnostics.A_function_whose_declared_type_is_not_void_must_return_a_value);
            }
            else if (type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)) {
                error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
            }
            else if (compilerOptions.noImplicitReturns) {
                if (!type) {
                    // If return type annotation is omitted check if function has any explicit return statements.
                    // If it does not have any - its inferred return type is void - don't do any checks.
                    // Otherwise get inferred return type from function body and report error only if it is not void / anytype
                    if (!hasExplicitReturn) {
                        return;
                    }
                    const inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                    if (isUnwrappedReturnTypeUndefinedVoidOrAny(func, inferredReturnType)) {
                        return;
                    }
                }
                error(errorNode, Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
    }

    function isUnwrappedReturnTypeUndefinedVoidOrAny(func: SignatureDeclaration, returnType: Type): boolean {
        const type = unwrapReturnType(returnType, getFunctionFlags(func));
        return !!(type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined)));
    }
    
    function hasParseDiagnostics(sourceFile: SourceFileBase): boolean {
        return sourceFile.parseDiagnostics.length > 0;
    }

    function grammarErrorOnNode(node: Node, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            diagnostics.add(createDiagnosticForNode(node, message, ...args));
            return true;
        }
        return false;
    }

    function checkGrammarIndexSignatureParameters(node: SignatureDeclaration): boolean {
        console.warn("Implement me - checkGrammarIndexSignatureParameters");
        // const parameter = node.parameters[0];
        // if (node.parameters.length !== 1) {
        //     if (parameter) {
        //         return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter);
        //     }
        //     else {
        //         return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter);
        //     }
        // }
        // //checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma);
        // if (parameter.dotDotDotToken) {
        //     return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
        // }
        // if (hasEffectiveModifiers(parameter)) {
        //     return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
        // }
        // if (parameter.questionToken) {
        //     return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
        // }
        // if (parameter.initializer) {
        //     return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
        // }
        // if (!parameter.type) {
        //     return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
        // }
        // const type = getTypeFromTypeNode(parameter.type);
        // if (someType(type, t => !!(t.flags & TypeFlags.StringOrNumberLiteralOrUnique)) || isGenericType(type)) {
        //     return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead);
        // }
        // if (!everyType(type, isValidIndexKeyType)) {
        //     return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type);
        // }
        // if (!node.type) {
        //     return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation);
        // }
        return false;
    }

    function checkGrammarIndexSignature(node: IndexSignatureDeclaration) {
        // Prevent cascading error by short-circuit
        return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node);
    }

    function checkGrammarFunctionLikeDeclaration(node: FunctionLikeDeclaration | MethodSignature): boolean {
        // Prevent cascading error by short-circuit
        const file = getSourceFileOfNode(node);
        return checkGrammarModifiers(node) ||
            checkGrammarTypeParameterList(node.typeParameters, file) ||
            checkGrammarParameterList(node.parameters);
            // checkGrammarArrowFunction(node, file) ||            
    }
    
    function checkGrammarTypeParameterList(typeParameters: NodeArray<TypeParameterDeclaration> | undefined, file: SourceFile): boolean {
        if (typeParameters && typeParameters.length === 0) {
            const start = typeParameters.pos - "<".length;
            const end = skipTrivia(file.text, typeParameters.end) + ">".length;
            return grammarErrorAtPos(file, start, end - start, Diagnostics.Type_parameter_list_cannot_be_empty);
        }
        return false;
    }

    function checkGrammarExpressionWithTypeArguments(node: ExpressionWithTypeArguments/* | TypeQueryNode*/) {
        return checkGrammarTypeArguments(node, node.typeArguments);
    }

    function checkGrammarTypeArguments(node: Node, typeArguments: NodeArray<TypeNode> | undefined): boolean {
        return checkGrammarForDisallowedTrailingComma(typeArguments) ||
            checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
    }

    function checkGrammarForAtLeastOneTypeArgument(node: Node, typeArguments: NodeArray<TypeNode> | undefined): boolean {
        if (typeArguments && typeArguments.length === 0) {
            const sourceFile = getSourceFileOfNode(node);
            const start = typeArguments.pos - "<".length;
            const end = skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
            return grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.Type_argument_list_cannot_be_empty);
        }
        return false;
    }

    function grammarErrorAtPos(nodeForSourceFile: Node, start: number, length: number, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean {
        const sourceFile = getSourceFileOfNode(nodeForSourceFile);
        if (!hasParseDiagnostics(sourceFile)) {
            diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, ...args));
            return true;
        }
        return false;
    }

    function checkGrammarForDisallowedTrailingComma(list: NodeArray<Node> | undefined, diag = Diagnostics.Trailing_comma_not_allowed): boolean {
        if (list && list.hasTrailingComma) {
            return grammarErrorAtPos(list[0], list.end - ",".length, ",".length, diag);
        }
        return false;
    }

    function checkGrammarParameterList(parameters: NodeArray<ParameterDeclaration>) {
        let seenOptionalParameter = false;
        const parameterCount = parameters?.length ?? 0;

        for (let i = 0; i < parameterCount; i++) {
            const parameter = parameters[i];
            if (parameter.dotDotDotToken) {
                if (i !== (parameterCount - 1)) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                }
                if (!(parameter.flags & NodeFlags.Ambient)) { // Allow `...foo,` in ambient declarations; see GH#23070
                    checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                }

                // if (parameter.questionToken) {
                //     return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);
                // }

                if (parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                }
            }
            // else if (hasEffectiveQuestionToken(parameter)) {
            //     seenOptionalParameter = true;
            //     if (parameter.questionToken && parameter.initializer) {
            //         return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
            //     }
            // }
            // else if (seenOptionalParameter && !parameter.initializer) {
            //     return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
            // }
        }
    }

    function checkSignatureDeclaration(node: SignatureDeclaration) {
        // Grammar checking
        if (node.kind === SyntaxKind.IndexSignature) {
            checkGrammarIndexSignature(node);
        }
        // TODO (yuisu): Remove this check in else-if when SyntaxKind.Construct is moved and ambient context is handled
        else if (
            node.kind === SyntaxKind.FunctionDeclaration
            // node.kind === SyntaxKind.FunctionType || node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.ConstructorType ||
            // node.kind === SyntaxKind.CallSignature || node.kind === SyntaxKind.Constructor ||
            // node.kind === SyntaxKind.ConstructSignature
        ) {
            checkGrammarFunctionLikeDeclaration(node as FunctionLikeDeclaration);
        }

        const functionFlags = getFunctionFlags(node as FunctionLikeDeclaration);
                
        checkUnmatchedJSDocParameters(node);

        forEach(node.parameters, checkParameter);

        // TODO(rbuckton): Should we start checking JSDoc types?
        if (node.type) {
            checkSourceElement(node.type);
        }

        addLazyDiagnostic(checkSignatureDeclarationDiagnostics);

        function checkSignatureDeclarationDiagnostics() {
            //checkCollisionWithArgumentsInGeneratedCode(node);

            let returnTypeNode = getEffectiveReturnTypeNode(node);
            let returnTypeErrorLocation = returnTypeNode;
            
            if (isInJSFile(node)) {
                const typeTag = getJSDocTypeTag(node);
                if (typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type)) {
                    const signature = getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
                    if (signature && signature.declaration) {
                        returnTypeNode = getEffectiveReturnTypeNode(signature.declaration);
                        returnTypeErrorLocation = typeTag.typeExpression.type;
                    }
                }
            }

            if (returnTypeNode && returnTypeErrorLocation) {
                const functionFlags = getFunctionFlags(node as FunctionDeclaration);
                // if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async) {
                //     checkAsyncFunctionReturnType(node as FunctionLikeDeclaration, returnTypeNode, returnTypeErrorLocation);
                // }
            }
            if (node.kind !== SyntaxKind.IndexSignature && (node as Node).kind !== SyntaxKind.JSDocFunctionType) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
    }

    // Check variable, parameter, or property declaration
    function checkVariableLikeDeclaration(node: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement) {        
        if (!isBindingElement(node)) {
            checkSourceElement(node.type);
        }

        // JSDoc `function(string, string): string` syntax results in parameters with no name
        if (!node.name) {
            return errorType;
        }

        if (isBindingElement(node)) {
            if (
                node.propertyName &&
                isIdentifier(node.name) &&
                isPartOfParameterDeclaration(node) &&
                nodeIsMissing((getContainingFunction(node) as FunctionLikeDeclaration).body)
            ) {
                // type F = ({a: string}) => void;
                //               ^^^^^^
                // variable renaming in function type notation is confusing,
                // so we forbid it even if noUnusedLocals is not enabled
                //potentialUnusedRenamedBindingElementsInTypes.push(node);
                return;
            }

            // if (isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTarget.ObjectSpreadRest) {
            //     checkExternalEmitHelpers(node, ExternalEmitHelpers.Rest);
            // }
            // check computed properties inside property names of binding elements
            // if (node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName) {
            //     checkComputedPropertyName(node.propertyName);
            // }

            // check private/protected variable access
            const parent = node.parent.parent;
            const parentCheckMode = node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal;
            const parentType = getTypeForBindingElementParent(parent, parentCheckMode);
            const name = node.propertyName || node.name;
            if (parentType && !isBindingPattern(name)) {
                const exprType = getLiteralTypeFromPropertyName(name);
                if (isTypeUsableAsPropertyName(exprType)) {
                    const nameText = getPropertyNameFromType(exprType);
                    const property = getPropertyOfType(parentType, nameText);
                    if (property) {
                        markPropertyAsReferenced(property, /*nodeForCheckWriteOnly*/ undefined, /*isSelfTypeAccess*/ false); // A destructuring is never a write-only reference.
                        checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind === SyntaxKind.SuperKeyword, /*writing*/ false, parentType, property);
                    }
                }
            }
        }

        // For a binding pattern, check contained binding elements
        if (isBindingPattern(node.name)) {
            // if (node.name.kind === SyntaxKind.ArrayBindingPattern && languageVersion < LanguageFeatureMinimumTarget.BindingPatterns && compilerOptions.downlevelIteration) {
            //     checkExternalEmitHelpers(node, ExternalEmitHelpers.Read);
            // }

            forEach(node.name.elements, checkSourceElement);
        }

        // For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
        if (node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) as FunctionLikeDeclaration).body)) {
            error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
            return;
        }
        // For a binding pattern, validate the initializer and exit
        if (isBindingPattern(node.name)) {
            if (isInAmbientOrTypeNode(node)) {
                return anyType;
            }
            const needCheckInitializer = hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind !== SyntaxKind.ForEachStatement;
            const needCheckWidenedType = false;//!some(node.name.elements, not(isOmittedExpression));
            if (needCheckInitializer || needCheckWidenedType) {
                // Don't validate for-in initializer as it is already an error
                const widenedType = getWidenedTypeForVariableLikeDeclaration(node);
                if (needCheckInitializer) {
                    const initializerType = checkExpressionCached(node.initializer);
                    if (strictNullChecks && needCheckWidenedType) {
                        checkNonNullNonVoidType(initializerType, node);
                    }
                    else {
                        checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
                    }
                }
                // check the binding pattern with empty elements
                if (needCheckWidenedType) {
                    if (isArrayBindingPattern(node.name)) {
                        checkIteratedTypeOrElementType(IterationUse.Destructuring, widenedType, undefinedType, node);
                    }
                    else if (strictNullChecks) {
                        checkNonNullNonVoidType(widenedType, node);
                    }
                }
            }
            return getTypeOfNode(node);
        }
        // For a commonjs `const x = require`, validate the alias and exit
        const symbol = getSymbolOfDeclaration(node);
     
        if (symbol.flags & SymbolFlags.Alias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node))) {
            checkAliasSymbol(node);
            return getTypeOfNode(node);
        }        
        const type = convertAutoToAny(getTypeOfSymbol(symbol));
        if (node === symbol.valueDeclaration) {
            // Node is the primary declaration of the symbol, just validate the initializer
            // Don't validate for-in initializer as it is already an error
            const initializer = hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node);
            if (initializer) { 
                const isJSObjectLiteralInitializer = isInJSFile(node) &&
                    isObjectLiteralExpression(initializer) &&
                    (initializer.properties.length === 0) &&
                    !!symbol.exports?.size;
                if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== SyntaxKind.ForEachStatement) {
                    let initializerType: Type;
                    // check the closure, but don't use its type
                    if (isInlineClosureExpression(initializer)) {                        
                        checkExpressionCached(initializer);

                        // if (isParameter(node)) {
                            // however, if we're initializing a parameter then get the closures
                            // result type
                            const sig = getResolvedSignature(initializer);
                            initializerType = getReturnTypeOfSignature(sig);
                        // }
                    } 
                    else if (!initializerType) {
                        initializerType = checkExpressionCached(initializer);
                    }

                    if (checkTypeAssignableToAndOptionallyElaborate(initializerType, type, node, initializer, /*headMessage*/ undefined)) {
                        // if everything is ok up to this point, and the initializer is a mapping, then override
                        // the symbol's resolved type - because the initializer here is probably more specific
                        // if (isMappingType(initializerType)) {
                        //     // not we need to use the local symbol here, not the symbol from above (which is a merged symbol including late bindings)
                        //     const localSymbol = getLocalSymbolForExportDefault(symbol);
                        //     const links = localSymbol && getSymbolLinks(localSymbol);
                        //     if (links) links.type = initializerType;
                        // }
                    }
                    // const blockScopeKind = getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped;
                    // if (blockScopeKind === NodeFlags.AwaitUsing) {
                    //     const globalAsyncDisposableType = getGlobalAsyncDisposableType(/*reportErrors*/ true);
                    //     const globalDisposableType = getGlobalDisposableType(/*reportErrors*/ true);
                    //     if (globalAsyncDisposableType !== emptyObjectType && globalDisposableType !== emptyObjectType) {
                    //         const optionalDisposableType = getUnionType([globalAsyncDisposableType, globalDisposableType, nullType, undefinedType]);
                    //         checkTypeAssignableTo(initializerType, optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined);
                    //     }
                    // }
                } 
            }
            if (symbol.declarations && symbol.declarations.length > 1) {
                if (some(symbol.declarations, d => d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node))) {
                    error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
                }
            }
        }
        else {
            // Node is a secondary declaration, check that type is identical to primary declaration and check that
            // initializer is consistent with type associated with the node
            const declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));

            if (
                !isErrorType(type) && !isErrorType(declarationType) &&
                !isTypeIdenticalTo(type, declarationType) &&
                !(symbol.flags & SymbolFlags.Assignment)
            ) {
                errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
            }
            if (hasOnlyExpressionInitializer(node) && node.initializer) {
                checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, /*headMessage*/ undefined);
            }
            if (symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
            }
        }
        if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature) {
            // We know we don't have a binding pattern or computed name here
            checkExportsOnMergedDeclarations(node);
            if (node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement) {
                checkVarDeclaredNamesNotShadowed(node);
            }
            checkCollisionsForDeclarationName(node, node.name);
        }

        return getTypeOfNode(node);
    }

    function checkNonNullNonVoidType(type: Type, node: Node): Type {
        const nonNullType = checkNonNullType(type, node);
        if (nonNullType.flags & TypeFlags.Void) {
            if (isEntityNameExpression(node)) {
                const nodeText = entityNameToString(node);
                if (isIdentifier(node) && nodeText === "undefined") {
                    error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText);
                    return nonNullType;
                }
                if (nodeText.length < 100) {
                    error(node, Diagnostics._0_is_possibly_undefined, nodeText);
                    return nonNullType;
                }
            }
            error(node, Diagnostics.Object_is_possibly_undefined);
        }
        return nonNullType;
    }
    
    function areDeclarationFlagsIdentical(left: Declaration, right: Declaration) {
        if (
            (left.kind === SyntaxKind.Parameter && right.kind === SyntaxKind.VariableDeclaration) ||
            (left.kind === SyntaxKind.VariableDeclaration && right.kind === SyntaxKind.Parameter)
        ) {
            // Differences in optionality between parameters and variables are allowed.
            return true;
        }

        // if (hasQuestionToken(left) !== hasQuestionToken(right)) {
        //     return false;
        // }

        const interestingFlags = ModifierFlags.Private |
            ModifierFlags.Protected |
            // ModifierFlags.Async |
            // ModifierFlags.Abstract |
            // ModifierFlags.Readonly |
            ModifierFlags.Static;

        return getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(right, interestingFlags);
    }

    function checkAliasSymbol(node: AliasDeclarationNode) {
        let symbol = getSymbolOfDeclaration(node);
        const target = resolveAlias(symbol);

        if (target !== unknownSymbol) {
            // For external modules, `symbol` represents the local symbol for an alias.
            // This local symbol will merge any other local declarations (excluding other aliases)
            // and symbol.flags will contains combined representation for all merged declaration.
            // Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
            // otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
            // in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
            symbol = getMergedSymbol(symbol.exportSymbol || symbol);

            // A type-only import/export will already have a grammar error in a JS file, so no need to issue more errors within
            // if (isInJSFile(node) && !(target.flags & SymbolFlags.Value) && !isTypeOnlyImportOrExportDeclaration(node)) {
            //     const errorNode = isImportOrExportSpecifier(node) ? node.propertyName || node.name :
            //         isNamedDeclaration(node) ? node.name :
            //         node;

            //     Debug.assert(node.kind !== SyntaxKind.NamespaceExport);
            //     if (node.kind === SyntaxKind.ExportSpecifier) {
            //         const diag = error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files);
            //         const alreadyExportedSymbol = getSourceFileOfNode(node).symbol?.exports?.get(moduleExportNameTextEscaped(node.propertyName || node.name));
            //         if (alreadyExportedSymbol === target) {
            //             const exportingDeclaration = alreadyExportedSymbol.declarations?.find(isJSDocNode);
            //             if (exportingDeclaration) {
            //                 addRelatedInfo(
            //                     diag,
            //                     createDiagnosticForNode(
            //                         exportingDeclaration,
            //                         Diagnostics._0_is_automatically_exported_here,
            //                         unescapeLeadingUnderscores(alreadyExportedSymbol.name),
            //                     ),
            //                 );
            //             }
            //         }
            //     }
            //     else {
            //         Debug.assert(node.kind !== SyntaxKind.VariableDeclaration);
            //         const importDeclaration = findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration));
            //         const moduleSpecifier = (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "...";
            //         const importedIdentifier = unescapeLeadingUnderscores(isIdentifier(errorNode) ? errorNode.text : symbol.name);
            //         error(
            //             errorNode,
            //             Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation,
            //             importedIdentifier,
            //             `import("${moduleSpecifier}").${importedIdentifier}`,
            //         );
            //     }
            //     return;
            // }

            const targetFlags = getSymbolFlags(target);
            const excludedMeanings = (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) |
                (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |
                (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0);
            if (targetFlags & excludedMeanings) {
                Debug.fail("Shouldn't have a symbol conflict here.");
                // const message = node.kind === SyntaxKind.ExportSpecifier ?
                //     Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :
                //     Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
                // error(node, message, symbolToString(symbol));
            }
            // else if (node.kind !== SyntaxKind.ExportSpecifier) {
            //     // Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
            //     // here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
            //     const appearsValueyToTranspiler = compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration);
            //     if (appearsValueyToTranspiler && symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue)) {
            //         error(
            //             node,
            //             Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled,
            //             symbolToString(symbol),
            //             isolatedModulesLikeFlagName,
            //         );
            //     }
            // }

            // if (
            //     getIsolatedModules(compilerOptions)
            //     && !isTypeOnlyImportOrExportDeclaration(node)
            //     && !(node.flags & NodeFlags.Ambient)
            // ) {
            //     const typeOnlyAlias = getTypeOnlyAliasDeclaration(symbol);
            //     const isType = !(targetFlags & SymbolFlags.Value);
            //     if (isType || typeOnlyAlias) {
            //         switch (node.kind) {
            //             case SyntaxKind.ImportClause:
            //             case SyntaxKind.ImportSpecifier:
            //             case SyntaxKind.ImportEqualsDeclaration: {
            //                 if (compilerOptions.verbatimModuleSyntax) {
            //                     Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");
            //                     const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node)
            //                         ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled
            //                         : isType
            //                         ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled
            //                         : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled;
            //                     const name = moduleExportNameTextUnescaped(node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name);
            //                     addTypeOnlyDeclarationRelatedInfo(
            //                         error(node, message, name),
            //                         isType ? undefined : typeOnlyAlias,
            //                         name,
            //                     );
            //                 }
            //                 if (isType && node.kind === SyntaxKind.ImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlags.Export)) {
            //                     error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);
            //                 }
            //                 break;
            //             }
            //             case SyntaxKind.ExportSpecifier: {
            //                 // Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.
            //                 // The exception is that `import type { A } from './a'; export { A }` is allowed
            //                 // because single-file analysis can determine that the export should be dropped.
            //                 if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {
            //                     const name = moduleExportNameTextUnescaped(node.propertyName || node.name);
            //                     const diagnostic = isType
            //                         ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)
            //                         : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);
            //                     addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? undefined : typeOnlyAlias, name);
            //                     break;
            //                 }
            //             }
            //         }
            //     }

            //     if (
            //         compilerOptions.verbatimModuleSyntax &&
            //         node.kind !== SyntaxKind.ImportEqualsDeclaration &&
            //         !isInJSFile(node) &&
            //         host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS
            //     ) {
            //         error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
            //     }
            //     else if (
            //         moduleKind === ModuleKind.Preserve &&
            //         node.kind !== SyntaxKind.ImportEqualsDeclaration &&
            //         node.kind !== SyntaxKind.VariableDeclaration &&
            //         host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS
            //     ) {
            //         // In `--module preserve`, ESM input syntax emits ESM output syntax, but there will be times
            //         // when we look at the `impliedNodeFormat` of this file and decide it's CommonJS (i.e., currently,
            //         // only if the file extension is .cjs/.cts). To avoid that inconsistency, we disallow ESM syntax
            //         // in files that are unambiguously CommonJS in this mode.
            //         error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve);
            //     }
            // }

            // TODO - implement this for clone_object, etc
            // if (isImportSpecifier(node)) {
            //     const targetSymbol = resolveAliasWithDeprecationCheck(symbol, node);
            //     if (isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations) {
            //         addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.name as string);
            //     }
            // }
        }
    }

    function checkParameter(node: ParameterDeclaration) {
        // Grammar checking
        // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
        // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
        // or if its FunctionBody is strict code(11.1.5).
        checkGrammarModifiers(node);

        checkVariableLikeDeclaration(node);
        const func = getContainingFunction(node)!;
        if (hasSyntacticModifier(node, ModifierFlags.ParameterPropertyModifier)) {            
        }        
        if (node.name && isIdentifier(node.name) && (node.name.text === "this" || node.name.text === "new")) {
            if (func.parameters.indexOf(node) !== 0) {
                error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.text as string);
            }                        
        }

        // Only check rest parameter type if it's not a binding pattern. Since binding patterns are
        // not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
        if (node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType)) {
            error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type);
        }
    }

    
    /**
     * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
     * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
     * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
     * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
     */
    function getReducedType(type: Type): Type {
        if (type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections) {
            return (type as UnionType).resolvedReducedType || ((type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType));
        }        
        else if (type.flags & TypeFlags.Intersection) {
            if (!((type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersectionComputed)) {
                (type as IntersectionType).objectFlags |= ObjectFlags.IsNeverIntersectionComputed |
                    (some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0);
            }
            return (type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type;
        }
        return type;
    }
    
    function isNeverReducedProperty(prop: Symbol) {
        return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
    }

    function isDiscriminantWithNeverType(prop: Symbol) {
        // Return true for a synthetic non-optional property with non-uniform types, where at least one is
        // a literal type and none is never, that reduces to never.
        return !(prop.flags & SymbolFlags.Optional) &&
            (getCheckFlags(prop) & (CheckFlags.Discriminant | CheckFlags.HasNeverType)) === CheckFlags.Discriminant &&
            !!(getTypeOfSymbol(prop).flags & TypeFlags.Never);
    }

    function isConflictingPrivateProperty(prop: Symbol) {
        // Return true for a synthetic property with multiple declarations, at least one of which is private.
        return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlags.ContainsPrivate);
    }
    
    function getReducedUnionType(unionType: UnionType) {
        const reducedTypes = sameMap(unionType.types, getReducedType);
        if (reducedTypes === unionType.types) {
            return unionType;
        }
        const reduced = getUnionType(reducedTypes);
        if (reduced.flags & TypeFlags.Union) {
            (reduced as UnionType).resolvedReducedType = reduced;
        }
        return reduced;
    }

    function isTypeIdenticalTo(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, identityRelation);
    }

    function isInAmbientOrTypeNode(node: Node): boolean {
        return !!(node.flags & NodeFlags.Ambient);
    }

    function checkExportsOnMergedDeclarations(node: Declaration): void {
        //addLazyDiagnostic(() => checkExportsOnMergedDeclarationsWorker(node));
    }

    function checkVarDeclaredNamesNotShadowed(node: VariableDeclaration | BindingElement) {
        // - ScriptBody : StatementList
        // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
        // also occurs in the VarDeclaredNames of StatementList.

        // - Block : { StatementList }
        // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
        // also occurs in the VarDeclaredNames of StatementList.

        // Variable declarations are hoisted to the top of their function scope. They can shadow
        // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
        // by the binder as the declaration scope is different.
        // A non-initialized declaration is a no-op as the block declaration will resolve before the var
        // declaration. the problem is if the declaration has an initializer. this will act as a write to the
        // block declared value. this is fine for let, but not const.
        // Only consider declarations with initializers, uninitialized const declarations will not
        // step on a let/const variable.
        // Do not consider const and const declarations, as duplicate block-scoped declarations
        // are handled by the binder.
        // We are only looking for const declarations that step on let\const declarations from a
        // different scope. e.g.:
        //      {
        //          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
        //          const x = 0; // symbol for this declaration will be 'symbol'
        //      }

        // skip block-scoped variables and parameters
        if ((getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped) !== 0 || isPartOfParameterDeclaration(node)) {
            return;
        }

        // NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
        // so we'll always treat binding elements as initialized

        const symbol = getSymbolOfDeclaration(node);
        if (symbol.flags & SymbolFlags.FunctionScopedVariable) {
            if (!isIdentifier(node.name)) return Debug.fail();
            const localDeclarationSymbol = resolveName(node, node.name.text, SymbolFlags.Variable, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
            if (
                localDeclarationSymbol &&
                localDeclarationSymbol !== symbol &&
                localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable
            ) {
                if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped) {
                    const varDeclList = getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKind.VariableDeclarationList)!;
                    const container = varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent
                        ? varDeclList.parent.parent
                        : undefined;

                    // names of block-scoped and function scoped variables can collide only
                    // if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
                    const namesShareScope = container &&
                        (container.kind === SyntaxKind.Block && isFunctionLike(container.parent) ||
                            // container.kind === SyntaxKind.ModuleBlock ||
                            // container.kind === SyntaxKind.ModuleDeclaration ||
                            container.kind === SyntaxKind.SourceFile);

                    // here we know that function scoped variable is "shadowed" by block scoped one
                    // a var declatation can't hoist past a lexical declaration and it results in a SyntaxError at runtime
                    if (!namesShareScope) {
                        const name = symbolToString(localDeclarationSymbol);
                        error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                    }
                }
            }
        }
    }

    function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration: Declaration | undefined, firstType: Type, nextDeclaration: Declaration, nextType: Type): void {
        const nextDeclarationName = getNameOfDeclaration(nextDeclaration);
        const message = nextDeclaration.kind === SyntaxKind.PropertyDeclaration /*|| nextDeclaration.kind === SyntaxKind.PropertySignature*/
            ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
            : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
        const declName = declarationNameToString(nextDeclarationName);
        const err = error(
            nextDeclarationName,
            message,
            declName,
            typeToString(firstType),
            typeToString(nextType),
        );
        if (firstDeclaration) {
            addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName));
        }
    }

    function reportErrorsFromWidening(declaration: Declaration, type: Type, wideningKind?: WideningKind) {
        addLazyDiagnostic(() => {
            if (noImplicitAny && getObjectFlags(type) & ObjectFlags.ContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration as FunctionLikeDeclaration))) {
                // Report implicit any error within type if possible, otherwise report error on declaration
                if (!reportWideningErrorsInType(type)) {
                    reportImplicitAny(declaration, type, wideningKind);
                }
            }
        });
    }

    function getContextualSignatureForFunctionLikeDeclaration(node: FunctionLikeDeclaration): Signature | undefined {
        // Only function expressions, arrow functions, and object literal methods are contextually typed.
        return isFunctionExpressionOrInlineClosure(node)// TODO || isObjectLiteralMethod(node)
            ? getContextualSignature(node as FunctionExpression)
            : undefined;
    }

    function findContextualNode(node: Node, includeCaches: boolean) {
        for (let i = contextualTypeCount - 1; i >= 0; i--) {
            if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {
                return i;
            }
        }
        return -1;
    }

    // Return the list of properties of the given type, augmented with properties from Function
    // if the type has call or construct signatures
    function getAugmentedPropertiesOfType(type: Type): Symbol[] {
        type = getApparentType(type);
        const propsByName = createSymbolTable(getPropertiesOfType(type));
        const functionType = getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType :
            getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType :
            undefined;
        if (functionType) {
            forEach(getPropertiesOfType(functionType), p => {
                if (!propsByName.has(p.name)) {
                    propsByName.set(p.name, p);
                }
            });
        }
        return getNamedMembers(propsByName);
    }

    function getAllPossiblePropertiesOfTypes(types: readonly Type[]): Symbol[] {
        const unionType = getUnionType(types);
        if (!(unionType.flags & TypeFlags.Union)) {
            return getAugmentedPropertiesOfType(unionType);
        }

        const props = createSymbolTable();
        for (const memberType of types) {
            for (const { name } of getAugmentedPropertiesOfType(memberType)) {
                if (!props.has(name)) {
                    const prop = createUnionOrIntersectionProperty(unionType as UnionType, name);
                    // May be undefined if the property is private
                    if (prop) props.set(name, prop);
                }
            }
        }
        return arrayFrom(props.values());
    }

    function checkFunctionExpressionOrObjectLiteralMethod(node: FunctionExpression, checkMode?: CheckMode): Type {
        // Debug.assert(isObjectLiteralMethod(node));
        checkNodeDeferred(node);

        if (isFunctionExpression(node)) {
            checkCollisionsForDeclarationName(node, node.name);
        }

        // The identityMapper object is used to indicate that function expressions are wildcards
        if (checkMode && checkMode & CheckMode.SkipContextSensitive && isContextSensitive(node)) {
            // Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
            if (!getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node)) {
                // Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
                const contextualSignature = getContextualSignature(node);
                if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                    const links = getNodeLinks(node);
                    if (links.contextFreeType) {
                        return links.contextFreeType;
                    }
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    const returnOnlySignature = createSignature(/*declaration*/ undefined, /*typeParameters*/ undefined, /*thisParameter*/ undefined, emptyArray, returnType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.IsNonInferrable);
                    const returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], emptyArray, emptyArray);
                    returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType;
                    return links.contextFreeType = returnOnlyType;
                }
            }
            return anyFunctionType;
        }

        // Grammar checking
        const hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
                
        contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);

        return getTypeOfSymbol(getSymbolOfDeclaration(node));
    }


    function checkAssertion(node: AssertionExpression, checkMode: CheckMode | undefined) {        
        return checkAssertionWorker(node, checkMode);
    }

    function checkAssertionWorker(node: JSDocTypeAssertion | AssertionExpression, checkMode: CheckMode | undefined) {
        const { type, expression } = getAssertionTypeAndExpression(node);
        const exprType = checkExpression(expression, checkMode);        
        const links = getNodeLinks(node);
        links.assertionExpressionType = exprType;
        checkSourceElement(type);
        checkNodeDeferred(node);
        return getTypeFromTypeNode(type);
    }


    function addIntraExpressionInferenceSite(context: InferenceContext, node: Expression, type: Type) {
        (context.intraExpressionInferenceSites ??= []).push({ node, type });
    }

    function checkParenthesizedExpression(node: ParenthesizedExpression, checkMode?: CheckMode): Type {
        if (hasJSDocNodes(node)) {
            // if (isJSDocSatisfiesExpression(node)) {
            //     return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode);
            // }
            if (isJSDocTypeAssertion(node)) {
                return checkAssertionWorker(node, checkMode);
            }
        }
        return checkExpression(node.expression, checkMode);
    }

    function checkNewStructExpresion(node: NewStructExpression, checkMode: CheckMode | undefined) {
        const { type, arguments: args } = node;
        const structType = getTypeFromTypeReference(type);
        
        const links = getNodeLinks(node);
        // links.resolvedType = structType;
        checkSourceElement(type);
        checkNodeDeferred(node);
        checkNewStructLiteral(node, checkMode);
        return getTypeFromTypeNode(type);
    }


    function checkNewStructLiteral(node: NewStructExpression, checkMode: CheckMode = CheckMode.Normal): Type {
        if (!node.arguments) return undefined;

        const inDestructuringPattern = isAssignmentTarget(node);
        // Grammar checking
        // TODO: checkGrammarObjectLiteralExpression(node, inDestructuringPattern);

        const allPropertiesTable = strictNullChecks ? createSymbolTable() : undefined;
        let propertiesTable = createSymbolTable();
        let propertiesArray: Symbol[] = [];
        let spread: Type = emptyObjectType;

        pushCachedContextualType(node);
        const contextualType = getApparentTypeOfContextualType(node, /*contextFlags*/ undefined);
        // const contextualTypeHasPattern = contextualType && contextualType.pattern &&
        //     (contextualType.pattern.kind === SyntaxKind.ObjectBindingPattern || contextualType.pattern.kind === SyntaxKind.ObjectLiteralExpression);
        // const inConstContext = isConstContext(node);        
        const checkFlags = 0;
        let objectFlags: ObjectFlags = ObjectFlags.FreshLiteral;
        let patternWithComputedProperties = false;
        let hasComputedStringProperty = false;
        let hasComputedNumberProperty = false;
        let hasComputedSymbolProperty = false;

        // Spreads may cause an early bail; ensure computed names are always checked (this is cached)
        // As otherwise they may not be checked until exports for the type at this position are retrieved,
        // which may never occur.
        // for (const elem of node.properties) {
        //     if (elem.name && isComputedPropertyName(elem.name)) {
        //         checkComputedPropertyName(elem.name);
        //     }
        // }

        let offset = 0;
        const hasNamedArgs = node.arguments && isPropertyAssignment(first(node.arguments));
        if (hasNamedArgs) {
            for (const memberDecl of node.arguments as readonly ObjectLiteralElementLike[]) {
                let member = getSymbolOfDeclaration(memberDecl);            
                if (
                    memberDecl.kind === SyntaxKind.PropertyAssignment ||
                    memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ||
                    isObjectLiteralMethod(memberDecl)
                ) {
                    let type = memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) :
                        // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring
                        // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.
                        // we don't want to say "could not find 'a'".
                        memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :
                        undefined;//checkObjectLiteralMethod(memberDecl, checkMode);
                
                    objectFlags |= getObjectFlags(type) & ObjectFlags.PropagatingFlags;                
                    const prop = createSymbol(SymbolFlags.Property | member.flags, member.name, checkFlags);                                
                    prop.declarations = member.declarations;
                    prop.parent = member.parent;
                    if (member.valueDeclaration) {
                        prop.valueDeclaration = member.valueDeclaration;
                    }

                    prop.links.type = type;
                    prop.links.target = member;
                    member = prop;
                    allPropertiesTable?.set(prop.name, prop);

                    if (
                        contextualType && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) &&
                        (memberDecl.kind === SyntaxKind.PropertyAssignment /*|| memberDecl.kind === SyntaxKind.MethodDeclaration*/) && isContextSensitive(memberDecl)
                    ) {
                        const inferenceContext = getInferenceContext(node);
                        Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                        const inferenceNode = memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl;
                        addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type);
                    }
                }                        

                
                propertiesTable.set(member.name, member);            
                propertiesArray.push(member);
            }
        }
        popContextualType();
        
        if (isErrorType(spread)) {
            return errorType;
        }
        
        // if (spread !== emptyObjectType) {
        //     if (propertiesArray.length > 0) {
        //         spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
        //         propertiesArray = [];
        //         propertiesTable = createSymbolTable();
        //         hasComputedStringProperty = false;
        //         hasComputedNumberProperty = false;
        //     }
        //     // remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
        //     return mapType(spread, t => t === emptyObjectType ? createObjectLiteralType() : t);
        // }

        return createObjectLiteralType();

        function createObjectLiteralType() {
            const indexInfos = [];
            if (hasComputedStringProperty) indexInfos.push(getNewStructLiteralIndexInfo(node, offset, propertiesArray, stringType));
            if (hasComputedNumberProperty) indexInfos.push(getNewStructLiteralIndexInfo(node, offset, propertiesArray, numberType));            
            const result = createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos);
            result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;          
            if (patternWithComputedProperties) {
                result.objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
            }            
            return result;
        }
    }

    function getNewStructLiteralIndexInfo(node: NewStructExpression, offset: number, properties: Symbol[], keyType: Type): IndexInfo {
        const propTypes: Type[] = [];
        for (let i = offset; i < properties.length; i++) {
            const prop = properties[i];
            if (
                keyType === stringType && !isSymbolWithSymbolName(prop) ||
                keyType === numberType && isSymbolWithNumericName(prop)                
            ) {
                propTypes.push(getTypeOfSymbol(properties[i]));
            }
        }
        const unionType = propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType;
        return createIndexInfo(keyType, unionType, false);
    }

    function isNumericName(name: DeclarationName): boolean {
        switch (name.kind) {
            // case SyntaxKind.ComputedPropertyName:
            //     return isNumericComputedName(name);
            case SyntaxKind.Identifier:
                return isNumericLiteralName((name as Identifier).text);
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.StringLiteral:
                return isNumericLiteralName((name as StringLiteral).text);
            default:
                return false;
        }
    }

    function isSymbolWithNumericName(symbol: Symbol) {
        const firstDecl = symbol.declarations?.[0];
        return isNumericLiteralName(symbol.name) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name));
    }

    function isSymbolWithSymbolName(symbol: Symbol) {
        const firstDecl = symbol.declarations?.[0];
        return isKnownSymbol(symbol);
    }

    /**
     * Whoa! Do you really want to use this function?
     *
     * Unless you're trying to get the *non-apparent* type for a
     * value-literal type or you're authoring relevant portions of this algorithm,
     * you probably meant to use 'getApparentTypeOfContextualType'.
     * Otherwise this may not be very useful.
     *
     * In cases where you *are* working on this function, you should understand
     * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
     *
     *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
     *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
     *
     * @param node the expression whose contextual type will be returned.
     * @returns the contextual type of an expression.
     */
    function getContextualType(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {        
        // Cached contextual types are obtained with no ContextFlags, so we can only consult them for
        // requests with no ContextFlags.
        const index = findContextualNode(node, /*includeCaches*/ !contextFlags);
        if (index >= 0) {
            return contextualTypes[index];
        }
        const { parent } = node;
        switch (parent.kind) {
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.BindingElement:                
                return getContextualTypeForInitializerExpression(node, contextFlags);
            case SyntaxKind.InlineClosureExpression:
            case SyntaxKind.ReturnStatement:                
                return getContextualTypeForReturnExpression(node, contextFlags);            
            // case SyntaxKind.AwaitExpression:
            //     return getContextualTypeForAwaitOperand(parent as AwaitExpression, contextFlags);
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:                
                return getContextualTypeForArgument(parent as CallExpression | NewExpression, node);            
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.CastExpression:
                return getTypeFromTypeNode((parent as AssertionExpression).type);
            case SyntaxKind.BinaryExpression:                
                return getContextualTypeForBinaryOperand(node, contextFlags);
            case SyntaxKind.LambdaIdentifierExpression:
            case SyntaxKind.LambdaOperatorExpression:
                return anyType;
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return getContextualTypeForObjectLiteralElement(parent as PropertyAssignment | ShorthandPropertyAssignment, contextFlags);
            // case SyntaxKind.SpreadAssignment:
            //     return getContextualType(parent.parent as ObjectLiteralExpression, contextFlags);
            case SyntaxKind.ArrayLiteralExpression: {
                const arrayLiteral = parent as ArrayLiteralExpression;
                const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);
                const elementIndex = indexOfNode(arrayLiteral.elements, node);
                const spreadIndices = getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements || emptyArray);
                return getContextualTypeForElementExpression(type, elementIndex, arrayLiteral.elements?.length || 0, spreadIndices.first, spreadIndices.last);
            }
            case SyntaxKind.ConditionalExpression:                
                return getContextualTypeForConditionalOperand(node, contextFlags);            
            case SyntaxKind.ParenthesizedExpression: {
                if (isInJSFile(parent)) {
                    if (isJSDocSatisfiesExpression(parent)) {
                        return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent));
                    }
                    // Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
                    const typeTag = getJSDocTypeTag(parent);
                    if (typeTag) {
                        return getTypeFromTypeNode(typeTag.typeExpression.type);
                    }
                }
                return getContextualType(parent as ParenthesizedExpression, contextFlags);
            }            
            // case SyntaxKind.ExportAssignment:
            //     return tryGetTypeFromEffectiveTypeNode(parent as ExportAssignment);            
            // case SyntaxKind.ImportAttribute:
            //     return getContextualImportAttributeType(parent as ImportAttribute);
        }
        return undefined;
    }

    function getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike, contextFlags: ContextFlags | undefined) {
        // if (isNewExpression(element.parent)) return anyType;
        
        // const objectLiteral = element.parent as ObjectLiteralExpression;
        const propertyAssignmentType = isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags);
        if (propertyAssignmentType) {
            return propertyAssignmentType;
        }
        const type = isNewExpression(element.parent) ? getTypeFromTypeNode(element.parent.expression as TypeNode) : getApparentTypeOfContextualType(element.parent, contextFlags);
        if (type) {
            if (hasBindableName(element)) {
                // For a (non-symbol) computed property, there is no reason to look up the name
                // in the type. It will just be "__computed", which does not appear in any
                // SymbolTable.
                if (isNewClassExpression(element.parent)) {
                    return getTypeOfPropertyOfContextualType(type, (element.name as Identifier).text);
                }

                const symbol = getSymbolOfDeclaration(element);                
                return getTypeOfPropertyOfContextualType(type, symbol.name, getSymbolLinks(symbol).nameType);
            }
            if (hasDynamicName(element)) {
                const name = getNameOfDeclaration(element);
                if (name && isComputedPropertyName(name)) {
                    const exprType = checkExpression(name.expression);
                    const propType = isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type, getPropertyNameFromType(exprType));
                    if (propType) {
                        return propType;
                    }
                }
            }
            if (element.name) {
                const nameType = getLiteralTypeFromPropertyName(element.name);
                // We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
                return mapType(type, t => findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType)?.type, /*noReductions*/ true);
            }
        }
        return undefined;
    }

    function getContextualTypeForBinaryOperand(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const binaryExpression = node.parent as BinaryExpression;
        const { left, operatorToken, right } = binaryExpression;
        switch (operatorToken.kind) {
            case SyntaxKind.EqualsToken:
            case SyntaxKind.BarBarEqualsToken:
            case SyntaxKind.AmpersandAmpersandEqualsToken:
            case SyntaxKind.QuestionQuestionEqualsToken:
                return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined;
            case SyntaxKind.BarBarToken:
            case SyntaxKind.QuestionQuestionToken:
                // When an || expression has a contextual type, the operands are contextually typed by that type, except
                // when that type originates in a binding pattern, the right operand is contextually typed by the type of
                // the left operand. When an || expression has no contextual type, the right operand is contextually typed
                // by the type of the left operand, except for the special case of Javascript declarations of the form
                // `namespace.prop = namespace.prop || {}`.
                const type = getContextualType(binaryExpression, contextFlags);
                return type;
                // return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ?
                //     getTypeOfExpression(left) : type;
            case SyntaxKind.AmpersandAmpersandToken:
            case SyntaxKind.CommaToken:
                return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;
            default:
                return undefined;
        }
    }

    /**
     * Try to find a resolved symbol for an expression without also resolving its type, as
     * getSymbolAtLocation would (as that could be reentrant into contextual typing)
     */
    function getSymbolForExpression(e: Expression) {
        if (canHaveSymbol(e) && e.symbol) {
            return e.symbol;
        }
        if (isIdentifier(e)) {
            return getResolvedSymbol(e);
        }
        if (isPropertyAccessExpression(e)) {
            const lhsType = getTypeOfExpression(e.expression);
            return isIdentifier(e.name) && getPropertyOfType(lhsType, e.name.text);
        }
        if (isElementAccessExpression(e)) {
            const propType = checkExpressionCached(e.argumentExpression);
            if (!isTypeUsableAsPropertyName(propType)) {
                return undefined;
            }
            const lhsType = getTypeOfExpression(e.expression);
            return getPropertyOfType(lhsType, getPropertyNameFromType(propType));
        }
        return undefined;

        // function tryGetPrivateIdentifierPropertyOfType(type: Type, id: PrivateIdentifier) {
        //     const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(id.text, id);
        //     return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type, lexicallyScopedSymbol);
        // }
    }

    // In an assignment expression, the right operand is contextually typed by the type of the left operand.
    // Don't do this for assignment declarations unless there is a type tag on the assignment, to avoid circularity from checking the right operand.
    function getContextualTypeForAssignmentDeclaration(binaryExpression: BinaryExpression): Type | undefined {
        const kind = getAssignmentDeclarationKind(binaryExpression);
        switch (kind) {
            case AssignmentDeclarationKind.None:
            case AssignmentDeclarationKind.ThisProperty:
                // Debug.fail("no this property");
                return unknownType;
                // const lhsSymbol = getSymbolForExpression(binaryExpression.left);
                // const decl = lhsSymbol && lhsSymbol.valueDeclaration;
                // // Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.
                // // We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.
                // if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {
                //     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
                //     return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) ||
                //         (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined);
                // }
                // if (kind === AssignmentDeclarationKind.None) {
                //     return getTypeOfExpression(binaryExpression.left);
                // }
                // return getContextualTypeForThisPropertyAssignment(binaryExpression);
            case AssignmentDeclarationKind.Property:
                if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {
                    return getContextualTypeForThisPropertyAssignment(binaryExpression);
                }
                // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.
                // See `bindStaticPropertyAssignment` in `binder.ts`.
                else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {
                    return getTypeOfExpression(binaryExpression.left);
                }
                else {
                    const decl = binaryExpression.left.symbol.valueDeclaration;
                    if (!decl) {
                        return undefined;
                    }
                    const lhs = cast(binaryExpression.left, isAccessExpression);
                    const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
                    if (overallAnnotation) {
                        return getTypeFromTypeNode(overallAnnotation);
                    }
                    else if (isIdentifier(lhs.expression)) {
                        const id = lhs.expression;
                        const parentSymbol = resolveName(id, id.text, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
                        if (parentSymbol) {
                            const annotated = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);
                            if (annotated) {
                                const nameStr = getElementOrPropertyAccessName(lhs);
                                if (nameStr !== undefined) {
                                    return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr);
                                }
                            }
                            return undefined;
                        }
                    }
                    return isInJSFile(decl) || decl === binaryExpression.left ? undefined : getTypeOfExpression(binaryExpression.left);
                }
            case AssignmentDeclarationKind.ExportsProperty:
            case AssignmentDeclarationKind.Prototype:
            case AssignmentDeclarationKind.PrototypeProperty:
            case AssignmentDeclarationKind.ModuleExports:
                let valueDeclaration: Declaration | undefined;
                if (kind !== AssignmentDeclarationKind.ModuleExports) {
                    valueDeclaration = canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined;
                }
                valueDeclaration ||= binaryExpression.symbol?.valueDeclaration;
                const annotated = valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration);
                return annotated ? getTypeFromTypeNode(annotated) : undefined;
            case AssignmentDeclarationKind.ObjectDefinePropertyValue:
            case AssignmentDeclarationKind.ObjectDefinePropertyExports:
            case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:
                return Debug.fail("Does not apply");
            default:
                return Debug.assertNever(kind);
        }
    }

    function getContextualTypeForThisPropertyAssignment(binaryExpression: BinaryExpression): Type | undefined {
        if (!binaryExpression.symbol) return getTypeOfExpression(binaryExpression.left);
        if (binaryExpression.symbol.valueDeclaration) {
            const annotated = getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration);
            if (annotated) {
                const type = getTypeFromTypeNode(annotated);
                if (type) {
                    return type;
                }
            }
        }
        
        const thisAccess = cast(binaryExpression.left, isAccessExpression);
        if (!isObjectLiteralMethod(getThisContainer(thisAccess.expression, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false))) {
            return undefined;
        }
        const thisType = checkThisExpression(thisAccess.expression);
        const nameStr = getElementOrPropertyAccessName(thisAccess);
        return nameStr !== undefined && getTypeOfPropertyOfContextualType(thisType, nameStr) || undefined;        
    }

    function checkThisExpression(node: Node): Type {
        Debug.fail("todo - checkThisExpression");
    }

    function getContextualTypeForReturnExpression(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const func = getContainingFunction(node);
        if (func) {
            let contextualReturnType = getContextualReturnType(func, contextFlags);
            if (contextualReturnType) {
                const functionFlags = getFunctionFlags(func);
                // if (functionFlags & FunctionFlags.Generator) { // Generator or AsyncGenerator function
                //     const isAsyncGenerator = (functionFlags & FunctionFlags.Async) !== 0;
                //     if (contextualReturnType.flags & TypeFlags.Union) {
                //         contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator));
                //     }
                //     const iterationReturnType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, contextualReturnType, (functionFlags & FunctionFlags.Async) !== 0);
                //     if (!iterationReturnType) {
                //         return undefined;
                //     }
                //     contextualReturnType = iterationReturnType;
                //     // falls through to unwrap Promise for AsyncGenerators
                // }

                // if (functionFlags & FunctionFlags.Async) { // Async function or AsyncGenerator function
                //     // Get the awaited type without the `Awaited<T>` alias
                //     const contextualAwaitedType = mapType(contextualReturnType, getAwaitedTypeNoAlias);
                //     return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
                // }

                return contextualReturnType; // Regular function or Generator function
            }
        }
        return undefined;
    }

    // In a variable, parameter or property declaration with a type annotation,
    //   the contextual type of an initializer expression is the type of the variable, parameter or property.
    // Otherwise, in a parameter declaration of a contextually typed function expression,
    //   the contextual type of an initializer expression is the contextual type of the parameter.
    // Otherwise, in a variable or parameter declaration with a binding pattern name,
    //   the contextual type of an initializer expression is the type implied by the binding pattern.
    // Otherwise, in a binding pattern inside a variable or parameter declaration,
    //   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
    function getContextualTypeForInitializerExpression(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const declaration = node.parent as VariableLikeDeclaration;
        if (hasInitializer(declaration) && node === declaration.initializer) {
            const result = getContextualTypeForVariableLikeDeclaration(declaration, contextFlags);
            if (result) {
                return result;
            }
            if (!(contextFlags! & ContextFlags.SkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0) {
                return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true, /*reportErrors*/ false);
            }
        }
        return undefined;
    }

    // Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
    // and without regard to its context (i.e. without regard any type annotation or initializer associated with the
    // declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
    // and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
    // used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
    // parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
    // the parameter.
    function getTypeFromBindingPattern(pattern: BindingPattern, includePatternInType = false, reportErrors = false): Type {
        // return pattern.kind === SyntaxKind.ObjectBindingPattern
        //     ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
        //     : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
        Debug.assertEqual(pattern.kind, SyntaxKind.ArrayBindingPattern);
        return getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
    }

   
    function hasDefaultValue(node: BindingElement | Expression): boolean {
        return (node.kind === SyntaxKind.BindingElement && !!(node as BindingElement).initializer) ||
            (node.kind === SyntaxKind.BinaryExpression && (node as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken);
    }
    
    // Return the type implied by an array binding pattern
    function getTypeFromArrayBindingPattern(pattern: BindingPattern, includePatternInType: boolean, reportErrors: boolean): Type {
        const elements = pattern.elements;
        const lastElement = lastOrUndefined(elements);
        const restElement = lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined;
        if (elements.length === 0 || elements.length === 1 && restElement) {
            // return languageVersion >= ScriptTarget.ES2015 ? createIterableType(anyType) : anyArrayType;
            return anyArrayType;
        }
        const elementTypes = map(elements, e => isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors));
        const minLength = findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1;
        const elementFlags = map(elements, (e, i) => e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required);
        let result = createTupleType(elementTypes, elementFlags) as TypeReference;
        if (includePatternInType) {
            result = cloneTypeReference(result);
            result.pattern = pattern;
            result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
        }
        return result;
    }

    // Return the type implied by a binding pattern element. This is the type of the initializer of the element if
    // one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
    // pattern. Otherwise, it is the type any.
    function getTypeFromBindingElement(element: BindingElement, includePatternInType?: boolean, reportErrors?: boolean): Type {
        if (element.initializer) {
            // The type implied by a binding pattern is independent of context, so we check the initializer with no
            // contextual type or, if the element itself is a binding pattern, with the type implied by that binding
            // pattern.
            const contextualType = isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType*/ true, /*reportErrors*/ false) : unknownType;
            return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, reportErrors ? CheckMode.Normal : CheckMode.Contextual, contextualType)));
        }
        if (isBindingPattern(element.name)) {
            return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors);
        }
        if (reportErrors) {//} && !declarationBelongsToPrivateAmbientMember(element)) {
            reportImplicitAny(element, anyType);
        }
        // When we're including the pattern in the type (an indication we're obtaining a contextual type), we
        // use a non-inferrable any type. Inference will never directly infer this type, but it is possible
        // to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
        // widening of the binding pattern type substitutes a regular any for the non-inferrable any.
        return includePatternInType ? nonInferrableAnyType : anyType;
    }

    function getContextualTypeForVariableLikeDeclaration(declaration: VariableLikeDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        // let's see how closely Diavolo is watching my PRs
        const typeNode = getEffectiveTypeAnnotationNode(declaration, currentFile) || (isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
        switch (declaration.kind) {
            case SyntaxKind.Parameter:
                return getContextuallyTypedParameterType(declaration);
            case SyntaxKind.BindingElement:
                return getContextualTypeForBindingElement(declaration, contextFlags);
            case SyntaxKind.PropertyDeclaration:
                // if (isStatic(declaration)) {
                //     return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags);
                // }
                // By default, do nothing and return undefined - only the above cases have context implied by a parent
        }
    }
    
    function getContextualTypeForBindingElement(declaration: BindingElement, contextFlags: ContextFlags | undefined): Type | undefined {
        const parent = declaration.parent.parent;
        const name = declaration.propertyName || declaration.name;
        const parentType = getContextualTypeForVariableLikeDeclaration(parent, contextFlags) ||
            parent.kind !== SyntaxKind.BindingElement && parent.initializer && checkDeclarationInitializer(parent, declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal);
        if (!parentType || isBindingPattern(name) || isComputedNonLiteralName(name)) return undefined;
        if (parent.name.kind === SyntaxKind.ArrayBindingPattern) {
            const index = indexOfNode(declaration.parent.elements, declaration);
            if (index < 0) return undefined;
            return getContextualTypeForElementExpression(parentType, index);
        }
        const nameType = getLiteralTypeFromPropertyName(name);
        if (isTypeUsableAsPropertyName(nameType)) {
            const text = getPropertyNameFromType(nameType);
            return getTypeOfPropertyOfType(parentType, text);
        }
    }
    
    // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
    function getContextualTypeForConditionalOperand(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const conditional = node.parent as ConditionalExpression;
        return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined;
    }

    function getContextualTypeForElementExpression(type: Type | undefined, index: number, length?: number, firstSpreadIndex?: number, lastSpreadIndex?: number): Type | undefined {
        return type && mapType(type, t => {            
            // If element index is known and a contextual property with that name exists, return it. Otherwise return the
            // iterated or element type of the contextual type.
            return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t, "" + index as string) ||
                getIteratedTypeOrElementType(IterationUse.Element, t, undefinedType, /*errorNode*/ undefined, /*checkAssignability*/ false);
        }, /*noReductions*/ true);
    }

    function getTypeOfPropertyOfContextualType(type: Type, name: string, nameType?: Type) {
        return mapType(type, t => {            
            if (t.flags & TypeFlags.StructuredType) {
                const prop = getPropertyOfType(t, name);
                if (prop) {
                    return isCircularMappedProperty(prop) ? undefined : removeMissingType(getTypeOfSymbol(prop), !!(prop.flags & SymbolFlags.Optional));
                }                
                return findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType || getStringLiteralType((name)))?.type;
            }
            return undefined;
        }, /*noReductions*/ true);
    }

    function isCircularMappedProperty(symbol: Symbol) {
        return !!(getCheckFlags(symbol) & CheckFlags.Mapped && !(symbol as MappedSymbol).links.type && findResolutionCycleStartIndex(symbol, TypeSystemPropertyName.Type) >= 0);
    }

    function getSpreadIndices(elements: readonly Node[]) {
        let first, last;        
        for (let i = 0; i < elements.length; i++) {
            if (isSpreadElement(elements[i])) {
                first ??= i;
                last = i;
            }
        }
        return { first, last };
    }

    function getInferenceContext(node: Node) {
        for (let i = inferenceContextCount - 1; i >= 0; i--) {
            if (isNodeDescendantOf(node, inferenceContextNodes[i])) {
                return inferenceContexts[i];
            }
        }
    }

    // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
    function getContextualTypeForArgument(callTarget: CallLikeExpression, arg: Expression): Type | undefined {
        const args = getEffectiveCallArguments(callTarget);
        const argIndex = args.indexOf(arg); // -1 for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
        return argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex);
    }

    function getContextualTypeForArgumentAtIndex(callTarget: CallLikeExpression, argIndex: number): Type {       
        // If we're already in the process of resolving the given signature, don't resolve again as
        // that could cause infinite recursion. Instead, return anySignature.
        const signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);
        
        const restIndex = signature.parameters.length - 1;
        return signatureHasRestParameter(signature) && argIndex >= restIndex ?
            getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), AccessFlags.Contextual) :
            getTypeAtPosition(signature, argIndex);
    }

    function getIndexedAccessType(objectType: Type, indexType: Type, accessFlags = AccessFlags.None, accessNode?: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {        
        return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
    }

    function isStringIndexSignatureOnlyType(type: Type): boolean {
        return type.flags & TypeFlags.Object && !isGenericMappedType(type) && getPropertiesOfType(type).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, stringType) ||
            type.flags & TypeFlags.UnionOrIntersection && every((type as UnionOrIntersectionType).types, isStringIndexSignatureOnlyType) ||
            false;
    }

    function getIndexedAccessTypeOrUndefined(objectType: Type, indexType: Type, accessFlags = AccessFlags.None, accessNode?: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type | undefined {
        if (objectType === wildcardType || indexType === wildcardType) {
            return wildcardType;
        }
        objectType = getReducedType(objectType);
        // If the object type has a string index signature and no other members we know that the result will
        // always be the type of that index signature and we can simplify accordingly.
        if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number)) {
            indexType = stringType;
        }
        // In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
        // an index signature have 'undefined' included in their type.
        if (compilerOptions.noUncheckedIndexedAccess && accessFlags & AccessFlags.ExpressionPosition) accessFlags |= AccessFlags.IncludeUndefined;
        
        // In the following we resolve T[K] to the type of the property in T selected by K.
        // We treat boolean as different from other unions to improve errors;
        // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
        const apparentObjectType = getReducedApparentType(objectType);
        if (indexType.flags & TypeFlags.Union && !(indexType.flags & TypeFlags.Boolean)) {
            const propTypes: Type[] = [];
            let wasMissingProp = false;
            for (const t of (indexType as UnionType).types) {
                const propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0));
                if (propType) {
                    propTypes.push(propType);
                }
                else if (!accessNode) {
                    // If there's no error node, we can immeditely stop, since error reporting is off
                    return undefined;
                }
                else {
                    // Otherwise we set a flag and return at the end of the loop so we still mark all errors
                    wasMissingProp = true;
                }
            }
            if (wasMissingProp) {
                return undefined;
            }
            return accessFlags & AccessFlags.Writing
                ? getIntersectionType(propTypes, IntersectionFlags.None, aliasSymbol, aliasTypeArguments)
                : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
        }
        return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | AccessFlags.CacheSymbol | AccessFlags.ReportDeprecated);
    }

    function getPropertyNameFromIndex(indexType: Type, accessNode: PropertyName | /*ObjectBindingPattern |*/ ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined) {
        return isTypeUsableAsPropertyName(indexType) ?
            getPropertyNameFromType(indexType) :
            accessNode && isPropertyName(accessNode) ?
            // late bound names are handled in the first branch, so here we only need to handle normal names
            getPropertyNameForPropertyNameNode(accessNode) :
            undefined;
    }

    function getIndexNodeForAccessExpression(accessNode: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression) {
        return accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression :
            accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType :
            accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression :
            accessNode;
    }

    /**
     * Returns if a type is or consists of a JSLiteral object type
     * In addition to objects which are directly literals,
     * * unions where every element is a jsliteral
     * * intersections where at least one element is a jsliteral
     * * and instantiable types constrained to a jsliteral
     * Should all count as literals and not print errors on access or assignment of possibly existing properties.
     * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
     */
    function isJSLiteralType(type: Type): boolean {
        if (noImplicitAny) {
            return false; // Flag is meaningless under `noImplicitAny` mode
        }
        if (getObjectFlags(type) & ObjectFlags.JSLiteral) {
            return true;
        }
        if (type.flags & TypeFlags.Union) {
            return every((type as UnionType).types, isJSLiteralType);
        }
        if (type.flags & TypeFlags.Intersection) {
            return some((type as IntersectionType).types, isJSLiteralType);
        }
        if (type.flags & TypeFlags.Instantiable) {
            const constraint = getResolvedBaseConstraint(type);
            return constraint !== type && isJSLiteralType(constraint);
        }
        return false;
    }

    function isAssignmentToReadonlyEntity(expr: Expression, symbol: Symbol, assignmentKind: AssignmentKind) {
        if (assignmentKind === AssignmentKind.None) {
            // no assigment means it doesn't matter whether the entity is readonly
            return false;
        }
        if (isReadonlySymbol(symbol)) {
            // Allow assignments to readonly properties within constructors of the same class declaration.
            // if (
            //     symbol.flags & SymbolFlags.Property &&
            //     isAccessExpression(expr) &&
            //     expr.expression.kind === SyntaxKind.ThisKeyword
            // ) {
            //     // Look for if this is the constructor for the class that `symbol` is a property of.
            //     const ctor = getContainingFunction(expr);
            //     if (!(ctor && (ctor.kind === SyntaxKind.Constructor || isJSConstructor(ctor)))) {
            //         return true;
            //     }
            //     if (symbol.valueDeclaration) {
            //         const isAssignmentDeclaration = isBinaryExpression(symbol.valueDeclaration);
            //         const isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
            //         const isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
            //         const isLocalThisPropertyAssignment = isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor.parent;
            //         const isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor;
            //         const isWriteableSymbol = isLocalPropertyDeclaration
            //             || isLocalParameterProperty
            //             || isLocalThisPropertyAssignment
            //             || isLocalThisPropertyAssignmentConstructorFunction;
            //         return !isWriteableSymbol;
            //     }
            // }
            return true;
        }
        if (isAccessExpression(expr)) {
            // references through namespace import should be readonly
            const node = skipParentheses(expr.expression);
            if (node.kind === SyntaxKind.Identifier) {
                Debug.fail("todo - isAssignmentToReadonlyEntity");
                // const symbol = getNodeLinks(node).resolvedSymbol!;
                // if (symbol.flags & SymbolFlags.Alias) {
                //     const declaration = getDeclarationOfAliasSymbol(symbol);
                //     return !!declaration && declaration.kind === SyntaxKind.NamespaceImport;
                // }
            }
        }
        return false;
    }
    
    function getPropertyTypeForIndexType(originalObjectType: Type, objectType: Type, indexType: Type, fullIndexType: Type, accessNode: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined, accessFlags: AccessFlags) {
        const accessExpression = accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined;
        const propName = accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);

        if (propName !== undefined) {
            if (accessFlags & AccessFlags.Contextual) {                
                return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
            }
            const prop = getPropertyOfType(objectType, propName);
            if (prop) {
                if (accessFlags & AccessFlags.ReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop)) {
                    const deprecatedNode = accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                    addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName as string);
                }
                if (accessExpression) {
                    markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                    if (isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression))) {
                        error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                        return undefined;
                    }
                    if (accessFlags & AccessFlags.CacheSymbol) {
                        getNodeLinks(accessNode!).resolvedSymbol = prop;
                    }
                    // if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                    //     return autoType;
                    // }
                }
                const propType = accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop);
                return accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) :
                    accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) :
                    propType;
            }
            if (everyType(objectType, isTupleType) && isNumericLiteralName(propName)) {
                const index = +propName;
                if (accessNode && everyType(objectType, t => !(t as TupleTypeReference).target.hasRestElement) && !(accessFlags & AccessFlags.NoTupleBoundsCheck)) {
                    const indexNode = getIndexNodeForAccessExpression(accessNode);
                    if (isTupleType(objectType)) {
                        if (index < 0) {
                            error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value);
                            return undefinedType;
                        }
                        error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), (propName));
                    }
                    else {
                        error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, (propName), typeToString(objectType));
                    }
                }
                if (index >= 0) {
                    errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                    return getTupleElementTypeOutOfStartCount(objectType, index, accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined);
                }
            }
        }
        if (!(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.StringLike | TypeFlags.NumberLike)) {
            if (objectType.flags & (TypeFlags.Any | TypeFlags.Never)) {
                return objectType;
            }
            // If no index signature is applicable, we default to the string index signature. In effect, this means the string
            // index signature applies even when accessing with a symbol-like type.
            const indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
            if (indexInfo) {
                if (accessFlags & AccessFlags.NoIndexSignatures && indexInfo.keyType !== numberType) {
                    if (accessExpression) {
                        if (accessFlags & AccessFlags.Writing) {
                            error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType));
                        }
                        else {
                            error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                        }
                    }
                    return undefined;
                }
                if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number)) {
                    const indexNode = getIndexNodeForAccessExpression(accessNode);
                    error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                    return accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, missingType]) : indexInfo.type;
                }
                errorIfWritingToReadonlyIndex(indexInfo);
                // When accessing an enum object with its own type,
                // e.g. E[E.A] for enum E { A }, undefined shouldn't
                // be included in the result type
                if (
                    (accessFlags & AccessFlags.IncludeUndefined) &&
                    !(objectType.symbol &&
                        objectType.symbol.flags & (SymbolFlags.RegularEnum | SymbolFlags.ConstEnum) &&
                        (indexType.symbol &&
                            indexType.flags & TypeFlags.EnumLiteral &&
                            getParentOfSymbol(indexType.symbol) === objectType.symbol))
                ) {
                    return getUnionType([indexInfo.type, missingType]);
                }
                return indexInfo.type;
            }
            if (indexType.flags & TypeFlags.Never) {
                return neverType;
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessExpression) {
                if (isObjectLiteralType(objectType)) {
                    if (noImplicitAny && indexType.flags & (TypeFlags.StringLiteral | TypeFlags.IntLiteral)) {
                        diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType)));
                        return undefinedType;
                    }
                    else if (indexType.flags & (TypeFlags.Number | TypeFlags.String)) {
                        const types = map((objectType as ResolvedType).properties, property => {
                            return getTypeOfSymbol(property);
                        });
                        return getUnionType(append(types, undefinedType));
                    }
                }

                if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports!.has(propName) && (globalThisSymbol.exports!.get(propName)!.flags & SymbolFlags.BlockScoped)) {
                    error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (propName), typeToString(objectType));
                }
                else if (noImplicitAny && !(accessFlags & AccessFlags.SuppressNoImplicitAnyError)) {
                    // if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                    //     const typeName = typeToString(objectType);
                    //     error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName as string, typeName, typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]");
                    // }
                    if (getIndexTypeOfType(objectType, numberType)) {
                        error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                    }
                    else {
                        let suggestion: string | undefined;
                        if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName as string, objectType))) {
                            if (suggestion !== undefined) {
                                error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName as string, typeToString(objectType), suggestion);
                            }
                        }
                        else {
                            const suggestion = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                            if (suggestion !== undefined) {
                                error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion);
                            }
                            else {
                                let errorInfo: DiagnosticMessageChain | undefined;
                                if (indexType.flags & TypeFlags.EnumLiteral) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                }                                
                                else if (indexType.flags & TypeFlags.StringLiteral) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType));
                                }
                                else if (indexType.flags & TypeFlags.IntLiteral) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as IntLiteralType).value, typeToString(objectType));
                                }
                                else if (indexType.flags & (TypeFlags.Number | TypeFlags.String)) {
                                    errorInfo = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                }

                                errorInfo = chainDiagnosticMessages(
                                    errorInfo,
                                    Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1,
                                    typeToString(fullIndexType),
                                    typeToString(objectType),
                                );
                                diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo));
                            }
                        }
                    }
                }
                return undefined;
            }
        }
        if (isJSLiteralType(objectType)) {
            return anyType;
        }
        if (accessNode) {
            const indexNode = getIndexNodeForAccessExpression(accessNode);
            if (indexType.flags & (TypeFlags.StringLiteral | TypeFlags.IntLiteral)) {
                error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, "" + (indexType as StringLiteralType | IntLiteralType).value, typeToString(objectType));
            }
            else if (indexType.flags & (TypeFlags.String | TypeFlags.Number)) {
                error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
            }            
            else if (!isMappingType(originalObjectType)) {
                // mapping type can accept pretty much anything as the index type
                error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
            }
        }
        if (isTypeAny(indexType)) {
            return indexType;
        }
        return undefined;

        function errorIfWritingToReadonlyIndex(indexInfo: IndexInfo | undefined): void {
            if (indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression))) {
                error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
        }
    }
    
    function getSuggestionForNonexistentIndexSignature(objectType: Type, expr: ElementAccessExpression, keyedType: Type): string | undefined {
        // check if object type has setter or getter
        function hasProp(name: "set" | "get") {
            const prop = getPropertyOfObjectType(objectType, name as string);
            if (prop) {
                const s = getSingleCallSignature(getTypeOfSymbol(prop));
                return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0));
            }
            return false;
        }

        const suggestedMethod = isAssignmentTarget(expr) ? "set" : "get";
        if (!hasProp(suggestedMethod)) {
            return undefined;
        }

        let suggestion = tryGetPropertyAccessOrIdentifierToString(expr.expression);
        if (suggestion === undefined) {
            suggestion = suggestedMethod;
        }
        else {
            suggestion += "." + suggestedMethod;
        }

        return suggestion;
    }

    function instantiateType(type: Type, mapper: TypeMapper | undefined): Type;
    function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined;
    function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined {
        return type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined) : type;
    }

    function isNonGenericTopLevelType(type: Type) {
        if (type.aliasSymbol && !type.aliasTypeArguments) {
            const declaration = getDeclarationOfKind(type.aliasSymbol, SyntaxKind.TypeAliasDeclaration);
            return !!(declaration && findAncestor(declaration.parent, n => n.kind === SyntaxKind.SourceFile ? true : "quit"));
        }
        return false;
    }

    // Return true if the given type could possibly reference a type parameter for which
    // we perform type inference (i.e. a type parameter of a generic function). We cache
    // results for union and intersection types for performance reasons.
    function couldContainTypeVariables(type: Type): boolean {
        const objectFlags = getObjectFlags(type);
        if (objectFlags & ObjectFlags.CouldContainTypeVariablesComputed) {
            return !!(objectFlags & ObjectFlags.CouldContainTypeVariables);
        }
        const result = !!(type.flags & TypeFlags.Instantiable ||
            type.flags & TypeFlags.Object && !isNonGenericTopLevelType(type) && (
                    objectFlags & ObjectFlags.Reference && ((type as TypeReference).node || some(getTypeArguments(type as TypeReference), couldContainTypeVariables)) ||
                    objectFlags & ObjectFlags.SingleSignatureType && !!length((type as SingleSignatureType).outerTypeParameters) ||
                    objectFlags & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) && type.symbol.declarations ||
                    objectFlags & (ObjectFlags.Mapped | ObjectFlags.ReverseMapped | ObjectFlags.ObjectRestType | ObjectFlags.InstantiationExpressionType)
                ) ||
            type.flags & TypeFlags.UnionOrIntersection && !(type.flags & TypeFlags.EnumLiteral) && !isNonGenericTopLevelType(type) && some((type as UnionOrIntersectionType).types, couldContainTypeVariables));
        if (type.flags & TypeFlags.ObjectFlagsType) {
            (type as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (result ? ObjectFlags.CouldContainTypeVariables : 0);
        }
        return result;
    }

    function instantiateTypeWithAlias(type: Type, mapper: TypeMapper, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined): Type {
        if (!couldContainTypeVariables(type)) {
            return type;
        }
        if (instantiationDepth === 100 || instantiationCount >= 5000000) {
            // We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
            // or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
            // that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
            tracing?.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", { typeId: type.id, instantiationDepth, instantiationCount });
            error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
            return errorType;
        }
        totalInstantiationCount++;
        instantiationCount++;
        instantiationDepth++;
        const result = instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments);
        instantiationDepth--;
        return result;
    }

    function instantiateTypes(types: readonly Type[], mapper: TypeMapper): readonly Type[];
    function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined;
    function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined {
        return instantiateList<Type>(types, mapper, instantiateType);
    }

    function instantiateList<T>(items: readonly T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[];
    function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined;
    function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined {
        if (items && items.length) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const mapped = instantiator(item, mapper);
                if (item !== mapped) {
                    const result = i === 0 ? [] : items.slice(0, i);
                    result.push(mapped);
                    for (i++; i < items.length; i++) {
                        result.push(instantiator(items[i], mapper));
                    }
                    return result;
                }
            }
        }
        return items;
    }

    function createNormalizedTypeReference(target: GenericType, typeArguments: readonly Type[] | undefined) {
        return target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(target as TupleType, typeArguments!) : createTypeReference(target, typeArguments);
    }

    function createTypeReference(target: GenericType, typeArguments: readonly Type[] | undefined): TypeReference {
        const id = getTypeListId(typeArguments);        
        // Debug.assertIsDefined(target?.instantiations)
        let type = target?.instantiations?.get(id);
        if (target && !type) {
            type = createObjectType(ObjectFlags.Reference, target.symbol) as TypeReference;
            target.instantiations?.set(id, type);
            type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0;
            type.target = target;
            type.resolvedTypeArguments = typeArguments;
        }
        return type;
    }

    function instantiateReverseMappedType(type: ReverseMappedType, mapper: TypeMapper) {
        const innerMappedType = instantiateType(type.mappedType, mapper);
        if (!(getObjectFlags(innerMappedType) & ObjectFlags.Mapped)) {
            return type;
        }
        const innerIndexType = instantiateType(type.constraintType, mapper);
        if (!(innerIndexType.flags & TypeFlags.Index)) {
            return type;
        }
        const instantiated = inferTypeForHomomorphicMappedType(
            instantiateType(type.source, mapper),
            innerMappedType as MappedType,
            innerIndexType as IndexType,
        );
        if (instantiated) {
            return instantiated;
        }
        return type; // Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
    }

    // We consider a type to be partially inferable if it isn't marked non-inferable or if it is
    // an object literal type with at least one property of an inferable type. For example, an object
    // literal { a: 123, b: x => true } is marked non-inferable because it contains a context sensitive
    // arrow function, but is considered partially inferable because property 'a' has an inferable type.
    function isPartiallyInferableType(type: Type): boolean {
        return !(getObjectFlags(type) & ObjectFlags.NonInferrableType) ||
            isObjectLiteralType(type) && some(getPropertiesOfType(type), prop => isPartiallyInferableType(getTypeOfSymbol(prop))) ||
            isTupleType(type) && some(getElementTypes(type), isPartiallyInferableType);
    }
    
    function getTemplateTypeFromMappedType(type: MappedType) {
        return type.templateType ||
            (type.templateType = type.declaration.type ?
                instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty*/ true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :
                errorType);
    }
    
    function inferReverseMappedTypeWorker(sourceType: Type, target: MappedType, constraint: IndexType): Type {
        const typeParameter = getIndexedAccessType(constraint.type, getTypeParameterFromMappedType(target)) as TypeParameter;
        const templateType = getTemplateTypeFromMappedType(target);
        const inference = createInferenceInfo(typeParameter);
        inferTypes([inference], sourceType, templateType);
        return getTypeFromInference(inference) || unknownType;
    }

    function inferReverseMappedType(source: Type, target: MappedType, constraint: IndexType): Type | undefined {
        const cacheKey = source.id + "," + target.id + "," + constraint.id;
        if (reverseMappedCache.has(cacheKey)) {
            return reverseMappedCache.get(cacheKey) || unknownType;
        }
        reverseMappedSourceStack.push(source);
        reverseMappedTargetStack.push(target);
        const saveExpandingFlags = reverseExpandingFlags;
        if (isDeeplyNestedType(source, reverseMappedSourceStack, reverseMappedSourceStack.length, 2)) reverseExpandingFlags |= ExpandingFlags.Source;
        if (isDeeplyNestedType(target, reverseMappedTargetStack, reverseMappedTargetStack.length, 2)) reverseExpandingFlags |= ExpandingFlags.Target;
        let type;
        if (reverseExpandingFlags !== ExpandingFlags.Both) {
            type = inferReverseMappedTypeWorker(source, target, constraint);
        }
        reverseMappedSourceStack.pop();
        reverseMappedTargetStack.pop();
        reverseExpandingFlags = saveExpandingFlags;
        reverseMappedCache.set(cacheKey, type);
        return type;
    }
    
    function createReverseMappedType(source: Type, target: MappedType, constraint: IndexType) {
        // We consider a source type reverse mappable if it has a string index signature or if
        // it has one or more properties and is of a partially inferable type.
        if (!(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(source))) {
            return undefined;
        }
        // For arrays and tuples we infer new arrays and tuples where the reverse mapping has been
        // applied to the element type(s).
        if (isArrayType(source)) {
            const elementType = inferReverseMappedType(getTypeArguments(source)[0], target, constraint);
            if (!elementType) {
                return undefined;
            }
            return createArrayType(elementType, isReadonlyArrayType(source));
        }
        if (isTupleType(source)) {
            const elementTypes = map(getElementTypes(source), t => inferReverseMappedType(t, target, constraint));
            if (!every(elementTypes, (t): t is Type => !!t)) {
                return undefined;
            }
            const elementFlags = getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ?
                sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :
                source.target.elementFlags;
            return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations);
        }
        // For all other object types we infer a new object type where the reverse mapping has been
        // applied to the type of each property.
        const reversed = createObjectType(ObjectFlags.ReverseMapped | ObjectFlags.Anonymous, /*symbol*/ undefined) as ReverseMappedType;
        reversed.source = source;
        reversed.mappedType = target;
        reversed.constraintType = constraint;
        return reversed;
    }

    /**
     * Infer a suitable input type for a homomorphic mapped type { [P in keyof T]: X }. We construct
     * an object type with the same set of properties as the source type, where the type of each
     * property is computed by inferring from the source property type to X for the type
     * variable T[P] (i.e. we treat the type T[P] as the type variable we're inferring for).
     */
    function inferTypeForHomomorphicMappedType(source: Type, target: MappedType, constraint: IndexType): Type | undefined {
        const cacheKey = source.id + "," + target.id + "," + constraint.id;
        if (reverseHomomorphicMappedCache.has(cacheKey)) {
            return reverseHomomorphicMappedCache.get(cacheKey);
        }
        const type = createReverseMappedType(source, target, constraint);
        reverseHomomorphicMappedCache.set(cacheKey, type);
        return type;
    }

    /**
     * Indicates whether a declaration can be treated as a constructor in a JavaScript
     * file.
     */
    function isJSConstructor(node: Node | undefined): node is FunctionDeclaration | FunctionExpression {
        if (!node || !isInJSFile(node)) {
            return false;
        }
        const func = isFunctionDeclaration(node) || isFunctionExpression(node) ? node :
            (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer :
            undefined;
        if (func) {
            // If the node has a @class or @constructor tag, treat it like a constructor.
            if (getJSDocClassTag(node)) return true;

            // If the node is a property of an object literal.
            if (isPropertyAssignment(walkUpParenthesizedExpressions(func.parent))) return false;

            // If the symbol of the node has members, treat it like a constructor.
            const symbol = getSymbolOfDeclaration(func);
            return !!symbol?.members?.size;
        }
        return false;
    }

    // Return the outer type parameters of a node or undefined if the node has no outer type parameters.
    function getOuterTypeParameters(node: Node, includeThisTypes?: boolean): TypeParameter[] | undefined {
        while (true) {
            node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead
            if (node && isBinaryExpression(node)) {
                // prototype assignments get the outer type parameters of their constructor function
                const assignmentKind = getAssignmentDeclarationKind(node);
                // if (assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty) {
                //     const symbol = getSymbolOfDeclaration(node.left as BindableStaticNameExpression | PropertyAssignment);
                //     if (symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d)) {
                //         node = symbol.parent.valueDeclaration!;
                //     }
                // }
            }
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case SyntaxKind.ClassExpression:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.CallSignature:
                // case SyntaxKind.ConstructSignature:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.FunctionType:
                // case SyntaxKind.ConstructorType:
                case SyntaxKind.JSDocFunctionType:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.InlineClosureExpression:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.JSDocTemplateTag:
                case SyntaxKind.JSDocTypedefTag:
                case SyntaxKind.JSDocEnumTag:
                case SyntaxKind.JSDocCallbackTag:
                case SyntaxKind.MappedType:
                case SyntaxKind.ConditionalType: {
                    const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                    if (node.kind === SyntaxKind.MappedType) {
                        return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node as MappedTypeNode).typeParameter)));
                    }
                    else if (node.kind === SyntaxKind.ConditionalType) {
                        return concatenate(outerTypeParameters, getInferTypeParameters(node as ConditionalTypeNode));
                    }
                    const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node as DeclarationWithTypeParameters));
                    const thisType = includeThisTypes &&
                        (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression || node.kind === SyntaxKind.InterfaceDeclaration || isJSConstructor(node)) &&
                        getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node as ClassLikeDeclaration | InterfaceDeclaration)).thisType;
                    return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
                }
                case SyntaxKind.JSDocParameterTag:
                    const paramSymbol = getParameterSymbolFromJSDoc(node as JSDocParameterTag);
                    if (paramSymbol) {
                        node = paramSymbol.valueDeclaration!;
                    }
                    break;
                case SyntaxKind.JSDoc: {
                    const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                    return (node as JSDoc).tags
                        ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))
                        : outerTypeParameters;
                }
            }
        }
    }

    function getParentSymbolOfTypeParameter(typeParameter: TypeParameter): Symbol | undefined {
        const tp = getDeclarationOfKind<TypeParameterDeclaration>(typeParameter.symbol, SyntaxKind.TypeParameter)!;
        const host = isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent;
        return host && getSymbolOfNode(host);
    }
    
    // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
    // The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
    // in-place and returns the same array.
    function appendTypeParameters(typeParameters: TypeParameter[] | undefined, declarations: readonly TypeParameterDeclaration[]): TypeParameter[] | undefined {
        for (const declaration of declarations) {
            typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)));
        }
        return typeParameters;
    }
    
    function getDeclaredTypeOfTypeParameter(symbol: Symbol): TypeParameter {
        const links = getSymbolLinks(symbol);
        return links.declaredType || (links.declaredType = createTypeParameter(symbol));
    }

    function createTypeParameter(symbol?: Symbol) {
        return createTypeWithSymbol(TypeFlags.TypeParameter, symbol!) as TypeParameter;
    }

    function getMappedType(type: Type, mapper: TypeMapper): Type {
        switch (mapper.kind) {
            case TypeMapKind.Simple:
                return type === mapper.source ? mapper.target : type;
            case TypeMapKind.Array: {
                const sources = mapper.sources;
                const targets = mapper.targets;
                for (let i = 0; i < sources.length; i++) {
                    if (type === sources[i]) {
                        return targets ? targets[i] : anyType;
                    }
                }
                return type;
            }
            case TypeMapKind.Deferred: {
                const sources = mapper.sources;
                const targets = mapper.targets;
                for (let i = 0; i < sources.length; i++) {
                    if (type === sources[i]) {
                        return targets[i]();
                    }
                }
                return type;
            }
            case TypeMapKind.Function:
                return mapper.func(type);
            case TypeMapKind.Composite:
            case TypeMapKind.Merged:
                const t1 = getMappedType(type, mapper.mapper1);
                return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
        }
    }

    function cloneTypeParameter(typeParameter: TypeParameter): TypeParameter {
        const result = createTypeParameter(typeParameter.symbol);
        result.target = typeParameter;
        return result;
    }

    function makeUnaryTypeMapper(source: Type, target: Type): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Simple, source, target });
    }

    function getTypeParameterFromMappedType(type: MappedType) {
        return type.typeParameter ||
            (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)));
    }

    function instantiateAnonymousType(type: AnonymousType, mapper: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): AnonymousType {
        Debug.assert(type.symbol, "anonymous type must have symbol to be instantiated");
        const result = createObjectType(type.objectFlags & ~(ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.CouldContainTypeVariables) | ObjectFlags.Instantiated, type.symbol) as AnonymousType;
        if (type.objectFlags & ObjectFlags.Mapped) {
            (result as MappedType).declaration = (type as MappedType).declaration;
            // C.f. instantiateSignature
            const origTypeParameter = getTypeParameterFromMappedType(type as MappedType);
            const freshTypeParameter = cloneTypeParameter(origTypeParameter);
            (result as MappedType).typeParameter = freshTypeParameter;
            mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
            freshTypeParameter.mapper = mapper;
        }
        if (type.objectFlags & ObjectFlags.InstantiationExpressionType) {
            (result as InstantiationExpressionType).node = (type as InstantiationExpressionType).node;
        }
        if (type.objectFlags & ObjectFlags.SingleSignatureType) {
            (result as SingleSignatureType).outerTypeParameters = (type as SingleSignatureType).outerTypeParameters;
        }
        result.target = type;
        result.mapper = mapper;
        result.aliasSymbol = aliasSymbol || type.aliasSymbol;
        result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
        result.objectFlags |= result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0;
        return result;
    }
    
    function makeArrayTypeMapper(sources: readonly TypeParameter[], targets: readonly Type[] | undefined): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Array, sources, targets });
    }

    function createTypeMapper(sources: readonly TypeParameter[], targets: readonly Type[] | undefined): TypeMapper {
        return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
    }

    function getAliasSymbolForTypeNode(node: Node) {
        let host = node.parent;
        while (isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) /*|| isTypeOperatorNode(host) && host.operator === SyntaxKind.ReadonlyKeyword*/) {
            host = host.parent;
        }
        return isTypeAlias(host) ? getSymbolOfDeclaration(host) : undefined;
    }

    function getTypeArgumentsForAliasSymbol(symbol: Symbol | undefined) {
        return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined;
    }

    function createDeferredTypeReference(target: GenericType, node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode, mapper?: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): DeferredTypeReference {
        if (!aliasSymbol) {
            aliasSymbol = getAliasSymbolForTypeNode(node);
            const localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
            aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
        }
        const type = createObjectType(ObjectFlags.Reference, target.symbol) as DeferredTypeReference;
        type.target = target;
        type.node = node;
        type.mapper = mapper;
        type.aliasSymbol = aliasSymbol;
        type.aliasTypeArguments = aliasTypeArguments;
        return type;
    }

    function instantiateMappedType(type: MappedType, mapper: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        // For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
        // operation depends on T as follows:
        // * If T is a primitive type no mapping is performed and the result is simply T.
        // * If T is a union type we distribute the mapped type over the union.
        // * If T is an array we map to an array where the element type has been transformed.
        // * If T is a tuple we map to a tuple where the element types have been transformed.
        // * If T is an intersection of array or tuple types we map to an intersection of transformed array or tuple types.
        // * Otherwise we map to an object type where the type of each property has been transformed.
        // For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
        // { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
        // { [P in keyof A]: X } | undefined.
        const typeVariable = getHomomorphicTypeVariable(type);
        if (typeVariable) {
            const mappedTypeVariable = instantiateType(typeVariable, mapper);
            if (typeVariable !== mappedTypeVariable) {
                return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments);
            }
        }
        // If the constraint type of the instantiation is the wildcard type, return the wildcard type.
        return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments);

        function instantiateConstituent(t: Type): Type {
            if (t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object | TypeFlags.Intersection) && t !== wildcardType && !isErrorType(t)) {
                if (!type.declaration.nameType) {
                    let constraint;
                    if (
                        isArrayType(t) || t.flags & TypeFlags.Any && findResolutionCycleStartIndex(typeVariable!, TypeSystemPropertyName.ImmediateBaseConstraint) < 0 &&
                            (constraint = getConstraintOfTypeParameter(typeVariable!)) && everyType(constraint, isArrayOrTupleType)
                    ) {
                        return instantiateMappedArrayType(t, type, prependTypeMapping(typeVariable!, t, mapper));
                    }
                    if (isTupleType(t)) {
                        return instantiateMappedTupleType(t, type, typeVariable!, mapper);
                    }
                    if (isArrayOrTupleOrIntersection(t)) {
                        return getIntersectionType(map((t as IntersectionType).types, instantiateConstituent));
                    }
                }
                return instantiateAnonymousType(type, prependTypeMapping(typeVariable!, t, mapper));
            }
            return t;
        }
    }

    function instantiateMappedTypeTemplate(type: MappedType, key: Type, isOptional: boolean, mapper: TypeMapper) {
        const templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
        const propType = instantiateType(getTemplateTypeFromMappedType(type.target as MappedType || type), templateMapper);
        const modifiers = getMappedTypeModifiers(type);
        return strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty*/ true) :
            strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional ? getTypeWithFacts(propType, TypeFacts.NEUndefined) :
            propType;
    }

    function getModifiedReadonlyState(state: boolean, modifiers: MappedTypeModifiers) {
        return modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state;
    }
    
    function instantiateMappedArrayType(arrayType: Type, mappedType: MappedType, mapper: TypeMapper) {
        const elementType = instantiateMappedTypeTemplate(mappedType, numberType, /*isOptional*/ true, mapper);
        return isErrorType(elementType) ? errorType :
            createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
    }

    function instantiateMappedTupleType(tupleType: TupleTypeReference, mappedType: MappedType, typeVariable: TypeVariable, mapper: TypeMapper) {
        // We apply the mapped type's template type to each of the fixed part elements. For variadic elements, we
        // apply the mapped type itself to the variadic element type. For other elements in the variable part of the
        // tuple, we surround the element type with an array type and apply the mapped type to that. This ensures
        // that we get sequential property key types for the fixed part of the tuple, and property key type number
        // for the remaining elements. For example
        //
        //   type Keys<T> = { [K in keyof T]: K };
        //   type Foo<T extends any[]> = Keys<[string, string, ...T, string]>; // ["0", "1", ...Keys<T>, number]
        //
        const elementFlags = tupleType.target.elementFlags;
        const fixedLength = tupleType.target.fixedLength;
        const fixedMapper = fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper;
        const newElementTypes = map(getElementTypes(tupleType), (type, i) => {
            const flags = elementFlags[i];
            return i < fixedLength ? instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(flags & ElementFlags.Optional), fixedMapper) :
                flags & ElementFlags.Variadic ? instantiateType(mappedType, prependTypeMapping(typeVariable, type, mapper)) :
                getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType;
        });
        const modifiers = getMappedTypeModifiers(mappedType);
        const newElementFlags = modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) :
            modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :
            elementFlags;
        const newReadonly = getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType));
        return contains(newElementTypes, errorType) ? errorType :
            createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations);
    }

    function getObjectTypeInstantiation(type: AnonymousType | DeferredTypeReference, mapper: TypeMapper, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]) {
        const declaration = type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! :
            type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node :
            type.symbol.declarations![0];
        const links = getNodeLinks(declaration);
        const target = type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference :
            type.objectFlags & ObjectFlags.Instantiated ? type.target! : type;
        let typeParameters = type.objectFlags & ObjectFlags.SingleSignatureType ? (type as SingleSignatureType).outerTypeParameters : links.outerTypeParameters;
        if (!typeParameters) {
            // The first time an anonymous type is instantiated we compute and store a list of the type
            // parameters that are in scope (and therefore potentially referenced). For type literals that
            // aren't the right hand side of a generic type alias declaration we optimize by reducing the
            // set of type parameters to those that are possibly referenced in the literal.
            let outerTypeParameters = getOuterTypeParameters(declaration, /*includeThisTypes*/ true);
            // if (isJSConstructor(declaration)) {
            //     const templateTagParameters = getTypeParametersFromDeclaration(declaration as DeclarationWithTypeParameters);
            //     outerTypeParameters = addRange(outerTypeParameters, templateTagParameters);
            // }
            typeParameters = outerTypeParameters || emptyArray;
            const allDeclarations = type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations!;
            typeParameters = (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ?
                filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) :
                typeParameters;
            links.outerTypeParameters = typeParameters;
        }
        if (typeParameters.length) {
            // We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            const combinedMapper = combineTypeMappers(type.mapper, mapper);
            const typeArguments = map(typeParameters, t => getMappedType(t, combinedMapper));
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            const id = (type.objectFlags & ObjectFlags.SingleSignatureType ? "S" : "") + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments);
            if (!target.instantiations) {
                target.instantiations = new Map<string, Type>();
                target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target);
            }
            let result = target.instantiations.get(id);
            if (!result) {
                if (type.objectFlags & ObjectFlags.SingleSignatureType) {
                    result = instantiateAnonymousType(type, mapper);
                    target.instantiations.set(id, result);
                    return result;
                }
                const newMapper = createTypeMapper(typeParameters, typeArguments);
                result = target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) :
                    target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) :
                    instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);
                target.instantiations.set(id, result); // Set cached result early in case we recursively invoke instantiation while eagerly computing type variable visibility below
                const resultObjectFlags = getObjectFlags(result);
                if (result.flags & TypeFlags.ObjectFlagsType && !(resultObjectFlags & ObjectFlags.CouldContainTypeVariablesComputed)) {
                    const resultCouldContainTypeVariables = some(typeArguments, couldContainTypeVariables); // one of the input type arguments might be or contain the result
                    if (!(getObjectFlags(result) & ObjectFlags.CouldContainTypeVariablesComputed)) {
                        // if `result` is one of the object types we tried to make (it may not be, due to how `instantiateMappedType` works), we can carry forward the type variable containment check from the input type arguments
                        if (resultObjectFlags & (ObjectFlags.Mapped | ObjectFlags.Anonymous | ObjectFlags.Reference)) {
                            (result as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0);
                        }
                        // If none of the type arguments for the outer type parameters contain type variables, it follows
                        // that the instantiated type doesn't reference type variables.
                        // Intrinsics have `CouldContainTypeVariablesComputed` pre-set, so this should only cover unions and intersections resulting from `instantiateMappedType`
                        else {
                            (result as ObjectFlagsType).objectFlags |= !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0;
                        }
                    }
                }
            }
            return result;
        }
        return type;
    }

    function combineTypeMappers(mapper1: TypeMapper | undefined, mapper2: TypeMapper): TypeMapper {
        return mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2;
    }

    function makeCompositeTypeMapper(kind: TypeMapKind.Composite | TypeMapKind.Merged, mapper1: TypeMapper, mapper2: TypeMapper): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind, mapper1, mapper2 });
    }


    function maybeTypeParameterReference(node: Node) {
        return !(node.parent.kind === SyntaxKind.TypeReference && (node.parent as TypeReferenceNode).typeArguments && node === (node.parent as TypeReferenceNode).typeName);
            //node.parent.kind === SyntaxKind.ImportType && (node.parent as ImportTypeNode).typeArguments && node === (node.parent as ImportTypeNode).qualifier);
    }
    
    function isTypeParameterPossiblyReferenced(tp: TypeParameter, node: Node) {
        // If the type parameter doesn't have exactly one declaration, if there are intervening statement blocks
        // between the node and the type parameter declaration, if the node contains actual references to the
        // type parameter, or if the node contains type queries that we can't prove couldn't contain references to the type parameter,
        // we consider the type parameter possibly referenced.
        if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
            const container = tp.symbol.declarations[0].parent;
            for (let n = node; n !== container; n = n.parent) {
                if (!n || n.kind === SyntaxKind.Block) {// || n.kind === SyntaxKind.ConditionalType && forEachChild((n as ConditionalTypeNode).extendsType, containsReference)) {
                    return true;
                }
            }
            return containsReference(node);
        }
        return true;
        function containsReference(node: Node): boolean {
            switch (node.kind) {
                // case SyntaxKind.ThisType:
                //     return !!tp.isThisType;
                case SyntaxKind.Identifier:
                    return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&
                        getTypeFromTypeNodeWorker(node as TypeNode) === tp; // use worker because we're looking for === equality
                case SyntaxKind.TypeQuery:
                    Debug.fail("todo - type query");
                    // const entityName = (node as TypeQueryNode).exprName;
                    // const firstIdentifier = getFirstIdentifier(entityName);
                    // if (!isThisIdentifier(firstIdentifier)) { // Don't attempt to analyze typeof this.xxx
                    //     const firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);
                    //     const tpDeclaration = tp.symbol.declarations![0]; // There is exactly one declaration, otherwise `containsReference` is not called
                    //     const tpScope = tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T>
                    //         tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration.
                    //         undefined; // Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.
                    //     if (firstIdentifierSymbol.declarations && tpScope) {
                    //         return some(firstIdentifierSymbol.declarations, idDecl => isNodeDescendantOf(idDecl, tpScope)) ||
                    //             some((node as TypeQueryNode).typeArguments, containsReference);
                    //     }
                    // }
                    // return true;
                // case SyntaxKind.MethodDeclaration:
                // case SyntaxKind.MethodSignature:
                //     return !(node as FunctionLikeDeclaration).type && !!(node as FunctionLikeDeclaration).body ||
                //         some((node as FunctionLikeDeclaration).typeParameters, containsReference) ||
                //         some((node as FunctionLikeDeclaration).parameters, containsReference) ||
                //         !!(node as FunctionLikeDeclaration).type && containsReference((node as FunctionLikeDeclaration).type!);
            }
            return !!forEachChild(node, containsReference);
        }
    }


    function instantiateTypeWorker(type: Type, mapper: TypeMapper, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined): Type {
        const flags = type.flags;
        if (flags & TypeFlags.TypeParameter) {
            return getMappedType(type, mapper);
        }
        if (flags & TypeFlags.Object) {
            const objectFlags = (type as ObjectType).objectFlags;
            if (objectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped)) {
                if (objectFlags & ObjectFlags.Reference && !(type as TypeReference).node) {
                    const resolvedTypeArguments = (type as TypeReference).resolvedTypeArguments;
                    const newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
                    return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference((type as TypeReference).target, newTypeArguments) : type;
                }
                if (objectFlags & ObjectFlags.ReverseMapped) {
                    return instantiateReverseMappedType(type as ReverseMappedType, mapper);
                }
                return getObjectTypeInstantiation(type as TypeReference | AnonymousType | MappedType, mapper, aliasSymbol, aliasTypeArguments);
            }
            return type;
        }
        if (flags & TypeFlags.UnionOrIntersection) {
            const origin = type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined;
            const types = origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types;
            const newTypes = instantiateTypes(types, mapper);
            if (newTypes === types && aliasSymbol === type.aliasSymbol) {
                return type;
            }
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return flags & TypeFlags.Intersection || origin && origin.flags & TypeFlags.Intersection ?
                getIntersectionType(newTypes, IntersectionFlags.None, newAliasSymbol, newAliasTypeArguments) :
                getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments);
        }
        if (flags & TypeFlags.Index) {
            return getIndexType(instantiateType((type as IndexType).type, mapper));
        }
        // if (flags & TypeFlags.TemplateLiteral) {
        //     return getTemplateLiteralType((type as TemplateLiteralType).texts, instantiateTypes((type as TemplateLiteralType).types, mapper));
        // }
        // if (flags & TypeFlags.StringMapping) {
        //     return getStringMappingType((type as StringMappingType).symbol, instantiateType((type as StringMappingType).type, mapper));
        // }
        if (flags & TypeFlags.IndexedAccess) {
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return getIndexedAccessType(instantiateType((type as IndexedAccessType).objectType, mapper), instantiateType((type as IndexedAccessType).indexType, mapper), (type as IndexedAccessType).accessFlags, /*accessNode*/ undefined, newAliasSymbol, newAliasTypeArguments);
        }
        if (flags & TypeFlags.Conditional) {
            return getConditionalTypeInstantiation(type as ConditionalType, combineTypeMappers((type as ConditionalType).mapper, mapper), /*forConstraint*/ false, aliasSymbol, aliasTypeArguments);
        }
        if (flags & TypeFlags.Substitution) {
            const newBaseType = instantiateType((type as SubstitutionType).baseType, mapper);
            if (isNoInferType(type)) {
                return getNoInferType(newBaseType);
            }
            const newConstraint = instantiateType((type as SubstitutionType).constraint, mapper);
            // A substitution type originates in the true branch of a conditional type and can be resolved
            // to just the base type in the same cases as the conditional type resolves to its true branch
            // (because the base type is then known to satisfy the constraint).
            if (newBaseType.flags & TypeFlags.TypeVariable && isGenericType(newConstraint)) {
                return getSubstitutionType(newBaseType, newConstraint);
            }
            if (newConstraint.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint))) {
                return newBaseType;
            }
            return newBaseType.flags & TypeFlags.TypeVariable ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]);
        }
        return type;
    }

    function getPermissiveInstantiation(type: Type) {
        return type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type :
            type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
    }

    function getRestrictiveInstantiation(type: Type) {
        if (type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never)) {
            return type;
        }
        if (type.restrictiveInstantiation) {
            return type.restrictiveInstantiation;
        }
        type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
        // We set the following so we don't attempt to set the restrictive instance of a restrictive instance
        // which is redundant - we'll produce new type identities, but all type params have already been mapped.
        // This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
        // assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
        // are constrained to `unknown` and produce tons of false positives/negatives!
        type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
        return type.restrictiveInstantiation;
    }

    function getSubstitutionType(baseType: Type, constraint: Type) {
        return constraint.flags & TypeFlags.AnyOrUnknown || constraint === baseType || baseType.flags & TypeFlags.Any ?
            baseType :
            getOrCreateSubstitutionType(baseType, constraint);
    }

    function getConditionalTypeInstantiation(type: ConditionalType, mapper: TypeMapper, forConstraint: boolean, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        const root = type.root;
        if (root.outerTypeParameters) {
            // We are instantiating a conditional type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            const typeArguments = map(root.outerTypeParameters, t => getMappedType(t, mapper));
            const id = (forConstraint ? "C" : "") + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            let result = root.instantiations!.get(id);
            if (!result) {
                const newMapper = createTypeMapper(root.outerTypeParameters, typeArguments);
                const checkType = root.checkType;
                const distributionType = root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined;
                // Distributive conditional types are distributed over union types. For example, when the
                // distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
                // result is (A extends U ? X : Y) | (B extends U ? X : Y).
                result = distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?
                    mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) :
                    getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments);
                root.instantiations!.set(id, result);
            }
            return result;
        }
        return type;
    }

    function isSimpleTupleType(node: TypeNode): boolean {
        console.debug("todo - isSimpleTupleType");
        return false;
        // return isTupleTypeNode(node) && length(node.elements) > 0 &&
        //     !some(node.elements, e => isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken));
    }

    function isDeferredType(type: Type, checkTuples: boolean) {
        return isGenericType(type) || checkTuples && isTupleType(type) && some(getElementTypes(type), isGenericType);
    }

    function getConditionalType(root: ConditionalRoot, mapper: TypeMapper | undefined, forConstraint: boolean, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        let result;
        let extraTypes: Type[] | undefined;
        let tailCount = 0;
        // We loop here for an immediately nested conditional type in the false position, effectively treating
        // types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
        // purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
        // another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
        // cases we increment the tail recursion counter and stop after 1000 iterations.
        while (true) {
            if (tailCount === 1000) {
                error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                return errorType;
            }
            const checkType = instantiateType(getActualTypeVariable(root.checkType), mapper);
            const extendsType = instantiateType(root.extendsType, mapper);
            if (checkType === errorType || extendsType === errorType) {
                return errorType;
            }
            if (checkType === wildcardType || extendsType === wildcardType) {
                return wildcardType;
            }
            const checkTypeNode = skipTypeParentheses(root.node.checkType);
            const extendsTypeNode = skipTypeParentheses(root.node.extendsType);
            // When the check and extends types are simple tuple types of the same arity, we defer resolution of the
            // conditional type when any tuple elements are generic. This is such that non-distributable conditional
            // types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.
            const checkTuples = isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) &&
                length((checkTypeNode as TupleTypeNode).elements) === length((extendsTypeNode as TupleTypeNode).elements);
            const checkTypeDeferred = isDeferredType(checkType, checkTuples);
            let combinedMapper: TypeMapper | undefined;
            if (root.inferTypeParameters) {
                // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be
                // instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint
                // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].
                // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated
                // as `number`
                // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`
                // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`
                // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.
                // So we need to:
                //    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)
                //    * incorporate all of the component mappers into the combined mapper for the true and false members
                // This means we have two mappers that need applying:
                //    * The original `mapper` used to create this conditional
                //    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)
                const context = createInferenceContext(root.inferTypeParameters, /*signature*/ undefined, InferenceFlags.None);
                if (mapper) {
                    context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper);
                }
                if (!checkTypeDeferred) {
                    // We don't want inferences from constraints as they may cause us to eagerly resolve the
                    // conditional type instead of deferring resolution. Also, we always want strict function
                    // types rules (i.e. proper contravariance) for inferences.
                    inferTypes(context.inferences, checkType, extendsType, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);
                }
                // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
                // those type parameters are used in type references (see getInferredTypeParameterConstraint). For
                // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
                combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;
            }
            // Instantiate the extends type including inferences for 'infer T' type parameters
            const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;
            // We attempt to resolve the conditional type only when the check and extends types are non-generic
            if (!checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples)) {
                // Return falseType for a definitely false extends check. We check an instantiations of the two
                // types with type parameters mapped to the wildcard type, the most permissive instantiations
                // possible (the wildcard type is assignable to and from all types). If those are not related,
                // then no instantiations will be and we can just return the false branch type.
                if (!(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) && (checkType.flags & TypeFlags.Any || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                    // Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a
                    // distributive conditional type applied to the constraint of a type variable, include trueType if
                    // there are possible values of the check type that are also possible values of the extends type.
                    // We use a reverse assignability check as it is less expensive than the comparable relationship
                    // and avoids false positives of a non-empty intersection check.
                    if (checkType.flags & TypeFlags.Any || forConstraint && !(inferredExtendsType.flags & TypeFlags.Never) && someType(getPermissiveInstantiation(inferredExtendsType), t => isTypeAssignableTo(t, getPermissiveInstantiation(checkType)))) {
                        (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                    }
                    // If falseType is an immediately nested conditional type that isn't distributive or has an
                    // identical checkType, switch to that type and loop.
                    const falseType = getTypeFromTypeNode(root.node.falseType);
                    if (falseType.flags & TypeFlags.Conditional) {
                        const newRoot = (falseType as ConditionalType).root;
                        if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
                            root = newRoot;
                            continue;
                        }
                        if (canTailRecurse(falseType, mapper)) {
                            continue;
                        }
                    }
                    result = instantiateType(falseType, mapper);
                    break;
                }
                // Return trueType for a definitely true extends check. We check instantiations of the two
                // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
                // that has no constraint. This ensures that, for example, the type
                //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
                // doesn't immediately resolve to 'string' instead of being deferred.
                if (inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                    const trueType = getTypeFromTypeNode(root.node.trueType);
                    const trueMapper = combinedMapper || mapper;
                    if (canTailRecurse(trueType, trueMapper)) {
                        continue;
                    }
                    result = instantiateType(trueType, trueMapper);
                    break;
                }
            }
            // Return a deferred type for a check that is neither definitely true nor definitely false
            result = createType(TypeFlags.Conditional) as ConditionalType;
            result.root = root;
            result.checkType = instantiateType(root.checkType, mapper);
            result.extendsType = instantiateType(root.extendsType, mapper);
            result.mapper = mapper;
            result.combinedMapper = combinedMapper;
            result.aliasSymbol = aliasSymbol || root.aliasSymbol;
            result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!); // TODO: GH#18217
            break;
        }
        return extraTypes ? getUnionType(append(extraTypes, result)) : result;
        // We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
        // (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
        // type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
        // recursion counter for those.
        function canTailRecurse(newType: Type, newMapper: TypeMapper | undefined) {
            if (newType.flags & TypeFlags.Conditional && newMapper) {
                const newRoot = (newType as ConditionalType).root;
                if (newRoot.outerTypeParameters) {
                    const typeParamMapper = combineTypeMappers((newType as ConditionalType).mapper, newMapper);
                    const typeArguments = map(newRoot.outerTypeParameters, t => getMappedType(t, typeParamMapper));
                    const newRootMapper = createTypeMapper(newRoot.outerTypeParameters, typeArguments);
                    const newCheckType = newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined;
                    if (!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (TypeFlags.Union | TypeFlags.Never))) {
                        root = newRoot;
                        mapper = newRootMapper;
                        aliasSymbol = undefined;
                        aliasTypeArguments = undefined;
                        if (newRoot.aliasSymbol) {
                            tailCount++;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
    }
    
    function mapTypeWithAlias(type: Type, mapper: (t: Type) => Type, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined) {
        return type.flags & TypeFlags.Union && aliasSymbol ?
            getUnionType(map((type as UnionType).types, mapper), UnionReduction.Literal, aliasSymbol, aliasTypeArguments) :
            mapType(type, mapper);
    }

    // Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
    // that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
    // want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
    // introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
    // they're the same type regardless of what's being distributed over.
    function hasDistributiveNameType(mappedType: MappedType) {
        const typeVariable = getTypeParameterFromMappedType(mappedType);
        return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
        function isDistributive(type: Type): boolean {
            return type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true :
                type.flags & TypeFlags.Conditional ? (type as ConditionalType).root.isDistributive && (type as ConditionalType).checkType === typeVariable :
                type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every((type as UnionOrIntersectionType).types, isDistributive) :
                type.flags & TypeFlags.IndexedAccess ? isDistributive((type as IndexedAccessType).objectType) && isDistributive((type as IndexedAccessType).indexType) :
                type.flags & TypeFlags.Substitution ? isDistributive((type as SubstitutionType).baseType) && isDistributive((type as SubstitutionType).constraint) :
                type.flags & TypeFlags.StringMapping ? isDistributive((type as StringMappingType).type) :
                false;
        }
    }

    function getMappedTypeNameTypeKind(type: MappedType): MappedTypeNameTypeKind {
        const nameType = getNameTypeFromMappedType(type);
        if (!nameType) {
            return MappedTypeNameTypeKind.None;
        }
        return isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type)) ? MappedTypeNameTypeKind.Filtering : MappedTypeNameTypeKind.Remapping;
    }

    /**
     * A union type which is reducible upon instantiation (meaning some members are removed under certain instantiations)
     * must be kept generic, as that instantiation information needs to flow through the type system. By replacing all
     * type parameters in the union with a special never type that is treated as a literal in `getReducedType`, we can cause
     * the `getReducedType` logic to reduce the resulting type if possible (since only intersections with conflicting
     * literal-typed properties are reducible).
     */
    function isGenericReducibleType(type: Type): boolean {
        return !!(type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections && some((type as UnionType).types, isGenericReducibleType) ||
            type.flags & TypeFlags.Intersection && isReducibleIntersection(type as IntersectionType));
    }

    function isReducibleIntersection(type: IntersectionType) {
        const uniqueFilled = type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper));
        return getReducedType(uniqueFilled) !== uniqueFilled;
    }

    function getIndexTypeForGenericType(type: InstantiableType | UnionOrIntersectionType, indexFlags: IndexFlags) {
        return indexFlags & IndexFlags.StringsOnly ?
            type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly)) :
            type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, IndexFlags.None));
    }

    function createIndexType(type: InstantiableType | UnionOrIntersectionType, indexFlags: IndexFlags) {
        const result = createType(TypeFlags.Index) as IndexType;
        result.type = type;
        result.indexFlags = indexFlags;
        return result;
    }

    function shouldDeferIndexType(type: Type, indexFlags = IndexFlags.None) {
        return !!(type.flags & TypeFlags.InstantiableNonPrimitive ||
            isGenericTupleType(type) ||
            isGenericMappedType(type) && (!hasDistributiveNameType(type) || getMappedTypeNameTypeKind(type) === MappedTypeNameTypeKind.Remapping) ||
            type.flags & TypeFlags.Union && !(indexFlags & IndexFlags.NoReducibleCheck) && isGenericReducibleType(type) ||
            type.flags & TypeFlags.Intersection && maybeTypeOfKind(type, TypeFlags.Instantiable) && some((type as IntersectionType).types, isEmptyAnonymousObjectType));
    }

    function getIndexType(type: Type, indexFlags = IndexFlags.None): Type {        
        return isNoInferType(type) ? getNoInferType(getIndexType((type as SubstitutionType).baseType, indexFlags)) :
            shouldDeferIndexType(type, indexFlags) ? getIndexTypeForGenericType(type as InstantiableType | UnionOrIntersectionType, indexFlags) :
            type.flags & TypeFlags.Union ? getIntersectionType(map((type as UnionType).types, t => getIndexType(t, indexFlags))) :
            type.flags & TypeFlags.Intersection ? getUnionType(map((type as IntersectionType).types, t => getIndexType(t, indexFlags))) :
            getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(type as MappedType, indexFlags) :
            type === wildcardType ? wildcardType :
            type.flags & TypeFlags.Unknown ? neverType :
            type.flags & (TypeFlags.Any | TypeFlags.Never) ? stringNumberSymbolType :            
            getLiteralTypeFromProperties(type, (indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike), indexFlags === IndexFlags.None);
    }

    function createOriginIndexType(type: InstantiableType | UnionOrIntersectionType) {
        const result = createOriginType(TypeFlags.Index) as IndexType;
        result.type = type;
        return result;
    }

    function getLiteralTypeFromProperty(prop: Symbol, include: TypeFlags, includeNonPublic?: boolean) {
        if (includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier)) {
            let type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
            if (!type) {
                const name = getNameOfDeclaration(prop.valueDeclaration) as PropertyName;
                type = prop.name === InternalSymbolName.Default ? getStringLiteralType("default") :
                    name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined);
            }
            if (type && type.flags & include) {
                return type;
            }
        }
        return neverType;
    }

    function getLiteralTypeFromProperties(type: Type, include: TypeFlags, includeOrigin: boolean) {
        const origin = includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined;
        const propertyTypes = map(getPropertiesOfType(type), prop => getLiteralTypeFromProperty(prop, include));
        const indexKeyTypes = map(getIndexInfosOfType(type), info =>
            info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?
                info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType);
        return getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReduction.Literal, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, origin);
    }

    function isKeyTypeIncluded(keyType: Type, include: TypeFlags): boolean {
        return !!(keyType.flags & include || keyType.flags & TypeFlags.Intersection && some((keyType as IntersectionType).types, t => isKeyTypeIncluded(t, include)));
    }
    
    // Return the lower bound of the key type in a mapped type. Intuitively, the lower
    // bound includes those keys that are known to always be present, for example because
    // because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
    function getLowerBoundOfKeyType(type: Type): Type {
        if (type.flags & TypeFlags.Index) {
            const t = getApparentType((type as IndexType).type);
            return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
        }
        if (type.flags & TypeFlags.Conditional) {
            console.debug("todo - getLowerBoundOfKeyType");
            // if ((type as ConditionalType).root.isDistributive) {
            //     const checkType = (type as ConditionalType).checkType;
            //     const constraint = getLowerBoundOfKeyType(checkType);
            //     if (constraint !== checkType) {
            //         return getConditionalTypeInstantiation(type as ConditionalType, prependTypeMapping((type as ConditionalType).root.checkType, constraint, (type as ConditionalType).mapper), /*forConstraint*/ false);
            //     }
            // }
            // return type;
        }
        if (type.flags & TypeFlags.Union) {
            return mapType(type as UnionType, getLowerBoundOfKeyType, /*noReductions*/ true);
        }
        if (type.flags & TypeFlags.Intersection) {
            // Similarly to getTypeFromIntersectionTypeNode, we preserve the special string & {}, number & {},
            // and bigint & {} intersections that are used to prevent subtype reduction in union types.
            const types = (type as IntersectionType).types;
            if (types.length === 2 && !!(types[0].flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.Float)) && types[1] === emptyTypeLiteralType) {
                return type;
            }
            return getIntersectionType(sameMap((type as UnionType).types, getLowerBoundOfKeyType));
        }
        return type;
    }

    
    /**
     * Maps forward-references to later types parameters to the empty object type.
     * This is used during inference when instantiating type parameter defaults.
     */
    function createBackreferenceMapper(context: InferenceContext, index: number): TypeMapper {
        const forwardInferences = context.inferences.slice(index);
        return createTypeMapper(map(forwardInferences, i => i.typeParameter), map(forwardInferences, () => unknownType));
    }    

    function mergeTypeMappers(mapper1: TypeMapper | undefined, mapper2: TypeMapper): TypeMapper {
        return mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2;
    }

    function prependTypeMapping(source: Type, target: Type, mapper: TypeMapper | undefined) {
        return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper);
    }

    function appendTypeMapping(mapper: TypeMapper | undefined, source: Type, target: Type) {
        return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target));
    }

    function getRestrictiveTypeParameter(tp: TypeParameter) {
        return !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (
            tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation
        );
    }

    function getConstraintDeclaration(type: TypeParameter): TypeNode | undefined {
        return mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0];
    }

    /**
     * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
     * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
     * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
     * reduction in the constraintType) when possible.
     * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
     */
    function getIndexTypeForMappedType(type: MappedType, indexFlags: IndexFlags) {
        const typeParameter = getTypeParameterFromMappedType(type);
        const constraintType = getConstraintTypeFromMappedType(type);
        const nameType = getNameTypeFromMappedType(type.target as MappedType || type);
        if (!nameType && !(indexFlags & IndexFlags.NoIndexSignatures)) {
            // no mapping and no filtering required, just quickly bail to returning the constraint in the common case
            return constraintType;
        }
        const keyTypes: Type[] = [];
        // Calling getApparentType on the `T` of a `keyof T` in the constraint type of a generic mapped type can
        // trigger a circularity. For example, `T extends { [P in keyof T & string as Captitalize<P>]: any }` is
        // a circular definition. For this reason, we only eagerly manifest the keys if the constraint is non-generic.
        if (isGenericIndexType(constraintType)) {
            // if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
            //     // We have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer
            //     // the whole `keyof whatever` for later since it's not safe to resolve the shape of modifier type.
            //     return getIndexTypeForGenericType(type, indexFlags);
            // }
            // Include the generic component in the resulting type.
            forEachType(constraintType, addMemberForKeyType);
        }
        // else if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
        //     const modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
        //     forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlags.StringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlags.StringsOnly), addMemberForKeyType);
        // }
        else {
            forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
        }
        // We had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the
        // original constraintType, so we can return the union that preserves aliases/origin data if possible.
        const result = indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes);
        if (result.flags & TypeFlags.Union && constraintType.flags & TypeFlags.Union && getTypeListId((result as UnionType).types) === getTypeListId((constraintType as UnionType).types)) {
            return constraintType;
        }
        return result;

        function addMemberForKeyType(keyType: Type) {
            const propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
            // `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
            // See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
            keyTypes.push(propNameType === stringType ? stringOrNumberType : propNameType);
        }
    }

    // This function is similar to instantiateType, except that (a) it only instantiates types that
    // are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
    // no reductions on instantiated union types.
    function instantiateInstantiableTypes(type: Type, mapper: TypeMapper): Type {
        if (type.flags & TypeFlags.Instantiable) {
            return instantiateType(type, mapper);
        }
        if (type.flags & TypeFlags.Union) {
            return getUnionType(map((type as UnionType).types, t => instantiateInstantiableTypes(t, mapper)), UnionReduction.None);
        }
        if (type.flags & TypeFlags.Intersection) {
            return getIntersectionType(map((type as IntersectionType).types, t => instantiateInstantiableTypes(t, mapper)));
        }
        return type;
    }

    function hasInferenceCandidatesOrDefault(info: InferenceInfo) {
        return !!(info.candidates || info.contraCandidates) || hasTypeParameterDefault(info.typeParameter);
    }

    /**
     * Indicates whether the declaration of a typeParameter has a default type.
     */
    function hasTypeParameterDefault(typeParameter: TypeParameter): boolean {
        return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default));
    }

    function containsType(types: readonly Type[], type: Type): boolean {
        return binarySearch(types, type, getTypeId, compareValues) >= 0;
    }
    
    // If the given contextual type contains instantiable types and if a mapper representing
    // return type inferences is available, instantiate those types using that mapper.
    function instantiateContextualType(contextualType: Type | undefined, node: Node, contextFlags: ContextFlags | undefined): Type | undefined {
        if (contextualType && maybeTypeOfKind(contextualType, TypeFlags.Instantiable)) {
            const inferenceContext = getInferenceContext(node);
            // If no inferences have been made, and none of the type parameters for which we are inferring
            // specify default types, nothing is gained from instantiating as type parameters would just be
            // replaced with their constraints similar to the apparent type.
            if (inferenceContext && contextFlags! & ContextFlags.Signature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault)) {
                // For contextual signatures we incorporate all inferences made so far, e.g. from return
                // types as well as arguments to the left in a function call.
                return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper);
            }
            if (inferenceContext?.returnMapper) {
                // For other purposes (e.g. determining whether to produce literal types) we only
                // incorporate inferences made from the return type in a function call. We remove
                // the 'boolean' type from the contextual type such that contextually typed boolean
                // literals actually end up widening to 'boolean' (see #48363).
                const type = instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper);
                return type.flags & TypeFlags.Union && containsType((type as UnionType).types, regularFalseType) && containsType((type as UnionType).types, regularTrueType) ?
                    filterType(type, t => t !== regularFalseType && t !== regularTrueType) :
                    type;
            }
        }
        return contextualType;
    }

    // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
    // be "pushed" onto a node using the contextualType property.
    function getApparentTypeOfContextualType(node: Expression, contextFlags: ContextFlags | undefined): Type | undefined {
        const contextualType = /*isObjectLiteralMethod(node) ?
            getContextualTypeForObjectLiteralMethod(node, contextFlags) :*/
            getContextualType(node, contextFlags);
        const instantiatedType = instantiateContextualType(contextualType, node, contextFlags);
        if (instantiatedType && !(contextFlags && contextFlags & ContextFlags.NoConstraints && instantiatedType.flags & TypeFlags.TypeVariable)) {
            const apparentType = mapType(
                instantiatedType,
                // When obtaining apparent type of *contextual* type we don't want to get apparent type of mapped types.
                // That would evaluate mapped types with array or tuple type constraints too eagerly
                // and thus it would prevent `getTypeOfPropertyOfContextualType` from obtaining per-position contextual type for elements of array literal expressions.
                // Apparent type of other mapped types is already the mapped type itself so we can just avoid calling `getApparentType` here for all mapped types.
                t => getObjectFlags(t) & ObjectFlags.Mapped ? t : getApparentType(t),
                /*noReductions*/ true,
            );
            // return apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType as UnionType) :
            //     apparentType.flags & TypeFlags.Union && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType) :
            //     apparentType;
            return apparentType;
        }
    }

    // If the given type is an object or union type with a single signature, and if that signature has at
    // least as many parameters as the given function, return the signature. Otherwise return undefined.
    function getContextualCallSignature(type: Type, node: SignatureDeclaration): Signature | undefined {
        const signatures = getSignaturesOfType(type, SignatureKind.Call);
        const applicableByArity = filter(signatures, s => !isAritySmaller(s, node));
        return applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity);
    }

    function getIntersectedSignatures(signatures: readonly Signature[]) {
        if (getStrictOptionValue(compilerOptions, "noImplicitAny")) {
            console.debug("todo - getIntersectedSignatures");
        }
        // return getStrictOptionValue(compilerOptions, "noImplicitAny")
        //     ? reduceLeft(
        //         signatures,
        //         (left: Signature | undefined, right) =>
        //             left === right || !left ? left
        //                 : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!)
        //                 : undefined,
        //     )
        //     : undefined;        
        return undefined;
    }

    function isParamVarArgs(param: ParameterDeclaration) {        
        return !!(getCombinedModifierFlagsCached(param) & ModifierFlags.VarArgs) || !!param.dotDotDotToken;
    }

    function isSignatureVarArgs(signature: Signature) {
        return !!(signature.flags & SignatureFlags.IsVarArgs);
    }

    function hasVarArgsParam(signature: SignatureDeclaration) {
        return some(signature.parameters, isParamVarArgs);
    }

    function hasEffectiveRestParameter(signature: Signature): boolean {
        if (hasVarArgsParam(signature.declaration as SignatureDeclaration)) {
            return true;
        } 
        else if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            return !isTupleType(restType) || restType.target.hasRestElement;
        }
        return false;
    }

    
    // Return the number of parameters in a signature. The rest parameter, if present, counts as one
    // parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
    // the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
    // latter example, the effective rest type is [...string[], boolean].
    function getParameterCount(signature: Signature) {
        const length = signature.parameters.length;
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[length - 1]);            
            if (isTupleType(restType)) {
                return length + restType.target.fixedLength - (restType.target.hasRestElement ? 0 : 1);
            }
        }
        return length;
    }

    /** If the contextual signature has fewer parameters than the function expression, do not use it */
    function isAritySmaller(signature: Signature, target: SignatureDeclaration) {
        let targetParameterCount = 0;
        for (; targetParameterCount < (target.parameters?.length ?? 0); targetParameterCount++) {
            const param = target.parameters[targetParameterCount];                        
            if (param.initializer || param.dotDotDotToken || isJSDocOptionalParameter(param)) {
                break;
            }
        }
        // if (target.parameters.length && parameterIsThisKeyword(target.parameters[0])) {
        //     targetParameterCount--;
        // }
        return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount;
    }


    // Return the contextual signature for a given expression node. A contextual type provides a
    // contextual signature if it has a single call signature and if that call signature is non-generic.
    // If the contextual type is a union type, get the signature from each type possible and if they are
    // all identical ignoring their return type, the result is same signature but with return type as
    // union type of return types from these signatures
    function getContextualSignature(node: FunctionExpression | InlineClosureExpression | SignatureDeclaration/* | MethodDeclaration*/): Signature | undefined {
        //Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));
        const typeTagSignature = getSignatureOfTypeTag(node);
        if (typeTagSignature) {
            return typeTagSignature;
        }
        const type = getApparentTypeOfContextualType(node as Expression, ContextFlags.Signature);
        if (!type) {
            return undefined;
        }
        if (!(type.flags & TypeFlags.Union)) {
            return getContextualCallSignature(type, node);
        }
        let signatureList: Signature[] | undefined;
        const types = (type as UnionType).types;
        for (const current of types) {
            const signature = getContextualCallSignature(current, node);
            if (signature) {
                if (!signatureList) {
                    // This signature will contribute to contextual union signature
                    signatureList = [signature];
                }
                else if (!compareSignaturesIdentical(signatureList[0], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
                    // Signatures aren't identical, do not use
                    return undefined;
                }
                else {
                    // Use this signature for contextual union signature
                    signatureList.push(signature);
                }
            }
        }
        // Result is union of signatures collected (return type is union of return types of this signature set)
        if (signatureList) {
            return signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList);
        }
    }

    function compareTypesIdentical(source: Type, target: Type): Ternary {
        return isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False;
    }
    
    function cloneSignature(sig: Signature): Signature {
        const result = createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags);
        result.target = sig.target;
        result.mapper = sig.mapper;
        result.compositeSignatures = sig.compositeSignatures;
        result.compositeKind = sig.compositeKind;
        return result;
    }

    function createUnionSignature(signature: Signature, unionSignatures: Signature[]) {
        const result = cloneSignature(signature);
        result.compositeSignatures = unionSignatures;
        result.compositeKind = TypeFlags.Union;
        result.target = undefined;
        result.mapper = undefined;
        return result;
    }

    function getMinArgumentCount(signature: Signature, flags?: MinArgumentCountFlags) {
        const strongArityForUntypedJS = flags! & MinArgumentCountFlags.StrongArityForUntypedJS;
        const voidIsNonOptional = flags! & MinArgumentCountFlags.VoidIsNonOptional;
        if (voidIsNonOptional || signature.resolvedMinArgumentCount === undefined) {
            let minArgumentCount: number | undefined;
            if (hasSyntacticModifier(signature.declaration, ModifierFlags.VarArgs)) {
                minArgumentCount = 0;
            } else if (signatureHasRestParameter(signature)) {
                const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                minArgumentCount = signature.parameters.length - 1;
                if (isTupleType(restType)) {
                    const firstOptionalIndex = findIndex(restType.target.elementFlags, f => !(f & ElementFlags.Required));
                    const requiredCount = firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex;
                    if (requiredCount > 0) {
                        minArgumentCount = signature.parameters.length - 1 + requiredCount;
                    }
                }
            }
            if (minArgumentCount === undefined) {
                // Not used in LPC
                // if (!strongArityForUntypedJS && signature.flags & SignatureFlags.IsUntypedSignatureInJSFile) {
                //     return 0;
                // }
                minArgumentCount = signature.minArgumentCount;
            }
            if (voidIsNonOptional) {
                return minArgumentCount;
            }
            for (let i = minArgumentCount - 1; i >= 0; i--) {
                const type = getTypeAtPosition(signature, i);
                if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {
                    break;
                }
                minArgumentCount = i;
            }
            signature.resolvedMinArgumentCount = minArgumentCount;
        }
        return signature.resolvedMinArgumentCount;
    }

    function acceptsVoid(t: Type): boolean {
        return !!(t.flags & TypeFlags.Void);
    }

    function getTypeAtPosition(signature: Signature, pos: number): Type {
        return tryGetTypeAtPosition(signature, pos) || anyType;
    }

    function tryGetTypeAtPosition(signature: Signature, pos: number): Type | undefined {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            return getTypeOfParameter(signature.parameters[pos]);
        }
        if (signatureHasRestParameter(signature)) {
            // We want to return the value undefined for an out of bounds parameter position,
            // so we need to check bounds here before calling getIndexedAccessType (which
            // otherwise would return the type 'undefined').
            const restType = getTypeOfSymbol(signature.parameters[paramCount]);
            const index = pos - paramCount;
            if (!isTupleType(restType) || restType.target.combinedFlags & ElementFlags.Variable || index < restType.target.fixedLength) {
                return getIndexedAccessType(restType, getNumberLiteralType(index));                
            }
        }
        return undefined;
    }
    
    function addOptionality(type: Type, isProperty = false, isOptional = true): Type {
        return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
    }
    
    function getTypeOfParameter(symbol: Symbol) {
        const declaration = symbol.valueDeclaration;
        return addOptionality(
            getTypeOfSymbol(symbol),
            /*isProperty*/ false,
            /*isOptional*/ !!declaration && (hasInitializer(declaration)),
        );
    }



    function isMatchingSignature(source: Signature, target: Signature, partialMatch: boolean) {
        const sourceParameterCount = getParameterCount(source);
        const targetParameterCount = getParameterCount(target);
        const sourceMinArgumentCount = getMinArgumentCount(source);
        const targetMinArgumentCount = getMinArgumentCount(target);
        const sourceHasRestParameter = hasEffectiveRestParameter(source);
        const targetHasRestParameter = hasEffectiveRestParameter(target);
        // A source signature matches a target signature if the two signatures have the same number of required,
        // optional, and rest parameters.
        if (
            sourceParameterCount === targetParameterCount &&
            sourceMinArgumentCount === targetMinArgumentCount &&
            sourceHasRestParameter === targetHasRestParameter
        ) {
            return true;
        }
        // A source signature partially matches a target signature if the target signature has no fewer required
        // parameters
        if (partialMatch && sourceMinArgumentCount <= targetMinArgumentCount) {
            return true;
        }
        return false;
    }

    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    function compareSignaturesIdentical(source: Signature, target: Signature, partialMatch: boolean, ignoreThisTypes: boolean, ignoreReturnTypes: boolean, compareTypes: (s: Type, t: Type) => Ternary): Ternary {
        // TODO (drosen): De-duplicate code between related functions.
        if (source === target) {
            return Ternary.True;
        }
        if (!(isMatchingSignature(source, target, partialMatch))) {
            return Ternary.False;
        }
        // Check that the two signatures have the same number of type parameters.
        if (length(source.typeParameters) !== length(target.typeParameters)) {
            return Ternary.False;
        }
        // Check that type parameter constraints and defaults match. If they do, instantiate the source
        // signature with the type parameters of the target signature and continue the comparison.
        if (target.typeParameters) {
            const mapper = createTypeMapper(source.typeParameters!, target.typeParameters);
            for (let i = 0; i < target.typeParameters.length; i++) {
                const s = source.typeParameters![i];
                const t = target.typeParameters[i];
                if (
                    !(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&
                            compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))
                ) {
                    return Ternary.False;
                }
            }
            source = instantiateSignature(source, mapper, /*eraseTypeParameters*/ true);
        }
        let result = Ternary.True;
        // if (!ignoreThisTypes) {
        //     const sourceThisType = getThisTypeOfSignature(source);
        //     if (sourceThisType) {
        //         const targetThisType = getThisTypeOfSignature(target);
        //         if (targetThisType) {
        //             const related = compareTypes(sourceThisType, targetThisType);
        //             if (!related) {
        //                 return Ternary.False;
        //             }
        //             result &= related;
        //         }
        //     }
        // }
        const targetLen = getParameterCount(target);
        for (let i = 0; i < targetLen; i++) {
            const s = getTypeAtPosition(source, i);
            const t = getTypeAtPosition(target, i);
            const related = compareTypes(t, s);
            if (!related) {
                return Ternary.False;
            }
            result &= related;
        }
        if (!ignoreReturnTypes) {
            const sourceTypePredicate = getTypePredicateOfSignature(source);
            const targetTypePredicate = getTypePredicateOfSignature(target);
            result &= sourceTypePredicate || targetTypePredicate ?
                compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :
                compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
        }
        return result;
    }    

    function compareTypePredicatesIdentical(source: TypePredicate | undefined, target: TypePredicate | undefined, compareTypes: (s: Type, t: Type) => Ternary): Ternary {
        return !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False :
            source.type === target.type ? Ternary.True :
            source.type && target.type ? compareTypes(source.type, target.type) :
            Ternary.False;
    }
    
    function isArrayOrTupleType(type: Type): type is TypeReference {
        return isArrayType(type);// || isTupleType(type);
    }

    function isArrayType(type: Type): type is TypeReference {
        return !!(getObjectFlags(type) & ObjectFlags.Reference) && ((type as TypeReference).target === globalArrayType || (type as TypeReference).target === globalReadonlyArrayType);
    }

    function isMappingType(type: Type): type is TypeReference {
        return !!(getObjectFlags(type) & ObjectFlags.Reference) && ((type as TypeReference).target === globalMappingType);
    }
    
    /**
     * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
     * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
     * getWidenedType. But in some cases getWidenedType is called without reporting errors
     * (type argument inference is an example).
     *
     * The return value indicates whether an error was in fact reported. The particular circumstances
     * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
     * an object literal property (arbitrarily deeply), this function reports an error. If no error is
     * reported, reportImplicitAnyError is a suitable fallback to report a general error.
     */
    function reportWideningErrorsInType(type: Type): boolean {
        let errorReported = false;
        if (getObjectFlags(type) & ObjectFlags.ContainsWideningType) {
            if (type.flags & TypeFlags.Union) {
                if (some((type as UnionType).types, isEmptyObjectType)) {
                    errorReported = true;
                }
                else {
                    for (const t of (type as UnionType).types) {
                        errorReported ||= reportWideningErrorsInType(t);
                    }
                }
            }
            else if (isArrayOrTupleType(type)) {
                // for (const t of getTypeArguments(type)) {
                //     errorReported ||= reportWideningErrorsInType(t);
                // }
            }
            else if (isObjectLiteralType(type)) {
                for (const p of getPropertiesOfObjectType(type)) {
                    const t = getTypeOfSymbol(p);
                    if (getObjectFlags(t) & ObjectFlags.ContainsWideningType) {
                        errorReported = reportWideningErrorsInType(t);
                        if (!errorReported) {
                            // we need to account for property types coming from object literal type normalization in unions
                            const valueDeclaration = p.declarations?.find(d => d.symbol.valueDeclaration?.parent === type.symbol.valueDeclaration);
                            if (valueDeclaration) {
                                error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)));
                                errorReported = true;
                            }
                        }
                    }
                }
            }
        }
        return errorReported;
    }

    function getExtractStringType(type: Type) {
        console.debug("todo - getExtractStringType - is this needed?");
        return stringType;
        // const extractTypeAlias = getGlobalExtractSymbol();
        // return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
    }
    
    function getNonNullableTypeIfNeeded(type: Type) {
        return type;
    }

    function tryGetTypeFromEffectiveTypeNode(node: Node) {
        const typeNode = getEffectiveTypeAnnotationNode(node, currentFile);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
    }

    function isEmptyArrayLiteral(node: Expression) {
        const expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        return expr.kind === SyntaxKind.ArrayLiteralExpression && (expr as ArrayLiteralExpression).elements.length === 0;
    }

    
    function getParameterTypeOfTypeTag(func: FunctionLikeDeclaration, parameter: ParameterDeclaration) {
        const signature = getSignatureOfTypeTag(func);
        if (!signature) return undefined;
        const pos = func.parameters.indexOf(parameter);
        return getTypeAtPosition(signature, pos); // TODO parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos);
    }

    // Return the inferred type for a variable, parameter, or property declaration
    function getTypeForVariableLikeDeclaration(
        declaration: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag,
        includeOptionality: boolean,
        checkMode: CheckMode,
    ): Type | undefined {        
        if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForEachStatement) {
            const forEach = declaration.parent.parent;
            const expressionType = getNonNullableTypeIfNeeded(checkExpression(forEach.expression, checkMode));

            if (isArrayType(expressionType) && expressionType.resolvedTypeArguments) {
                // unlike TS, LPC allows an array of any type in a foreach, so just return the type arg.
                return first(expressionType.resolvedTypeArguments);
                // A variable declared in a for..in statement is of type string, or of type keyof T when the
                // right hand expression is of a type parameter type.                                
                // const indexType = getIndexType(expressionType);                
                // return indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType;
            } else if (isMappingType(expressionType)) {
                // checkRightHandSideOfForOf will return undefined if the for-of expression type was
                // missing properties/signatures required to get its iteratedType (like
                // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
                // or it may have led to an error inside getElementTypeOfIterable.
                const mappingType = checkRightHandSideOfForOf(forEach) || anyType;
                if (mappingType.flags & TypeFlags.Union) {
                    // if the maping returned a union type, then we need to determine the declarations position in a var decl list
                    // the final type is the same position in the union type
                    const declIndex = declaration.parent.declarations.indexOf(declaration);
                    const declType = (mappingType as UnionType).types.at(declIndex) || anyType;

                    // finally make sure the types are compatible, because in this situation the variable decl won't have an initializer
                    if (declaration.type) {
                        const declaredType = getTypeFromTypeNode(declaration.type);
                        if (!checkTypeAssignableToAndOptionallyElaborate(declType, declaredType, declaration, forEach.expression)) {
                            return errorType;
                        }
                    }

                    return declType;
                } else if (mappingType === undefinedWideningType) {
                    // this means it was a plain, untyped mapping object
                    // use the type of the variable declaration
                    return tryGetTypeFromEffectiveTypeNode(declaration);
                }

                return mappingType;
            }            
        }

        if (isBindingPattern(declaration.parent)) {
            Debug.fail("implement me - getTypeForVariableLikeDeclaration");
            // return getTypeForBindingElement(declaration as BindingElement);
        }

        const isProperty = (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration);
        const isOptional = false;//includeOptionality && isOptionalDeclaration(declaration);

        // Use type from type annotation if one is present
        const declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
        // if (isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
        //     if (declaredType) {
        //         // If the catch clause is explicitly annotated with any or unknown, accept it, otherwise error.
        //         return isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType;
        //     }
        //     // If the catch clause is not explicitly annotated, treat it as though it were explicitly
        //     // annotated with unknown or any, depending on useUnknownInCatchVariables.
        //     return useUnknownInCatchVariables ? unknownType : anyType;
        // }
        if (declaredType) {
            return addOptionality(declaredType, isProperty, isOptional);
        }

        if (
            (noImplicitAny || isInJSFile(declaration)) &&
            isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) &&
            !(getCombinedModifierFlagsCached(declaration) & ModifierFlags.Export) && !(declaration.flags & NodeFlags.Ambient)
        ) {
            // If --noImplicitAny is on or the declaration is in a Javascript file,
            // use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
            // initializer or a 'null' or 'undefined' initializer.
            if ((!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
                return autoType;
            }
            // Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
            // literal initializer.
            if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
                return autoArrayType;
            }
        }

        if (isParameter(declaration)) {
            if (!declaration.symbol) {
                // parameters of function types defined in JSDoc in TS files don't have symbols
                return;
            }
            const func = declaration.parent as FunctionLikeDeclaration;
            // For a parameter of a set accessor, use the type of the get accessor if one is present
            // if (func.kind === SyntaxKind.SetAccessor && hasBindableName(func)) {
            //     const getter = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(declaration.parent), SyntaxKind.GetAccessor);
            //     if (getter) {
            //         const getterSignature = getSignatureFromDeclaration(getter);
            //         const thisParameter = getAccessorThisParameter(func as AccessorDeclaration);
            //         if (thisParameter && declaration === thisParameter) {
            //             // Use the type from the *getter*
            //             Debug.assert(!thisParameter.type);
            //             return getTypeOfSymbol(getterSignature.thisParameter!);
            //         }
            //         return getReturnTypeOfSignature(getterSignature);
            //     }
            // }
            const parameterTypeOfTypeTag = getParameterTypeOfTypeTag(func, declaration);
            if (parameterTypeOfTypeTag) return parameterTypeOfTypeTag;
            // Use contextual parameter type if one is available
            const type = getContextuallyTypedParameterType(declaration);//declaration.symbol.name === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
            if (type) {
                return addOptionality(type, /*isProperty*/ false, isOptional);
            }
        }

        // Use the type of the initializer expression if one is present and the declaration is
        // not a parameter of a contextually typed function
        if (hasOnlyExpressionInitializer(declaration) && !!declaration.initializer) {
            // if (isInJSFile(declaration) && !isParameter(declaration)) {
            //     const containerObjectType = getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration));
            //     if (containerObjectType) {
            //         return containerObjectType;
            //     }
            // }
            const type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode));
            return addOptionality(type, isProperty, isOptional);
        }

        // if (isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration))) {
        //     // We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
        //     // Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
        //     // if (!hasStaticModifier(declaration)) {
        //         const constructor = findConstructorDeclaration(declaration.parent);
        //         const type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :
        //             getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :
        //             undefined;
        //         return type && addOptionality(type, /*isProperty*/ true, isOptional);
        //     // }
        //     // else {
        //     //     const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);
        //     //     const type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :
        //     //         getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :
        //     //         undefined;
        //     //     return type && addOptionality(type, /*isProperty*/ true, isOptional);
        //     // }
        // }

        // if (isJsxAttribute(declaration)) {
        //     // if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
        //     // I.e <Elem attr /> is sugar for <Elem attr={true} />
        //     return trueType;
        // }

        // If the declaration specifies a binding pattern and is not a parameter of a contextually
        // typed function, use the type implied by the binding pattern
        // if (isBindingPattern(declaration.name)) {
        //     return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ false, /*reportErrors*/ true);
        // }

        // No type specified and nothing can be inferred
        return undefined;
    }

    function isNullOrUndefined(node: Expression) {
        const expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        return expr.kind === SyntaxKind.NullKeyword || expr.kind === SyntaxKind.Identifier && getResolvedSymbol(expr as Identifier) === undefinedSymbol;
    }

    function widenTypeInferredFromInitializer(declaration: HasExpressionInitializer, type: Type) {
        const widened = getWidenedLiteralType(type);
        if (isInJSFile(declaration)) {
            if (isEmptyLiteralType(widened)) {
                reportImplicitAny(declaration, anyType);
                return anyType;
            }
            else if (isEmptyArrayLiteralType(widened)) {
                reportImplicitAny(declaration, anyArrayType);
                return anyArrayType;
            }
        }
        return widened;
    }

    function checkDeclarationInitializer(
        declaration: HasExpressionInitializer,
        checkMode: CheckMode,
        contextualType?: Type | undefined,
    ) {
        const initializer = getEffectiveInitializer(declaration)!;
        // if (isInJSFile(declaration)) {
        //     const typeNode = tryGetJSDocSatisfiesTypeNode(declaration);
        //     if (typeNode) {
        //         return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode);
        //     }
        // }
        const type = getQuickTypeOfExpression(initializer) || (contextualType ?
            checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext*/ undefined, checkMode || CheckMode.Normal) :
            checkExpressionCached(initializer, checkMode));
        // TODO
        // if (isParameter(isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration)) {
        //     if (declaration.name.kind === SyntaxKind.ObjectBindingPattern && isObjectLiteralType(type)) {
        //         return padObjectLiteralType(type as ObjectType, declaration.name);
        //     }
        //     if (declaration.name.kind === SyntaxKind.ArrayBindingPattern && isTupleType(type)) {
        //         return padTupleType(type, declaration.name);
        //     }
        // }
        return type;
    }
    
    function checkBreakOrContinueStatement(node: BreakOrContinueStatement) {
        // Grammar checking
        checkGrammarBreakOrContinueStatement(node);

        // TODO: Check that target label is valid
    }

    function checkGrammarBreakOrContinueStatement(node: BreakOrContinueStatement): boolean {
        let current: Node = node;
        while (current) {
            if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {
                return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);
            }

            switch (current.kind) {
                case SyntaxKind.LabeledStatement:
                    if (node.label && (current as LabeledStatement).label.text === node.label.text) {
                        // found matching label - verify that label usage is correct
                        // continue can only target labels that are on iteration statements
                        const isMisplacedContinueLabel = node.kind === SyntaxKind.ContinueStatement
                            && !isIterationStatement((current as LabeledStatement).statement, /*lookInLabeledStatements*/ true);

                        if (isMisplacedContinueLabel) {
                            return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                        }

                        return false;
                    }
                    break;
                case SyntaxKind.SwitchStatement:
                    if (node.kind === SyntaxKind.BreakStatement && !node.label) {
                        // unlabeled break within switch statement - ok
                        return false;
                    }
                    break;
                default:
                    if (isIterationStatement(current, /*lookInLabeledStatements*/ false) && !node.label) {
                        // unlabeled break or continue within iteration statement - ok
                        return false;
                    }
                    break;
            }

            current = current.parent;
        }

        if (node.label) {
            const message = node.kind === SyntaxKind.BreakStatement
                ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;

            return grammarErrorOnNode(node, message);
        }
        else {
            const message = node.kind === SyntaxKind.BreakStatement
                ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
            return grammarErrorOnNode(node, message);
        }
    }
    
    function checkExpressionWithContextualType(node: Expression, contextualType: Type, inferenceContext: InferenceContext | undefined, checkMode: CheckMode): Type {
        const contextNode = getContextNode(node);
        pushContextualType(contextNode, contextualType, /*isCache*/ false);
        pushInferenceContext(contextNode, inferenceContext);
        const type = checkExpression(node, checkMode | CheckMode.Contextual | (inferenceContext ? CheckMode.Inferential : 0));
        // In CheckMode.Inferential we collect intra-expression inference sites to process before fixing any type
        // parameters. This information is no longer needed after the call to checkExpression.
        if (inferenceContext && inferenceContext.intraExpressionInferenceSites) {
            inferenceContext.intraExpressionInferenceSites = undefined;
        }
        // We strip literal freshness when an appropriate contextual type is present such that contextually typed
        // literals always preserve their literal types (otherwise they might widen during type inference). An alternative
        // here would be to not mark contextually typed literals as fresh in the first place.
        const result = maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags*/ undefined)) ?
            getRegularTypeOfLiteralType(type) : type;
        popInferenceContext();
        popContextualType();
        return result;
    }

    function isLiteralOfContextualType(candidateType: Type, contextualType: Type | undefined): boolean {
        if (contextualType) {
            if (contextualType.flags & TypeFlags.UnionOrIntersection) {
                const types = (contextualType as UnionType).types;
                return some(types, t => isLiteralOfContextualType(candidateType, t));
            }
            if (contextualType.flags & TypeFlags.InstantiableNonPrimitive) {
                // If the contextual type is a type variable constrained to a primitive type, consider
                // this a literal context for literals of that primitive type. For example, given a
                // type parameter 'T extends string', infer string literal types for T.
                const constraint = getBaseConstraintOfType(contextualType) || unknownType;
                return maybeTypeOfKind(constraint, TypeFlags.String) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||
                    maybeTypeOfKind(constraint, TypeFlags.Number) && maybeTypeOfKind(candidateType, TypeFlags.IntLiteral) ||
                    maybeTypeOfKind(constraint, TypeFlags.Float) && maybeTypeOfKind(candidateType, TypeFlags.FloatLiteral) ||
                    maybeTypeOfKind(constraint, TypeFlags.Bytes) && maybeTypeOfKind(candidateType, TypeFlags.BytesLiteral) ||
                    isLiteralOfContextualType(candidateType, constraint);
            }
            // If the contextual type is a literal of a particular primitive type, we consider this a
            // literal context for all literals of that primitive type.
            return !!(contextualType.flags & (TypeFlags.StringLiteral | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||
                contextualType.flags & TypeFlags.IntLiteral && maybeTypeOfKind(candidateType, TypeFlags.IntLiteral) ||
                contextualType.flags & TypeFlags.FloatLiteral && maybeTypeOfKind(candidateType, TypeFlags.FloatLiteral) ||
                contextualType.flags & TypeFlags.BooleanLiteral && maybeTypeOfKind(candidateType, TypeFlags.BooleanLiteral) ||
                contextualType.flags & TypeFlags.Bytes && maybeTypeOfKind(candidateType, TypeFlags.BytesLiteral));
        }
        return false;
    }

    function pushInferenceContext(node: Node, inferenceContext: InferenceContext | undefined) {
        inferenceContextNodes[inferenceContextCount] = node;
        inferenceContexts[inferenceContextCount] = inferenceContext;
        inferenceContextCount++;
    }

    function popInferenceContext() {
        inferenceContextCount--;
    }

    function pushCachedContextualType(node: Expression) {
        pushContextualType(node, getContextualType(node, /*contextFlags*/ undefined), /*isCache*/ true);
    }

    function pushContextualType(node: Expression, type: Type | undefined, isCache: boolean) {
        contextualTypeNodes[contextualTypeCount] = node;
        contextualTypes[contextualTypeCount] = type;
        contextualIsCache[contextualTypeCount] = isCache;
        contextualTypeCount++;
    }

    function popContextualType() {
        contextualTypeCount--;
    }

    function getContextNode(node: Expression): Expression {
        return node;
    }

    function isEmptyLiteralType(type: Type): boolean {
        return strictNullChecks ? type === implicitNeverType : type === undefinedWideningType;
    }

    function isEmptyArrayLiteralType(type: Type): boolean {
        const elementType = getElementTypeOfArrayType(type);
        return !!elementType && isEmptyLiteralType(elementType);
    }

    function getElementTypeOfArrayType(type: Type): Type | undefined {
        return isArrayType(type) ? getTypeArguments(type)[0] : undefined;
    }
    
    /**
     * Pop an entry from the type resolution stack and return its associated result value. The result value will
     * be true if no circularities were detected, or false if a circularity was found.
     */
    function popTypeResolution(): boolean {
        resolutionTargets.pop();
        resolutionPropertyNames.pop();
        return resolutionResults.pop()!;
    }

    function getDefaultTypeArgumentType(isInJavaScriptFile: boolean): Type {
        return isInJavaScriptFile ? anyType : unknownType;
    }


    /**
     * Fill in default types for unsupplied type arguments. If `typeArguments` is undefined
     * when a default type is supplied, a new array will be created and returned.
     *
     * @param typeArguments The supplied type arguments.
     * @param typeParameters The requested type parameters.
     * @param minTypeArgumentCount The minimum number of required type arguments.
     */
    function fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[];
    function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[] | undefined;
    function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean) {
        const numTypeParameters = length(typeParameters);
        if (!numTypeParameters) {
            return [];
        }
        const numTypeArguments = length(typeArguments);
        if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
            const result = typeArguments ? typeArguments.slice() : [];
            // Map invalid forward references in default types to the error type
            for (let i = numTypeArguments; i < numTypeParameters; i++) {
                result[i] = errorType;
            }
            const baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
            for (let i = numTypeArguments; i < numTypeParameters; i++) {
                let defaultType = getDefaultFromTypeParameter(typeParameters![i]);
                if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                    defaultType = anyType;
                }
                result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;
            }
            result.length = typeParameters!.length;
            return result;
        }
        return typeArguments && typeArguments.slice();        
    }

    
    /**
     * Gets the minimum number of type arguments needed to satisfy all non-optional type
     * parameters.
     */
    function getMinTypeArgumentCount(typeParameters: readonly TypeParameter[] | undefined): number {
        let minTypeArgumentCount = 0;        
        if (typeParameters) {
            for (let i = 0; i < typeParameters.length; i++) {
                if (!hasTypeParameterDefault(typeParameters[i])) {
                    minTypeArgumentCount = i + 1;
                }
            }
        }
        return minTypeArgumentCount;
    }

    function getEffectiveTypeArguments(node: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments , typeParameters: readonly TypeParameter[]): Type[] {
        return fillMissingTypeArguments(map(node.typeArguments!, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node));
    }

    function getTypeArguments(type: TypeReference): readonly Type[] {
        if (!type.resolvedTypeArguments) {
            if (!pushTypeResolution(type, TypeSystemPropertyName.ResolvedTypeArguments)) {
                return concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType)) || emptyArray;
            }
            const node = type.node;
            const typeArguments = !node ? emptyArray :
                node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) :
                node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] :
                map((node as any).elements, getTypeFromTypeNode);
            if (popTypeResolution()) {
                type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
            }
            else {
                type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray);
                error(
                    type.node || currentNode,
                    type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves,
                    type.target.symbol && symbolToString(type.target.symbol),
                );
            }
        }
        return type.resolvedTypeArguments;
    }

    function findResolutionCycleStartIndex(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): number {
        for (let i = resolutionTargets.length - 1; i >= resolutionStart; i--) {
            if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {
                return -1;
            }
            if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {
                return i;
            }
        }
        return -1;
    }

    function resolutionTargetHasProperty(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): boolean {
        switch (propertyName) {
            case TypeSystemPropertyName.Type:
                return !!getSymbolLinks(target as Symbol).type;
            case TypeSystemPropertyName.DeclaredType:
                return !!getSymbolLinks(target as Symbol).declaredType;
            // case TypeSystemPropertyName.ResolvedBaseConstructorType:
            //     return !!(target as InterfaceType).resolvedBaseConstructorType;
            case TypeSystemPropertyName.ResolvedReturnType:
                return !!(target as Signature).resolvedReturnType;
            case TypeSystemPropertyName.ImmediateBaseConstraint:
                return !!(target as Type).immediateBaseConstraint;
            case TypeSystemPropertyName.ResolvedTypeArguments:
                return !!(target as TypeReference).resolvedTypeArguments;
            case TypeSystemPropertyName.ResolvedBaseTypes:
                return !!(target as InterfaceType).baseTypesResolved;
            case TypeSystemPropertyName.WriteType:
                return !!getSymbolLinks(target as Symbol).writeType;
            case TypeSystemPropertyName.ParameterInitializerContainsUndefined:
                return getNodeLinks(target as ParameterDeclaration).parameterInitializerContainsUndefined !== undefined;
        }
        // @ts-ignore
        return Debug.assertNever(propertyName);
    }
    /**
     * Push an entry on the type resolution stack. If an entry with the given target and the given property name
     * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
     * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
     * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
     * In order to see if the same query has already been done before, the target object and the propertyName both
     * must match the one passed in.
     *
     * @param target The symbol, type, or signature whose type is being queried
     * @param propertyName The property name that should be used to query the target for its type
     */
    function pushTypeResolution(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): boolean {
        const resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
        if (resolutionCycleStartIndex >= 0) {
            // A cycle was found
            const { length } = resolutionTargets;
            for (let i = resolutionCycleStartIndex; i < length; i++) {
                resolutionResults[i] = false;
            }
            return false;
        }
        resolutionTargets.push(target);
        resolutionResults.push(/*items*/ true);
        resolutionPropertyNames.push(propertyName);
        return true;
    }

    function widenTypeForVariableLikeDeclaration(type: Type | undefined, declaration: any, reportErrors?: boolean) {
        if (type) {
            // TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
            // if (type.flags & TypeFlags.ESSymbol && isGlobalSymbolConstructor(declaration.parent)) {
            //     type = getESSymbolLikeTypeForNode(declaration);
            // }
            if (reportErrors) {
                reportErrorsFromWidening(declaration, type);
            }

            // always widen a 'unique symbol' type if the type was created for a different declaration.
            // if (type.flags & TypeFlags.UniqueESSymbol && (isBindingElement(declaration) || !declaration.type) && type.symbol !== getSymbolOfDeclaration(declaration)) {
            //     type = esSymbolType;
            // }

            return getWidenedType(type);
        }

        // Rest parameters default to type any[], other parameters default to type any
        type = isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType;

        // Report implicit any errors unless this is a private property within an ambient declaration
        if (reportErrors) {
            // if (!declarationBelongsToPrivateAmbientMember(declaration)) {
            //     reportImplicitAny(declaration, type);
            // }
        }
        return type;
    }

    
    // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
    // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
    // is a bit more involved. For example:
    //
    //   var [x, s = ""] = [1, "one"];
    //
    // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
    // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
    // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
    function getWidenedTypeForVariableLikeDeclaration(declaration: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag, reportErrors?: boolean): Type {
        return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true, CheckMode.Normal), declaration, reportErrors);
    }
    
    function containsArgumentsReference(declaration: SignatureDeclaration): boolean {
        const links = getNodeLinks(declaration);
        if (links.containsArgumentsReference === undefined) {
            if (links.flags & NodeCheckFlags.CaptureArguments) {
                links.containsArgumentsReference = true;
            }
            else {
                links.containsArgumentsReference = traverse((declaration as FunctionLikeDeclaration).body!);
            }
        }
        return links.containsArgumentsReference;

        function traverse(node: Node): boolean {
            if (!node) return false;
            switch (node.kind) {
                case SyntaxKind.Identifier:
                    return (node as Identifier).text === argumentsSymbol.name && getReferencedValueSymbol(node as Identifier) === argumentsSymbol;

                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.MethodDeclaration:                
                    return (node as NamedDeclaration).name!.kind === SyntaxKind.ComputedPropertyName
                        && traverse((node as NamedDeclaration).name!);

                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                    return traverse((node as PropertyAccessExpression | ElementAccessExpression).expression);

                case SyntaxKind.PropertyAssignment:
                    return traverse((node as PropertyAssignment).initializer);

                default:
                    return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);
            }
        }
    }

    function checkJSDocCommentWorker(node: string | readonly JSDocComment[] | undefined) {
        if (isArray(node)) {
            forEach(node, tag => {
                if (isJSDocLinkLike(tag)) {
                    checkSourceElement(tag);
                }
            });
        }
    }
    
    function checkTypeNameIsReserved(name: Identifier, message: DiagnosticMessage): void {
        // TS 1.0 spec (April 2014): 3.6.1
        // The predefined type keywords are reserved and cannot be used as names of user defined types.
        switch (name.text) {
            case "any":
            case "unknown":
            case "never":
            case "number":
            case "bigint":
            case "boolean":
            case "string":
            case "symbol":
            case "void":
            case "object":
            case "undefined":
                error(name, message, name.text as string);
        }
    }

    function hasNonCircularTypeParameterDefault(typeParameter: TypeParameter) {
        return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
    }
    
    function checkTypeParameter(node: TypeParameterDeclaration) {
        // Grammar Checking
        checkGrammarModifiers(node);
        if (node.expression) {
            grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected);
        }

        checkSourceElement(node.constraint);
        checkSourceElement(node.default);
        const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
        // Resolve base constraint to reveal circularity errors
        getBaseConstraintOfType(typeParameter);
        if (!hasNonCircularTypeParameterDefault(typeParameter)) {
            error(node.default, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
        }
        const constraintType = getConstraintOfTypeParameter(typeParameter);
        const defaultType = getDefaultFromTypeParameter(typeParameter);
        if (constraintType && defaultType) {
            checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
        }
        checkNodeDeferred(node);
        addLazyDiagnostic(() => checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0));
    }

    /**
     * Check each type parameter and check that type parameters have no duplicate type parameter declarations
     */
    function checkTypeParameters(typeParameterDeclarations: readonly TypeParameterDeclaration[] | undefined) {
        let seenDefault = false;
        if (typeParameterDeclarations) {
            for (let i = 0; i < typeParameterDeclarations.length; i++) {
                const node = typeParameterDeclarations[i];
                checkTypeParameter(node);

                addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));
            }
        }

        function createCheckTypeParameterDiagnostic(node: TypeParameterDeclaration, i: number) {
            return () => {
                if (node.default) {
                    seenDefault = true;
                    checkTypeParametersNotReferenced(node.default, typeParameterDeclarations!, i);
                }
                else if (seenDefault) {
                    error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                }
                for (let j = 0; j < i; j++) {
                    if (typeParameterDeclarations![j].symbol === node.symbol) {
                        error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));
                    }
                }
            };
        }
    }

    /** Check that type parameter defaults only reference previously declared type parameters */
    function checkTypeParametersNotReferenced(root: TypeNode, typeParameters: readonly TypeParameterDeclaration[], index: number) {
        visit(root);
        function visit(node: Node) {
            if (node.kind === SyntaxKind.TypeReference) {
                const type = getTypeFromTypeReference(node as TypeReferenceNode);
                if (type.flags & TypeFlags.TypeParameter) {
                    for (let i = index; i < typeParameters.length; i++) {
                        if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {
                            error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
                        }
                    }
                }
            }
            forEachChild(node, visit);
        }
    }
    
    function checkJSDocVariableTag(node: JSDocVariableTag) {
        let lastErr: Diagnostic;
        if (!node.typeExpression) {            
            lastErr = error(node.name, Diagnostics.LPCDoc_var_tag_should_have_a_type_annotation);
        }
        
        // make sure there are no other tag types in this comment block
        const host = node.parent; 
        if (!lastErr && some(host.tags, tag => !isJSDocVariableTag(tag))) {
            lastErr = error(node.name, Diagnostics.LPCDoc_var_tags_must_be_in_their_own_LPCDoc_comment);
        }

        // check to make sure an inherited variable exists
        if (!lastErr) {
            if (!nodeIsMissing(node.name)) {
                const name = isIdentifier(node.name) ? node.name : node.name.right;                
                const varSymbol = resolveName(node.name, name, SymbolFlags.Variable, Diagnostics.Cannot_find_name_0, false, true);
                if (varSymbol) {
                    const varSourceFile = getSourceFileOfNode(varSymbol.valueDeclaration);
                    const tagSourceFile = getSourceFileOfNode(node);
                    if (varSourceFile == tagSourceFile) {
                        lastErr = error(node.name, Diagnostics.LPCDoc_var_tags_can_only_annotate_inherited_variables_0_is_a_local_variable, name.text);
                    }
                }
            } else {
                lastErr = error(node.name, Diagnostics.LPCDoc_var_tag_should_provide_a_variable_name);
            }
        }

        checkSourceElement(node.typeExpression);        
    }

    function checkJSDocTypeAliasTag(node: JSDocTypedefTag | JSDocCallbackTag) {
        if (!node.typeExpression) {
            // If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
            error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
        }

        if (node.name) {
            checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
        }
        checkSourceElement(node.typeExpression);
        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
    }

    function checkJSDocTemplateTag(node: JSDocTemplateTag): void {
        checkSourceElement(node.constraint);
        for (const tp of node.typeParameters) {
            checkSourceElement(tp);
        }
    }

    function checkJSDocTypeTag(node: JSDocTypeTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocLinkLikeTag(node: JSDocLink | JSDocLinkCode | JSDocLinkPlain) {
        if (node.name) {
            resolveJSDocMemberName(node.name, /*ignoreErrors*/ true);
        }
    }
    
    function checkJSDocParameterTag(node: JSDocParameterTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocPropertyTag(node: JSDocPropertyTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocReturnTag(node: JSDocReturnTag) {
        checkSourceElement(node.typeExpression);
    }

    function checkJSDocFunctionType(node: JSDocFunctionType): void {
        addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny);
        checkSignatureDeclaration(node);

        function checkJSDocFunctionTypeImplicitAny() {
            if (!node.type) {
                reportImplicitAny(node, anyType);
            }
        }
    }

    function checkUnmatchedJSDocParameters(node: SignatureDeclaration) {
        const jsdocParameters = filter(getJSDocTags(node), isJSDocParameterTag);
        if (!length(jsdocParameters)) return;

        const isJs = isInJSFile(node);
        const parameters = new Set<string>();
        const excludedParameters = new Set<number>();
        forEach(node.parameters, ({ name }, index) => {
            if (name && isIdentifier(name)) {
                parameters.add(name.text);
            }
            if (name && isBindingPattern(name)) {
                excludedParameters.add(index);
            }
        });

        const containsArguments = containsArgumentsReference(node);
        if (containsArguments) {
            const lastJSDocParamIndex = jsdocParameters.length - 1;
            const lastJSDocParam = jsdocParameters[lastJSDocParamIndex];
            if (
                isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression &&
                lastJSDocParam.typeExpression.type && !parameters.has(lastJSDocParam.name.text) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type))
            ) {
                error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name));
            }
        }
        else {
            forEach(jsdocParameters, ({ name, isNameFirst }, index) => {
                if (excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.text)) {
                    return;
                }
                if (isQualifiedName(name)) {
                    if (isJs) {
                        error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left));
                    }
                }
                else {
                    if (!isNameFirst) {
                        errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name));
                    }
                }
            });
        }
    }

    function isContextSensitiveFunctionOrObjectLiteralMethod(func: Node): func is FunctionExpression | InlineClosureExpression  {
        return (isFunctionExpressionOrInlineClosure(func)) &&// || isObjectLiteralMethod(func)) &&
            isContextSensitiveFunctionLikeDeclaration(func);
    }

    /**
     * Returns the effective arguments for an expression that works like a function invocation.
     */
    function getEffectiveCallArguments(node: CallLikeExpression): readonly Expression[] {
        // if (node.kind === SyntaxKind.BinaryExpression) {
        //     return [node.left];
        // }
        const args = node.arguments || emptyArray;
        const spreadIndex = getSpreadArgumentIndex(args);
        if (spreadIndex >= 0) {
            // Create synthetic arguments from spreads of tuple types.
            const effectiveArgs = args.slice(0, spreadIndex);
            for (let i = spreadIndex; i < args.length; i++) {
                const arg = args[i];
                // We can call checkExpressionCached because spread expressions never have a contextual type.
                const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));
                // if (spreadType && isTupleType(spreadType)) {
                //     forEach(getElementTypes(spreadType), (t, i) => {
                //         const flags = spreadType.target.elementFlags[i];
                //         const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t, !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);
                //         effectiveArgs.push(syntheticArg);
                //     });
                // }
                // else {
                    effectiveArgs.push(arg);
                // }
            }
            return effectiveArgs;
        }
        return args;
    }

    function getWidenedLiteralType(type: Type): Type {
        return type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType :
            type.flags & TypeFlags.IntLiteral && isFreshLiteralType(type) ? intType :
            type.flags & TypeFlags.FloatLiteral && isFreshLiteralType(type) ? floatType :
            type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type) ? booleanType :
            type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedLiteralType) :
            type;
    }

    function getRestTypeAtPosition(source: Signature, pos: number, readonly?: boolean): Type {
        console.warn("todo - getRestTypeAtPosition");
        return anyType;
    }

    // Return contextual type of parameter or undefined if no contextual type is available
    function getContextuallyTypedParameterType(parameter: ParameterDeclaration): Type | undefined {
        const func = parameter.parent;
        if (!isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            return undefined;
        }
        const iife = getImmediatelyInvokedFunctionExpression(func);
        if (iife && iife.arguments) {
            const args = getEffectiveCallArguments(iife);
            const indexOfParameter = func.parameters.indexOf(parameter);
            if (parameter.dotDotDotToken) {
                return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, /*context*/ undefined, CheckMode.Normal);
            }
            const links = getNodeLinks(iife);
            const cached = links.resolvedSignature;
            links.resolvedSignature = anySignature;
            const type = indexOfParameter < args.length ?
                getWidenedLiteralType(checkExpression(args[indexOfParameter])) :
                parameter.initializer ? undefined : undefinedWideningType;
            links.resolvedSignature = cached;
            return type;
        }
        const contextualSignature = getContextualSignature(func);
        if (contextualSignature) {
            const index = func.parameters.indexOf(parameter);
            return parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ?
                getRestTypeAtPosition(contextualSignature, index) :
                tryGetTypeAtPosition(contextualSignature, index);
        }
    }

    function getEffectiveDeclarationFlags(n: Declaration, flagsToCheck: ModifierFlags): ModifierFlags {
        let flags = getCombinedModifierFlagsCached(n);

        // children of classes (even ambient classes) should not be marked as ambient or export
        // because those flags have no useful semantics there.
        if (
            // n.parent.kind !== SyntaxKind.InterfaceDeclaration &&
            n.parent.kind !== SyntaxKind.ClassDeclaration &&
            n.parent.kind !== SyntaxKind.ClassExpression &&
            n.flags & NodeFlags.Ambient
        ) {
            const container = getEnclosingContainer(n);
            if ((container && container.flags & NodeFlags.ExportContext) && !(flags & ModifierFlags.Ambient)) {
                // It is nested in an ambient export context, which means it is automatically exported
                flags |= ModifierFlags.Export;
            }
            flags |= ModifierFlags.Ambient;
        }

        return flags & flagsToCheck;
    }

    function checkFunctionOrConstructorSymbolWorker(symbol: Symbol): void {       
        function getCanonicalOverload(overloads: Declaration[], implementation: FunctionLikeDeclaration | undefined): Declaration {
            // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
            // Error on all deviations from this canonical set of flags
            // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
            // report the errors on those. To achieve this, we will say that the implementation is
            // the canonical signature only if it is in the same container as the first overload
            const implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
            return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
        }

        function checkFlagAgreementBetweenOverloads(overloads: Declaration[], implementation: FunctionLikeDeclaration | undefined, flagsToCheck: ModifierFlags, someOverloadFlags: ModifierFlags, allOverloadFlags: ModifierFlags): void {
            // Error if some overloads have a flag that is not shared by all overloads. To find the
            // deviations, we XOR someOverloadFlags with allOverloadFlags
            const someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
            if (someButNotAllOverloadFlags !== 0) {
                const canonicalFlags = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
                forEach(overloads, o => {
                    const deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
                    // if (deviation & ModifierFlags.Export) {
                    //     error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                    // }
                    // else if (deviation & ModifierFlags.Ambient) {
                    //     error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                    // }
                    // if (deviation & (ModifierFlags.Private | ModifierFlags.Protected)) {
                    //     error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                    // }
                    // else if (deviation & ModifierFlags.Abstract) {
                    //     error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                    // }
                });
            }
        }

        function checkQuestionTokenAgreementBetweenOverloads(overloads: Declaration[], implementation: FunctionLikeDeclaration | undefined, someHaveQuestionToken: boolean, allHaveQuestionToken: boolean): void {
            // if (someHaveQuestionToken !== allHaveQuestionToken) {
            //     const canonicalHasQuestionToken = hasQuestionToken(getCanonicalOverload(overloads, implementation));
            //     forEach(overloads, o => {
            //         const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;
            //         if (deviation) {
            //             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required);
            //         }
            //     });
            // }
        }

        const flagsToCheck: ModifierFlags = ModifierFlags.Export | ModifierFlags.Ambient | ModifierFlags.Private | ModifierFlags.Protected ;
        let someNodeFlags: ModifierFlags = ModifierFlags.None;
        let allNodeFlags = flagsToCheck;
        let someHaveQuestionToken = false;
        let allHaveQuestionToken = true;
        let hasOverloads = false;
        let bodyDeclaration: FunctionLikeDeclaration | undefined;
        let lastSeenNonAmbientDeclaration: FunctionLikeDeclaration | undefined;
        let previousDeclaration: SignatureDeclaration | undefined;

        const declarations = symbol.declarations;
        const isConstructor = (symbol.flags & SymbolFlags.Constructor) !== 0;

        // function reportImplementationExpectedError(node: SignatureDeclaration): void {
        //     if (node.name && nodeIsMissing(node.name)) {
        //         return;
        //     }

        //     let seen = false;
        //     const subsequentNode = forEachChild(node.parent, c => {
        //         if (seen) {
        //             return c;
        //         }
        //         else {
        //             seen = c === node;
        //         }
        //     });
        //     // We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
        //     // In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
        //     if (subsequentNode && subsequentNode.pos === node.end) {
        //         if (subsequentNode.kind === node.kind) {
        //             const errorNode: Node = (subsequentNode as FunctionLikeDeclaration).name || subsequentNode;
        //             const subsequentName = (subsequentNode as FunctionLikeDeclaration).name;
        //             if (
        //                 node.name && subsequentName && (
        //                     // both are private identifiers
        //                     // isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.text === subsequentName.text ||
        //                     // Both are computed property names
        //                     isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) ||
        //                     // Both are literal property names that are the same.
        //                     isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) &&
        //                         getTextOfIdentifierOrLiteral(node.name) === getTextOfIdentifierOrLiteral(subsequentName)
        //                 )
        //             ) {
        //                 const reportError = (node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature);
        //                 // we can get here in two cases
        //                 // 1. mixed static and instance class members
        //                 // 2. something with the same name was defined before the set of overloads that prevents them from merging
        //                 // here we'll report error only for the first case since for second we should already report error in binder
        //                 if (reportError) {
        //                     const diagnostic = Diagnostics.Function_overload_must_not_be_static;
        //                     error(errorNode, diagnostic);
        //                 }
        //                 return;
        //             }
        //             if (nodeIsPresent((subsequentNode as FunctionLikeDeclaration).body)) {
        //                 error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name));
        //                 return;
        //             }
        //         }
        //     }
        //     const errorNode: Node = node.name || node;
        //     // if (isConstructor) {
        //     //     error(errorNode, Diagnostics.Constructor_implementation_is_missing);
        //     // }
        //     // else {
        //         // Report different errors regarding non-consecutive blocks of declarations depending on whether
        //         // the node in question is abstract.
        //         // if (hasSyntacticModifier(node, ModifierFlags.Abstract)) {
        //         //     error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
        //         // }
        //         // else {
        //             error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
        //         // }
        //     // }
        // }

        let duplicateFunctionDeclaration = false;
        let multipleConstructorImplementation = false;
        let hasNonAmbientClass = false;
        const functionDeclarations = [] as Declaration[];
        if (declarations) {
            for (const current of declarations) {
                const node = current as SignatureDeclaration | ClassDeclaration | ClassExpression;
                const inAmbientContext = node.flags & NodeFlags.Ambient;
                const inAmbientContextOrInterface = node.parent && (node.parent.kind === SyntaxKind.TypeLiteral) || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    // check if declarations are consecutive only if they are non-ambient
                    // 1. ambient declarations can be interleaved
                    // i.e. this is legal
                    //     declare function foo();
                    //     declare function bar();
                    //     declare function foo();
                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                    previousDeclaration = undefined;
                }

                if ((node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression) && !inAmbientContext) {
                    hasNonAmbientClass = true;
                }

                if (node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature) {
                    functionDeclarations.push(node);
                    const currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    // someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node);
                    // allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node);
                    const bodyIsPresent = nodeIsPresent((node as FunctionLikeDeclaration).body);

                    if (bodyIsPresent && bodyDeclaration) {
                        if (isConstructor) {
                            multipleConstructorImplementation = true;
                        }
                        else {
                            duplicateFunctionDeclaration = true;
                        }
                    }
                    // else if (previousDeclaration?.parent === node.parent && previousDeclaration.end !== node.pos) {
                    //     reportImplementationExpectedError(previousDeclaration);
                    // }

                    if (bodyIsPresent) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node as FunctionLikeDeclaration;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }

                    previousDeclaration = node;

                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node as FunctionLikeDeclaration;
                    }
                }
                // if (isInJSFile(current) && isFunctionLike(current) && current.jsDoc) {
                //     hasOverloads = length(getJSDocOverloadTags(current)) > 0;
                // }
            }
        }

        // if (multipleConstructorImplementation) {
        //     forEach(functionDeclarations, declaration => {
        //         error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed);
        //     });
        // }

        if (duplicateFunctionDeclaration) {
            forEach(functionDeclarations, declaration => {
                error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation);
            });
        }

        if (hasNonAmbientClass && !isConstructor && symbol.flags & SymbolFlags.Function && declarations) {
            // const relatedDiagnostics = filter(declarations, d => d.kind === SyntaxKind.ClassDeclaration)
            //     .map(d => createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class));

            forEach(declarations, declaration => {
                const diagnostic = declaration.kind === SyntaxKind.ClassDeclaration
                    ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0
                    : declaration.kind === SyntaxKind.FunctionDeclaration
                    ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient
                    : undefined;
                if (diagnostic) {
                    addRelatedInfo(
                        error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)),
                        // ...relatedDiagnostics,
                    );
                }
            });
        }

        // Abstract methods can't have an implementation -- in particular, they don't need one.
        // if (
        //     lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&
        //     !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlags.Abstract) && !lastSeenNonAmbientDeclaration.questionToken
        // ) {
        //     reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
        // }

        if (hasOverloads) {
            if (declarations) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
            }

            if (bodyDeclaration) {
                const signatures = getSignaturesOfSymbol(symbol);
                const bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                for (const signature of signatures) {
                    if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                        const errorNode = bodySignature.declaration && isJSDocSignature(bodySignature.declaration)
                            ? (bodySignature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName
                            : bodySignature.declaration;
                        addRelatedInfo(
                            error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature),
                            createDiagnosticForNode(signature.declaration, Diagnostics.The_implementation_signature_is_declared_here),
                        );
                        break;
                    }
                }
            }
        }
    }

    function createTypeEraser(sources: readonly TypeParameter[]): TypeMapper {
        return createTypeMapper(sources, /*targets*/ undefined);
    }

    function createErasedSignature(signature: Signature) {
        // Create an instantiation of the signature where all type arguments are the any type.
        return instantiateSignature(signature, createTypeEraser(signature.typeParameters!), /*eraseTypeParameters*/ true);
    }

    function getErasedSignature(signature: Signature): Signature {
        return signature.typeParameters ?
            signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
            signature;
    }

    function isImplementationCompatibleWithOverload(implementation: Signature, overload: Signature): boolean {
        const erasedSource = getErasedSignature(implementation);
        const erasedTarget = getErasedSignature(overload);

        // First see if the return types are compatible in either direction.
        const sourceReturnType = getReturnTypeOfSignature(erasedSource);
        const targetReturnType = getReturnTypeOfSignature(erasedTarget);
        if (
            targetReturnType === voidType
            || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)
            || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)
        ) {
            return isSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);
        }

        return false;
    }

    function isSignatureAssignableTo(source: Signature, target: Signature, ignoreReturnTypes: boolean): boolean {
        return compareSignaturesRelated(source, target, ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None, /*reportErrors*/ false, /*errorReporter*/ undefined, /*incompatibleErrorReporter*/ undefined, compareTypesAssignable, /*reportUnreliableMarkers*/ undefined) !== Ternary.False;
    }

    /**
     * Returns true if `s` is `(...args: A) => R` where `A` is `any`, `any[]`, `never`, or `never[]`, and `R` is `any` or `unknown`.
     */
    function isTopSignature(s: Signature) {
        if (!s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length === 1 && signatureHasRestParameter(s)) {
            const paramType = getTypeOfParameter(s.parameters[0]);
            const restType = isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType;
            return !!(restType.flags & (TypeFlags.Any | TypeFlags.Never) && getReturnTypeOfSignature(s).flags & TypeFlags.AnyOrUnknown);
        }
        return false;
    }

    function createCanonicalSignature(signature: Signature) {
        // Create an instantiation of the signature where each unconstrained type parameter is replaced with
        // its original. When a generic class or interface is instantiated, each generic method in the class or
        // interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
        // where different generations of the same type parameter are in scope). This leads to a lot of new type
        // identities, and potentially a lot of work comparing those identities, so here we create an instantiation
        // that uses the original type identities for all unconstrained type parameters.
        return getSignatureInstantiation(
            signature,
            map(signature.typeParameters, tp => tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp),
            isInJSFile(signature.declaration),
        );
    }


    function getCanonicalSignature(signature: Signature): Signature {
        return signature.typeParameters ?
            signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
            signature;
    }

    function applyToParameterTypes(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {
        const sourceCount = getParameterCount(source);
        const targetCount = getParameterCount(target);
        const sourceRestType = getEffectiveRestType(source);
        const targetRestType = getEffectiveRestType(target);
        const targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
        const paramCount = sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount);
        // const sourceThisType = getThisTypeOfSignature(source);
        // if (sourceThisType) {
        //     const targetThisType = getThisTypeOfSignature(target);
        //     if (targetThisType) {
        //         callback(sourceThisType, targetThisType);
        //     }
        // }
        for (let i = 0; i < paramCount; i++) {
            callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
        }
        if (targetRestType) {
            callback(getRestTypeAtPosition(source, paramCount, /*readonly*/ false), targetRestType);
        }
    }

    // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
    function instantiateSignatureInContextOf(signature: Signature, contextualSignature: Signature, inferenceContext?: InferenceContext, compareTypes?: TypeComparer): Signature {
        const context = createInferenceContext(signature.typeParameters!, signature, InferenceFlags.None, compareTypes);
        // We clone the inferenceContext to avoid fixing. For example, when the source signature is <T>(x: T) => T[] and
        // the contextual signature is (...args: A) => B, we want to infer the element type of A's constraint (say 'any')
        // for T but leave it possible to later infer '[any]' back to A.
        const restType = getEffectiveRestType(contextualSignature);
        const mapper = inferenceContext && (restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper);
        const sourceSignature = mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature;
        applyToParameterTypes(sourceSignature, signature, (source, target) => {
            // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
            inferTypes(context.inferences, source, target);
        });
        if (!inferenceContext) {
            applyToReturnTypes(contextualSignature, signature, (source, target) => {
                inferTypes(context.inferences, source, target, InferencePriority.ReturnType);
            });
        }
        return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration));
    }

    function typePredicateKindsMatch(a: TypePredicate, b: TypePredicate): boolean {
        return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
    }
    
    function applyToReturnTypes(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {
        const targetTypePredicate = getTypePredicateOfSignature(target);
        if (targetTypePredicate) {
            const sourceTypePredicate = getTypePredicateOfSignature(source);
            if (sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type) {
                callback(sourceTypePredicate.type, targetTypePredicate.type);
                return;
            }
        }
        const targetReturnType = getReturnTypeOfSignature(target);
        if (couldContainTypeVariables(targetReturnType)) {
            callback(getReturnTypeOfSignature(source), targetReturnType);
        }
    }

    function getTypePredicateParent(node: Node): SignatureDeclaration | undefined {
        switch (node.parent.kind) {
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.CallSignature:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.FunctionType:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:            
                const parent = node.parent as SignatureDeclaration;
                if (node === parent.type) {
                    return parent;
                }
            case SyntaxKind.JSDocTypeExpression:            
                return getJSDocHost(node) as SignatureDeclaration;
        }
    }

    function checkTypePredicate(node: TypePredicateNode): void {
        const parent = getTypePredicateParent(node);
        if (!parent) {
            // The parent must not be valid.
            error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
            return;
        }

        const signature = getSignatureFromDeclaration(parent);
        const typePredicate = getTypePredicateOfSignature(signature);
        if (!typePredicate) {
            return;
        }

        checkSourceElement(node.type);

        const { parameterName } = node;
        // if (typePredicate.kind === TypePredicateKind.This || typePredicate.kind === TypePredicateKind.AssertsThis) {
        //     getTypeFromThisTypeNode(parameterName as ThisTypeNode);
        // }
        // else {
            if (typePredicate.parameterIndex >= 0) {
                if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) {
                    error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                }
                else {
                    if (typePredicate.type) {
                        const leadingError = () => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type);
                        checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, /*headMessage*/ undefined, leadingError);
                    }
                }
            }
            else if (parameterName) {
                let hasReportedError = false;
                for (const { name } of parent.parameters) {
                    if (
                        isBindingPattern(name) &&
                        checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)
                    ) {
                        hasReportedError = true;
                        break;
                    }
                }
                if (!hasReportedError) {
                    error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                }
            }
        // }
    }
    
    function checkIfTypePredicateVariableIsDeclaredInBindingPattern(
        pattern: BindingPattern,
        predicateVariableNode: Node,
        predicateVariableName: string,
    ) {
        for (const element of pattern.elements) {
            if (isOmittedExpression(element)) {
                continue;
            }

            const name = element.name;
            if (name.kind === SyntaxKind.Identifier && name.text === predicateVariableName) {
                error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                return true;
            }
            else if (name.kind === SyntaxKind.ArrayBindingPattern){// || name.kind === SyntaxKind.ObjectBindingPattern) {
                if (
                    checkIfTypePredicateVariableIsDeclaredInBindingPattern(
                        name,
                        predicateVariableNode,
                        predicateVariableName,
                    )
                ) {
                    return true;
                }
            }
        }
    }

    function getUnionOrIntersectionTypePredicate(signatures: readonly Signature[], kind: TypeFlags | undefined): TypePredicate | undefined {
        let last: TypePredicate | undefined;
        const types: Type[] = [];
        for (const sig of signatures) {
            const pred = getTypePredicateOfSignature(sig);
            if (pred) {
                // Constituent type predicates must all have matching kinds. We don't create composite type predicates for assertions.
                if (/*pred.kind !== TypePredicateKind.This &&*/ pred.kind !== TypePredicateKind.Identifier || last && !typePredicateKindsMatch(last, pred)) {
                    return undefined;
                }
                last = pred;
                types.push(pred.type);
            }
            else {
                // In composite union signatures we permit and ignore signatures with a return type `false`.
                const returnType = kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined;
                if (returnType !== falseType && returnType !== regularFalseType) {
                    return undefined;
                }
            }
        }
        if (!last) {
            return undefined;
        }
        const compositeType = getUnionOrIntersectionType(types, kind);
        return createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType);
    }

    function createTypePredicate(kind: TypePredicateKind, parameterName: string | undefined, parameterIndex: number | undefined, type: Type | undefined): TypePredicate {
        return { kind, parameterName, parameterIndex, type } as TypePredicate;
    }
    
    function instantiateTypePredicate(predicate: TypePredicate, mapper: TypeMapper): TypePredicate {
        return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
    }

    function getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined {        
        if (!signature.resolvedTypePredicate) {
            if (signature.target) {
                const targetTypePredicate = getTypePredicateOfSignature(signature.target);
                signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate;
            }
            else if (signature.compositeSignatures) {
                signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
            }
            else {
                const type = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
                let jsdocPredicate: TypePredicate | undefined;
                if (!type) {
                    const jsdocSignature = getSignatureOfTypeTag(signature.declaration!);
                    if (jsdocSignature && signature !== jsdocSignature) {
                        jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                    }
                }
                if (type || jsdocPredicate) {
                    signature.resolvedTypePredicate = type && isTypePredicateNode(type) ?
                        createTypePredicateFromTypePredicateNode(type, signature) :
                        jsdocPredicate || noTypePredicate;
                }
                else if (signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags & TypeFlags.Boolean) && getParameterCount(signature) > 0) {
                    const { declaration } = signature;
                    signature.resolvedTypePredicate = noTypePredicate; // avoid infinite loop
                    signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate;
                }
                else {
                    signature.resolvedTypePredicate = noTypePredicate;
                }
            }
            Debug.assert(!!signature.resolvedTypePredicate);
        }
        return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
    }

    function createTypePredicateFromTypePredicateNode(node: TypePredicateNode, signature: Signature): TypePredicate {
        const parameterName = node.parameterName;        
        const type = node.type && getTypeFromTypeNode(node.type);
        return parameterName.kind === SyntaxKind.ThisType ?
            createTypePredicate(/*node.assertsModifier ? TypePredicateKind.AssertsThis : */TypePredicateKind.This, /*parameterName*/ undefined, /*parameterIndex*/ undefined, type) :
            createTypePredicate(/*node.assertsModifier ? TypePredicateKind.AssertsIdentifier : */TypePredicateKind.Identifier, parameterName.text as string, findIndex(signature.parameters, p => p.name === parameterName.text), type);
    }

    function getTypePredicateFromBody(func: FunctionLikeDeclaration): TypePredicate | undefined {
        // switch (func.kind) {
        //     case SyntaxKind.Constructor:
        //     case SyntaxKind.GetAccessor:
        //     case SyntaxKind.SetAccessor:
        //         return undefined;
        // }
        const functionFlags = getFunctionFlags(func);
        if (functionFlags !== FunctionFlags.Normal) return undefined;

        // Only attempt to infer a type predicate if there's exactly one return.
        let singleReturn: Expression | undefined;
        if (func.body && func.body.kind !== SyntaxKind.Block) {
            singleReturn = func.body; // arrow function
        }
        else {
            const bailedEarly = forEachReturnStatement(func.body as Block, returnStatement => {
                if (singleReturn || !returnStatement.expression) return true;
                singleReturn = returnStatement.expression;
            });
            if (bailedEarly || !singleReturn || functionHasImplicitReturn(func)) return undefined;
        }
        return checkIfExpressionRefinesAnyParameter(func, singleReturn);
    }

    function checkIfExpressionRefinesAnyParameter(func: FunctionLikeDeclaration, expr: Expression): TypePredicate | undefined {
        expr = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
        const returnType = checkExpressionCached(expr);
        if (!(returnType.flags & TypeFlags.Boolean)) return undefined;

        return forEach(func.parameters, (param, i) => {
            const initType = getTypeOfSymbol(param.symbol);
            if (!initType || initType.flags & TypeFlags.Boolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param)) {
                // Refining "x: boolean" to "x is true" or "x is false" isn't useful.
                return;
            }
            const trueType = checkIfExpressionRefinesParameter(func, expr, param, initType);
            if (trueType) {
                return createTypePredicate(TypePredicateKind.Identifier, (param.name.text), i, trueType);
            }
        });
    }

    function checkIfExpressionRefinesParameter(func: FunctionLikeDeclaration, expr: Expression, param: ParameterDeclaration, initType: Type): Type | undefined {
        const antecedent = (expr as Expression & { flowNode?: FlowNode; }).flowNode ||
            expr.parent.kind === SyntaxKind.ReturnStatement && (expr.parent as ReturnStatement).flowNode ||
            createFlowNode(FlowFlags.Start, /*node*/ undefined, /*antecedent*/ undefined);
        const trueCondition = createFlowNode(FlowFlags.TrueCondition, expr, antecedent);

        const trueType = getFlowTypeOfReference(param.name, initType, initType, func, trueCondition);
        if (trueType === initType) return undefined;

        // "x is T" means that x is T if and only if it returns true. If it returns false then x is not T.
        // This means that if the function is called with an argument of type trueType, there can't be anything left in the `else` branch. It must reduce to `never`.
        const falseCondition = createFlowNode(FlowFlags.FalseCondition, expr, antecedent);
        const falseSubtype = getFlowTypeOfReference(param.name, initType, trueType, func, falseCondition);
        return falseSubtype.flags & TypeFlags.Never ? trueType : undefined;
    }

    function getInferredTypes(context: InferenceContext): Type[] {
        const result: Type[] = [];
        for (let i = 0; i < context.inferences.length; i++) {
            result.push(getInferredType(context, i));
        }
        return result;
    }

    function isTypeOrBaseIdenticalTo(s: Type, t: Type) {
        return t === missingType ? s === t :
            (isTypeIdenticalTo(s, t) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.IntLiteral));
    }

    function isTypeCloselyMatchedBy(s: Type, t: Type) {
        return !!(s.flags & TypeFlags.Object && t.flags & TypeFlags.Object && s.symbol && s.symbol === t.symbol ||
            s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol);
    }

    function hasSkipDirectInferenceFlag(node: Node) {
        return !!getNodeLinks(node).skipDirectInference;
    }

    function isFromInferenceBlockedSource(type: Type) {
        return !!(type.symbol && some(type.symbol.declarations, hasSkipDirectInferenceFlag));
    }

    /**
     * @returns `true` if `type` has the shape `[T[0]]` where `T` is `typeParameter`
     */
    function isTupleOfSelf(typeParameter: TypeParameter, type: Type) {
        return isTupleType(type) && getTupleElementType(type, 0) === getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type, "1");
    }

    function getTupleElementType(type: Type, index: number) {
        const propType = getTypeOfPropertyOfType(type, "" + index as string);
        if (propType) {
            return propType;
        }
        if (everyType(type, isTupleType)) {
            return getTupleElementTypeOutOfStartCount(type, index, compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined);
        }
        return undefined;
    }

    function getTotalFixedElementCount(type: TupleType) {
        return type.fixedLength + getEndElementCount(type, ElementFlags.Fixed);
    }

    function getTupleElementTypeOutOfStartCount(type: Type, index: number, undefinedOrMissingType: Type | undefined) {
        return mapType(type, t => {
            const tupleType = t as TupleTypeReference;
            const restType = getRestTypeOfTupleType(tupleType);
            if (!restType) {
                return undefinedType;
            }
            if (undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target)) {
                return getUnionType([restType, undefinedOrMissingType]);
            }
            return restType;
        });
    }
    
    function isTypeParameterAtTopLevel(type: Type, tp: TypeParameter, depth = 0): boolean {
        return !!(type === tp ||
            type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isTypeParameterAtTopLevel(t, tp, depth)) ||
            depth < 3 && type.flags & TypeFlags.Conditional && (
                    isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type as ConditionalType), tp, depth + 1) ||
                    isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type as ConditionalType), tp, depth + 1)
                ));
    }

    function distributeIndexOverObjectType(objectType: Type, indexType: Type, writing: boolean) {
        // (T | U)[K] -> T[K] | U[K] (reading)
        // (T | U)[K] -> T[K] & U[K] (writing)
        // (T & U)[K] -> T[K] & U[K]
        if (objectType.flags & TypeFlags.Union || objectType.flags & TypeFlags.Intersection && !shouldDeferIndexType(objectType)) {
            const types = map((objectType as UnionOrIntersectionType).types, t => getSimplifiedType(getIndexedAccessType(t, indexType), writing));
            return objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types);
        }
    }

    /** Create an object with properties named in the string literal type. Every property has type `any` */
    function createEmptyObjectTypeFromStringLiteral(type: Type) {
        const members = createSymbolTable();
        forEachType(type, t => {
            if (!(t.flags & TypeFlags.StringLiteral)) {
                return;
            }
            const name = ((t as StringLiteralType).value);
            const literalProp = createSymbol(SymbolFlags.Property, name);
            literalProp.links.type = anyType;
            if (t.symbol) {
                literalProp.declarations = t.symbol.declarations;
                literalProp.valueDeclaration = t.symbol.valueDeclaration;
            }
            members.set(name, literalProp);
        });
        const indexInfos = type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly*/ false)] : emptyArray;
        return createAnonymousType(/*symbol*/ undefined, members, emptyArray, emptyArray, indexInfos);
    }

    function tupleTypesDefinitelyUnrelated(source: TupleTypeReference, target: TupleTypeReference) {
        return !(target.target.combinedFlags & ElementFlags.Variadic) && target.target.minLength > source.target.minLength ||
            !target.target.hasRestElement && (source.target.hasRestElement || target.target.fixedLength < source.target.fixedLength);
    }

    function typesDefinitelyUnrelated(source: Type, target: Type) {
        // Two tuple types with incompatible arities are definitely unrelated.
        // Two object types that each have a property that is unmatched in the other are definitely unrelated.
        return isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) :
            !!getUnmatchedProperty(source, target, /*requireOptionalProperties*/ false, /*matchDiscriminantProperties*/ true) &&
            !!getUnmatchedProperty(target, source, /*requireOptionalProperties*/ false, /*matchDiscriminantProperties*/ false);
    }

    function isTupleTypeStructureMatching(t1: TupleTypeReference, t2: TupleTypeReference) {
        return getTypeReferenceArity(t1) === getTypeReferenceArity(t2) &&
            every(t1.target.elementFlags, (f, i) => (f & ElementFlags.Variable) === (t2.target.elementFlags[i] & ElementFlags.Variable));
    }

    function getBaseSignature(signature: Signature) {
        const typeParameters = signature.typeParameters;
        if (typeParameters) {
            if (signature.baseSignatureCache) {
                return signature.baseSignatureCache;
            }
            const typeEraser = createTypeEraser(typeParameters);
            const baseConstraintMapper = createTypeMapper(typeParameters, map(typeParameters, tp => getConstraintOfTypeParameter(tp) || unknownType));
            let baseConstraints: readonly Type[] = map(typeParameters, tp => instantiateType(tp, baseConstraintMapper) || unknownType);
            // Run N type params thru the immediate constraint mapper up to N times
            // This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
            for (let i = 0; i < typeParameters.length - 1; i++) {
                baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);
            }
            // and then apply a type eraser to remove any remaining circularly dependent type parameters
            baseConstraints = instantiateTypes(baseConstraints, typeEraser);
            return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters*/ true);
        }
        return signature;
    }

    function removeMissingOrUndefinedType(type: Type): Type {
        return exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, TypeFacts.NEUndefined);
    }

    function inferTypes(inferences: InferenceInfo[], originalSource: Type, originalTarget: Type, priority = InferencePriority.None, contravariant = false) {
        let bivariant = false;
        let propagationType: Type;
        let inferencePriority: number = InferencePriority.MaxValue;
        let visited: Map<string, number>;
        let sourceStack: Type[];
        let targetStack: Type[];
        let expandingFlags = ExpandingFlags.None;
        inferFromTypes(originalSource, originalTarget);

        function inferFromTypes(source: Type, target: Type): void {
            if (!couldContainTypeVariables(target) || isNoInferType(target)) {
                return;
            }
            if (source === wildcardType || source === blockedStringType) {
                // We are inferring from an 'any' type. We want to infer this type for every type parameter
                // referenced in the target type, so we record it as the propagation type and infer from the
                // target to itself. Then, as we find candidates we substitute the propagation type.
                const savePropagationType = propagationType;
                propagationType = source;
                inferFromTypes(target, target);
                propagationType = savePropagationType;
                return;
            }
            if (source.aliasSymbol && source.aliasSymbol === target.aliasSymbol) {
                if (source.aliasTypeArguments) {
                    // Source and target are types originating in the same generic type alias declaration.
                    // Simply infer from source type arguments to target type arguments, with defaults applied.
                    const params = getSymbolLinks(source.aliasSymbol).typeParameters!;
                    const minParams = getMinTypeArgumentCount(params);
                    const sourceTypes = fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                    const targetTypes = fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                    inferFromTypeArguments(sourceTypes, targetTypes!, getAliasVariances(source.aliasSymbol));
                }
                // And if there weren't any type arguments, there's no reason to run inference as the types must be the same.
                return;
            }
            if (source === target && source.flags & TypeFlags.UnionOrIntersection) {
                // When source and target are the same union or intersection type, just relate each constituent
                // type to itself.
                for (const t of (source as UnionOrIntersectionType).types) {
                    inferFromTypes(t, t);
                }
                return;
            }
            if (target.flags & TypeFlags.Union) {
                // First, infer between identically matching source and target constituents and remove the
                // matching types.
                const [tempSources, tempTargets] = inferFromMatchingTypes(source.flags & TypeFlags.Union ? (source as UnionType).types : [source], (target as UnionType).types, isTypeOrBaseIdenticalTo);
                // Next, infer between closely matching source and target constituents and remove
                // the matching types. Types closely match when they are instantiations of the same
                // object type or instantiations of the same type alias.
                const [sources, targets] = inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy);
                if (targets.length === 0) {
                    return;
                }
                target = getUnionType(targets);
                if (sources.length === 0) {
                    // All source constituents have been matched and there is nothing further to infer from.
                    // However, simply making no inferences is undesirable because it could ultimately mean
                    // inferring a type parameter constraint. Instead, make a lower priority inference from
                    // the full source to whatever remains in the target. For example, when inferring from
                    // string to 'string | T', make a lower priority inference of string for T.
                    inferWithPriority(source, target, InferencePriority.NakedTypeVariable);
                    return;
                }
                source = getUnionType(sources);
            }
            else if (target.flags & TypeFlags.Intersection && !every((target as IntersectionType).types, isNonGenericObjectType)) {
                // We reduce intersection types unless they're simple combinations of object types. For example,
                // when inferring from 'string[] & { extra: any }' to 'string[] & T' we want to remove string[] and
                // infer { extra: any } for T. But when inferring to 'string[] & Iterable<T>' we want to keep the
                // string[] on the source side and infer string for T.
                if (!(source.flags & TypeFlags.Union)) {
                    // Infer between identically matching source and target constituents and remove the matching types.
                    const [sources, targets] = inferFromMatchingTypes(source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source], (target as IntersectionType).types, isTypeIdenticalTo);
                    if (sources.length === 0 || targets.length === 0) {
                        return;
                    }
                    source = getIntersectionType(sources);
                    target = getIntersectionType(targets);
                }
            }
            if (target.flags & (TypeFlags.IndexedAccess | TypeFlags.Substitution)) {
                if (isNoInferType(target)) {
                    return;
                }
                target = getActualTypeVariable(target);
            }
            if (target.flags & TypeFlags.TypeVariable) {
                // Skip inference if the source is "blocked", which is used by the language service to
                // prevent inference on nodes currently being edited.
                if (isFromInferenceBlockedSource(source)) {
                    return;
                }
                const inference = getInferenceInfoForType(target);
                if (inference) {
                    // If target is a type parameter, make an inference, unless the source type contains
                    // a "non-inferrable" type. Types with this flag set are markers used to prevent inference.
                    //
                    // For example:
                    //     - anyFunctionType is a wildcard type that's used to avoid contextually typing functions;
                    //       it's internal, so should not be exposed to the user by adding it as a candidate.
                    //     - autoType (and autoArrayType) is a special "any" used in control flow; like anyFunctionType,
                    //       it's internal and should not be observable.
                    //     - silentNeverType is returned by getInferredType when instantiating a generic function for
                    //       inference (and a type variable has no mapping).
                    //
                    // This flag is infectious; if we produce Box<never> (where never is silentNeverType), Box<never> is
                    // also non-inferrable.
                    //
                    // As a special case, also ignore nonInferrableAnyType, which is a special form of the any type
                    // used as a stand-in for binding elements when they are being inferred.
                    if (getObjectFlags(source) & ObjectFlags.NonInferrableType || source === nonInferrableAnyType) {
                        return;
                    }
                    if (!inference.isFixed) {
                        const candidate = propagationType || source;
                        if (candidate === blockedStringType) {
                            return;
                        }
                        if (inference.priority === undefined || priority < inference.priority) {
                            inference.candidates = undefined;
                            inference.contraCandidates = undefined;
                            inference.topLevel = true;
                            inference.priority = priority;
                        }
                        if (priority === inference.priority) {
                            // Inferring A to [A[0]] is a zero information inference (it guarantees A becomes its constraint), but oft arises from generic argument list inferences
                            // By discarding it early, we can allow more fruitful results to be used instead.
                            if (isTupleOfSelf(inference.typeParameter, candidate)) {
                                return;
                            }
                            // We make contravariant inferences only if we are in a pure contravariant position,
                            // i.e. only if we have not descended into a bivariant position.
                            if (contravariant && !bivariant) {
                                if (!contains(inference.contraCandidates, candidate)) {
                                    inference.contraCandidates = append(inference.contraCandidates, candidate);
                                    clearCachedInferences(inferences);
                                }
                            }
                            else if (!contains(inference.candidates, candidate)) {
                                inference.candidates = append(inference.candidates, candidate);
                                clearCachedInferences(inferences);
                            }
                        }
                        if (!(priority & InferencePriority.ReturnType) && target.flags & TypeFlags.TypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target as TypeParameter)) {
                            inference.topLevel = false;
                            clearCachedInferences(inferences);
                        }
                    }
                    inferencePriority = Math.min(inferencePriority, priority);
                    return;
                }
                // Infer to the simplified version of an indexed access, if possible, to (hopefully) expose more bare type parameters to the inference engine
                const simplified = getSimplifiedType(target, /*writing*/ false);
                if (simplified !== target) {
                    inferFromTypes(source, simplified);
                }
                else if (target.flags & TypeFlags.IndexedAccess) {
                    const indexType = getSimplifiedType((target as IndexedAccessType).indexType, /*writing*/ false);
                    // Generally simplifications of instantiable indexes are avoided to keep relationship checking correct, however if our target is an access, we can consider
                    // that key of that access to be "instantiated", since we're looking to find the infernce goal in any way we can.
                    if (indexType.flags & TypeFlags.Instantiable) {
                        const simplified = distributeIndexOverObjectType(getSimplifiedType((target as IndexedAccessType).objectType, /*writing*/ false), indexType, /*writing*/ false);
                        if (simplified && simplified !== target) {
                            inferFromTypes(source, simplified);
                        }
                    }
                }
            }
            if (
                getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (
                    (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)
                ) &&
                !((source as TypeReference).node && (target as TypeReference).node)
            ) {
                // If source and target are references to the same generic type, infer from type arguments
                inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target));
            }
            else if (source.flags & TypeFlags.Index && target.flags & TypeFlags.Index) {
                inferFromContravariantTypes((source as IndexType).type, (target as IndexType).type);
            }
            else if ((isLiteralType(source) || source.flags & TypeFlags.String) && target.flags & TypeFlags.Index) {
                const empty = createEmptyObjectTypeFromStringLiteral(source);
                inferFromContravariantTypesWithPriority(empty, (target as IndexType).type, InferencePriority.LiteralKeyof);
            }
            else if (source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess) {
                inferFromTypes((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType);
                inferFromTypes((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType);
            }
            else if (source.flags & TypeFlags.StringMapping && target.flags & TypeFlags.StringMapping) {
                if ((source as StringMappingType).symbol === (target as StringMappingType).symbol) {
                    inferFromTypes((source as StringMappingType).type, (target as StringMappingType).type);
                }
            }
            else if (source.flags & TypeFlags.Substitution) {
                inferFromTypes((source as SubstitutionType).baseType, target);
                inferWithPriority(getSubstitutionIntersection(source as SubstitutionType), target, InferencePriority.SubstituteSource); // Make substitute inference at a lower priority
            }
            else if (target.flags & TypeFlags.Conditional) {
                invokeOnce(source, target as ConditionalType, inferToConditionalType);
            }
            else if (target.flags & TypeFlags.UnionOrIntersection) {
                inferToMultipleTypes(source, (target as UnionOrIntersectionType).types, target.flags);
            }
            else if (source.flags & TypeFlags.Union) {
                // Source is a union or intersection type, infer from each constituent type
                const sourceTypes = (source as UnionOrIntersectionType).types;
                for (const sourceType of sourceTypes) {
                    inferFromTypes(sourceType, target);
                }
            }
            // else if (target.flags & TypeFlags.TemplateLiteral) {
            //     inferToTemplateLiteralType(source, target as TemplateLiteralType);
            // }
            else {
                source = getReducedType(source);
                if (isGenericMappedType(source) && isGenericMappedType(target)) {
                    invokeOnce(source, target, inferFromGenericMappedTypes);
                }
                if (!(priority & InferencePriority.NoConstraints && source.flags & (TypeFlags.Intersection | TypeFlags.Instantiable))) {
                    const apparentSource = getApparentType(source);
                    // getApparentType can return _any_ type, since an indexed access or conditional may simplify to any other type.
                    // If that occurs and it doesn't simplify to an object or intersection, we'll need to restart `inferFromTypes`
                    // with the simplified source.
                    if (apparentSource !== source && !(apparentSource.flags & (TypeFlags.Object | TypeFlags.Intersection))) {
                        return inferFromTypes(apparentSource, target);
                    }
                    source = apparentSource;
                }
                if (source.flags & (TypeFlags.Object | TypeFlags.Intersection)) {
                    invokeOnce(source, target, inferFromObjectTypes);
                }
            }
        }

        function inferWithPriority(source: Type, target: Type, newPriority: InferencePriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferFromTypes(source, target);
            priority = savePriority;
        }

        function inferFromContravariantTypesWithPriority(source: Type, target: Type, newPriority: InferencePriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferFromContravariantTypes(source, target);
            priority = savePriority;
        }

        function inferToMultipleTypesWithPriority(source: Type, targets: Type[], targetFlags: TypeFlags, newPriority: InferencePriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferToMultipleTypes(source, targets, targetFlags);
            priority = savePriority;
        }

        // Ensure an inference action is performed only once for the given source and target types.
        // This includes two things:
        // Avoiding inferring between the same pair of source and target types,
        // and avoiding circularly inferring between source and target types.
        // For an example of the last, consider if we are inferring between source type
        // `type Deep<T> = { next: Deep<Deep<T>> }` and target type `type Loop<U> = { next: Loop<U> }`.
        // We would then infer between the types of the `next` property: `Deep<Deep<T>>` = `{ next: Deep<Deep<Deep<T>>> }` and `Loop<U>` = `{ next: Loop<U> }`.
        // We will then infer again between the types of the `next` property:
        // `Deep<Deep<Deep<T>>>` and `Loop<U>`, and so on, such that we would be forever inferring
        // between instantiations of the same types `Deep` and `Loop`.
        // In particular, we would be inferring from increasingly deep instantiations of `Deep` to `Loop`,
        // such that we would go on inferring forever, even though we would never infer
        // between the same pair of types.
        function invokeOnce<Source extends Type, Target extends Type>(source: Source, target: Target, action: (source: Source, target: Target) => void) {
            const key = source.id + "," + target.id;
            const status = visited && visited.get(key);
            if (status !== undefined) {
                inferencePriority = Math.min(inferencePriority, status);
                return;
            }
            (visited || (visited = new Map<string, number>())).set(key, InferencePriority.Circularity);
            const saveInferencePriority = inferencePriority;
            inferencePriority = InferencePriority.MaxValue;
            // We stop inferring and report a circularity if we encounter duplicate recursion identities on both
            // the source side and the target side.
            const saveExpandingFlags = expandingFlags;
            (sourceStack ??= []).push(source);
            (targetStack ??= []).push(target);
            if (isDeeplyNestedType(source, sourceStack, sourceStack.length, 2)) expandingFlags |= ExpandingFlags.Source;
            if (isDeeplyNestedType(target, targetStack, targetStack.length, 2)) expandingFlags |= ExpandingFlags.Target;
            if (expandingFlags !== ExpandingFlags.Both) {
                action(source, target);
            }
            else {
                inferencePriority = InferencePriority.Circularity;
            }
            targetStack.pop();
            sourceStack.pop();
            expandingFlags = saveExpandingFlags;
            visited.set(key, inferencePriority);
            inferencePriority = Math.min(inferencePriority, saveInferencePriority);
        }

        function inferFromMatchingTypes(sources: Type[], targets: Type[], matches: (s: Type, t: Type) => boolean): [Type[], Type[]] {
            let matchedSources: Type[] | undefined;
            let matchedTargets: Type[] | undefined;
            for (const t of targets) {
                for (const s of sources) {
                    if (matches(s, t)) {
                        inferFromTypes(s, t);
                        matchedSources = appendIfUnique(matchedSources, s);
                        matchedTargets = appendIfUnique(matchedTargets, t);
                    }
                }
            }
            return [
                matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,
                matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,
            ];
        }

        function inferFromTypeArguments(sourceTypes: readonly Type[], targetTypes: readonly Type[], variances: readonly VarianceFlags[]) {
            const count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
            for (let i = 0; i < count; i++) {
                if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {
                    inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
                }
                else {
                    inferFromTypes(sourceTypes[i], targetTypes[i]);
                }
            }
        }

        function inferFromContravariantTypes(source: Type, target: Type) {
            contravariant = !contravariant;
            inferFromTypes(source, target);
            contravariant = !contravariant;
        }

        function inferFromContravariantTypesIfStrictFunctionTypes(source: Type, target: Type) {
            if (strictFunctionTypes || priority & InferencePriority.AlwaysStrict) {
                inferFromContravariantTypes(source, target);
            }
            else {
                inferFromTypes(source, target);
            }
        }

        function getInferenceInfoForType(type: Type) {
            if (type.flags & TypeFlags.TypeVariable) {
                for (const inference of inferences) {
                    if (type === inference.typeParameter) {
                        return inference;
                    }
                }
            }
            return undefined;
        }

        function getSingleTypeVariableFromIntersectionTypes(types: Type[]) {
            let typeVariable: Type | undefined;
            for (const type of types) {
                const t = type.flags & TypeFlags.Intersection && find((type as IntersectionType).types, t => !!getInferenceInfoForType(t));
                if (!t || typeVariable && t !== typeVariable) {
                    return undefined;
                }
                typeVariable = t;
            }
            return typeVariable;
        }

        function inferToMultipleTypes(source: Type, targets: Type[], targetFlags: TypeFlags) {
            let typeVariableCount = 0;
            if (targetFlags & TypeFlags.Union) {
                let nakedTypeVariable: Type | undefined;
                const sources = source.flags & TypeFlags.Union ? (source as UnionType).types : [source];
                const matched = new Array<boolean>(sources.length);
                let inferenceCircularity = false;
                // First infer to types that are not naked type variables. For each source type we
                // track whether inferences were made from that particular type to some target with
                // equal priority (i.e. of equal quality) to what we would infer for a naked type
                // parameter.
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        nakedTypeVariable = t;
                        typeVariableCount++;
                    }
                    else {
                        for (let i = 0; i < sources.length; i++) {
                            const saveInferencePriority = inferencePriority;
                            inferencePriority = InferencePriority.MaxValue;
                            inferFromTypes(sources[i], t);
                            if (inferencePriority === priority) matched[i] = true;
                            inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;
                            inferencePriority = Math.min(inferencePriority, saveInferencePriority);
                        }
                    }
                }
                if (typeVariableCount === 0) {
                    // If every target is an intersection of types containing a single naked type variable,
                    // make a lower priority inference to that type variable. This handles inferring from
                    // 'A | B' to 'T & (X | Y)' where we want to infer 'A | B' for T.
                    const intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(targets);
                    if (intersectionTypeVariable) {
                        inferWithPriority(source, intersectionTypeVariable, InferencePriority.NakedTypeVariable);
                    }
                    return;
                }
                // If the target has a single naked type variable and no inference circularities were
                // encountered above (meaning we explored the types fully), create a union of the source
                // types from which no inferences have been made so far and infer from that union to the
                // naked type variable.
                if (typeVariableCount === 1 && !inferenceCircularity) {
                    const unmatched = flatMap(sources, (s, i) => matched[i] ? undefined : s);
                    if (unmatched.length) {
                        inferFromTypes(getUnionType(unmatched), nakedTypeVariable!);
                        return;
                    }
                }
            }
            else {
                // We infer from types that are not naked type variables first so that inferences we
                // make from nested naked type variables and given slightly higher priority by virtue
                // of being first in the candidates array.
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        typeVariableCount++;
                    }
                    else {
                        inferFromTypes(source, t);
                    }
                }
            }
            // Inferences directly to naked type variables are given lower priority as they are
            // less specific. For example, when inferring from Promise<string> to T | Promise<T>,
            // we want to infer string for T, not Promise<string> | string. For intersection types
            // we only infer to single naked type variables.
            if (targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0) {
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        inferWithPriority(source, t, InferencePriority.NakedTypeVariable);
                    }
                }
            }
        }

        function inferToMappedType(source: Type, target: MappedType, constraintType: Type): boolean {
            if ((constraintType.flags & TypeFlags.Union) || (constraintType.flags & TypeFlags.Intersection)) {
                let result = false;
                for (const type of (constraintType as (UnionType | IntersectionType)).types) {
                    result = inferToMappedType(source, target, type) || result;
                }
                return result;
            }
            if (constraintType.flags & TypeFlags.Index) {
                // We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
                // where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
                // type and then make a secondary inference from that type to T. We make a secondary inference
                // such that direct inferences to T get priority over inferences to Partial<T>, for example.
                const inference = getInferenceInfoForType((constraintType as IndexType).type);
                if (inference && !inference.isFixed && !isFromInferenceBlockedSource(source)) {
                    const inferredType = inferTypeForHomomorphicMappedType(source, target, constraintType as IndexType);
                    if (inferredType) {
                        // We assign a lower priority to inferences made from types containing non-inferrable
                        // types because we may only have a partial result (i.e. we may have failed to make
                        // reverse inferences for some properties).
                        inferWithPriority(
                            inferredType,
                            inference.typeParameter,
                            getObjectFlags(source) & ObjectFlags.NonInferrableType ?
                                InferencePriority.PartialHomomorphicMappedType :
                                InferencePriority.HomomorphicMappedType,
                        );
                    }
                }
                return true;
            }
            if (constraintType.flags & TypeFlags.TypeParameter) {
                // We're inferring from some source type S to a mapped type { [P in K]: X }, where K is a type
                // parameter. First infer from 'keyof S' to K.
                inferWithPriority(getIndexType(source, /*indexFlags*/ !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None), constraintType, InferencePriority.MappedTypeConstraint);
                // If K is constrained to a type C, also infer to C. Thus, for a mapped type { [P in K]: X },
                // where K extends keyof T, we make the same inferences as for a homomorphic mapped type
                // { [P in keyof T]: X }. This enables us to make meaningful inferences when the target is a
                // Pick<T, K>.
                const extendedConstraint = getConstraintOfType(constraintType);
                if (extendedConstraint && inferToMappedType(source, target, extendedConstraint)) {
                    return true;
                }
                // If no inferences can be made to K's constraint, infer from a union of the property types
                // in the source to the template type X.
                const propTypes = map(getPropertiesOfType(source), getTypeOfSymbol);
                const indexTypes = map(getIndexInfosOfType(source), info => info !== enumNumberIndexInfo ? info.type : neverType);
                inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target));
                return true;
            }
            return false;
        }

        function inferToConditionalType(source: Type, target: ConditionalType) {
            if (source.flags & TypeFlags.Conditional) {
                inferFromTypes((source as ConditionalType).checkType, target.checkType);
                inferFromTypes((source as ConditionalType).extendsType, target.extendsType);
                inferFromTypes(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target));
                inferFromTypes(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target));
            }
            else {
                const targetTypes = [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)];
                inferToMultipleTypesWithPriority(source, targetTypes, target.flags, contravariant ? InferencePriority.ContravariantConditional : 0);
            }
        }

        function inferFromGenericMappedTypes(source: MappedType, target: MappedType) {
            // The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
            // from S to T and from X to Y.
            inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target));
            inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target));
            const sourceNameType = getNameTypeFromMappedType(source);
            const targetNameType = getNameTypeFromMappedType(target);
            if (sourceNameType && targetNameType) inferFromTypes(sourceNameType, targetNameType);
        }

        function inferFromObjectTypes(source: Type, target: Type) {
            if (
                getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (
                    (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)
                )
            ) {
                // If source and target are references to the same generic type, infer from type arguments
                inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target));
                return;
            }
            if (isGenericMappedType(source) && isGenericMappedType(target)) {
                inferFromGenericMappedTypes(source, target);
            }
            if (getObjectFlags(target) & ObjectFlags.Mapped && !(target as MappedType).declaration.nameType) {
                const constraintType = getConstraintTypeFromMappedType(target as MappedType);
                if (inferToMappedType(source, target as MappedType, constraintType)) {
                    return;
                }
            }
            // Infer from the members of source and target only if the two types are possibly related
            if (!typesDefinitelyUnrelated(source, target)) {
                if (isArrayOrTupleType(source)) {
                    if (isTupleType(target)) {
                        const sourceArity = getTypeReferenceArity(source);
                        const targetArity = getTypeReferenceArity(target);
                        const elementTypes = getTypeArguments(target);
                        const elementFlags = target.target.elementFlags;
                        // When source and target are tuple types with the same structure (fixed, variadic, and rest are matched
                        // to the same kind in each position), simply infer between the element types.
                        if (isTupleType(source) && isTupleTypeStructureMatching(source, target)) {
                            for (let i = 0; i < targetArity; i++) {
                                inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                            }
                            return;
                        }
                        const startLength = isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0;
                        const endLength = Math.min(isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0, target.target.hasRestElement ? getEndElementCount(target.target, ElementFlags.Fixed) : 0);
                        // Infer between starting fixed elements.
                        for (let i = 0; i < startLength; i++) {
                            inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                        }
                        if (!isTupleType(source) || sourceArity - startLength - endLength === 1 && source.target.elementFlags[startLength] & ElementFlags.Rest) {
                            // Single rest element remains in source, infer from that to every element in target
                            const restType = getTypeArguments(source)[startLength];
                            for (let i = startLength; i < targetArity - endLength; i++) {
                                inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);
                            }
                        }
                        else {
                            const middleLength = targetArity - startLength - endLength;
                            if (middleLength === 2) {
                                if (elementFlags[startLength] & elementFlags[startLength + 1] & ElementFlags.Variadic) {
                                    // Middle of target is [...T, ...U] and source is tuple type
                                    const targetInfo = getInferenceInfoForType(elementTypes[startLength]);
                                    if (targetInfo && targetInfo.impliedArity !== undefined) {
                                        // Infer slices from source based on implied arity of T.
                                        inferFromTypes(sliceTupleType(source, startLength, endLength + sourceArity - targetInfo.impliedArity), elementTypes[startLength]);
                                        inferFromTypes(sliceTupleType(source, startLength + targetInfo.impliedArity, endLength), elementTypes[startLength + 1]);
                                    }
                                }
                                else if (elementFlags[startLength] & ElementFlags.Variadic && elementFlags[startLength + 1] & ElementFlags.Rest) {
                                    // Middle of target is [...T, ...rest] and source is tuple type
                                    // if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
                                    const param = getInferenceInfoForType(elementTypes[startLength])?.typeParameter;
                                    const constraint = param && getBaseConstraintOfType(param);
                                    if (constraint && isTupleType(constraint) && !constraint.target.hasRestElement) {
                                        const impliedArity = constraint.target.fixedLength;
                                        inferFromTypes(sliceTupleType(source, startLength, sourceArity - (startLength + impliedArity)), elementTypes[startLength]);
                                        inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength)!, elementTypes[startLength + 1]);
                                    }
                                }
                                else if (elementFlags[startLength] & ElementFlags.Rest && elementFlags[startLength + 1] & ElementFlags.Variadic) {
                                    // Middle of target is [...rest, ...T] and source is tuple type
                                    // if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
                                    const param = getInferenceInfoForType(elementTypes[startLength + 1])?.typeParameter;
                                    const constraint = param && getBaseConstraintOfType(param);
                                    if (constraint && isTupleType(constraint) && !constraint.target.hasRestElement) {
                                        const impliedArity = constraint.target.fixedLength;
                                        const endIndex = sourceArity - getEndElementCount(target.target, ElementFlags.Fixed);
                                        const startIndex = endIndex - impliedArity;
                                        const trailingSlice = createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex), /*readonly*/ false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex));

                                        inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity)!, elementTypes[startLength]);
                                        inferFromTypes(trailingSlice, elementTypes[startLength + 1]);
                                    }
                                }
                            }
                            else if (middleLength === 1 && elementFlags[startLength] & ElementFlags.Variadic) {
                                // Middle of target is exactly one variadic element. Infer the slice between the fixed parts in the source.
                                // If target ends in optional element(s), make a lower priority a speculative inference.
                                const endsInOptional = target.target.elementFlags[targetArity - 1] & ElementFlags.Optional;
                                const sourceSlice = sliceTupleType(source, startLength, endLength);
                                inferWithPriority(sourceSlice, elementTypes[startLength], endsInOptional ? InferencePriority.SpeculativeTuple : 0);
                            }
                            else if (middleLength === 1 && elementFlags[startLength] & ElementFlags.Rest) {
                                // Middle of target is exactly one rest element. If middle of source is not empty, infer union of middle element types.
                                const restType = getElementTypeOfSliceOfTupleType(source, startLength, endLength);
                                if (restType) {
                                    inferFromTypes(restType, elementTypes[startLength]);
                                }
                            }
                        }
                        // Infer between ending fixed elements
                        for (let i = 0; i < endLength; i++) {
                            inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);
                        }
                        return;
                    }
                    if (isArrayType(target)) {
                        inferFromIndexTypes(source, target);
                        return;
                    }
                }
                inferFromProperties(source, target);
                inferFromSignatures(source, target, SignatureKind.Call);
                inferFromSignatures(source, target, SignatureKind.Construct);
                inferFromIndexTypes(source, target);
            }
        }

        function inferFromProperties(source: Type, target: Type) {
            const properties = getPropertiesOfObjectType(target);
            for (const targetProp of properties) {
                const sourceProp = getPropertyOfType(source, targetProp.name);
                if (sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag)) {
                    inferFromTypes(
                        removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags & SymbolFlags.Optional)),
                        removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags & SymbolFlags.Optional)),
                    );
                }
            }
        }

        function inferFromSignatures(source: Type, target: Type, kind: SignatureKind) {
            const sourceSignatures = getSignaturesOfType(source, kind);
            const sourceLen = sourceSignatures.length;
            if (sourceLen > 0) {
                // We match source and target signatures from the bottom up, and if the source has fewer signatures
                // than the target, we infer from the first source signature to the excess target signatures.
                const targetSignatures = getSignaturesOfType(target, kind);
                const targetLen = targetSignatures.length;
                for (let i = 0; i < targetLen; i++) {
                    const sourceIndex = Math.max(sourceLen - targetLen + i, 0);
                    inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));
                }
            }
        }

        function inferFromSignature(source: Signature, target: Signature) {
            if (!(source.flags & SignatureFlags.IsNonInferrable)) {
                const saveBivariant = bivariant;
                const kind = target.declaration ? target.declaration.kind : SyntaxKind.Unknown;
                // Once we descend into a bivariant signature we remain bivariant for all nested inferences
                bivariant = bivariant || kind === SyntaxKind.MethodDeclaration || kind === SyntaxKind.MethodSignature;// || kind === SyntaxKind.Constructor;
                applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes);
                bivariant = saveBivariant;
            }
            applyToReturnTypes(source, target, inferFromTypes);
        }

        function inferFromIndexTypes(source: Type, target: Type) {
            // Inferences across mapped type index signatures are pretty much the same a inferences to homomorphic variables
            const priority = (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0;
            const indexInfos = getIndexInfosOfType(target);
            if (isObjectTypeWithInferableIndex(source)) {
                for (const targetInfo of indexInfos) {
                    const propTypes: Type[] = [];
                    for (const prop of getPropertiesOfType(source)) {
                        if (isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), targetInfo.keyType)) {
                            const propType = getTypeOfSymbol(prop);
                            propTypes.push(prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType);
                        }
                    }
                    for (const info of getIndexInfosOfType(source)) {
                        if (isApplicableIndexType(info.keyType, targetInfo.keyType)) {
                            propTypes.push(info.type);
                        }
                    }
                    if (propTypes.length) {
                        inferWithPriority(getUnionType(propTypes), targetInfo.type, priority);
                    }
                }
            }
            for (const targetInfo of indexInfos) {
                const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
                if (sourceInfo) {
                    inferWithPriority(sourceInfo.type, targetInfo.type, priority);
                }
            }
        }
    }

    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    function compareSignaturesRelated(source: Signature, target: Signature, checkMode: SignatureCheckMode, reportErrors: boolean, errorReporter: ErrorReporter | undefined, incompatibleErrorReporter: ((source: Type, target: Type) => void) | undefined, compareTypes: TypeComparer, reportUnreliableMarkers: TypeMapper | undefined): Ternary {
        // TODO (drosen): De-duplicate code between related functions.
        if (source === target) {
            return Ternary.True;
        }

        if (!(checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source)) && isTopSignature(target)) {
            return Ternary.True;
        }
        if (checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source) && !isTopSignature(target)) {
            return Ternary.False;
        }

        const targetCount = getParameterCount(target);
        const sourceHasMoreParameters = !hasEffectiveRestParameter(target) &&
            (checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
        if (sourceHasMoreParameters) {
            if (reportErrors && !(checkMode & SignatureCheckMode.StrictArity)) {
                // the second condition should be redundant, because there is no error reporting when comparing signatures by strict arity
                // since it is only done for subtype reduction
                errorReporter!(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount);
            }
            return Ternary.False;
        }

        if (source.typeParameters && source.typeParameters !== target.typeParameters) {
            target = getCanonicalSignature(target);
            source = instantiateSignatureInContextOf(source, target, /*inferenceContext*/ undefined, compareTypes);
        }

        const sourceCount = getParameterCount(source);
        const sourceRestType = getNonArrayRestType(source);
        const targetRestType = getNonArrayRestType(target);
        if (sourceRestType || targetRestType) {
            void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers);
        }

        const kind = target.declaration ? target.declaration.kind : SyntaxKind.Unknown;
        const strictVariance = !(checkMode & SignatureCheckMode.Callback) && strictFunctionTypes && kind !== SyntaxKind.MethodDeclaration &&
            kind !== SyntaxKind.MethodSignature;
        let result = Ternary.True;

        // const sourceThisType = getThisTypeOfSignature(source);
        // if (sourceThisType && sourceThisType !== voidType) {
        //     const targetThisType = getThisTypeOfSignature(target);
        //     if (targetThisType) {
        //         // void sources are assignable to anything.
        //         const related = !strictVariance && compareTypes(sourceThisType, targetThisType, /*reportErrors*/ false)
        //             || compareTypes(targetThisType, sourceThisType, reportErrors);
        //         if (!related) {
        //             if (reportErrors) {
        //                 errorReporter!(Diagnostics.The_this_types_of_each_signature_are_incompatible);
        //             }
        //             return Ternary.False;
        //         }
        //         result &= related;
        //     }
        // }

        const paramCount = sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount);
        const restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;

        for (let i = 0; i < paramCount; i++) {
            const sourceType = i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);
            const targetType = i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);
            if (sourceType && targetType && (sourceType !== targetType || checkMode & SignatureCheckMode.StrictArity)) {
                // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
                // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
                // they naturally relate only contra-variantly). However, if the source and target parameters both have
                // function types with a single call signature, we know we are relating two callback parameters. In
                // that case it is sufficient to only relate the parameters of the signatures co-variantly because,
                // similar to return values, callback parameters are output positions. This means that a Promise<T>,
                // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
                // with respect to T.
                const sourceSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType));
                const targetSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType));
                const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&
                    getTypeFacts(sourceType, TypeFacts.IsUndefinedOrNull) === getTypeFacts(targetType, TypeFacts.IsUndefinedOrNull);
                let related = callbacks ?
                    compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :
                    !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors*/ false) || compareTypes(targetType, sourceType, reportErrors);
                // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
                if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors*/ false)) {
                    related = Ternary.False;
                }
                if (!related) {
                    if (reportErrors) {
                        errorReporter!(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, (getParameterNameAtPosition(source, i)), (getParameterNameAtPosition(target, i)));
                    }
                    return Ternary.False;
                }
                result &= related;
            }
        }

        if (!(checkMode & SignatureCheckMode.IgnoreReturnTypes)) {
            // If a signature resolution is already in-flight, skip issuing a circularity error
            // here and just use the `any` type directly
            const targetReturnType = isResolvingReturnTypeOfSignature(target) ? anyType
                // : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))
                : getReturnTypeOfSignature(target);
            if (targetReturnType === voidType || targetReturnType === anyType) {
                return result;
            }
            const sourceReturnType = isResolvingReturnTypeOfSignature(source) ? anyType
                // : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))
                : getReturnTypeOfSignature(source);

            // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
            const targetTypePredicate = getTypePredicateOfSignature(target);
            if (targetTypePredicate) {
                const sourceTypePredicate = getTypePredicateOfSignature(source);
                if (sourceTypePredicate) {
                    result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes);
                }
                else if (isIdentifierTypePredicate(targetTypePredicate)) {// || isThisTypePredicate(targetTypePredicate)) {
                    if (reportErrors) {
                        errorReporter!(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source));
                    }
                    return Ternary.False;
                }
            }
            else {
                // When relating callback signatures, we still need to relate return types bi-variantly as otherwise
                // the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
                // wouldn't be co-variant for T without this rule.
                result &= checkMode & SignatureCheckMode.BivariantCallback && compareTypes(targetReturnType, sourceReturnType, /*reportErrors*/ false) ||
                    compareTypes(sourceReturnType, targetReturnType, reportErrors);
                if (!result && reportErrors && incompatibleErrorReporter) {
                    incompatibleErrorReporter(sourceReturnType, targetReturnType);
                }
            }
        }

        return result;
    }

    function compareTypePredicateRelatedTo(
        source: TypePredicate,
        target: TypePredicate,
        reportErrors: boolean,
        errorReporter: ErrorReporter | undefined,
        compareTypes: (s: Type, t: Type, reportErrors?: boolean) => Ternary,
    ): Ternary {
        console.info("todo - compareTypePredicateRelatedTo");
        return Ternary.True;
        // if (source.kind !== target.kind) {
        //     if (reportErrors) {
        //         errorReporter!(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
        //         errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        //     }
        //     return Ternary.False;
        // }

        // if (source.kind === TypePredicateKind.Identifier || source.kind === TypePredicateKind.AssertsIdentifier) {
        //     if (source.parameterIndex !== (target as IdentifierTypePredicate).parameterIndex) {
        //         if (reportErrors) {
        //             errorReporter!(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target as IdentifierTypePredicate).parameterName);
        //             errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        //         }
        //         return Ternary.False;
        //     }
        // }

        // const related = source.type === target.type ? Ternary.True :
        //     source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :
        //     Ternary.False;
        // if (related === Ternary.False && reportErrors) {
        //     errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        // }
        // return related;
    }
    
    function isGenericType(type: Type): boolean {
        return !!getGenericObjectFlags(type);
    }

    function isGenericObjectType(type: Type): boolean {
        return !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericObjectType);
    }

    function getGenericObjectFlags(type: Type): ObjectFlags {
        if (type.flags & (TypeFlags.UnionOrIntersection)) {
            if (!((type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericTypeComputed)) {
                (type as UnionOrIntersectionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |
                    reduceLeft((type as UnionOrIntersectionType).types, (flags, t) => flags | getGenericObjectFlags(t), 0);
            }
            return (type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericType;
        }
        if (type.flags & TypeFlags.Substitution) {
            if (!((type as SubstitutionType).objectFlags & ObjectFlags.IsGenericTypeComputed)) {
                (type as SubstitutionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |
                    getGenericObjectFlags((type as SubstitutionType).baseType) | getGenericObjectFlags((type as SubstitutionType).constraint);
            }
            return (type as SubstitutionType).objectFlags & ObjectFlags.IsGenericType;
        }        
        return (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0) |
            (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0);
    }

    function isInstantiatedGenericParameter(signature: Signature, pos: number) {
        let type;
        return !!(signature.target && (type = tryGetTypeAtPosition(signature.target, pos)) && isGenericType(type));
    }

    // Return the rest type at the given position, transforming `any[]` into just `any`. We do this because
    // in signatures we want `any[]` in a rest position to be compatible with anything, but `any[]` isn't
    // assignable to tuple types with required elements.
    function getRestOrAnyTypeAtPosition(source: Signature, pos: number): Type {
        const restType = getRestTypeAtPosition(source, pos);
        const elementType = restType && getElementTypeOfArrayType(restType);
        return elementType && isTypeAny(elementType) ? anyType : restType;
    }

    function checkCollisionsForDeclarationName(node: Node, name: Identifier | undefined) {
        if (!name) return;
        // TODO: needed?
        //checkCollisionWithRequireExportsInGeneratedCode(node, name);        
        // recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
        // recordPotentialCollisionWithReflectInGeneratedCode(node, name);        
    }

    function checkVariableStatement(node: VariableStatement) {
        // Grammar checking
        if (!checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList)) checkGrammarForDisallowedBlockScopedVariableStatement(node);
        checkVariableDeclarationList(node.declarationList);
    }

    function checkBlock(node: Block) {
        // Grammar checking for SyntaxKind.Block
        if (node.kind === SyntaxKind.Block) {
            //checkGrammarStatementInAmbientContext(node);
        }
        if (isFunctionOrModuleBlock(node)) {
            const saveFlowAnalysisDisabled = flowAnalysisDisabled;
            forEach(node.statements, checkSourceElement);
            flowAnalysisDisabled = saveFlowAnalysisDisabled;
        }
        else {
            forEach(node.statements, checkSourceElement);
        }
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }

    type PotentiallyUnusedIdentifier = SourceFile | StructDeclaration | /*ClassLikeDeclaration |*/ Block | CaseBlock | ForStatement | ForEachStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration /*| JSDocFunctionType*/>;

    function registerForUnusedIdentifiersCheck(node: PotentiallyUnusedIdentifier): void {
        addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics);

        function registerForUnusedIdentifiersCheckDiagnostics() {
            // May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
            const sourceFile = getSourceFileOfNode(node);
            let potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
            if (!potentiallyUnusedIdentifiers) {
                potentiallyUnusedIdentifiers = [];
                allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
            }
            // TODO: GH#22580
            // Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
            potentiallyUnusedIdentifiers.push(node);
        }
    }

    function errorOrSuggestion(isError: boolean, location: Node, message: DiagnosticMessage | DiagnosticMessageChain, ...args: DiagnosticArguments): void {
        // Pseudo-synthesized input node
        if (location.pos < 0 || location.end < 0) {
            if (!isError) {
                return; // Drop suggestions (we have no span to suggest on)
            }
            // Issue errors globally
            const file = getSourceFileOrIncludeOfNode(location);
            addErrorOrSuggestion(isError, "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message)); // eslint-disable-line local/no-in-operator
            return;
        }
        addErrorOrSuggestion(isError, "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message)); // eslint-disable-line local/no-in-operator
    }

    function isReachableFlowNode(flow: FlowNode) {
        const result = isReachableFlowNodeWorker(flow, /*noCacheCheck*/ false);
        lastFlowNode = flow;
        lastFlowNodeReachable = result;
        return result;
    }

    function getFlowNodeId(flow: FlowNode): number {
        if (flow.id <= 0) {
            flow.id = nextFlowId;
            nextFlowId++;
        }
        return flow.id;
    }

    function visibilityToString(flags: ModifierFlags): string {
        if (flags === ModifierFlags.Private) {
            return "private";
        }
        if (flags === ModifierFlags.Protected) {
            return "protected";
        }
        return "public";
    }

    function checkGrammarModifiers(node: HasModifiers): boolean {
        const quickResult = reportObviousModifierErrors(node);
        if (quickResult !== undefined) {
            return quickResult;
        }
        
        const blockScopeKind = isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None;
        let lastStatic: Node | undefined, lastDeclare: Node | undefined, lastAsync: Node | undefined, lastOverride: Node | undefined;
        let flags = ModifierFlags.None;
        let sawExportBeforeDecorators = false;
        // We parse decorators and modifiers in four contiguous chunks:
        // [...leadingDecorators, ...leadingModifiers, ...trailingDecorators, ...trailingModifiers]. It is an error to
        // have both leading and trailing decorators.
        let hasLeadingDecorators = false;
        for (const modifier of (node as HasModifiers).modifiers!) {                        
            
            if (node.kind === SyntaxKind.PropertySignature || node.kind === SyntaxKind.MethodSignature) {
                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind));
            }
            if (node.kind === SyntaxKind.IndexSignature && (modifier.kind !== SyntaxKind.StaticKeyword || !isClassLike(node.parent))) {
                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind));
            }                        
            switch (modifier.kind) {                
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.ProtectedKeyword:
                case SyntaxKind.PrivateKeyword:
                    const text = visibilityToString(modifierToFlag(modifier.kind));

                    if (flags & ModifierFlags.AccessibilityModifier) {
                        return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen);
                    }                    
                    else if (flags & ModifierFlags.Static) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                    }                    
                    else if (flags & ModifierFlags.Readonly) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                    }
                    // else if (flags & ModifierFlags.Async) {
                    //     return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                    // }                                        
                    flags |= modifierToFlag(modifier.kind);
                    break;

                case SyntaxKind.StaticKeyword:
                    if (flags & ModifierFlags.Static) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static");
                    }                    
                    // else if (flags & ModifierFlags.Async) {
                    //     return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                    // }                    
                    else if (node.kind === SyntaxKind.Parameter) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                    }                    
                    flags |= ModifierFlags.Static;
                    lastStatic = modifier;
                    break;

                // case SyntaxKind.AsyncKeyword:
                //     if (flags & ModifierFlags.Async) {
                //         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async");
                //     }
                //     else if (flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient) {
                //         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                //     }
                //     else if (node.kind === SyntaxKind.Parameter) {
                //         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                //     }
                //     if (flags & ModifierFlags.Abstract) {
                //         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                //     }
                //     flags |= ModifierFlags.Async;
                //     lastAsync = modifier;
                //     break;                
            }            
        }
               
        if (node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && isBindingPattern(node.name)) {
            return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
        }
        else if (node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && node.dotDotDotToken) {
            return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
        }
        // if (flags & ModifierFlags.Async) {
        //     return checkGrammarAsyncModifier(node, lastAsync!);
        // }
        return false;
    }
     
    /**
     * true | false: Early return this value from checkGrammarModifiers.
     * undefined: Need to do full checking on the modifiers.
     */
    function reportObviousModifierErrors(node: HasModifiers | HasIllegalModifiers): boolean | undefined {
        if (!node.modifiers) return false;

        const modifier = findFirstIllegalModifier(node);
        return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here);
    }

    function findFirstIllegalModifier(node: HasModifiers | HasIllegalModifiers): Modifier | undefined {
        switch (node.kind) {            
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.IndexSignature:            
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.Parameter:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.VariableStatement:
                return undefined;
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
            case SyntaxKind.MissingDeclaration:
                return find(node.modifiers, isModifier);
            default:
                // if (node.parent.kind === SyntaxKind.SourceFile) {
                //     return undefined;
                // }
                switch (node.kind) {                    
                    case SyntaxKind.ClassDeclaration:                                            
                    case SyntaxKind.ClassExpression:                    
                    case SyntaxKind.TypeAliasDeclaration:
                    case SyntaxKind.StructDeclaration:
                    case SyntaxKind.InlineClosureExpression:
                        return find(node.modifiers, isModifier);                    
                    default:
                        Debug.assertNever(node);
                }
        }
    }

    function findFirstModifierExcept(node: HasModifiers, allowedModifier: SyntaxKind): Modifier | undefined {
        const modifier = find(node.modifiers, isModifier);
        return modifier && modifier.kind !== allowedModifier ? modifier : undefined;
    }

    function checkGrammarForDisallowedBlockScopedVariableStatement(node: VariableStatement) {
        return false;
        // if (!allowLetAndConstDeclarations(node.parent)) {
        //     const blockScopeKind = getCombinedNodeFlagsCached(node.declarationList) & NodeFlags.BlockScoped;
        //     if (blockScopeKind) {
        //         const keyword = blockScopeKind === NodeFlags.Let ? "let" :
        //             blockScopeKind === NodeFlags.Const ? "const" :
        //             blockScopeKind === NodeFlags.Using ? "using" :
        //             blockScopeKind === NodeFlags.AwaitUsing ? "await using" :
        //             Debug.fail("Unknown BlockScope flag");
        //         return grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword);
        //     }
        // }
    }

    function checkGrammarVariableDeclarationList(declarationList: VariableDeclarationList): boolean {
        const declarations = declarationList.declarations;
       
        // TODO


        // if (!declarationList.declarations.length) {
        //     return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, Diagnostics.Variable_declaration_list_cannot_be_empty);
        // }

        // const blockScopeFlags = declarationList.flags & NodeFlags.BlockScoped;
        // if ((blockScopeFlags === NodeFlags.Using || blockScopeFlags === NodeFlags.AwaitUsing) && isForInStatement(declarationList.parent)) {
        //     return grammarErrorOnNode(
        //         declarationList,
        //         blockScopeFlags === NodeFlags.Using ?
        //             Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration :
        //             Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration,
        //     );
        // }

        // if (blockScopeFlags === NodeFlags.AwaitUsing) {
        //     return checkAwaitGrammar(declarationList);
        // }

        return false;
    }

    function isDeclarationWithExplicitTypeAnnotation(node: Declaration) {
        return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) &&
            !!(getEffectiveTypeAnnotationNode(node, currentFile) ||
                isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer));
    }

    function getExplicitTypeOfSymbol(symbol: Symbol, diagnostic?: Diagnostic) {
        symbol = resolveSymbol(symbol);
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.ValueModule)) {
            return getTypeOfSymbol(symbol);
        }
        if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
            if (getCheckFlags(symbol) & CheckFlags.Mapped) {
                const origin = (symbol as MappedSymbol).links.syntheticOrigin;
                if (origin && getExplicitTypeOfSymbol(origin)) {
                    return getTypeOfSymbol(symbol);
                }
            }
            const declaration = symbol.valueDeclaration;
            if (declaration) {
                if (isDeclarationWithExplicitTypeAnnotation(declaration)) {
                    return getTypeOfSymbol(symbol);
                }
                if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForEachStatement) {
                    const statement = declaration.parent.parent as ForEachStatement;
                    const expressionType = getTypeOfDottedName(statement.expression, /*diagnostic*/ undefined);
                    if (expressionType) {
                        const use = IterationUse.ForOf;
                        return checkIteratedTypeOrElementType(use, expressionType, undefinedType, /*errorNode*/ undefined);
                    }
                }
                if (diagnostic) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)));
                }
            }
        }
    }

    // We require the dotted function name in an assertion expression to be comprised of identifiers
    // that reference function, method, class or value module symbols; or variable, property or
    // parameter symbols with declarations that have explicit type annotations. Such references are
    // resolvable with no possibility of triggering circularities in control flow analysis.
    function getTypeOfDottedName(node: Expression, diagnostic: Diagnostic | undefined): Type | undefined {
        // if (!(node.flags & NodeFlags.InWithStatement)) {
            switch (node.kind) {
                case SyntaxKind.Identifier:
                    const symbolFlags = isCallExpression(node.parent) ? SymbolFlags.Function : undefined;
                    const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node as Identifier, symbolFlags));
                    return getExplicitTypeOfSymbol(symbol, diagnostic);
                // case SyntaxKind.ThisKeyword:
                //     return getExplicitThisType(node);
                case SyntaxKind.SuperKeyword:
                    return checkSuperExpression(node as SuperAccessExpression);
                case SyntaxKind.PropertyAccessExpression: {
                    const type = getTypeOfDottedName((node as PropertyAccessExpression).expression, diagnostic);
                    if (type) {
                        const name = (node as PropertyAccessExpression).name;
                        let prop: Symbol | undefined;                        
                        // if (isPrivateIdentifier(name)) {
                        //     if (!type.symbol) {
                        //         return undefined;
                        //     }
                        //     prop = getPropertyOfType(type, getSymbolNameForPrivateIdentifier(type.symbol, name.text));
                        // }
                        // else {
                        prop = isIdentifier(name) && getPropertyOfType(type, name.text);
                        // }
                        return prop && getExplicitTypeOfSymbol(prop, diagnostic);
                    }
                    return undefined;
                }
                case SyntaxKind.ParenthesizedExpression:
                    return getTypeOfDottedName((node as ParenthesizedExpression).expression, diagnostic);
            }
        // }
    }

    function getEffectsSignature(node: CallExpression) {
        const links = getNodeLinks(node);
        let signature = links.effectsSignature;
        // console.warn("todo - implement me - getEffectsSignature");
        if (signature === undefined) {
            // A call expression parented by an expression statement is a potential assertion. Other call
            // expressions are potential type predicate function calls. In order to avoid triggering
            // circularities in control flow analysis, we use getTypeOfDottedName when resolving the call
            // target expression of an assertion.
            let funcType: Type | undefined;
            // if (isBinaryExpression(node)) {
            //     const rightType = checkNonNullExpression(node.right);
            //     funcType = getSymbolHasInstanceMethodOfObjectType(rightType);
            // } else
            if (node.parent.kind === SyntaxKind.ExpressionStatement) {
                funcType = getTypeOfDottedName(node.expression, /*diagnostic*/ undefined);
            }
            else if (node.expression.kind !== SyntaxKind.SuperKeyword) {
                // if (isOptionalChain(node)) {
                //     funcType = checkNonNullType(
                //         getOptionalExpressionType(checkExpression(node.expression), node.expression),
                //         node.expression,
                //     );
                // }
                // else {
                    funcType = checkNonNullExpression(node.expression);
                // }
            }
            const signatures = getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, SignatureKind.Call);
            const candidate = signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] :
                some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) :
                undefined;
            signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature;
        }
        return signature === unknownSignature ? undefined : signature;
    }

    function hasTypePredicateOrNeverReturnType(signature: Signature) {        
        return !!(getTypePredicateOfSignature(signature) ||
            signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags & TypeFlags.Never);
    }

    function getUnionOrIntersectionType(types: Type[], kind: TypeFlags | undefined, unionReduction?: UnionReduction) {
        return kind !== TypeFlags.Intersection ? getUnionType(types, unionReduction) : getIntersectionType(types);
    }

    /** NOTE: Return value of `[]` means a different thing than `undefined`. `[]` means func returns `void`, `undefined` means it returns `never`. */
    function checkAndAggregateReturnExpressionTypes(func: FunctionLikeDeclaration, checkMode: CheckMode | undefined): Type[] | undefined {
        const functionFlags = getFunctionFlags(func);
        const aggregatedTypes: Type[] = [];
        let hasReturnWithNoExpression = functionHasImplicitReturn(func);
        let hasReturnOfTypeNever = false;
        forEachReturnStatement(func.body as Block, returnStatement => {
            let expr = returnStatement.expression;
            if (expr) {
                expr = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
                // Bare calls to this same function don't contribute to inference
                // and `return await` is also safe to unwrap here
                // if (functionFlags & FunctionFlags.Async && expr.kind === SyntaxKind.AwaitExpression) {
                //     expr = skipParentheses((expr as AwaitExpression).expression, /*excludeJSDocTypeAssertions*/ true);
                // }
                if (
                    expr.kind === SyntaxKind.CallExpression &&
                    (expr as CallExpression).expression.kind === SyntaxKind.Identifier &&
                    checkExpressionCached((expr as CallExpression).expression).symbol === getMergedSymbol(func.symbol) &&
                    (!isFunctionExpressionOrInlineClosure(func.symbol.valueDeclaration!))// || isConstantReference((expr as CallExpression).expression))
                ) {
                    hasReturnOfTypeNever = true;
                    return;
                }

                let type = checkExpressionCached(expr, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);
                // if (functionFlags & FunctionFlags.Async) {
                //     // From within an async function you can return either a non-promise value or a promise. Any
                //     // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                //     // return type of the body should be unwrapped to its awaited type, which should be wrapped in
                //     // the native Promise<T> type by the caller.
                //     type = unwrapAwaitedType(checkAwaitedType(type, /*withAlias*/ false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
                // }
                if (type.flags & TypeFlags.Never) {
                    hasReturnOfTypeNever = true;
                }
                pushIfUnique(aggregatedTypes, type);
            }
            else {
                hasReturnWithNoExpression = true;
            }
        });
        if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func))) {
            return undefined;
        }
        if (
            strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression &&
            !(false/*isJSConstructor(func)*/ && aggregatedTypes.some(t => t.symbol === func.symbol))
        ) {
            // Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
            pushIfUnique(aggregatedTypes, undefinedType);
        }
        return aggregatedTypes;
    }

    function mayReturnNever(func: FunctionLikeDeclaration): boolean {
        switch (func.kind) {
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InlineClosureExpression:
                return true;
            // case SyntaxKind.MethodDeclaration:
            //     return func.parent.kind === SyntaxKind.ObjectLiteralExpression;
            default:
                return false;
        }
    }

    function isResolvingReturnTypeOfSignature(signature: Signature): boolean {
        return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) ||
            !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyName.ResolvedReturnType) >= 0;
    }

    function getContextualReturnType(functionDecl: SignatureDeclaration, contextFlags: ContextFlags | undefined): Type | undefined {
        // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
        // corresponding set accessor has a type annotation, return statements in the function are contextually typed
        const returnType = getReturnTypeFromAnnotation(functionDecl);
        if (returnType) {
            return returnType;
        }
        // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
        // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
        const signature = getContextualSignatureForFunctionLikeDeclaration(functionDecl as FunctionExpression);
        if (signature && !isResolvingReturnTypeOfSignature(signature)) {
            const returnType = getReturnTypeOfSignature(signature);
            const functionFlags = getFunctionFlags(functionDecl);
            if (functionFlags & FunctionFlags.Generator) {
                return filterType(returnType, t => {
                    return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive));// || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode*/ undefined);
                });
            }
            if (functionFlags & FunctionFlags.Async) {
                return filterType(returnType, t => {
                    return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive));// || !!getAwaitedTypeOfPromise(t);
                });
            }
            return returnType;
        }
        const iife = getImmediatelyInvokedFunctionExpression(functionDecl);
        if (iife) {
            return getContextualType(iife, contextFlags);
        }
        return undefined;
    }

    function getReturnTypeFromBody(func: FunctionLikeDeclaration, checkMode?: CheckMode): Type {
        if (!func.body) {
            return errorType;
        }

        const functionFlags = getFunctionFlags(func);
        const isAsync = (functionFlags & FunctionFlags.Async) !== 0;
        const isGenerator = (functionFlags & FunctionFlags.Generator) !== 0;

        let returnType: Type | undefined;
        let yieldType: Type | undefined;
        let nextType: Type | undefined;
        let fallbackReturnType: Type = voidType;
        
        if (func.body.kind !== SyntaxKind.Block) { // Async or normal arrow function
            if (isInlineClosureExpression(func) && isArray(func.body)) {
                console.debug("todo - remove this hack");
                return anyType;
            }
            returnType = checkExpressionCached(func.body, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);            

            // if an inline closure is set to a single identifier which is a function, use the resolved return type of that function
            if (isInlineClosureExpression(func) && isIdentifier(func.body) && getObjectFlags(returnType) & ObjectFlags.Anonymous) {
                const resolvedSig = getSingleCallSignature(returnType);

                if (resolvedSig && !resolvedSig.resolvedReturnType) {
                    returnType = getReturnTypeOfSignature(resolvedSig) || returnType;
                }                
                else {
                    returnType = resolvedSig?.resolvedReturnType || returnType;
                }
            }            
            
            // if (isAsync) {
            //     // From within an async function you can return either a non-promise value or a promise. Any
            //     // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
            //     // return type of the body should be unwrapped to its awaited type, which we will wrap in
            //     // the native Promise<T> type later in this function.
            //     returnType = unwrapAwaitedType(checkAwaitedType(returnType, /*withAlias*/ false, /*errorNode*/ func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
            // }
        }
        // else if (isGenerator) { // Generator or AsyncGenerator function
        //     const returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
        //     if (!returnTypes) {
        //         fallbackReturnType = neverType;
        //     }
        //     else if (returnTypes.length > 0) {
        //         returnType = getUnionType(returnTypes, UnionReduction.Subtype);
        //     }
        //     const { yieldTypes, nextTypes } = checkAndAggregateYieldOperandTypes(func, checkMode);
        //     yieldType = some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined;
        //     nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
        // }
        else { // Async or normal function
            const types = checkAndAggregateReturnExpressionTypes(func, checkMode);
            if (!types) {
                // For an async function, the return type will not be never, but rather a Promise for never.
                // return functionFlags & FunctionFlags.Async
                //     ? createPromiseReturnType(func, neverType) // Async function
                //     : neverType; // Normal function
                return neverType;
            }
            if (types.length === 0) {
                // For an async function, the return type will not be void/undefined, but rather a Promise for void/undefined.
                const contextualReturnType = getContextualReturnType(func, /*contextFlags*/ undefined);
                const returnType = contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType;
                // return functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, returnType) : // Async function
                //     returnType; // Normal function
                return returnType;
            }

            // Return a union of the return expression types.
            returnType = getUnionType(types, UnionReduction.Subtype);
        }

        if (returnType || yieldType || nextType) {
            if (yieldType) reportErrorsFromWidening(func, yieldType, WideningKind.GeneratorYield);
            if (returnType) reportErrorsFromWidening(func, returnType, WideningKind.FunctionReturn);
            if (nextType) reportErrorsFromWidening(func, nextType, WideningKind.GeneratorNext);
            if (
                returnType && isUnitType(returnType) ||
                yieldType && isUnitType(yieldType) ||
                nextType && isUnitType(nextType)
            ) {
                const contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
                const contextualType = !contextualSignature ? undefined :
                    contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :
                    instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags*/ undefined);
                // if (isGenerator) {
                //     yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKind.Yield, isAsync);
                //     returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKind.Return, isAsync);
                //     nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKind.Next, isAsync);
                // }
                // else {
                    returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync);
                //}
            }

            if (yieldType) yieldType = getWidenedType(yieldType);
            if (returnType) returnType = getWidenedType(returnType);
            if (nextType) nextType = getWidenedType(nextType);
        }

        // if (isGenerator) {
        //     return createGeneratorType(
        //         yieldType || neverType,
        //         returnType || fallbackReturnType,
        //         nextType || getContextualIterationType(IterationTypeKind.Next, func) || unknownType,
        //         isAsync,
        //     );
        // }
        //else {
            //Debug.fail("todo implement me - getReturnTypeFromBody - async");
            // From within an async function you can return either a non-promise value or a promise. Any
            // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
            // return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
            // return isAsync
            //     ? createPromiseType(returnType || fallbackReturnType)
            //     : returnType || fallbackReturnType;
            return returnType || fallbackReturnType;
        // }
    }

    function getWidenedLiteralLikeTypeForContextualType(type: Type, contextualType: Type | undefined) {
        if (!isLiteralOfContextualType(type, contextualType)) {            
            //type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type));
            type = (getWidenedLiteralType(type));
        }
        return getRegularTypeOfLiteralType(type);
    }

    function getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(type: Type | undefined, contextualSignatureReturnType: Type | undefined, isAsync: boolean) {
        if (type && isUnitType(type)) {
            // const contextualType = !contextualSignatureReturnType ? undefined :
            //     isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :
            //     contextualSignatureReturnType;
            const contextualType = contextualSignatureReturnType;
            type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
        }
        return type;
    }

    function getReturnTypeOfSignature(signature: Signature): Type {        
        if (!signature.resolvedReturnType) {
            if (!pushTypeResolution(signature, TypeSystemPropertyName.ResolvedReturnType)) {
                return errorType;
            }
            let type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :
                signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) :
                getReturnTypeFromAnnotation(signature.declaration!) ||
                (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration));
            // if (signature.flags & SignatureFlags.IsInnerCallChain) {
            //     type = addOptionalTypeMarker(type);
            // }
            if (signature.flags & SignatureFlags.IsOuterCallChain) {
                type = getOptionalType(type);
            }
            if (!popTypeResolution()) {
                if (signature.declaration) {
                    const typeNode = getEffectiveReturnTypeNode(signature.declaration);
                    if (typeNode) {
                        error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself);
                    }
                    else if (noImplicitAny) {
                        const declaration = signature.declaration as Declaration;
                        const name = getNameOfDeclaration(declaration);
                        if (name) {
                            error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name));
                        }
                        else {
                            error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                        }
                    }
                }
                type = anyType;
            }
            signature.resolvedReturnType ??= type;
        }
        return signature.resolvedReturnType;
    }

    function isExhaustiveSwitchStatement(node: SwitchStatement): boolean {
        const links = getNodeLinks(node);
        if (links.isExhaustive === undefined) {
            links.isExhaustive = 0; // Indicate resolution is in process
            const exhaustive = computeExhaustiveSwitchStatement(node);
            if (links.isExhaustive === 0) {
                links.isExhaustive = exhaustive;
            }
        }
        else if (links.isExhaustive === 0) {
            links.isExhaustive = false; // Resolve circularity to false
        }
        return links.isExhaustive;
    }

    function isNeitherUnitTypeNorNever(type: Type): boolean {
        return !(type.flags & (TypeFlags.Unit | TypeFlags.Never));
    }

    function eachTypeContainedIn(source: Type, types: Type[]) {
        return source.flags & TypeFlags.Union ? !forEach((source as UnionType).types, t => !contains(types, t)) : contains(types, source);
    }

    function computeExhaustiveSwitchStatement(node: SwitchStatement): boolean {                
        const type = checkExpressionCached(node.expression);
        if (!isLiteralType(type)) {
            return false;
        }
        const switchTypes = getSwitchClauseTypes(node);
        if (!switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever)) {
            return false;
        }
        return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
    }

    
    function isReachableFlowNodeWorker(flow: FlowNode, noCacheCheck: boolean): boolean {
        let count = 0;
        while (true) {
            if (count++ > 100) {
                console.warn("Bailing out of reachable flow worker");
                return lastFlowNodeReachable;
            }
            if (flow === lastFlowNode) {
                return lastFlowNodeReachable;
            }
            const flags = flow.flags;            
            if (flags & FlowFlags.Shared) {
                if (!noCacheCheck) {
                    const id = getFlowNodeId(flow);
                    const reachable = flowNodeReachable[id];
                    return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck*/ true));                    
                }
                noCacheCheck = false;
            }
            // TODO - this was not part of the typescript codebase
            // I added it to prevent an infinite loop
            if (flags & FlowFlags.Unreachable) {
                return false;
            }
            if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)) {
                flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation).antecedent;
            }
            else if (flags & FlowFlags.Call) {
                const signature = getEffectsSignature((flow as FlowCall).node);
                if (signature) {                    
                    if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {
                        return false;
                    }
                }
                flow = (flow as FlowCall).antecedent;
            }
            else if (flags & FlowFlags.BranchLabel) {
                // A branching point is reachable if any branch is reachable.
                return some((flow as FlowLabel).antecedent, f => isReachableFlowNodeWorker(f, /*noCacheCheck*/ false));
            }
            else if (flags & FlowFlags.LoopLabel) {
                const antecedents = (flow as FlowLabel).antecedent;
                if (antecedents === undefined || antecedents.length === 0) {
                    return false;
                }
                // A loop is reachable if the control flow path that leads to the top is reachable.
                flow = antecedents[0];
            }
            else if (flags & FlowFlags.SwitchClause) {
                // The control flow path representing an unmatched value in a switch statement with
                // no default clause is unreachable if the switch statement is exhaustive.
                const data = (flow as FlowSwitchClause).node;
                if (data.clauseStart === data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement)) {
                    return false;
                }
                flow = (flow as FlowSwitchClause).antecedent;
            }
            else if (flags & FlowFlags.ReduceLabel) {
                // Cache is unreliable once we start adjusting labels
                lastFlowNode = undefined;
                const target = (flow as FlowReduceLabel).node.target;
                const saveAntecedents = target.antecedent;
                target.antecedent = (flow as FlowReduceLabel).node.antecedents;
                const result = isReachableFlowNodeWorker((flow as FlowReduceLabel).antecedent, /*noCacheCheck*/ false);
                target.antecedent = saveAntecedents;
                return result;
            }
            else {
                return !(flags & FlowFlags.Unreachable);
            }
        }
    }

    function getNodeCheckFlags(node: Node): NodeCheckFlags {
        const nodeId = node.id || 0;
        if (nodeId < 0 || nodeId >= nodeLinks.length) return 0;
        return nodeLinks[nodeId]?.flags || 0;
    }

    function hasNodeCheckFlag(node: Node, flag: LazyNodeCheckFlags) {
        calculateNodeCheckFlagWorker(node, flag);
        return !!(getNodeCheckFlags(node) & flag);
    }

    function calculateNodeCheckFlagWorker(node: Node, flag: LazyNodeCheckFlags) {
        if (!compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions)) {
            // Unless noCheck is passed, assume calculation of node check flags has been done eagerly.
            // This saves needing to mark up where in the eager traversal certain results are "done",
            // just to reconcile the eager and lazy results. This wouldn't be hard if an eager typecheck
            // was actually an in-order traversal, but it isn't - some nodes are deferred, and so don't
            // have these node check flags calculated until that deferral is completed. As an example,
            // in concept, we could consider a class that we've called `checkSourceElement` on as having had
            // these flags calculated, but since the method bodies are deferred, we actually can't set the
            // flags as having been calculated until that deferral is completed.
            // The downside to this either/or approach to eager or lazy calculation is that we can't combine
            // a partial eager traversal and lazy calculation for the missing bits, and there's a bit of
            // overlap in functionality. This isn't a huge loss for any usecases today, but would be nice
            // alongside language service partial file checking and editor-triggered emit.
            return;
        }
        const links = getNodeLinks(node);
        if (links.calculatedFlags & flag) {
            return;
        }
        // This is only the set of `NodeCheckFlags` our emitter actually looks for, not all of them
        switch (flag) {
            case NodeCheckFlags.SuperInstance:
            case NodeCheckFlags.SuperStatic:
                return checkSingleSuperExpression(node);
            case NodeCheckFlags.MethodWithSuperPropertyAccessInAsync:
            case NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync:
            case NodeCheckFlags.ContainsSuperPropertyInStaticInitializer:
                return checkChildSuperExpressions(node);
            case NodeCheckFlags.CaptureArguments:
            case NodeCheckFlags.ContainsCapturedBlockScopeBinding:
            case NodeCheckFlags.NeedsLoopOutParameter:
            case NodeCheckFlags.ContainsConstructorReference:
                return checkChildIdentifiers(node);
            case NodeCheckFlags.ConstructorReference:
                return checkSingleIdentifier(node);
            case NodeCheckFlags.LoopWithCapturedBlockScopedBinding:
            case NodeCheckFlags.BlockScopedBindingInLoop:
            case NodeCheckFlags.CapturedBlockScopedBinding:
                return checkContainingBlockScopeBindingUses(node);
            default:
                return Debug.assertNever(flag, `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}`);
        }

        function forEachNodeRecursively<T>(root: Node, cb: (node: Node, parent: Node) => T | "skip" | undefined): T | undefined {
            const rootResult = cb(root, root.parent);
            if (rootResult === "skip") return undefined;
            if (rootResult) return rootResult;
            return forEachChildRecursively(root, cb);
        }

        function checkSuperExpressions(node: Node) {
            const links = getNodeLinks(node);
            if (links.calculatedFlags & flag) return "skip";
            links.calculatedFlags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync | NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync | NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;
            checkSingleSuperExpression(node);
            return undefined;
        }

        function checkChildSuperExpressions(node: Node) {
            forEachNodeRecursively(node, checkSuperExpressions);
        }

        function checkSingleSuperExpression(node: Node) {
            const nodeLinks = getNodeLinks(node); // This is called on sub-nodes of the original input, make sure we set `calculatedFlags` on the correct node
            nodeLinks.calculatedFlags |= NodeCheckFlags.SuperInstance | NodeCheckFlags.SuperStatic; // Yes, we set this on non-applicable nodes, so we can entirely skip the traversal on future calls
            if (node.kind === SyntaxKind.SuperKeyword) {
                checkSuperExpression(node as SuperAccessExpression);
            }
        }
                
        function checkIdentifiers(node: Node) {
            const links = getNodeLinks(node);
            if (links.calculatedFlags & flag) return "skip";
            links.calculatedFlags |= NodeCheckFlags.CaptureArguments | NodeCheckFlags.ContainsCapturedBlockScopeBinding | NodeCheckFlags.NeedsLoopOutParameter | NodeCheckFlags.ContainsConstructorReference;
            checkSingleIdentifier(node);
            return undefined;
        }

        function checkChildIdentifiers(node: Node) {
            forEachNodeRecursively(node, checkIdentifiers);
        }

        function checkSingleIdentifier(node: Node) {
            const nodeLinks = getNodeLinks(node);
            nodeLinks.calculatedFlags |= NodeCheckFlags.ConstructorReference | NodeCheckFlags.CapturedBlockScopedBinding | NodeCheckFlags.BlockScopedBindingInLoop;
            if (isIdentifier(node) && isExpressionNode(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name === node)) {
                const s = getSymbolAtLocation(node, /*ignoreErrors*/ true);
                if (s && s !== unknownSymbol) {
                    checkIdentifierCalculateNodeCheckFlags(node, s);
                }
            }
        }

        function checkBlockScopeBindings(node: Node) {
            const links = getNodeLinks(node);
            if (links.calculatedFlags & flag) return "skip";
            links.calculatedFlags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding | NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding;
            checkSingleBlockScopeBinding(node);
            return undefined;
        }

        function checkContainingBlockScopeBindingUses(node: Node) {
            const scope = getEnclosingBlockScopeContainer(isDeclarationName(node) ? node.parent : node);
            forEachNodeRecursively(scope, checkBlockScopeBindings);
        }

        function checkSingleBlockScopeBinding(node: Node) {
            checkSingleIdentifier(node);
            // if (isComputedPropertyName(node)) {
            //     checkComputedPropertyName(node);
            // }
            // if (isPrivateIdentifier(node) && isClassElement(node.parent)) {
            //     setNodeLinksForPrivateIdentifierScope(node.parent as PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration);
            // }
        }
    }

    function isAutoTypedProperty(symbol: Symbol) {
        // A property is auto-typed when its declaration has no type annotation or initializer and we're in
        // noImplicitAny mode or a .js file.
        const declaration = symbol.valueDeclaration;
        return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) &&
            !declaration.initializer && (noImplicitAny || isInJSFile(declaration));
    }
    
    function getFlowTypeOfProperty(reference: Node, prop: Symbol | undefined) {
        const initialType = prop?.valueDeclaration
                && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration) & ModifierFlags.Ambient)
                && getTypeOfPropertyInBaseClass(prop)
            || undefinedType;
        return getFlowTypeOfReference(reference, autoType, initialType);
    }

    // Return the inherited type of the given property or undefined if property doesn't exist in a base class.
    function getTypeOfPropertyInBaseClass(property: Symbol) {
        const classType = getDeclaringClass(property);
        const baseClassType = classType && getBaseTypes(classType)[0];
        return baseClassType && getTypeOfPropertyOfType(baseClassType, property.name);
    }

    // Return the declaring class type of a property or undefined if property not declared in class
    function getDeclaringClass(prop: Symbol) {
        return prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) as InterfaceType : undefined;
    }

    function getFlowTypeOfAccessExpression(node: ElementAccessExpression | PropertyAccessExpression | QualifiedName, prop: Symbol | undefined, propType: Type, errorNode: Node, checkMode: CheckMode | undefined) {
        // Only compute control flow type if this is a property access expression that isn't an
        // assignment target, and the referenced property was declared as a variable, property,
        // accessor, or optional method.
        const assignmentKind = getAssignmentTargetKind(node);
        if (assignmentKind === AssignmentKind.Definite) {
            return removeMissingType(propType, !!(prop && prop.flags & SymbolFlags.Optional));
        }
        if (
            prop &&
            !(prop.flags & (SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.Accessor))
            && !(prop.flags & SymbolFlags.Method && propType.flags & TypeFlags.Union)
            //&& !isDuplicatedCommonJSExport(prop.declarations)
        ) {
            return propType;
        }
        if (propType === autoType) {
            return getFlowTypeOfProperty(node, prop);
        }
        propType = getNarrowableTypeForReference(propType, node, checkMode);
        // If strict null checks and strict property initialization checks are enabled, if we have
        // a this.xxx property access, if the property is an instance property without an initializer,
        // and if we are in a constructor of the same class as the property declaration, assume that
        // the property is uninitialized at the top of the control flow.
        let assumeUninitialized = false;
        // if (strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind === SyntaxKind.ThisKeyword) {
        //     const declaration = prop && prop.valueDeclaration;
        //     if (declaration && isPropertyWithoutInitializer(declaration)) {
        //         if (!isStatic(declaration)) {
        //             const flowContainer = getControlFlowContainer(node);
        //             if (flowContainer.kind === SyntaxKind.Constructor && flowContainer.parent === declaration.parent && !(declaration.flags & NodeFlags.Ambient)) {
        //                 assumeUninitialized = true;
        //             }
        //         }
        //     }
        // } else 
        if (
            strictNullChecks && prop && prop.valueDeclaration &&
            isPropertyAccessExpression(prop.valueDeclaration) &&
            getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) &&
            getControlFlowContainer(node) === getControlFlowContainer(prop.valueDeclaration)
        ) {
            assumeUninitialized = true;
        }
        const flowType = getFlowTypeOfReference(node, propType, assumeUninitialized ? getOptionalType(propType) : propType);
        if (assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType)) {
            error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop!)); // TODO: GH#18217
            // Return the declared type to reduce follow-on errors
            return propType;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }

    function getOptionalType(type: Type, isProperty = false): Type {
        Debug.assert(strictNullChecks);
        const missingOrUndefined = isProperty ? undefinedOrMissingType : undefinedType;
        return type === missingOrUndefined || type.flags & TypeFlags.Union && (type as UnionType).types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]);
    }

    
    /**
     * Check whether the requested property access is valid.
     * Returns true if node is a valid property access, and false otherwise.
     * @param node The node to be checked.
     * @param isSuper True if the access is from `super.`.
     * @param type The type of the object whose property is being accessed. (Not the type of the property.)
     * @param prop The symbol for the property being accessed.
     */
    function checkPropertyAccessibility(
        node: PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | /*ImportTypeNode |*/ PropertyAssignment | ShorthandPropertyAssignment | BindingElement,
        isSuper: boolean,
        writing: boolean,
        type: Type,
        prop: Symbol,
        reportError = true,
    ): boolean {
        const errorNode = !reportError ? undefined :
            node.kind === SyntaxKind.QualifiedName ? node.right :
            //node.kind === SyntaxKind.ImportType ? node :
            node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name;

        return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type, prop, errorNode);
    }

    /**
     * Check whether the requested property can be accessed at the requested location.
     * Returns true if node is a valid property access, and false otherwise.
     * @param location The location node where we want to check if the property is accessible.
     * @param isSuper True if the access is from `super.`.
     * @param writing True if this is a write property access, false if it is a read property access.
     * @param containingType The type of the object whose property is being accessed. (Not the type of the property.)
     * @param prop The symbol for the property being accessed.
     * @param errorNode The node where we should report an invalid property access error, or undefined if we should not report errors.
     */
    function checkPropertyAccessibilityAtLocation(location: Node, isSuper: boolean, writing: boolean, containingType: Type, prop: Symbol, errorNode?: Node): boolean {
        const flags = getDeclarationModifierFlagsFromSymbol(prop, writing);

        if (isSuper) {
            // TS 1.0 spec (April 2014): 4.8.2
            // - In a constructor, instance member function, instance member accessor, or
            //   instance member variable initializer where this references a derived class instance,
            //   a super property access is permitted and must specify a public instance member function of the base class.
            // - In a static member function or static member accessor
            //   where this references the constructor function object of a derived class,
            //   a super property access is permitted and must specify a public static member function of the base class.
            // if (languageVersion < ScriptTarget.ES2015) {
            //     if (symbolHasNonMethodDeclaration(prop)) {
            //         if (errorNode) {
            //             error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
            //         }
            //         return false;
            //     }
            // }
            // if (flags & ModifierFlags.Abstract) {
            //     // A method cannot be accessed in a super property access if the method is abstract.
            //     // This error could mask a private property access error. But, a member
            //     // cannot simultaneously be private and abstract, so this will trigger an
            //     // additional error elsewhere.
            //     if (errorNode) {
            //         error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)!));
            //     }
            //     return false;
            // }
            // A class field cannot be accessed via super.* from a derived class.
            // This is true for both [[Set]] (old) and [[Define]] (ES spec) semantics.
            // if (!(flags & ModifierFlags.Static) && prop.declarations?.some(isClassInstanceProperty)) {
            //     if (errorNode) {
            //         error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop));
            //     }
            //     return false;
            // }
        }

        // Referencing abstract properties within their own constructors is not allowed
        // if (
        //     (flags & ModifierFlags.Abstract) && symbolHasNonMethodDeclaration(prop) &&
        //     (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent))
        // ) {
        //     const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!);
        //     if (declaringClassDeclaration && isNodeUsedDuringClassInitialization(location)) {
        //         if (errorNode) {
        //             error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name!));
        //         }
        //         return false;
        //     }
        // }

        // Public properties are otherwise accessible.
        if (!(flags & ModifierFlags.NonPublicAccessibilityModifier)) {
            return true;
        }

        // Property is known to be private or protected at this point

        // Private property is accessible if the property is within the declaring class
        // if (flags & ModifierFlags.Private) {
        //     const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!)!;
        //     if (!isNodeWithinClass(location, declaringClassDeclaration)) {
        //         if (errorNode) {
        //             error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)!));
        //         }
        //         return false;
        //     }
        //     return true;
        // }

        // Property is known to be protected at this point

        // All protected properties of a supertype are accessible in a super access
        if (isSuper) {
            return true;
        }

        // Find the first enclosing class that has the declaring classes of the protected constituents
        // of the property as base classes
        // let enclosingClass = forEachEnclosingClass(location, enclosingDeclaration => {
        //     const enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration)) as InterfaceType;
        //     return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
        // });
        // // A protected property is accessible if the property is within the declaring class or classes derived from it
        // if (!enclosingClass) {
        //     // allow PropertyAccessibility if context is in function with this parameter
        //     // static member access is disallowed
        //     enclosingClass = getEnclosingClassFromThisParameter(location);
        //     enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
        //     if (flags & ModifierFlags.Static || !enclosingClass) {
        //         if (errorNode) {
        //             error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType));
        //         }
        //         return false;
        //     }
        // }
        // No further restrictions for static properties
        // if (flags & ModifierFlags.Static) {
        //     return true;
        // }
        if (containingType.flags & TypeFlags.TypeParameter) {
            // get the original type -- represented as the type constraint of the 'this' type
            containingType = (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)!; // TODO: GH#18217 Use a different variable that's allowed to be undefined
        }
        // if (!containingType || !hasBaseType(containingType, enclosingClass)) {
        //     if (errorNode) {
        //         error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType));
        //     }
        //     return false;
        // }
        return true;
    }


    function markPropertyAsReferenced(prop: Symbol, nodeForCheckWriteOnly: Node | undefined, isSelfTypeAccess: boolean) {
        const valueDeclaration = prop && (prop.flags & SymbolFlags.ClassMember) && prop.valueDeclaration;
        if (!valueDeclaration) {
            return;
        }
        const hasPrivateModifier = hasEffectiveModifier(valueDeclaration, ModifierFlags.Private);
        const hasPrivateIdentifier = prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name);
        if (!hasPrivateModifier && !hasPrivateIdentifier) {
            return;
        }
        if (nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlags.SetAccessor)) {
            return;
        }
        if (isSelfTypeAccess) {
            // Find any FunctionLikeDeclaration because those create a new 'this' binding. But this should only matter for methods (or getters/setters).
            const containingMethod = findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration);
            if (containingMethod && containingMethod.symbol === prop) {
                return;
            }
        }

        (getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop)!.isReferenced = SymbolFlags.All;
    }

    function isSelfTypeAccess(name: Expression | QualifiedName, parent: Symbol | undefined) {
        return !!parent && isEntityNameExpression(name) && parent === getResolvedSymbol(getFirstIdentifier(name));
    }
       
    // The invalid initializer error is needed in two situation:
    // 1. When result is undefined, after checking for a missing "this."
    // 2. When result is defined
    function checkAndReportErrorForInvalidInitializer(errorLocation: Node | undefined, name: string, propertyWithInvalidInitializer: PropertyDeclaration, result: Symbol | undefined) {
        // TODO
        // if (!emitStandardClassFields) {
        //     if (errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name)) {
        //         return true;
        //     }
        //     // We have a match, but the reference occurred within a property initializer and the identifier also binds
        //     // to a local variable in the constructor where the code will be emitted. Note that this is actually allowed
        //     // with emitStandardClassFields because the scope semantics are different.
        //     error(
        //         errorLocation,
        //         errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos)
        //             ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor
        //             : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,
        //         declarationNameToString(propertyWithInvalidInitializer.name),
        //         diagnosticName(name),
        //     );
        //     return true;
        // }
        return false;
    }

    // Fully type check a source file and collect the relevant diagnostics.
    function checkSourceFileWorker(node: SourceFile) {
        const links = getNodeLinks(node);
        if (!(links.flags & NodeCheckFlags.TypeChecked)) {
            if (skipTypeChecking(node, compilerOptions, host)) {
                return;
            }

            // Grammar checking
            checkGrammarSourceFile(node);

            clear(potentialThisCollisions);
            clear(potentialNewTargetCollisions);
            clear(potentialWeakMapSetCollisions);
            clear(potentialReflectCollisions);
            //clear(potentialUnusedRenamedBindingElementsInTypes);

            if (links.flags & NodeCheckFlags.PartiallyTypeChecked) {
                potentialThisCollisions = links.potentialThisCollisions!;
                potentialNewTargetCollisions = links.potentialNewTargetCollisions!;
                potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions!;
                potentialReflectCollisions = links.potentialReflectCollisions!;
                //potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes!;
            }
                        
            forEach(node.statements, checkSourceElement);
            checkSourceElement(node.endOfFileToken);

            const symbol = getSymbolOfNode(node);
            // const type = getDeclaredTypeOfSymbol(symbol);
            const classType = getDeclaredTypeOfClassOrInterface(symbol);
            // resolveClassOrInterfaceMembers(classType);
            
            checkDeferredNodes(node);
            
            registerForUnusedIdentifiersCheck(node);

            addLazyDiagnostic(() => {
                // This relies on the results of other lazy diagnostics, so must be computed after them
                if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {
                    checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), (containingNode, kind, diag) => {
                        if (!containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {
                            diagnostics.add(diag);
                        }
                    });
                }
                // if (!node.isDeclarationFile) {
                //     checkPotentialUncheckedRenamedBindingElementsInTypes();
                // }
            });

            // every source file is a "module"
            checkExternalModuleExports(node);                                    

            // TODO

            // if (potentialNewTargetCollisions.length) {
            //     forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
            //     clear(potentialNewTargetCollisions);
            // }
            
            links.flags |= NodeCheckFlags.TypeChecked;            
        }
    }
    
    function unusedIsError(kind: UnusedKind, isAmbient: boolean): boolean {
        if (isAmbient) {
            return false;
        }
        switch (kind) {
            case UnusedKind.Local:
                return !!compilerOptions.noUnusedLocals;
            case UnusedKind.Parameter:
                return !!compilerOptions.noUnusedParameters;
            default:
                return Debug.assertNever(kind);
        }
    }

    function getPotentiallyUnusedIdentifiers(sourceFile: SourceFile): readonly PotentiallyUnusedIdentifier[] {
        return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray;
    }

    function checkSourceFileNodesWorker(file: SourceFile, nodes: readonly Node[]) {
        // TODO
        console.warn("Implement me - checkSourceFileNodesWorker");
    }

    function checkDeferredNodes(context: SourceFile) {
        const links = getNodeLinks(context);
        if (links.deferredNodes) {
            links.deferredNodes.forEach(checkDeferredNode);
        }
        links.deferredNodes = undefined;
    }

    function makeFunctionTypeMapper(func: (t: Type) => Type, debugInfo: () => string): TypeMapper {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined });
    }

    /**
     * Recursively resolve entity names and jsdoc instance references:
     * 1. K#m as K.prototype.m for a class (or other value) K
     * 2. K.m as K.prototype.m
     * 3. I.m as I.m for a type I, or any other I.m that fails to resolve in (1) or (2)
     *
     * For unqualified names, a container K may be provided as a second argument.     
     */
    function resolveJSDocMemberName(name: EntityName | JSDocMemberName, ignoreErrors?: boolean, container?: Symbol): Symbol | undefined {
        if (isEntityName(name)) {
            // resolve static values first
            const meaning = SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value;
            let symbol = resolveEntityName(name, meaning, ignoreErrors, /*dontResolveAlias*/ true, getHostSignatureFromJSDoc(name));
            if (!symbol && isIdentifier(name) && container) {
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.text, meaning));
            }
            if (symbol) {
                return symbol;
            }
        }
        const left = isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container);
        const right = isIdentifier(name) ? name.text : name.right.text;
        if (left) {
            const proto = left.flags & SymbolFlags.Value && getPropertyOfType(getTypeOfSymbol(left), "prototype");
            const t = proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left);
            return getPropertyOfType(t, right);
        }
    }

    function getSymbolAtLocation(node: Node, ignoreErrors?: boolean): Symbol | undefined {
        if (isSourceFile(node)) {
            return getMergedSymbol(node.symbol);
        }
        const { parent } = node;
        const grandParent = parent?.parent;

        if (isDeclarationNameOrImportPropertyName(node)) {
            // This is a declaration, call getSymbolOfNode
            const parentSymbol = getSymbolOfDeclaration(parent as Declaration);
            return parentSymbol; // TODO:            
            // return isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node
            //     ? getImmediateAliasedSymbol(parentSymbol)
            //     : parentSymbol;
        }
        // else if (isLiteralComputedPropertyDeclarationName(node)) {
        //     return getSymbolOfDeclaration(parent.parent as Declaration);
        // }

        if (node.kind === SyntaxKind.Identifier) {
            // if (isInRightSideOfImportOrExportAssignment(node as Identifier)) {
            //     return getSymbolOfNameOrPropertyAccessExpression(node as Identifier);
            // } else if (
            //     parent.kind === SyntaxKind.BindingElement &&
            //     grandParent.kind === SyntaxKind.ObjectBindingPattern &&
            //     node === (parent as BindingElement).propertyName
            // ) {
            //     const typeOfPattern = getTypeOfNode(grandParent);
            //     const propertyDeclaration = getPropertyOfType(typeOfPattern, (node as Identifier).text);

            //     if (propertyDeclaration) {
            //         return propertyDeclaration;
            //     }
            // }
            // else if (isMetaProperty(parent) && parent.name === node) {
            //     if (parent.keywordToken === SyntaxKind.NewKeyword && idText(node as Identifier) === "target") {
            //         // `target` in `new.target`
            //         return checkNewTargetMetaProperty(parent).symbol;
            //     }
            //     // The `meta` in `import.meta` could be given `getTypeOfNode(parent).symbol` (the `ImportMeta` interface symbol), but
            //     // we have a fake expression type made for other reasons already, whose transient `meta`
            //     // member should more exactly be the kind of (declarationless) symbol we want.
            //     // (See #44364 and #45031 for relevant implementation PRs)
            //     if (parent.keywordToken === SyntaxKind.ImportKeyword && idText(node as Identifier) === "meta") {
            //         return getGlobalImportMetaExpressionType().members!.get("meta" as string);
            //     }
            //     // no other meta properties are valid syntax, thus no others should have symbols
            //     return undefined;
            // }
        }

        switch (node.kind) {
            case SyntaxKind.Identifier:
            //case SyntaxKind.PrivateIdentifier:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.QualifiedName:              
                return getSymbolOfNameOrPropertyAccessExpression(node as EntityName | PropertyAccessExpression);              
                // falls through            
            case SyntaxKind.SuperKeyword:
                return checkExpression(node as Expression).symbol;
            case SyntaxKind.DefineDirective:
                const defineNode = node as DefineDirective;
                return resolveEntityName(defineNode.name, SymbolFlags.Define);
            case SyntaxKind.StringLiteral:
            //case SyntaxKind.NoSubstitutionTemplateLiteral:
                // 1). import x = require("./mo/*gotToDefinitionHere*/d")
                // 2). External module name in an import declaration
                // 3). Dynamic import call or require in javascript
                // 4). type A = import("./f/*gotToDefinitionHere*/oo")
                if (
                    ((node.parent.kind === SyntaxKind.InheritDeclaration) && (node.parent as InheritDeclaration).inheritClause === node)
                ) {
                    return resolveExternalModuleName(node, node as LiteralExpression, undefined, ignoreErrors);
                }
                    // (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||
                //     //((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) && (node.parent as ImportDeclaration).moduleSpecifier === node) ||
                //     //(isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier === node) ||
                //     //((isInJSFile(node) && isRequireCall(node.parent, /*requireStringLiteralLikeArgument*/ false)) || isImportCall(node.parent)) ||
                //     (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)
                // ) {
                //     return resolveExternalModuleName(node, node as LiteralExpression, ignoreErrors);
                // }
                // if (isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) {
                //     return getSymbolOfDeclaration(parent);
                // }
                // falls through

            case SyntaxKind.IntLiteral:            
                // index access
                const objectType = isElementAccessExpression(parent)
                    ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined
                    : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent)
                    ? getTypeFromTypeNode(grandParent.objectType)
                    : undefined;
                return objectType && getPropertyOfType(objectType, ((node as StringLiteral | IntLiteral).text));
            
            //case SyntaxKind.FunctionKeyword:
            case SyntaxKind.EqualsGreaterThanToken:
            //case SyntaxKind.ClassKeyword:
                return getSymbolOfNode(node.parent);
            // case SyntaxKind.ImportType:
            //     return isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;

            // case SyntaxKind.ImportKeyword:
            // case SyntaxKind.NewKeyword:
            //     return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined;            
            default:
                return undefined;
        }
    }
        
    function checkDeferredNode(node: Node) {
        tracing?.push(tracing.Phase.Check, "checkDeferredNode", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath });
        const saveCurrentNode = currentNode;
        currentNode = node;
        instantiationCount = 0;
        switch (node.kind) {
            // TODO - lots to implement here
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
            // case SyntaxKind.TaggedTemplateExpression:            
                // These node kinds are deferred checked when overload resolution fails
                // To save on work, we ensure the arguments are checked just once, in
                // a deferred way
                resolveUntypedCall(node as CallLikeExpression);
                break;            
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InlineClosureExpression:
            // case SyntaxKind.MethodDeclaration:
            // case SyntaxKind.MethodSignature:
                checkFunctionExpressionOrObjectLiteralMethodDeferred(node as FunctionExpression);
                break;            
            case SyntaxKind.ClassExpression:
                //checkClassExpressionDeferred(node as ClassExpression);
                break;
            case SyntaxKind.TypeParameter:
                checkTypeParameterDeferred(node as TypeParameterDeclaration);
                break;            
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.CastExpression:
            // case SyntaxKind.AsExpression:
            case SyntaxKind.ParenthesizedExpression:
                checkAssertionDeferred(node as AssertionExpression | JSDocTypeAssertion);
                break;            
            case SyntaxKind.BinaryExpression:
                // if (isInstanceOfExpression(node)) {
                //     resolveUntypedCall(node);
                // }
                break;
            default:
                console.log("Unhandled deferred node kind: ", Debug.formatSyntaxKind(node.kind));
        }
        currentNode = saveCurrentNode;
        tracing?.pop();
    }    

    function checkAssertionDeferred(node: JSDocTypeAssertion | AssertionExpression) {
        const { type } = getAssertionTypeAndExpression(node);
        const errNode = isParenthesizedExpression(node) ? type : node;
        const links = getNodeLinks(node);
        Debug.assertIsDefined(links.assertionExpressionType);
        const exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(links.assertionExpressionType));
        const targetType = getTypeFromTypeNode(type);
        if (!isErrorType(targetType)) {
            addLazyDiagnostic(() => {
                const widenedType = getWidenedType(exprType);
                if (!isTypeComparableTo(targetType, widenedType)) {
                    checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);
                }
            });
        }
    }

    /**
     * This is *not* a bi-directional relationship.
     * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
     */
    function checkTypeComparableTo(source: Type, target: Type, errorNode: Node, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined): boolean {
        return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
    }

    function getAssertionTypeAndExpression(node: JSDocTypeAssertion | AssertionExpression) {
        let type: TypeNode;
        let expression: Expression;
        switch (node.kind) {
            case SyntaxKind.CastExpression:
            case SyntaxKind.TypeAssertionExpression:
                type = node.type;
                expression = node.expression;
                break;
            case SyntaxKind.ParenthesizedExpression:
                type = getJSDocTypeAssertionType(node);
                expression = node.expression;
                break;
        }

        return { type, expression };
    }

    function checkTypeParameterDeferred(node: TypeParameterDeclaration) {
        if (isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent)) {
            const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
            const modifiers = getTypeParameterModifiers(typeParameter) & (ModifierFlags.In | ModifierFlags.Out);
            if (modifiers) {
                const symbol = getSymbolOfDeclaration(node.parent);
                if (isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped))) {
                    error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types);
                }
                else if (modifiers === ModifierFlags.In || modifiers === ModifierFlags.Out) {
                    tracing?.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) });
                    const source = createMarkerType(symbol, typeParameter, modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck);
                    const target = createMarkerType(symbol, typeParameter, modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck);
                    const saveVarianceTypeParameter = typeParameter;
                    varianceTypeParameter = typeParameter;
                    checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation);
                    varianceTypeParameter = saveVarianceTypeParameter;
                    tracing?.pop();
                }
            }
        }
    }
    
    function checkFunctionExpressionOrObjectLiteralMethodDeferred(node: FunctionExpression | InlineClosureExpression) {
        // Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));

        const functionFlags = getFunctionFlags(node);
        const returnType = getReturnTypeFromAnnotation(node);
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);

        if (node.body) {   
            if (isInlineClosureExpression(node) && isArray(node.body as unknown as NodeArray<Expression>)) {
                console.warn("todo - getReturnTypeFromBody - possible FluffOS function shortcut");                               
                // TODO - remove this hack                
                (node.body as unknown as NodeArray<Expression>).forEach(e => checkExpression(e));
                return;
            }

            if (!getEffectiveReturnTypeNode(node)) {
                // There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
                // we need. An example is the noImplicitAny errors resulting from widening the return expression
                // of a function. Because checking of function expression bodies is deferred, there was never an
                // appropriate time to do this during the main walk of the file (see the comment at the top of
                // checkFunctionExpressionBodies). So it must be done now.
                getReturnTypeOfSignature(getSignatureFromDeclaration(node));
            }

            if (node.body.kind === SyntaxKind.Block) {
                checkSourceElement(node.body);
            }
            else {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so we
                // should not be checking assignability of a promise to the return type. Instead, we need to
                // check assignability of the awaited type of the expression body against the promised type of
                // its return type annotation.
                const exprType = checkExpression(node.body);
                const returnOrPromisedType = returnType && unwrapReturnType(returnType, functionFlags);
                if (returnOrPromisedType) {
                    const effectiveCheckNode = getEffectiveCheckNode(node.body);
                    // if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async) { // Async function
                    //     const awaitedType = checkAwaitedType(exprType, /*withAlias*/ false, effectiveCheckNode, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                    //     checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode);
                    // }
                    // else { // Normal function
                        checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode);
                    // }
                }
            }
        }
    }
    
    function resolveUntypedCall(node: CallLikeExpression): Signature {                
        if (callLikeExpressionMayHaveTypeArguments(node)) {
            // Check type arguments even though we will give an error that untyped calls may not accept type arguments.
            // This gets us diagnostics for the type arguments and marks them as referenced.
            forEach(node.typeArguments, checkSourceElement);
        }

        if (isBinaryExpression(node)) {
            checkExpression((node as BinaryExpression).left);
        }
        else if (isCallOrNewExpression(node)) {
            forEach(node.arguments, argument => {
                checkExpression(argument);
            });
        }
        return anySignature;
    }

    function callLikeExpressionMayHaveTypeArguments(node: CallLikeExpression): node is CallExpression /*| NewExpression*/ {
        return isCallOrNewExpression(node);
    }
    
    function getSignaturesOfSymbol(symbol: Symbol | undefined): Signature[] {
        if (!symbol || !symbol.declarations) return emptyArray;
        const result: Signature[] = [];
        for (let i = 0; i < symbol.declarations.length; i++) {
            const decl = symbol.declarations[i];
            if (!isFunctionLike(decl)) continue;
            // Don't include signature if node is the implementation of an overloaded function. A node is considered
            // an implementation node if it has a body and the previous node is of the same kind and immediately
            // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
            if (i > 0 && (decl as FunctionLikeDeclaration).body) {
                const previous = symbol.declarations[i - 1];
                if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                    continue;
                }
            }
            if (isInJSFile(decl) && decl.jsDoc) {
                const tags = getJSDocOverloadTags(decl);
                if (length(tags)) {
                    for (const tag of tags) {
                        const jsDocSignature = tag.typeExpression;
                        if (jsDocSignature.type === undefined && !isConstructorDeclaration(decl)) {
                            reportImplicitAny(jsDocSignature, anyType);
                        }
                        result.push(getSignatureFromDeclaration(jsDocSignature));
                    }
                    continue;
                }
            }
            // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.
            // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.
            result.push(
                (!isFunctionExpressionOrInlineClosure(decl) &&
                    !isObjectLiteralMethod(decl) &&
                    getSignatureOfTypeTag(decl)) ||
                    getSignatureFromDeclaration(decl),
            );
        }
        return result;
    }

    function getIndexSymbol(symbol: Symbol): Symbol | undefined {
        return symbol?.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined;
    }

    function getIndexInfosOfSymbol(symbol: Symbol): IndexInfo[] {
        const indexSymbol = getIndexSymbol(symbol);
        return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray;
    }

    function getIndexInfosOfIndexSymbol(indexSymbol: Symbol): IndexInfo[] {
        if (indexSymbol.declarations) {
            const indexInfos: IndexInfo[] = [];
            for (const declaration of (indexSymbol.declarations as IndexSignatureDeclaration[])) {
                if (declaration.parameters.length === 1) {
                    const parameter = declaration.parameters[0];
                    if (parameter.type) {
                        forEachType(getTypeFromTypeNode(parameter.type), keyType => {
                            if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType)) {
                                indexInfos.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, hasEffectiveModifier(declaration, ModifierFlags.Readonly), declaration));
                            }
                        });
                    }
                }
            }
            return indexInfos;
        }
        return emptyArray;
    }

    function isValidIndexKeyType(type: Type): boolean {
        return !!(type.flags & (TypeFlags.String | TypeFlags.Number));
    }

    function resolveDeclaredMembers(type: InterfaceType): InterfaceTypeWithDeclaredMembers {
        if (!(type as InterfaceTypeWithDeclaredMembers).declaredProperties) {
            resolveAnonymousTypeMembers(type);
            
            const symbol = type.symbol;
            const members = getMembersOfSymbol(symbol);            
            
            (type as InterfaceTypeWithDeclaredMembers).declaredProperties = getNamedMembers(members);
            // Start with signatures at empty array in case of recursive types
            (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = emptyArray;
            (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = emptyArray;
            (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = emptyArray;

            (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call));
            (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New));
            (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = getIndexInfosOfSymbol(symbol);
        }
        return type as InterfaceTypeWithDeclaredMembers;
    }
    
    function checkExpression(node: Expression|QualifiedName, checkMode?: CheckMode, forceTuple?: boolean, symbolFlags?: SymbolFlags): Type {
        tracing?.push(tracing.Phase.Check, "checkExpression", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath });
        const saveCurrentNode = currentNode;
        currentNode = node;
        instantiationCount = 0;
        const uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple, symbolFlags);
        const type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        currentNode = saveCurrentNode;
        tracing?.pop();
        return type;
    }

    function resolveTypeReferenceMembers(type: TypeReference): void {
        const source = resolveDeclaredMembers(type.target);
        const typeParameters = concatenate(source.typeParameters!, [source.thisType!]);
        const typeArguments = getTypeArguments(type);
        const paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]);
        resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
    }

    function instantiateSignature(signature: Signature, mapper: TypeMapper, eraseTypeParameters?: boolean): Signature {
        let freshTypeParameters: TypeParameter[] | undefined;
        if (signature.typeParameters && !eraseTypeParameters) {
            // First create a fresh set of type parameters, then include a mapping from the old to the
            // new type parameters in the mapper function. Finally store this mapper in the new type
            // parameters such that we can use it when instantiating constraints.
            freshTypeParameters = map(signature.typeParameters, cloneTypeParameter);
            mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            for (const tp of freshTypeParameters) {
                tp.mapper = mapper;
            }
        }
        // Don't compute resolvedReturnType and resolvedTypePredicate now,
        // because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
        // See GH#17600.
        const result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, signature.minArgumentCount, signature.flags & SignatureFlags.PropagatingFlags);
        result.target = signature;
        result.mapper = mapper;
        return result;
    }

    function instantiateSignatures(signatures: readonly Signature[], mapper: TypeMapper): readonly Signature[] {
        return instantiateList<Signature>(signatures, mapper, instantiateSignature);
    }   

    function instantiateIndexInfo(info: IndexInfo, mapper: TypeMapper) {
        return createIndexInfo(info.keyType, instantiateType(info.type, mapper), info.isReadonly, info.declaration);
    }

    function instantiateIndexInfos(indexInfos: readonly IndexInfo[], mapper: TypeMapper): readonly IndexInfo[] {
        return instantiateList<IndexInfo>(indexInfos, mapper, instantiateIndexInfo);
    }

    function addInheritedMembers(symbols: SymbolTable, baseSymbols: Symbol[]) {
        for (const base of baseSymbols) {
            // if (isStaticPrivateIdentifierProperty(base)) {
            //     continue;
            // }
            const derived = symbols.get(base.name);
            if (
                !derived
                // non-constructor/static-block assignment declarations are ignored here; they're not treated as overrides
                || derived.valueDeclaration
                    && isBinaryExpression(derived.valueDeclaration)                    
            ) {
                symbols.set(base.name, base);                
            }
        }
    }

    function resolveObjectTypeMembers(type: ObjectType, source: InterfaceTypeWithDeclaredMembers, typeParameters: readonly TypeParameter[], typeArguments: readonly Type[]) {
        let mapper: TypeMapper | undefined;
        let members: SymbolTable;
        let callSignatures: readonly Signature[];
        let constructSignatures: readonly Signature[];
        let indexInfos: readonly IndexInfo[];
        if (rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
            members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties);
            callSignatures = source.declaredCallSignatures;
            constructSignatures = source.declaredConstructSignatures;
            indexInfos = source.declaredIndexInfos;
        }
        else {
            mapper = createTypeMapper(typeParameters, typeArguments);
            members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly*/ typeParameters.length === 1);
            callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
            constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
            indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
        }
        const baseTypes = getBaseTypes(source);
        if (baseTypes.length) {
            if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
                const symbolTable = createSymbolTable(source.declaredProperties);
                // copy index signature symbol as well (for quickinfo)
                const sourceIndex = getIndexSymbol(source.symbol);
                if (sourceIndex) {
                    symbolTable.set(InternalSymbolName.Index, sourceIndex);
                }
                members = symbolTable;
            }
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            const thisArgument = lastOrUndefined(typeArguments);
            for (const baseType of baseTypes) {
                const instantiatedBaseType = /*thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) :*/ baseType;
                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Call));
                constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct));
                const inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly*/ false)];
                indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, info => !findIndexInfo(indexInfos, info.keyType)));
            }
        }
        setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
    }

    
    /**
     * Returns true if the class or interface member given by the symbol is free of "this" references. The
     * function may return false for symbols that are actually free of "this" references because it is not
     * feasible to perform a complete analysis in all cases. In particular, property members with types
     * inferred from their initializers and function members with inferred return types are conservatively
     * assumed not to be free of "this" references.
     */
    function isThisless(symbol: Symbol): boolean {
        // TODO
        // if (symbol.declarations && symbol.declarations.length === 1) {
        //     const declaration = symbol.declarations[0];
        //     if (declaration) {
        //         switch (declaration.kind) {
        //             case SyntaxKind.PropertyDeclaration:
        //             case SyntaxKind.PropertySignature:
        //                 return isThislessVariableLikeDeclaration(declaration as VariableLikeDeclaration);
        //             case SyntaxKind.MethodDeclaration:
        //             case SyntaxKind.MethodSignature:
        //             case SyntaxKind.Constructor:
        //             case SyntaxKind.GetAccessor:
        //             case SyntaxKind.SetAccessor:
        //                 return isThislessFunctionLikeDeclaration(declaration as FunctionLikeDeclaration | AccessorDeclaration);
        //         }
        //     }
        // }
        return true;
    }

    function instantiateSymbol(symbol: Symbol, mapper: TypeMapper): Symbol {
        const links = getSymbolLinks(symbol);
        // If the type of the symbol is already resolved, and if that type could not possibly
        // be affected by instantiation, simply return the symbol itself.
        if (links.type && !couldContainTypeVariables(links.type)) {
            if (!(symbol.flags & SymbolFlags.SetAccessor)) {
                return symbol;
            }
            // If we're a setter, check writeType.
            if (links.writeType && !couldContainTypeVariables(links.writeType)) {
                return symbol;
            }
        }
        if (getCheckFlags(symbol) & CheckFlags.Instantiated) {
            // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
            // type mappers. This ensures that original type identities are properly preserved and that aliases
            // always reference a non-aliases.
            symbol = links.target!;
            mapper = combineTypeMappers(links.mapper, mapper);
        }
        // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
        // also transient so that we can just store data on it directly.
        const result = createSymbol(symbol.flags, symbol.name, CheckFlags.Instantiated | getCheckFlags(symbol) & (CheckFlags.Readonly | CheckFlags.Late | CheckFlags.OptionalParameter | CheckFlags.RestParameter));
        result.declarations = symbol.declarations;
        result.parent = symbol.parent;
        result.links.target = symbol;
        result.links.mapper = mapper;
        if (symbol.valueDeclaration) {
            result.valueDeclaration = symbol.valueDeclaration;
        }
        if (links.nameType) {
            result.links.nameType = links.nameType;
        }
        return result;
    }


    // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
    // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
    function createInstantiatedSymbolTable(symbols: Symbol[], mapper: TypeMapper, mappingThisOnly: boolean): SymbolTable {
        const result = createSymbolTable();
        for (const symbol of symbols) {
            result.set(symbol.name, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
        }
        return result;
    }

    function getNamedOrIndexSignatureMembers(members: SymbolTable): Symbol[] {
        const result = getNamedMembers(members);
        const index = getIndexSymbolFromSymbolTable(members);
        return index ? concatenate(result, [index]) : result;
    }

    /**
     * Converts an AnonymousType to a ResolvedType.
     */
    function resolveAnonymousTypeMembers(type: AnonymousType) {
        if (type.target) {
            setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
            const members = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper!, /*mappingThisOnly*/ false);
            const callSignatures = instantiateSignatures(getSignaturesOfType(type.target, SignatureKind.Call), type.mapper!);
            const constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, SignatureKind.Construct), type.mapper!);
            const indexInfos = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper!);
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            return;
        }
        const symbol = getMergedSymbol(type.symbol);
        if (!symbol) {
            console.debug("no symbol found");
            return;
        }
        if (symbol.flags & SymbolFlags.TypeLiteral) {
            setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
            const members = getMembersOfSymbol(symbol);
            const callSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call));
            const constructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New));
            const indexInfos = getIndexInfosOfSymbol(symbol);
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            return;
        }
        // Combinations of function, class, enum and module
        let members = getExportsOfSymbol(symbol);
        let indexInfos: IndexInfo[] | undefined;
        // if (symbol === globalThisSymbol) {
        //     const varsOnly = new Map<string, Symbol>();
        //     members.forEach(p => {
        //         if (!(p.flags & SymbolFlags.BlockScoped) && !(p.flags & SymbolFlags.ValueModule && p.declarations?.length && every(p.declarations, isAmbientModule))) {
        //             varsOnly.set(p.name, p);
        //         }
        //     });
        //     members = varsOnly;
        // }
        let baseConstructorIndexInfo: IndexInfo | undefined;
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, emptyArray);
        if (symbol?.flags & SymbolFlags.Class) {
            const classType = getDeclaredTypeOfClassOrInterface(symbol);            
            if (classType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.TypeVariable)) {
                members = createSymbolTable(getNamedOrIndexSignatureMembers(members));
                addInheritedMembers(members, getPropertiesOfType(classType));
            }            
        }

        const indexSymbol = getIndexSymbolFromSymbolTable(members);
        if (indexSymbol) {
            indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
        }
        else {
            if (baseConstructorIndexInfo) {
                indexInfos = append(indexInfos, baseConstructorIndexInfo);
            }
            // if (
            //     symbol.flags & SymbolFlags.Enum && (getDeclaredTypeOfSymbol(symbol).flags & TypeFlags.Enum ||
            //         some(type.properties, prop => !!(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike)))
            // ) {
            //     indexInfos = append(indexInfos, enumNumberIndexInfo);
            // }
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray);
        // We resolve the members before computing the signatures because a signature may use
        // typeof with a qualified name expression that circularly references the type we are
        // in the process of resolving (see issue #6072). The temporarily empty signature list
        // will never be observed because a qualified name can't reference signatures.
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {
            type.callSignatures = getSignaturesOfSymbol(symbol);
        }
        // And likewise for construct signatures for classes
        if (symbol.flags & SymbolFlags.Class) {
            const classType = getDeclaredTypeOfClassOrInterface(symbol);
            let constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray;            
            if (symbol.flags & SymbolFlags.Function) {
                console.debug("todo - resolveAnonymousTypeMembers - function");
                constructSignatures = addRange(
                    constructSignatures.slice(),
                    mapDefined(
                        type.callSignatures,
                        sig => undefined
                            // isJSConstructor(sig.declaration) ?
                            //     createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) :
                            //     undefined,
                    ),
                );
            }
            if (!constructSignatures.length) {
                constructSignatures = getDefaultConstructSignatures(classType);
            }
            type.constructSignatures = constructSignatures;
        }
    }

    function typeArgumentsFromTypeReferenceNode(node: NodeWithTypeArguments): Type[] | undefined {
        return map(node.typeArguments, getTypeFromTypeNode);
    }

    function getDefaultConstructSignatures(classType: InterfaceType): Signature[] {        
        const baseConstructorType = getBaseConstructorTypeOfClass(classType);
        const baseSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);
        const declaration = getClassLikeDeclarationOfSymbol(classType.symbol);
        const isAbstract = false;//!!declaration && hasSyntacticModifier(declaration, ModifierFlags.Abstract);
        if (baseSignatures.length === 0) {
            return [createSignature(/*declaration*/ undefined, classType.localTypeParameters, /*thisParameter*/ undefined, emptyArray, classType, /*resolvedTypePredicate*/ undefined, 0, isAbstract ? SignatureFlags.Abstract : SignatureFlags.None)];
        }
        const baseTypeNode = getBaseTypeNodeOfClass(classType)!;
        const isJavaScript = isInJSFile(baseTypeNode);
        const typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
        const typeArgCount = length(typeArguments);
        const result: Signature[] = [];
        for (const baseSig of baseSignatures) {
            const minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
            const typeParamCount = length(baseSig.typeParameters);
            if (isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount) {
                const sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);
                sig.typeParameters = classType.localTypeParameters;
                sig.resolvedReturnType = classType;
                sig.flags = isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract;
                result.push(sig);
            }
        }
        return result;
    }

    function resolveClassOrInterfaceMembers(type: InterfaceType): void {
        resolveObjectTypeMembers(type, resolveDeclaredMembers(type), emptyArray, emptyArray);
    }
    
    function resolveReverseMappedTypeMembers(type: ReverseMappedType) {
        console.debug("todo - resolveReverseMappedTypeMembers");
        // const indexInfo = getIndexInfoOfType(type.source, stringType);
        // const modifiers = getMappedTypeModifiers(type.mappedType);
        // const readonlyMask = modifiers & MappedTypeModifiers.IncludeReadonly ? false : true;
        // const optionalMask = modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional;
        // const indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray;
        // const members = createSymbolTable();
        // const limitedConstraint = getLimitedConstraint(type);
        // for (const prop of getPropertiesOfType(type.source)) {
        //     // In case of a reverse mapped type with an intersection constraint, if we were able to
        //     // extract the filtering type literals we skip those properties that are not assignable to them,
        //     // because the extra properties wouldn't get through the application of the mapped type anyway
        //     if (limitedConstraint) {
        //         const propertyNameType = getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique);
        //         if (!isTypeAssignableTo(propertyNameType, limitedConstraint)) {
        //             continue;
        //         }
        //     }
        //     const checkFlags = CheckFlags.ReverseMapped | (readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0);
        //     const inferredProp = createSymbol(SymbolFlags.Property | prop.flags & optionalMask, prop.name, checkFlags) as ReverseMappedSymbol;
        //     inferredProp.declarations = prop.declarations;
        //     inferredProp.links.nameType = getSymbolLinks(prop).nameType;
        //     inferredProp.links.propertyType = getTypeOfSymbol(prop);
        //     if (
        //         type.constraintType.type.flags & TypeFlags.IndexedAccess
        //         && (type.constraintType.type as IndexedAccessType).objectType.flags & TypeFlags.TypeParameter
        //         && (type.constraintType.type as IndexedAccessType).indexType.flags & TypeFlags.TypeParameter
        //     ) {
        //         // A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
        //         // inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
        //         // type identities produced, we simplify such indexed access occurences
        //         const newTypeParam = (type.constraintType.type as IndexedAccessType).objectType;
        //         const newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type as ReplaceableIndexedAccessType, newTypeParam);
        //         inferredProp.links.mappedType = newMappedType as MappedType;
        //         inferredProp.links.constraintType = getIndexType(newTypeParam) as IndexType;
        //     }
        //     else {
        //         inferredProp.links.mappedType = type.mappedType;
        //         inferredProp.links.constraintType = type.constraintType;
        //     }
        //     members.set(prop.name, inferredProp);
        // }
        // setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos);
    }

    function resolveMappedTypeMembers(type: MappedType) {
        console.debug("todo - resolveMappedTypeMembers");
    }

    function resolveStructuredTypeMembers(type: StructuredType): ResolvedType {        
        if (!(type as ResolvedType).members) {
            if (type.flags & TypeFlags.Object) {
                if ((type as ObjectType).objectFlags & ObjectFlags.Reference) {
                    resolveTypeReferenceMembers(type as TypeReference);
                }
                else if ((type as ObjectType).objectFlags & ObjectFlags.ClassOrInterface) {
                    resolveClassOrInterfaceMembers(type as InterfaceType);
                }
                else if ((type as ObjectType).objectFlags & ObjectFlags.ClassOrInterface) {
                    resolveClassOrInterfaceMembers(type as InterfaceType);
                }
                else if ((type as ReverseMappedType).objectFlags & ObjectFlags.ReverseMapped) {
                    resolveReverseMappedTypeMembers(type as ReverseMappedType);
                }
                else if ((type as ObjectType).objectFlags & ObjectFlags.Anonymous) {
                    resolveAnonymousTypeMembers(type as AnonymousType);
                }
                else if ((type as MappedType).objectFlags & ObjectFlags.Mapped) {
                    resolveMappedTypeMembers(type as MappedType);
                }
                else {
                    // console.warn("Unhandled object type " + Debug.formatObjectFlags(type.objectFlags));
                }
            }
            else if (type.flags & TypeFlags.Union) {
                resolveUnionTypeMembers(type as UnionType);
            }
            else if (type.flags & TypeFlags.Intersection) {
                resolveIntersectionTypeMembers(type as IntersectionType);
            }
            else {
                Debug.fail("Unhandled type " + Debug.formatTypeFlags(type.flags));
            }
        }
        return type as ResolvedType;
    }
    
    function resolveIntersectionTypeMembers(type: IntersectionType) {
        // The members and properties collections are empty for intersection types. To get all properties of an
        // intersection type use getPropertiesOfType (only the language service uses this).
        let callSignatures: Signature[] | undefined;
        let constructSignatures: Signature[] | undefined;
        let indexInfos: IndexInfo[] | undefined;
        const types = type.types;
        const mixinFlags = findMixins(types);
        const mixinCount = countWhere(mixinFlags, b => b);
        for (let i = 0; i < types.length; i++) {
            const t = type.types[i];
            // When an intersection type contains mixin constructor types, the construct signatures from
            // those types are discarded and their return types are mixed into the return types of all
            // other construct signatures in the intersection type. For example, the intersection type
            // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
            // 'new(s: string) => A & B'.
            if (!mixinFlags[i]) {
                let signatures = getSignaturesOfType(t, SignatureKind.Construct);
                if (signatures.length && mixinCount > 0) {
                    signatures = map(signatures, s => {
                        const clone = cloneSignature(s);
                        clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                        return clone;
                    });
                }
                constructSignatures = appendSignatures(constructSignatures, signatures);
            }
            callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));
            indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, /*union*/ false), indexInfos);
        }
        setStructuredTypeMembers(type, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray);
    }

    function appendSignatures(signatures: Signature[] | undefined, newSignatures: readonly Signature[]) {
        for (const sig of newSignatures) {
            if (!signatures || every(signatures, s => !compareSignaturesIdentical(s, sig, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, compareTypesIdentical))) {
                signatures = append(signatures, sig);
            }
        }
        return signatures;
    }

    function appendIndexInfo(indexInfos: IndexInfo[] | undefined, newInfo: IndexInfo, union: boolean) {
        if (indexInfos) {
            for (let i = 0; i < indexInfos.length; i++) {
                const info = indexInfos[i];
                if (info.keyType === newInfo.keyType) {
                    indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                    return indexInfos;
                }
            }
        }
        return append(indexInfos, newInfo);
    }

    // A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
    // rest parameter of type any[].
    function isMixinConstructorType(type: Type) {
        const signatures = getSignaturesOfType(type, SignatureKind.Construct);
        if (signatures.length === 1) {
            const s = signatures[0];
            if (!s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s)) {
                const paramType = getTypeOfParameter(s.parameters[0]);
                return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType;
            }
        }
        return false;
    }

    function findMixins(types: readonly Type[]): readonly boolean[] {
        const constructorTypeCount = countWhere(types, t => getSignaturesOfType(t, SignatureKind.Construct).length > 0);
        const mixinFlags = map(types, isMixinConstructorType);
        if (constructorTypeCount > 0 && constructorTypeCount === countWhere(mixinFlags, b => b)) {
            const firstMixinIndex = mixinFlags.indexOf(/*searchElement*/ true);
            mixinFlags[firstMixinIndex] = false;
        }
        return mixinFlags;
    }

    function includeMixinType(type: Type, types: readonly Type[], mixinFlags: readonly boolean[], index: number): Type {
        const mixedTypes: Type[] = [];
        for (let i = 0; i < types.length; i++) {
            if (i === index) {
                mixedTypes.push(type);
            }
            else if (mixinFlags[i]) {
                mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));
            }
        }
        return getIntersectionType(mixedTypes);
    }


    function resolveUnionTypeMembers(type: UnionType) {
        // The members and properties collections are empty for union types. To get all properties of a union
        // type use getPropertiesOfType (only the language service uses this).
        const callSignatures = getUnionSignatures(map(type.types, t => t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call)));
        const constructSignatures = getUnionSignatures(map(type.types, t => getSignaturesOfType(t, SignatureKind.Construct)));
        const indexInfos = getUnionIndexInfos(type.types);
        setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
    }

    function getUnionIndexInfos(types: readonly Type[]): IndexInfo[] {
        const sourceInfos = getIndexInfosOfType(types[0]);
        if (sourceInfos) {
            const result = [];
            for (const info of sourceInfos) {
                const indexType = info.keyType;
                if (every(types, t => !!getIndexInfoOfType(t, indexType))) {
                    result.push(createIndexInfo(indexType, getUnionType(map(types, t => getIndexTypeOfType(t, indexType)!)), some(types, t => getIndexInfoOfType(t, indexType)!.isReadonly)));
                }
            }
            return result;
        }
        return emptyArray;
    }

    // The signatures of a union type are those signatures that are present in each of the constituent types.
    // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
    // parameters and may differ in return types. When signatures differ in return types, the resulting return
    // type is the union of the constituent return types.
    function getUnionSignatures(signatureLists: readonly (readonly Signature[])[]): Signature[] {
        let result: Signature[] | undefined;
        let indexWithLengthOverOne: number | undefined;
        for (let i = 0; i < signatureLists.length; i++) {
            if (signatureLists[i].length === 0) return emptyArray;
            if (signatureLists[i].length > 1) {
                indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets
            }
            for (const signature of signatureLists[i]) {
                // Only process signatures with parameter lists that aren't already in the result list
                if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true)) {
                    const unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                    if (unionSignatures) {
                        let s = signature;
                        // Union the result types when more than one signature matches
                        if (unionSignatures.length > 1) {
                            let thisParameter = signature.thisParameter;
                            const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);
                            if (firstThisParameterOfUnionSignatures) {
                                const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));
                                thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
                            }
                            s = createUnionSignature(signature, unionSignatures);
                            s.thisParameter = thisParameter;
                        }
                        (result || (result = [])).push(s);
                    }
                }
            }
        }
        if (!length(result) && indexWithLengthOverOne !== -1) {
            // No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
            // signature that handles all over them. We only do this when there are overloads in only one constituent.
            // (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
            // signatures from the type, whose ordering would be non-obvious)
            const masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
            let results: Signature[] | undefined = masterList.slice();
            for (const signatures of signatureLists) {
                if (signatures !== masterList) {
                    const signature = signatures[0];
                    Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");
                    results = !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature));
                    if (!results) {
                        break;
                    }
                }
            }
            result = results;
        }
        return result || emptyArray;
    }

    function combineSignaturesOfUnionMembers(left: Signature, right: Signature): Signature {
        const typeParams = left.typeParameters || right.typeParameters;
        let paramMapper: TypeMapper | undefined;
        if (left.typeParameters && right.typeParameters) {
            paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
            // We just use the type parameter defaults from the first signature
        }
        const declaration = left.declaration;
        const params = combineUnionParameters(left, right, paramMapper);
        //const thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper);
        const minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
        const result = createSignature(
            declaration,
            typeParams,
            undefined, // TODO            // thisParam,
            params,
            /*resolvedReturnType*/ undefined,
            /*resolvedTypePredicate*/ undefined,
            minArgCount,
            (left.flags | right.flags) & SignatureFlags.PropagatingFlags,
        );
        result.compositeKind = TypeFlags.Union;
        result.compositeSignatures = concatenate(left.compositeKind !== TypeFlags.Intersection && left.compositeSignatures || [left], [right]);
        if (paramMapper) {
            result.mapper = left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
        }
        else if (left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures) {
            result.mapper = left.mapper;
        }
        return result;
    }

    function combineUnionParameters(left: Signature, right: Signature, mapper: TypeMapper | undefined) {
        const leftCount = getParameterCount(left);
        const rightCount = getParameterCount(right);
        const longest = leftCount >= rightCount ? left : right;
        const shorter = longest === left ? right : left;
        const longestCount = longest === left ? leftCount : rightCount;
        const eitherHasEffectiveRest = hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right);
        const needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
        const params = new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0));
        for (let i = 0; i < longestCount; i++) {
            let longestParamType = tryGetTypeAtPosition(longest, i)!;
            if (longest === right) {
                longestParamType = instantiateType(longestParamType, mapper);
            }
            let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
            if (shorter === right) {
                shorterParamType = instantiateType(shorterParamType, mapper);
            }
            const unionParamType = getIntersectionType([longestParamType, shorterParamType]);
            const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
            const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
            const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
            const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);

            const paramName = leftName === rightName ? leftName :
                !leftName ? rightName :
                !rightName ? leftName :
                undefined;
            const paramSymbol = createSymbol(
                SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),
                paramName || `arg${i}` as string,
                isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,
            );
            paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
            params[i] = paramSymbol;
        }
        if (needsExtraRestElement) {
            const restParamSymbol = createSymbol(SymbolFlags.FunctionScopedVariable, "args" as string, CheckFlags.RestParameter);
            restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount));
            if (shorter === right) {
                restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper);
            }
            params[longestCount] = restParamSymbol;
        }
        return params;
    }

    function getParameterNameAtPosition(signature: Signature, pos: number, overrideRestType?: Type) {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            return signature.parameters[pos].name;
        }
        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        const restType = overrideRestType || getTypeOfSymbol(restParameter);
        // if (isTupleType(restType)) {
        //     const associatedNames = ((restType as TypeReference).target as TupleType).labeledElementDeclarations;
        //     const index = pos - paramCount;
        //     return getTupleElementLabel(associatedNames?.[index], index, restParameter.name);
        // }
        return restParameter.name;
    }

    function compareTypeParametersIdentical(sourceParams: readonly TypeParameter[] | undefined, targetParams: readonly TypeParameter[] | undefined): boolean {
        if (length(sourceParams) !== length(targetParams)) {
            return false;
        }
        if (!sourceParams || !targetParams) {
            return true;
        }

        const mapper = createTypeMapper(targetParams, sourceParams);
        for (let i = 0; i < sourceParams.length; i++) {
            const source = sourceParams[i];
            const target = targetParams[i];
            if (source === target) continue;
            // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
            if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;
            // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
            // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
            // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
            // and, since it's just an inference _default_, just picking one arbitrarily works OK.
        }

        return true;
    }

    /** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
    function getConstraintFromTypeParameter(typeParameter: TypeParameter): Type | undefined {
        if (!typeParameter.constraint) {
            if (typeParameter.target) {
                const targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
            }
            else {                
                const constraintDeclaration = getConstraintDeclaration(typeParameter);
                if (!constraintDeclaration) {
                    typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                }
                else {
                    let type = getTypeFromTypeNode(constraintDeclaration);
                    if (type.flags & TypeFlags.Any && !isErrorType(type)) { // Allow errorType to propegate to keep downstream errors suppressed
                        // use stringNumberSymbolType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
                        // use unknown otherwise
                        type = constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType;
                    }
                    typeParameter.constraint = type;
                }
            }
        }
        return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
    }

    function getEffectiveTypeArgumentAtIndex(node: TypeReferenceNode | ExpressionWithTypeArguments, typeParameters: readonly TypeParameter[], index: number): Type {
        if (node.typeArguments && index < node.typeArguments.length) {
            return getTypeFromTypeNode(node.typeArguments[index]);
        }
        return getEffectiveTypeArguments(node, typeParameters)[index];
    }
    
    function getInferredTypeParameterConstraint(typeParameter: TypeParameter, omitTypeReferences?: boolean) {
        let inferences: Type[] | undefined;
        if (typeParameter.symbol?.declarations) {
            for (const declaration of typeParameter.symbol.declarations) {
                if (declaration.parent.kind === SyntaxKind.InferType) {
                    // When an 'infer T' declaration is immediately contained in a type reference node
                    // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
                    // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
                    // present, we form an intersection of the inferred constraint types.
                    const [childTypeParameter = declaration.parent, grandParent] = walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent);
                    if (grandParent.kind === SyntaxKind.TypeReference && !omitTypeReferences) {
                        const typeReference = grandParent as TypeReferenceNode;
                        const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReference);
                        if (typeParameters) {
                            const index = typeReference.typeArguments!.indexOf(childTypeParameter as TypeNode);
                            if (index < typeParameters.length) {
                                const declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                                if (declaredConstraint) {
                                    // Type parameter constraints can reference other type parameters so
                                    // constraints need to be instantiated. If instantiation produces the
                                    // type parameter itself, we discard that inference. For example, in
                                    //   type Foo<T extends string, U extends T> = [T, U];
                                    //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
                                    // the instantiated constraint for U is X, so we discard that inference.
                                    const mapper = makeDeferredTypeMapper(
                                        typeParameters,
                                        typeParameters.map((_, index) => () => {
                                            return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index);
                                        }),
                                    );
                                    const constraint = instantiateType(declaredConstraint, mapper);
                                    if (constraint !== typeParameter) {
                                        inferences = append(inferences, constraint);
                                    }
                                }
                            }
                        }
                    }
                    // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
                    // or a named rest tuple element, we infer an 'unknown[]' constraint.
                    else if (
                        grandParent.kind === SyntaxKind.Parameter && (grandParent as ParameterDeclaration).dotDotDotToken ||
                        grandParent.kind === SyntaxKind.RestType ||
                        grandParent.kind === SyntaxKind.NamedTupleMember && (grandParent as NamedTupleMember).dotDotDotToken
                    ) {
                        inferences = append(inferences, createArrayType(unknownType));
                    }
                    // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
                    // constraint.
                    // else if (grandParent.kind === SyntaxKind.TemplateLiteralTypeSpan) {
                    //     inferences = append(inferences, stringType);
                    // }
                    // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
                    // constraint.
                    else if (grandParent.kind === SyntaxKind.TypeParameter && grandParent.parent.kind === SyntaxKind.MappedType) {
                        inferences = append(inferences, stringNumberSymbolType);
                    }
                    // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
                    // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template
                    // of the check type's mapped type
                    else if (
                        grandParent.kind === SyntaxKind.MappedType && (grandParent as MappedTypeNode).type &&
                        skipParentheses((grandParent as MappedTypeNode).type!) === declaration.parent && grandParent.parent.kind === SyntaxKind.ConditionalType &&
                        (grandParent.parent as ConditionalTypeNode).extendsType === grandParent && (grandParent.parent as ConditionalTypeNode).checkType.kind === SyntaxKind.MappedType &&
                        ((grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode).type
                    ) {
                        const checkMappedType = (grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode;
                        const nodeType = getTypeFromTypeNode(checkMappedType.type!);
                        inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)), checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType)));
                    }
                }
            }
        }
        return inferences && getIntersectionType(inferences);
    }
    
    function findMatchingSignature(signatureList: readonly Signature[], signature: Signature, partialMatch: boolean, ignoreThisTypes: boolean, ignoreReturnTypes: boolean): Signature | undefined {
        for (const s of signatureList) {
            if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) {
                return s;
            }
        }
    }

    function compareTypesSubtypeOf(source: Type, target: Type): Ternary {
        return isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False;
    }
    
    function findMatchingSignatures(signatureLists: readonly (readonly Signature[])[], signature: Signature, listIndex: number): Signature[] | undefined {
        if (signature.typeParameters) {
            // We require an exact match for generic signatures, so we only return signatures from the first
            // signature list and only if they have exact matches in the other signature lists.
            if (listIndex > 0) {
                return undefined;
            }
            for (let i = 1; i < signatureLists.length; i++) {
                if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false)) {
                    return undefined;
                }
            }
            return [signature];
        }
        let result: Signature[] | undefined;
        for (let i = 0; i < signatureLists.length; i++) {
            // Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.
            // Prefer matching this types if possible.
            const match = i === listIndex
                ? signature
                : findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true)
                    || findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ true, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true);
            if (!match) {
                return undefined;
            }
            result = appendIfUnique(result, match);
        }
        return result;
    }

    function getSingleSignature(type: Type, kind: SignatureKind, allowMembers: boolean): Signature | undefined {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            if (allowMembers || resolved.properties && resolved.properties?.length === 0 && resolved.indexInfos?.length === 0) {
                if (kind === SignatureKind.Call && resolved.callSignatures?.length === 1 && resolved.constructSignatures?.length === 0) {
                    return resolved.callSignatures[0];
                }
                if (kind === SignatureKind.Construct && resolved.constructSignatures?.length === 1 && resolved.callSignatures?.length === 0) {
                    return resolved.constructSignatures[0];
                }
            }
        }
        return undefined;
    }

    function checkCatchExpression(node: CatchExpression|CatchStatement, checkMode?: CheckMode): Type {
        if (node.block && node.expression) {
            error(node, Diagnostics.Catch_expression_cannot_also_have_a_block);
        }

        if (node.block) {
            checkBlock(node.block);
        } else {
            checkExpression(node.expression, checkMode);                            
        }
        
        
        // catch always returns either 0 or a string
        // for both LD & Fluff
        return getUnionType([falseType, stringType]);        
    }

    function checkSuperExpression(node: SuperAccessExpression, checkMode?: CheckMode): Type {
        getNodeLinks(node).flags |= NodeCheckFlags.SuperInstance;

        // grammar
        const sourceFile = getSourceFileOfNode(node);
        const sourceSymbol = getSymbolOfNode(sourceFile);
        if (!sourceSymbol.inherits?.size && (!node.namespace || getTextOfNode(node.namespace) !== InternalSymbolName.EfunSuperPrefix)) {
            error(node, Diagnostics.Super_access_can_only_be_used_in_a_file_that_inherits_from_another_file);
        }

        // type
        const sourceType = getDeclaredTypeOfSymbol(sourceSymbol) as InterfaceType;
        const baseSourceType = sourceType && getBaseTypes(sourceType)[0];
        if (!baseSourceType) {
            return errorType;
        }

        // resolve the name
        return checkIdentifier(node.name, checkMode);
    }

    function hasTypeParameterByName(typeParameters: readonly TypeParameter[] | undefined, name: string) {
        return some(typeParameters, tp => tp.symbol.name === name);
    }

    function getUniqueTypeParameterName(typeParameters: readonly TypeParameter[], baseName: string) {
        let len = (baseName as string).length;
        while (len > 1 && (baseName as string).charCodeAt(len - 1) >= CharacterCodes._0 && (baseName as string).charCodeAt(len - 1) <= CharacterCodes._9) len--;
        const s = (baseName as string).slice(0, len);
        for (let index = 1; true; index++) {
            const augmentedName = s + index as string;
            if (!hasTypeParameterByName(typeParameters, augmentedName)) {
                return augmentedName;
            }
        }
    }
    
    function getUniqueTypeParameters(context: InferenceContext, typeParameters: readonly TypeParameter[]): readonly TypeParameter[] {
        const result: TypeParameter[] = [];
        let oldTypeParameters: TypeParameter[] | undefined;
        let newTypeParameters: TypeParameter[] | undefined;
        for (const tp of typeParameters) {
            const name = tp.symbol.name;
            if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
                const newName = getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name);
                const symbol = createSymbol(SymbolFlags.TypeParameter, newName);
                const newTypeParameter = createTypeParameter(symbol);
                newTypeParameter.target = tp;
                oldTypeParameters = append(oldTypeParameters, tp);
                newTypeParameters = append(newTypeParameters, newTypeParameter);
                result.push(newTypeParameter);
            }
            else {
                result.push(tp);
            }
        }
        if (newTypeParameters) {
            const mapper = createTypeMapper(oldTypeParameters!, newTypeParameters);
            for (const tp of newTypeParameters) {
                tp.mapper = mapper;
            }
        }
        return result;
    }

    function hasOverlappingInferences(a: InferenceInfo[], b: InferenceInfo[]) {
        for (let i = 0; i < a.length; i++) {
            if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
                return true;
            }
        }
        return false;
    }

    function mergeInferences(target: InferenceInfo[], source: InferenceInfo[]) {
        for (let i = 0; i < target.length; i++) {
            if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {
                target[i] = source[i];
            }
        }
    }
    
    function instantiateTypeWithSingleGenericCallSignature(node: Expression|QualifiedName, type: Type, checkMode?: CheckMode) {        
        // not needed for LPC?
        if (checkMode && checkMode & (CheckMode.Inferential | CheckMode.SkipGenericFunctions)) {
            const callSignature = getSingleSignature(type, SignatureKind.Call, /*allowMembers*/ true);
            const constructSignature = getSingleSignature(type, SignatureKind.Construct, /*allowMembers*/ true);
            const signature = callSignature || constructSignature;
            if (signature && signature.typeParameters) {
                const contextualType = getApparentTypeOfContextualType(node as Expression, ContextFlags.NoConstraints);
                if (contextualType) {
                    const contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? SignatureKind.Call : SignatureKind.Construct, /*allowMembers*/ false);
                    if (contextualSignature && !contextualSignature.typeParameters) {
                        if (checkMode & CheckMode.SkipGenericFunctions) {
                            skippedGenericFunction(node, checkMode);
                            return anyFunctionType;
                        }
                        const context = getInferenceContext(node)!;
                        // We have an expression that is an argument of a generic function for which we are performing
                        // type argument inference. The expression is of a function type with a single generic call
                        // signature and a contextual function type with a single non-generic call signature. Now check
                        // if the outer function returns a function type with a single non-generic call signature and
                        // if some of the outer function type parameters have no inferences so far. If so, we can
                        // potentially add inferred type parameters to the outer function return type.
                        const returnType = context.signature && getReturnTypeOfSignature(context.signature);
                        const returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
                        if (returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates)) {
                            // Instantiate the signature with its own type parameters as type arguments, possibly
                            // renaming the type parameters to ensure they have unique names.
                            const uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
                            const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
                            // Infer from the parameters of the instantiated signature to the parameters of the
                            // contextual signature starting with an empty set of inference candidates.
                            const inferences = map(context.inferences, info => createInferenceInfo(info.typeParameter));
                            applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {
                                inferTypes(inferences, source, target, /*priority*/ 0, /*contravariant*/ true);
                            });
                            if (some(inferences, hasInferenceCandidates)) {
                                // We have inference candidates, indicating that one or more type parameters are referenced
                                // in the parameter types of the contextual signature. Now also infer from the return type.
                                applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {
                                    inferTypes(inferences, source, target);
                                });
                                // If the type parameters for which we produced candidates do not have any inferences yet,
                                // we adopt the new inference candidates and add the type parameters of the expression type
                                // to the set of inferred type parameters for the outer function return type.
                                if (!hasOverlappingInferences(context.inferences, inferences)) {
                                    mergeInferences(context.inferences, inferences);
                                    context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                                    return getOrCreateTypeFromSignature(instantiatedSignature);
                                }
                            }
                        }
                        // TODO: The signature may reference any outer inference contexts, but we map pop off and then apply new inference contexts, and thus get different inferred types.
                        // That this is cached on the *first* such attempt is not currently an issue, since expression types *also* get cached on the first pass. If we ever properly speculate, though,
                        // the cached "isolatedSignatureType" signature field absolutely needs to be included in the list of speculative caches.
                        return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context), flatMap(inferenceContexts, c => c && map(c.inferences, i => i.typeParameter)).slice());
                    }
                }
            }
        }
        return type;
    }

    function checkIndexedAccess(node: ElementAccessExpression, checkMode: CheckMode | undefined): Type {
        return node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain, checkMode) :
            checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode);
    }
    
    function checkElementAccessChain(node: ElementAccessChain, checkMode: CheckMode | undefined) {
        const exprType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(exprType, node.expression);
        return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType !== exprType);
    }

    function checkElementAccessExpression(node: ElementAccessExpression, exprType: Type, checkMode: CheckMode | undefined): Type {
        const objectType = getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType;
        const indexExpression = node.argumentExpression;
        const indexType = checkExpression(indexExpression);

        if (isErrorType(objectType) || objectType === silentNeverType) {
            return objectType;
        }

        const effectiveIndexType = indexType;// isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType;
        const assignmentTargetKind = getAssignmentTargetKind(node);
        let accessFlags: AccessFlags;
        if (assignmentTargetKind === AssignmentKind.None) {
            accessFlags = AccessFlags.ExpressionPosition;
        }
        else {
            accessFlags = AccessFlags.Writing | (0);
            if (assignmentTargetKind === AssignmentKind.Compound) {
                accessFlags |= AccessFlags.ExpressionPosition;
            }
        }
        const indexedAccessType = getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType;
        return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node);
    }

    function checkExpressionWorker(node: Expression | QualifiedName, checkMode: CheckMode | undefined, forceTuple?: boolean, symbolFlags?: SymbolFlags): Type {
        const kind = node.kind;
        if (cancellationToken) {
            // Only bother checking on a few construct kinds.  We don't want to be excessively
            // hitting the cancellation token on every node we check.
            switch (kind) {
                case SyntaxKind.ClassExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.InlineClosureExpression:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        switch (kind) {
            case SyntaxKind.Identifier:
                return checkIdentifier(node as Identifier, checkMode, symbolFlags);
            // case SyntaxKind.PrivateIdentifier:
            //     return checkPrivateIdentifierExpression(node as PrivateIdentifier);
            // case SyntaxKind.ThisKeyword:
            //     return checkThisExpression(node);
            // case SyntaxKind.SuperKeyword:
            //     return checkSuperExpression(node);
            // case SyntaxKind.NullKeyword:
            //     return nullWideningType;
            // case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.StringLiteral:
                if (checkMode & CheckMode.StringLiteralAsObject) {
                    const obj = tryResolveStringToObject(node as StringLiteral);
                    if (obj) return obj;
                }            
                return getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteral).text));            
            case SyntaxKind.BytesLiteral:
                return getFreshTypeOfLiteralType(getBytesLiteralType((node as BytesLiteral).text));
            case SyntaxKind.IntLiteral:
                //checkGrammarNumericLiteral(node as NumericLiteral);
                // if ((node as IntLiteral).text == "0") {
                //     return falseType;
                // }
                return getFreshTypeOfLiteralType(getNumberLiteralType(+(node as IntLiteral).text));
            case SyntaxKind.FloatLiteral:
                return getFreshTypeOfLiteralType(getNumberLiteralType(parseFloat((node as FloatLiteral).text)));                        
            // case SyntaxKind.TemplateExpression:
            //     return checkTemplateExpression(node as TemplateExpression);            
            case SyntaxKind.ArrayLiteralExpression:
                return checkArrayLiteral(node as ArrayLiteralExpression, checkMode, forceTuple);            
            case SyntaxKind.MappingLiteralExpression:
                return checkMappingLiteral(node as MappingLiteralExpression, checkMode, false);
            case SyntaxKind.MappingEntryExpression:
                return checkMappingEntry(node as MappingEntryExpression, checkMode, false);
            // case SyntaxKind.ObjectLiteralExpression:
            //     return checkObjectLiteral(node as ObjectLiteralExpression, checkMode);
            case SyntaxKind.PropertyAccessExpression:
                return checkPropertyAccessExpression(node as PropertyAccessExpression, checkMode);
            case SyntaxKind.QualifiedName:
                return checkQualifiedName(node as QualifiedName, checkMode);
            case SyntaxKind.ElementAccessExpression:
                return checkIndexedAccess(node as ElementAccessExpression, checkMode);            
            case SyntaxKind.CallExpression:                
                // if ((node as CallExpression).expression.kind === SyntaxKind.ImportKeyword) {
                //     return checkImportCallExpression(node as ImportCall);
                // }
                // falls through
            case SyntaxKind.NewExpression:
                return checkCallExpression(node as CallExpression, checkMode);
            case SyntaxKind.CloneObjectExpression:
                return checkCloneObjectExpression(node as CloneObjectExpression, checkMode);
            case SyntaxKind.NewStructExpression:
                return checkNewStructExpresion(node as NewStructExpression, checkMode);
            // case SyntaxKind.TaggedTemplateExpression:
            //     return checkTaggedTemplateExpression(node as TaggedTemplateExpression);
            case SyntaxKind.ParenthesizedExpression:
                return checkParenthesizedExpression(node as ParenthesizedExpression, checkMode);
            // case SyntaxKind.ClassExpression:
            //     return checkClassExpression(node as ClassExpression);
            case SyntaxKind.FunctionExpression:
                return checkFunctionExpressionOrObjectLiteralMethod(node as FunctionExpression, checkMode);
            case SyntaxKind.InlineClosureExpression:
                return checkInlineClosureExpression(node as InlineClosureExpression, checkMode);            
            // case SyntaxKind.ArrowFunction:
            //     return checkFunctionExpressionOrObjectLiteralMethod(node as FunctionExpression | ArrowFunction, checkMode);
            // case SyntaxKind.TypeOfExpression:
            //     return checkTypeOfExpression(node as TypeOfExpression);
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.CastExpression:
                return checkAssertion(node as AssertionExpression, checkMode);
            // case SyntaxKind.NonNullExpression:
            //     return checkNonNullAssertion(node as NonNullExpression);
            case SyntaxKind.ExpressionWithTypeArguments:
                console.debug("todo - implement check expression w/ type args");
                return anyType;
            //     return checkExpressionWithTypeArguments(node as ExpressionWithTypeArguments);
            // case SyntaxKind.SatisfiesExpression:
            //     return checkSatisfiesExpression(node as SatisfiesExpression);
            // case SyntaxKind.MetaProperty:
            //     return checkMetaProperty(node as MetaProperty);
            // case SyntaxKind.DeleteExpression:
            //     return checkDeleteExpression(node as DeleteExpression);
            // case SyntaxKind.VoidExpression:
            //     return checkVoidExpression(node as VoidExpression);
            // case SyntaxKind.AwaitExpression:
            //     return checkAwaitExpression(node as AwaitExpression);
            case SyntaxKind.PrefixUnaryExpression:
                return checkPrefixUnaryExpression(node as PrefixUnaryExpression);
            case SyntaxKind.PostfixUnaryExpression:
                return checkPostfixUnaryExpression(node as PostfixUnaryExpression);
            case SyntaxKind.BinaryExpression:
                return checkBinaryExpression(node as BinaryExpression, checkMode);
            case SyntaxKind.ConditionalExpression:
                return checkConditionalExpression(node as ConditionalExpression, checkMode);
            case SyntaxKind.RangeExpression:
                return checkRangeExpression(node as RangeExpression, checkMode);
            case SyntaxKind.SpreadElement:
                return checkSpreadExpression(node as SpreadElement, checkMode);            
            case SyntaxKind.SyntheticExpression:
                Debug.fail("TODO - implement me - checkExpressionWorker - SyntheticExpression");
                return anyType;
            //     return checkSyntheticExpression(node as SyntheticExpression);
            case SyntaxKind.VariableDeclaration:
                return checkVariableDeclaration(node as VariableDeclaration);            
            case SyntaxKind.SuperAccessExpression:
                return checkSuperExpression(node as SuperAccessExpression);
            case SyntaxKind.CatchExpression:
                return checkCatchExpression(node as CatchExpression);
            case SyntaxKind.PropertyAssignment:
                return checkPropertyAssignment(node as unknown as PropertyAssignment, checkMode);
            case SyntaxKind.EvaluateExpression:
                return checkEvaluateExpression(node as EvaluateExpression, checkMode);
        }   
        console.warn("Implement me - checkExpressionWorker - " + Debug.formatSyntaxKind(node.kind));
        return errorType;
    }

    function checkRangeExpression(node: RangeExpression, checkMode?: CheckMode): Type {
        const rangeTypes: Type[] = [];
        if (node.left) rangeTypes.push(checkExpression(node.left, checkMode));
        if (node.right) rangeTypes.push(checkExpression(node.right, checkMode));

        return rangeTypes.length > 1 ? getUnionType(rangeTypes, UnionReduction.Subtype) : rangeTypes[0];        
    }

    function checkConditionalExpression(node: ConditionalExpression, checkMode?: CheckMode): Type {
        const type = checkTruthinessExpression(node.condition, checkMode);
        checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type, node.whenTrue);
        const type1 = checkExpression(node.whenTrue, checkMode);
        const type2 = checkExpression(node.whenFalse, checkMode);
        return getUnionType([type1, type2], UnionReduction.Subtype);
    }

    function checkDeprecatedSignature(signature: Signature, node: CallLikeExpression) {
        if (signature.flags & SignatureFlags.IsSignatureCandidateForOverloadFailure) return;
        if (signature.declaration && signature.declaration.flags & NodeFlags.Deprecated) {            
            const suggestionNode = getDeprecatedSuggestionNode(node);
            const name = tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node));
            addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature));
        }
    }

    function addDeprecatedSuggestionWithSignature(location: Node, declaration: Node, deprecatedEntity: string | undefined, signatureString: string) {
        const diagnostic = deprecatedEntity
            ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)
            : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString);
        return addDeprecatedSuggestionWorker(declaration, diagnostic);
    }

    /**
     * Tries to resolve a string literal node as an object. Will return the object's type if found, or undefined if not.
     * @param stringNode String literal node
     * @param location Optional location node 
     * @returns 
     */
    function tryResolveStringToObject(stringNode: StringLiteral, location?: Node): Type | undefined {
        const specifier = stringNode;
        const locationNode = location || stringNode;
        
        const moduleSymbol = resolveExternalModuleName(locationNode, specifier, undefined);
        if (moduleSymbol) {            
            const objectSymbol = resolveExternalObjectSymbol(moduleSymbol, specifier, /*dontResolveAlias*/ true);
            if (objectSymbol && isSourceFile(objectSymbol.valueDeclaration)) {                
                const objectType = getTypeOfSymbol(objectSymbol);
                return objectType;                
            }           
        }
    }

    function checkCloneObjectExpression(node: CloneObjectExpression | NewExpression, checkMode?: CheckMode): Type {
        checkGrammarImportCallExpression(node);

        if (!node.arguments?.length) {
            // this is an error but we'll return a type anyway
            return anyType;
        }

        const specifier = node.arguments[0];
        const specifierType = checkExpressionCached(specifier);
        
        // type-check extra arguments for completion
        for (let i = 1; i < node.arguments.length; ++i) {
            checkExpressionCached(node.arguments[i]);
        }

        if (specifierType.flags & TypeFlags.Undefined || specifierType.flags & TypeFlags.Null || !isTypeAssignableTo(specifierType, stringType)) {
            error(specifier, Diagnostics.Clone_object_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
        }

        // resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
        const moduleSymbol = resolveExternalModuleName(node, specifier, specifierType);
        if (moduleSymbol) {            
            const objectSymbol = resolveExternalObjectSymbol(moduleSymbol, specifier, /*dontResolveAlias*/ true);
            if (objectSymbol && isSourceFile(objectSymbol.valueDeclaration)) {                
                const objectType = getTypeOfSymbol(objectSymbol);
                return objectType;                
            }           
        }

        // grammar is valid but could not find the module.
        // return anyType to keep things flowing.
        return anyType;
    }

    function resolveExternalObjectSymbol(moduleSymbol: Symbol|undefined, referencingLocation: Node, dontResolveAlias: boolean): Symbol | undefined {
        const symbol = resolveExternalModuleSymbol(moduleSymbol);

        if (!dontResolveAlias && symbol) {            
            Debug.fail("TODO - implement me - resolveExternalObjectSymbol");
        }

        return symbol;
    }    

    function checkGrammarImportCallExpression(node: CloneObjectExpression | NewExpression): boolean {
        const nodeArguments = node.arguments;
        if (nodeArguments?.length === 0) {
            return grammarErrorOnNode(node, Diagnostics.Clone_object_can_only_accept_an_object_name_and_an_optional_set_of_attributes_as_arguments_1450);
        }
    }

    /**
     * Syntactically and semantically checks a call or new expression.
     * @param node The call/new expression to be checked.
     * @returns On success, the expression's signature's return type. On failure, anyType.
     */
    function checkCallExpression(node: CallExpression | NewExpression, checkMode?: CheckMode): Type {
        //checkGrammarTypeArguments(node, node.typeArguments);

        const signature = getResolvedSignature(node, /*candidatesOutArray*/ undefined, checkMode);
        if (signature === resolvingSignature) {
            // CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
            // returns a function type. We defer checking and return silentNeverType.
            return silentNeverType;
        }

        checkDeprecatedSignature(signature, node);

        if (node.expression && isNewExpression(node) && isStructTypeNode(node.expression)) {
            // fluff-style new(class foo) syntax
            checkSourceElement(node.expression);
            return getTypeFromTypeNode(node.expression);
        }
        if (isNewExpression(node) && !node.expression && node.arguments?.length) {
            return checkCloneObjectExpression(node);
        }
        if (isCallExpression(node)) {            
            if (node.expression.kind === SyntaxKind.SuperKeyword) {
                return voidType;
            }
            
            const fnName = getNameOfDeclaration(node.expression);                        
            const nameStr = fnName && isIdentifier(fnName) ? fnName.text : undefined;
            if (nameStr === "this_object") {
                // this_object() is a special case that should return the type of the parent sourcefile
                const file = getSourceFileOfNode(node);
                const thisObjectPragmas = file.pragmas.get("this-object") ?? file.pragmas.get("this_object");
                let resultType: Type;

                // if a pragma is found, use the first pragma value as the type
                if (thisObjectPragmas) {
                    const stringLiteral = thisObjectPragmaToStringLiteral(file, thisObjectPragmas);                    
                    resultType = stringLiteral.text?.length ? tryResolveStringToObject(stringLiteral) : undefined;
                }

                if (!resultType) {
                    const sourceFileSymbol = getSymbolAtLocation(file);                    
                    resultType = getTypeOfSymbol(sourceFileSymbol);
                    // resultType = firstOrUndefined(resolveBaseTypeOfSourceFile(getTypeOfSymbol(sourceFileSymbol) as InterfaceType, file));
                }

                return resultType;
            } else if (nameStr === "base_name" && !node.arguments?.length) { 
                // only return the base name of the current file is args is 0
                const file = getSourceFileOfNode(node);
                const basePath = getLibRootedFileName(file.fileName, compilerOptions);                
                return getStringLiteralType(basePath);
            }
           
            // I don't think this is needed anymore since error() was added to binder
            // if (signature.declaration && !(checkMode || 0 & CheckMode.TypeOnly)) {
            //     // check if the function has a return type of error
            //     // we'll use this to mark efuns (like fluff's `error`) that stop execution
            //     // and should be treated as an explicit return
            //     const throwsTag = getJSDocThrowsTag(signature.declaration);
            //     if (throwsTag) {
            //         const fn = getContainingFunction(node);
            //         (fn as Mutable<Node>).flags |= NodeFlags.HasExplicitReturn;
            //     }
            // }        
            
            // evaluate $() args will not checked via call expression resolution
            // so manually check them here.
            if (nameStr === "$" && languageVariant === LanguageVariant.FluffOS && findAncestor(node, isInlineClosureExpression)) {
                const args = node.arguments || emptyArray;                
                                                
                // the first arg should be an identifier pointing at a function
                const fnIdentifier = firstOrUndefined(args);
                if (fnIdentifier && isIdentifier(fnIdentifier)) {
                    const fnType = checkExpressionCached(fnIdentifier, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);   
                    // check args 2+
                    for (let i = 1; i < args.length; ++i) {
                        checkExpression(args[i]);
                    }
                    
                    return fnType;
                }

                args.forEach(a => checkExpression(a));
                return anyType;
            }
        }

        const returnType = getReturnTypeOfSignature(signature);
        // Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
        // as a fresh unique symbol literal type.
        // if (returnType.flags & TypeFlags.ESSymbolLike && isSymbolOrSymbolForCall(node)) {
        //     return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent));
        // }
        if (
            node.kind === SyntaxKind.CallExpression && node.parent.kind === SyntaxKind.ExpressionStatement &&
            returnType.flags & TypeFlags.Void && getTypePredicateOfSignature(signature)
        ) {
            if (!isDottedName(node.expression)) {
                error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
            }
            else if (!getEffectsSignature(node)) {
                const diagnostic = error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
                getTypeOfDottedName(node.expression, diagnostic);
            }
        }

        // if (isInJSFile(node)) {
        //     const jsSymbol = getSymbolOfExpando(node, /*allowDeclaration*/ false);
        //     if (jsSymbol?.exports?.size) {
        //         const jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray);
        //         jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral;
        //         return getIntersectionType([returnType, jsAssignmentType]);
        //     }
        // }

        return returnType;
    }
    
    function checkPostfixUnaryExpression(node: PostfixUnaryExpression): Type {
        const operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        const ok = checkArithmeticOperandType(
            node.operand,
            checkNonNullType(operandType, node.operand),
            Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type,
        );
        if (ok) {
            // run check only if former checks succeeded to avoid reporting cascading errors
            checkReferenceExpression(
                node.operand,
                Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
                Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,
            );
        }
        return getUnaryResultType(operandType);
    }

    function getFreshTypeOfLiteralType(type: Type): Type {
        if (type.flags & TypeFlags.Freshable) {
            if (!(type as FreshableType).freshType) {
                const freshType = createLiteralType(type.flags, (type as LiteralType).value, (type as LiteralType).symbol, type as LiteralType);
                freshType.freshType = freshType;
                (type as FreshableType).freshType = freshType;
            }
            return (type as FreshableType).freshType;
        }
        return type;
    }
    
    function maybeTypeOfKindConsideringBaseConstraint(type: Type, kind: TypeFlags): boolean {
        if (maybeTypeOfKind(type, kind)) {
            return true;
        }

        const baseConstraint = getBaseConstraintOrType(type);
        return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind);
    }
    
    /**
     * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
     * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
     */
    function getBaseConstraintOrType(type: Type) {
        return getBaseConstraintOfType(type) || type;
    }


    function checkPrefixUnaryExpression(node: PrefixUnaryExpression): Type {
        const operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        switch (node.operand.kind) {
            case SyntaxKind.IntLiteral:
                switch (node.operator) {
                    case SyntaxKind.MinusToken:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand as IntLiteral).text));
                    case SyntaxKind.PlusToken:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand as IntLiteral).text));
                }
                break;
            case SyntaxKind.FloatLiteral:
                switch (node.operator) {
                    case SyntaxKind.MinusToken:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand as FloatLiteral).text));
                    case SyntaxKind.PlusToken:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand as FloatLiteral).text));
                }
        }
        switch (node.operator) {
            case SyntaxKind.PlusToken:
            case SyntaxKind.MinusToken:
            case SyntaxKind.TildeToken:
                checkNonNullType(operandType, node.operand);
                // if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.ESSymbolLike)) {
                //     error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator));
                // }
                if (node.operator === SyntaxKind.PlusToken) {
                    if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.FloatLiteral)) {
                        error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));
                    }
                    return numberType;
                }
                return getUnaryResultType(operandType);
            case SyntaxKind.ExclamationToken:
                checkTruthinessOfType(operandType, node.operand);
                const facts = getTypeFacts(operandType, TypeFacts.Truthy | TypeFacts.Falsy);
                return facts === TypeFacts.Truthy ? falseType :
                    facts === TypeFacts.Falsy ? trueType :
                    booleanType;
            case SyntaxKind.PlusPlusToken:
            case SyntaxKind.MinusMinusToken:
                const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
                if (ok) {
                    // run check only if former checks succeeded to avoid reporting cascading errors
                    checkReferenceExpression(
                        node.operand,
                        Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
                        Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,
                    );
                }
                return getUnaryResultType(operandType);
        }
        return errorType;
    }

    function getUnaryResultType(operandType: Type): Type {
        if (maybeTypeOfKind(operandType, TypeFlags.FloatLiteral)) {
            return isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike)
                ? intType
                : floatType;
        }
        // If it's not a bigint type, implicit coercion will result in a number
        return numberType;
    }

    function checkDestructuringAssignment(exprOrAssignment: Expression | ShorthandPropertyAssignment, sourceType: Type, checkMode?: CheckMode, rightIsThis?: boolean): Type {
        console.debug("TODO - Implement me - checkDestructuringAssignment");
        return anyType;
        // let target: Expression;
        // if (exprOrAssignment.kind === SyntaxKind.ShorthandPropertyAssignment) {
        //     const prop = exprOrAssignment as ShorthandPropertyAssignment;
        //     if (prop.objectAssignmentInitializer) {
        //         // In strict null checking mode, if a default value of a non-undefined type is specified, remove
        //         // undefined from the final type.
        //         if (
        //             strictNullChecks &&
        //             !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFacts.IsUndefined))
        //         ) {
        //             sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined);
        //         }
        //         checkBinaryLikeExpression(prop.name, prop.equalsToken!, prop.objectAssignmentInitializer, checkMode);
        //     }
        //     target = (exprOrAssignment as ShorthandPropertyAssignment).name;
        // }
        // else {
        //     target = exprOrAssignment;
        // }

        // if (target.kind === SyntaxKind.BinaryExpression && (target as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken) {
        //     checkBinaryExpression(target as BinaryExpression, checkMode);
        //     target = (target as BinaryExpression).left;
        //     // A default value is specified, so remove undefined from the final type.
        //     if (strictNullChecks) {
        //         sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined);
        //     }
        // }
        // if (target.kind === SyntaxKind.ObjectLiteralExpression) {
        //     return checkObjectLiteralAssignment(target as ObjectLiteralExpression, sourceType, rightIsThis);
        // }
        // if (target.kind === SyntaxKind.ArrayLiteralExpression) {
        //     return checkArrayLiteralAssignment(target as ArrayLiteralExpression, sourceType, checkMode);
        // }
        // return checkReferenceAssignment(target, sourceType, checkMode);
    }

    function isTypeEqualityComparableTo(source: Type, target: Type) {        
        return (target.flags & TypeFlags.Nullable) !== 0 || isTypeComparableTo(source, target);
    }

    function extractDefinitelyFalsyTypes(type: Type): Type {
        return mapType(type, getDefinitelyFalsyPartOfType);
    }

    function getDefinitelyFalsyPartOfType(type: Type): Type {
        return type.flags & TypeFlags.String ? emptyStringType :
            type.flags & TypeFlags.Number ? zeroType :
            //type.flags & TypeFlags.BigInt ? zeroBigIntType :
            type === regularFalseType ||
                type === falseType ||
                type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) ||
                type.flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" ||
                type.flags & TypeFlags.IntLiteral && (type as IntLiteralType).value === 0 ||
                type.flags & TypeFlags.FloatLiteral && (type as FloatLiteralType).value===0 ? type :
            neverType;
    }


    function createCheckBinaryExpression() {
        interface WorkArea {
            readonly checkMode: CheckMode | undefined;
            skip: boolean;
            stackIndex: number;
            /**
             * Holds the types from the left-side of an expression from [0..stackIndex].
             * Holds the type of the result at stackIndex+1. This allows us to reuse existing stack entries
             * and avoid storing an extra property on the object (i.e., `lastResult`).
             */
            typeStack: (Type | undefined)[];
        }

        const trampoline = createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState);

        return (node: BinaryExpression, checkMode: CheckMode | undefined) => {
            const result = trampoline(node, checkMode);
            Debug.assertIsDefined(result);
            return result;
        };

        function onEnter(node: BinaryExpression, state: WorkArea | undefined, checkMode: CheckMode | undefined) {
            if (state) {
                state.stackIndex++;
                state.skip = false;
                setLeftType(state, /*type*/ undefined);
                setLastResult(state, /*type*/ undefined);
            }
            else {
                state = {
                    checkMode,
                    skip: false,
                    stackIndex: 0,
                    typeStack: [undefined, undefined],
                };
            }

            // if (isInJSFile(node) && getAssignedExpandoInitializer(node)) {
            //     state.skip = true;
            //     setLastResult(state, checkExpression(node.right, checkMode));
            //     return state;
            // }

            // TODO
            //checkGrammarNullishCoalesceWithLogicalExpression(node);

            const operator = node.operatorToken.kind;
            if (operator === SyntaxKind.EqualsToken && (node.left.kind === SyntaxKind.ObjectLiteralExpression || node.left.kind === SyntaxKind.ArrayLiteralExpression)) {
                state.skip = true;
                setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, /*node.right.kind === SyntaxKind.ThisKeyword*/ false));
                return state;
            }

            return state;
        }

        function onLeft(left: Expression, state: WorkArea, _node: BinaryExpression) {
            if (!state.skip) {
                return maybeCheckExpression(state, left);
            }
        }

        function onOperator(operatorToken: BinaryOperatorToken, state: WorkArea, node: BinaryExpression) {
            if (!state.skip) {
                const leftType = getLastResult(state);
                Debug.assertIsDefined(leftType);
                setLeftType(state, leftType);
                setLastResult(state, /*type*/ undefined);
                const operator = operatorToken.kind;
                if (isLogicalOrCoalescingBinaryOperator(operator)) {
                    let parent = node.parent;
                    while (parent.kind === SyntaxKind.ParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent)) {
                        parent = parent.parent;
                    }
                    if (operator === SyntaxKind.AmpersandAmpersandToken || isIfStatement(parent)) {
                        checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType, isIfStatement(parent) ? parent.thenStatement : undefined);
                    }
                    checkTruthinessOfType(leftType, node.left);
                }
            }
        }

        function onRight(right: Expression, state: WorkArea, _node: BinaryExpression) {
            if (!state.skip) {
                return maybeCheckExpression(state, right);
            }
        }

        function onExit(node: BinaryExpression, state: WorkArea): Type | undefined {
            let result: Type | undefined;
            if (state.skip) {
                result = getLastResult(state);
            }
            else {                
                const leftType = getLeftType(state);
                Debug.assertIsDefined(leftType);

                const rightType = getLastResult(state);
                Debug.assertIsDefined(rightType);

                result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node);
            }

            state.skip = false;
            setLeftType(state, /*type*/ undefined);
            setLastResult(state, /*type*/ undefined);
            state.stackIndex--;
            return result;
        }

        function foldState(state: WorkArea, result: Type | undefined, _side: "left" | "right") {
            setLastResult(state, result);
            return state;
        }

        function maybeCheckExpression(state: WorkArea, node: Expression): BinaryExpression | undefined {
            if (isBinaryExpression(node)) {
                return node;
            }
            setLastResult(state, checkExpression(node, state.checkMode));
        }

        function getLeftType(state: WorkArea) {
            return state.typeStack[state.stackIndex];
        }

        function setLeftType(state: WorkArea, type: Type | undefined) {
            state.typeStack[state.stackIndex] = type;
        }

        function getLastResult(state: WorkArea) {
            return state.typeStack[state.stackIndex + 1];
        }

        function setLastResult(state: WorkArea, type: Type | undefined) {
            // To reduce overhead, reuse the next stack entry to store the
            // last result. This avoids the overhead of an additional property
            // on `WorkArea` and reuses empty stack entries as we walk back up
            // the stack.
            state.typeStack[state.stackIndex + 1] = type;
        }
    }

    
    // This like getBaseTypeOfLiteralType, but instead treats enum literals as strings/numbers instead
    // of returning their enum base type (which depends on the types of other literals in the enum).
    function getBaseTypeOfLiteralTypeForComparison(type: Type): Type {
        return type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :
            type.flags & (TypeFlags.IntLiteral) ? intType :
            type.flags & TypeFlags.FloatLiteral ? floatType :
            //type.flags & TypeFlags.BooleanLiteral ? booleanType :
            type.flags & TypeFlags.Union ? mapType(type, getBaseTypeOfLiteralTypeForComparison) :
            type;
    }

    function removeDefinitelyFalsyTypes(type: Type): Type {
        return filterType(type, t => hasTypeFacts(t, TypeFacts.Truthy));
    }

    /**
     * This is a *shallow* check: An expression is side-effect-free if the
     * evaluation of the expression *itself* cannot produce side effects.
     * For example, x++ / 3 is side-effect free because the / operator
     * does not have side effects.
     * The intent is to "smell test" an expression for correctness in positions where
     * its value is discarded (e.g. the left side of the comma operator).
     */
    function isSideEffectFree(node: Node): boolean {
        node = skipParentheses(node);
        switch (node.kind) {
            case SyntaxKind.Identifier:
            case SyntaxKind.StringLiteral:
            // case SyntaxKind.RegularExpressionLiteral:
            // case SyntaxKind.TaggedTemplateExpression:
            // case SyntaxKind.TemplateExpression:
            // case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.IntLiteral:
            case SyntaxKind.FloatLiteral:
            // case SyntaxKind.TrueKeyword:
            // case SyntaxKind.FalseKeyword:
            case SyntaxKind.NullKeyword:
            // case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.InlineClosureExpression:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:            
                return true;

            case SyntaxKind.ConditionalExpression:
                return isSideEffectFree((node as ConditionalExpression).whenTrue) &&
                    isSideEffectFree((node as ConditionalExpression).whenFalse);

            case SyntaxKind.BinaryExpression:
                if (isAssignmentOperator((node as BinaryExpression).operatorToken.kind)) {
                    return false;
                }
                return isSideEffectFree((node as BinaryExpression).left) &&
                    isSideEffectFree((node as BinaryExpression).right);

            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PostfixUnaryExpression:
                // Unary operators ~, !, +, and - have no side effects.
                // The rest do.
                switch ((node as PrefixUnaryExpression).operator) {
                    case SyntaxKind.ExclamationToken:
                    case SyntaxKind.PlusToken:
                    case SyntaxKind.MinusToken:
                    case SyntaxKind.TildeToken:
                        return true;
                }
                return false;

            // Some forms listed here for clarity
            // case SyntaxKind.VoidExpression: // Explicit opt-out
            // case SyntaxKind.TypeAssertionExpression: // Not SEF, but can produce useful type warnings
            // case SyntaxKind.AsExpression: // Not SEF, but can produce useful type warnings
            default:
                return false;
        }
    }

    function addDuplicateDeclarationErrorsForSymbols(target: Symbol, message: DiagnosticMessage, symbolName: string, source: Symbol) {
        forEach(target.declarations, node => {
            addDuplicateDeclarationError(node, message, symbolName, source.declarations);
        });
    }

    function lookupOrIssueError(location: Node | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): Diagnostic {
        // if (location?.flags & NodeFlags.ExternalFile) {
        //     // don't issue diagnostics for nodes from an external file
        //     return undefined;
        // }

        const diagnostic = location
            ? createDiagnosticForNode(location, message, ...args)
            : createCompilerDiagnostic(message, ...args);
        const existing = diagnostics.lookup(diagnostic);
        if (existing) {
            return existing;
        }
        else {
            diagnostics.add(diagnostic);
            return diagnostic;
        }
    }

    /**
     * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
     * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
     */
    function checkTypeAssignableToAndOptionallyElaborate(source: Type, target: Type, errorNode: Node | undefined, expr: Expression | undefined, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined): boolean {
        return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, /*errorOutputContainer*/ undefined);
    }

    function checkTypeRelatedToAndOptionallyElaborate(
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        errorNode: Node | undefined,
        expr: Expression | undefined,
        headMessage: DiagnosticMessage | undefined,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean; } | undefined,
    ): boolean {
        if (isTypeRelatedTo(source, target, relation)) return true;
        if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
            return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
        }
        return false;
    }

    function isOrHasGenericConditional(type: Type): boolean {
        return !!(type.flags & TypeFlags.Conditional || (type.flags & TypeFlags.Intersection && some((type as IntersectionType).types, isOrHasGenericConditional)));
    }

    function checkTypeAssignableTo(source: Type, target: Type, errorNode: Node | undefined, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined, errorOutputObject?: { errors?: Diagnostic[]; }): boolean {
        return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
    }

    function elaborateDidYouMeanToCallOrConstruct(
        node: Expression,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        headMessage: DiagnosticMessage | undefined,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean; } | undefined,
    ): boolean {
        const callSignatures = getSignaturesOfType(source, SignatureKind.Call);
        const constructSignatures = getSignaturesOfType(source, SignatureKind.Construct);
        for (const signatures of [constructSignatures, callSignatures]) {
            if (
                some(signatures, s => {
                    const returnType = getReturnTypeOfSignature(s);
                    return !(returnType.flags & (TypeFlags.Any | TypeFlags.Never)) && checkTypeRelatedTo(returnType, target, relation, /*errorNode*/ undefined);
                })
            ) {
                const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};
                checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);
                const diagnostic = resultObj.errors![resultObj.errors!.length - 1];
                addRelatedInfo(
                    diagnostic,
                    createDiagnosticForNode(
                        node,
                        signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression,
                    ),
                );
                return true;
            }
        }
        return false;
    }

    function hasContextSensitiveReturnExpression(node: FunctionLikeDeclaration) {
        if (node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body) {
            return false;
        }
        if (node.body.kind !== SyntaxKind.Block) {
            return isContextSensitive(node.body);
        }
        return !!forEachReturnStatement(node.body as Block, statement => !!statement.expression && isContextSensitive(statement.expression));
    }

    function isContextSensitiveFunctionLikeDeclaration(node: FunctionLikeDeclaration): boolean {
        return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node);
    }
    
    // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
    // that is subject to contextual typing.
    function isContextSensitive(node: Expression/* | MethodDeclaration */| ObjectLiteralElementLike ): boolean {
        //Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));
        switch (node.kind) {
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InlineClosureExpression:
            //case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration: // Function declarations can have context when annotated with a jsdoc @type
                return isContextSensitiveFunctionLikeDeclaration(node as FunctionExpression | InlineClosureExpression /*| MethodDeclaration*/);
            case SyntaxKind.ObjectLiteralExpression:
                return some((node as ObjectLiteralExpression).properties, isContextSensitive);
            case SyntaxKind.ArrayLiteralExpression:
                return some((node as ArrayLiteralExpression).elements, isContextSensitive);
            case SyntaxKind.ConditionalExpression:
                return isContextSensitive((node as ConditionalExpression).whenTrue) ||
                    isContextSensitive((node as ConditionalExpression).whenFalse);
            case SyntaxKind.BinaryExpression:
                return ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken) &&
                    (isContextSensitive((node as BinaryExpression).left) || isContextSensitive((node as BinaryExpression).right));
            case SyntaxKind.PropertyAssignment:
                return isContextSensitive((node as PropertyAssignment).initializer);
            case SyntaxKind.ParenthesizedExpression:
                return isContextSensitive((node as ParenthesizedExpression).expression);            
        }

        return false;
    }

    function symbolValueDeclarationIsContextSensitive(symbol: Symbol): boolean {
        return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration);
    }

    function getTypeNameForErrorDisplay(type: Type) {
        return typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.UseFullyQualifiedType);
    }

    function getTypeNamesForErrorDisplay(left: Type, right: Type): [string, string] {
        let leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left);
        let rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right);
        if (leftStr === rightStr) {
            leftStr = getTypeNameForErrorDisplay(left);
            rightStr = getTypeNameForErrorDisplay(right);
        }
        return [leftStr, rightStr];
    }

    function getBaseTypesIfUnrelated(leftType: Type, rightType: Type, isRelated: (left: Type, right: Type) => boolean): [Type, Type] {
        let effectiveLeft = leftType;
        let effectiveRight = rightType;

        const leftBase = getBaseTypeOfLiteralType(leftType);
        const rightBase = getBaseTypeOfLiteralType(rightType);
        if (!isRelated(leftBase, rightBase)) {
            effectiveLeft = leftBase;
            effectiveRight = rightBase;
        }
        return [effectiveLeft, effectiveRight];
    }

    function elaborateError(
        node: Expression | undefined,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        headMessage: DiagnosticMessage | undefined,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean; } | undefined,
    ): boolean {
        if (!node || isOrHasGenericConditional(target)) return false;
        if (
            !checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined)
            && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
        ) {
            return true;
        }
        switch (node.kind) {
            case SyntaxKind.ParenthesizedExpression:
                return elaborateError((node as  ParenthesizedExpression ).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
            case SyntaxKind.BinaryExpression:
                switch ((node as BinaryExpression).operatorToken.kind) {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.CommaToken:
                        return elaborateError((node as BinaryExpression).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                }
                break;
            case SyntaxKind.ObjectLiteralExpression:
                console.warn("todo - elaborateError - ObjectLiteralExpression");
                //return elaborateObjectLiteral(node as ObjectLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);
            case SyntaxKind.ArrayLiteralExpression:                
                return elaborateArrayLiteral(node as ArrayLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);            
            case SyntaxKind.InlineClosureExpression:                
                return elaborateInlineClosure(node as InlineClosureExpression, source, target, relation, containingMessageChain, errorOutputContainer);
        }
        return false;
    }

    function elaborateArrayLiteral(
        node: ArrayLiteralExpression,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean; } | undefined,
    ) {
        if (target.flags & (TypeFlags.Primitive | TypeFlags.Never)) return false;
        // if (isTupleLikeType(source)) {
        //     return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
        // }
        // recreate a tuple from the elements, if possible
        // Since we're re-doing the expression type, we need to reapply the contextual type
        pushContextualType(node, target, /*isCache*/ false);
        const tupleizedType = checkArrayLiteral(node, CheckMode.Contextual, /*forceTuple*/ true);
        popContextualType();
        // if (isTupleLikeType(tupleizedType)) {
        //     return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer);
        // }
        return false;
    }

    function elaborateInlineClosure(
        node: InlineClosureExpression,
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean; } | undefined,
    ): boolean {
        // Don't elaborate blocks
        if (isBlock(node.body)) {
            return false;
        }
        // Or functions with annotated parameter types
        if (some(node.parameters, hasType)) {
            return false;
        }
        const sourceSig = getSingleCallSignature(source);
        if (!sourceSig) {
            return false;
        }
        const targetSignatures = getSignaturesOfType(target, SignatureKind.Call);
        if (!length(targetSignatures)) {
            return false;
        }
        const returnExpression = node.body;
        const sourceReturn = getReturnTypeOfSignature(sourceSig);
        const targetReturn = getUnionType(map(targetSignatures, getReturnTypeOfSignature));
        if (!checkTypeRelatedTo(sourceReturn, targetReturn, relation, /*errorNode*/ undefined)) {
            const elaborated = returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
            if (elaborated) {
                return elaborated;
            }
            const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};
            checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, /*headMessage*/ undefined, containingMessageChain, resultObj);
            if (resultObj.errors) {
                if (target.symbol && length(target.symbol.declarations)) {
                    addRelatedInfo(
                        resultObj.errors[resultObj.errors.length - 1],
                        createDiagnosticForNode(
                            target.symbol.declarations![0],
                            Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature,
                        ),
                    );
                }               
            }
        }
        return false;
    }

    function checkReferenceExpression(expr: Expression, invalidReferenceMessage: DiagnosticMessage, invalidOptionalChainMessage: DiagnosticMessage): boolean {
        // References are combinations of identifiers, parentheses, and property accesses.
        const node = skipOuterExpressions(expr, OuterExpressionKinds.Assertions | OuterExpressionKinds.Parentheses);
        if (node.kind !== SyntaxKind.Identifier && !isAccessExpression(node)) {
            error(expr, invalidReferenceMessage);
            return false;
        }
        if (node.flags & NodeFlags.OptionalChain) {
            error(expr, invalidOptionalChainMessage);
            return false;
        }
        return true;
    }
    
    function addDuplicateDeclarationError(node: Declaration, message: DiagnosticMessage, symbolName: string, relatedNodes: readonly Declaration[] | undefined) {
        const errorNode = getNameOfDeclaration(node) || node;//(getExpandoInitializer(node, /*isPrototypeAssignment*/ false) ? getNameOfExpando(node) : getNameOfDeclaration(node)) || node;
        const err = lookupOrIssueError(errorNode, message, symbolName);
        for (const relatedNode of relatedNodes || emptyArray) {
            const adjustedNode = getNameOfDeclaration(relatedNode) || relatedNode;
            if (adjustedNode === errorNode) continue;
            err.relatedInformation = err.relatedInformation || [];
            const leadingMessage = createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName);
            const followOnMessage = createDiagnosticForNode(adjustedNode, Diagnostics.and_here);
            if (length(err.relatedInformation) >= 5 || some(err.relatedInformation, r => compareDiagnostics(r, followOnMessage) === Comparison.EqualTo || compareDiagnostics(r, leadingMessage) === Comparison.EqualTo)) continue;
            addRelatedInfo(err, !length(err.relatedInformation) ? leadingMessage : followOnMessage);
        }
    }

    /** Return properties of an object type or an empty array for other types */
    function getPropertiesOfObjectType(type: Type): Symbol[] {
        if (type.flags & TypeFlags.Object) {
            return resolveStructuredTypeMembers(type as ObjectType).properties;
        }
        return emptyArray;
    }
    
    function reportObjectPossiblyNullOrUndefinedError(node: Node, facts: TypeFacts) {
        const nodeText = isEntityNameExpression(node) ? entityNameToString(node) : undefined;
        console.debug("TODO - Implement me - reportObjectPossiblyNullOrUndefinedError");
        // TODO
        // if (node.kind === SyntaxKind.NullKeyword) {
        //     error(node, Diagnostics.The_value_0_cannot_be_used_here, "null");
        //     return;
        // }
        // if (nodeText !== undefined && nodeText.length < 100) {
        //     if (isIdentifier(node) && nodeText === "undefined") {
        //         error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined");
        //         return;
        //     }
        //     error(
        //         node,
        //         facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?
        //             Diagnostics._0_is_possibly_null_or_undefined :
        //             Diagnostics._0_is_possibly_undefined :
        //             Diagnostics._0_is_possibly_null,
        //         nodeText,
        //     );
        // }
        // else {
        //     error(
        //         node,
        //         facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?
        //             Diagnostics.Object_is_possibly_null_or_undefined :
        //             Diagnostics.Object_is_possibly_undefined :
        //             Diagnostics.Object_is_possibly_null,
        //     );
        // }
    }


    function checkNonNullType(type: Type, node: Node) {
        return checkNonNullTypeWithReporter(type, node, reportObjectPossiblyNullOrUndefinedError);
    }

    function errorAndMaybeSuggestAwait(
        location: Node,
        maybeMissingAwait: boolean,
        message: DiagnosticMessage,
        ...args: DiagnosticArguments
    ): Diagnostic {
        const diagnostic = error(location, message, ...args);
        // if (maybeMissingAwait) {
        //     const related = createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await);
        //     addRelatedInfo(diagnostic, related);
        // }
        return diagnostic;
    }

    /**
     * This is *not* a bi-directional relationship.
     * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
     *
     * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
     * It is used to check following cases:
     *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
     *   - the types of `case` clause expressions and their respective `switch` expressions.
     *   - the type of an expression in a type assertion with the type being asserted.
     */
    function isTypeComparableTo(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, comparableRelation);
    }

    function areTypesComparable(type1: Type, type2: Type): boolean {
        return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
    }

    function checkArithmeticOperandType(operand: Node, type: Type, diagnostic: DiagnosticMessage, isAwaitValid = false): boolean {        
        if (!isTypeAssignableTo(type, validArithmeticType)) {
            errorAndMaybeSuggestAwait(
                operand,
                false,
                diagnostic,
            );
            return false;
        }
        return true;
    }
    
    function isArrayLiteralTypeWithOnlyZero(type: Type): type is TypeReference {
        if (isArrayType(type) && type.resolvedTypeArguments?.length === 1) {
            const elemType = first(type.resolvedTypeArguments);
            return elemType.flags & TypeFlags.IntLiteral && (elemType as IntLiteralType).value === 0;
        }
        return false;
    }

    function checkBinaryLikeExpressionWorker(
        left: Expression,
        operatorToken: BinaryOperatorToken,
        right: Expression,
        leftType: Type,
        rightType: Type,
        checkMode?: CheckMode,
        errorNode?: Node,
    ): Type {
        const operator = operatorToken.kind;
        switch (operator) {
            case SyntaxKind.AsteriskToken:
            case SyntaxKind.AsteriskAsteriskToken:
            case SyntaxKind.AsteriskEqualsToken:
            case SyntaxKind.AsteriskAsteriskEqualsToken:
            case SyntaxKind.SlashToken:
            case SyntaxKind.SlashEqualsToken:
            case SyntaxKind.PercentToken:
            case SyntaxKind.PercentEqualsToken:
            case SyntaxKind.MinusToken:
            case SyntaxKind.MinusEqualsToken:
            case SyntaxKind.LessThanLessThanToken:
            case SyntaxKind.LessThanLessThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
            case SyntaxKind.BarToken:
            case SyntaxKind.BarEqualsToken:
            case SyntaxKind.CaretToken:
            case SyntaxKind.CaretEqualsToken:
            case SyntaxKind.AmpersandToken:
            case SyntaxKind.AmpersandEqualsToken:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }

                leftType = checkNonNullType(leftType, left);
                rightType = checkNonNullType(rightType, right);

                let suggestedOperator: PunctuationSyntaxKind | undefined;
                // if a user tries to apply a bitwise operator to 2 boolean operands
                // try and return them a helpful suggestion
                if (
                    (leftType.flags & TypeFlags.BooleanLike) &&
                    (rightType.flags & TypeFlags.BooleanLike) &&
                    (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined
                ) {
                    error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator));
                    return numberType;
                }
                else {
                    // otherwise just check each operand separately and report errors as normal
                    const leftOk = checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/ true);
                    const rightOk = checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid*/ true);
                    let resultType: Type;

                    // check for a special case where an array literal with a zero is on the right and another array is on the left
                    // if (isArrayType(leftType) && isArrayLiteralTypeWithOnlyZero(rightType)) {
                    //     resultType = rightType.resolvedTypeArguments[0];
                    // }
                    // else 
                    if (isArrayType(leftType) && isArrayType(rightType)) {
                        //compareTypesAssignable(rightType, leftType)
                        resultType = leftType;//first(rightType.resolvedTypeArguments) ?? anyType;
                    }
                    // If both are any or unknown, allow operation; assume it will resolve to number
                    else if (
                        (isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlags.AnyOrUnknown)) ||
                        // Or, if neither could be bigint, implicit coercion results in a number result
                        !(maybeTypeOfKind(leftType, TypeFlags.FloatLiteral) || maybeTypeOfKind(rightType, TypeFlags.FloatLiteral))
                    ) {
                        resultType = numberType;
                    }
                    // At least one is assignable to bigint, so check that both are
                    // else if (bothAreBigIntLike(leftType, rightType)) {
                    //     switch (operator) {
                    //         case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    //         case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    //             reportOperatorError();
                    //             break;
                    //         case SyntaxKind.AsteriskAsteriskToken:
                    //         case SyntaxKind.AsteriskAsteriskEqualsToken:
                    //             // if (languageVersion < ScriptTarget.ES2016) {
                    //             //     error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);
                    //             // }
                    //     }
                    //     resultType = bigintType;
                    // }
                    // Exactly one of leftType/rightType is assignable to bigint
                    else {
                        reportOperatorError(bothAreFloat);
                        resultType = errorType;
                    }
                    if (leftOk && rightOk) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                }
            case SyntaxKind.PlusToken:
            case SyntaxKind.PlusEqualsToken:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }

                if (!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(rightType, TypeFlags.StringLike)) {
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                }

                let resultType: Type | undefined;
                if (isTypeAssignableToKind(leftType, TypeFlags.NumberLike, /*strict*/ true) && isTypeAssignableToKind(rightType, TypeFlags.NumberLike, /*strict*/ true)) {
                    // Operands of an enum type are treated as having the primitive type Number.
                    // If both operands are of the Number primitive type, the result is of the Number primitive type.
                    resultType = numberType;
                }
                // else if (isTypeAssignableToKind(leftType, TypeFlags.BigIntLike, /*strict*/ true) && isTypeAssignableToKind(rightType, TypeFlags.BigIntLike, /*strict*/ true)) {
                //     // If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.
                //     resultType = bigintType;
                // }
                else if (isTypeAssignableToKind(leftType, TypeFlags.StringLike, /*strict*/ true) || isTypeAssignableToKind(rightType, TypeFlags.StringLike, /*strict*/ true)) {
                    // If one or both operands are of the String primitive type, the result is of the String primitive type.
                    resultType = stringType;
                }
                else if (isTypeAssignableToKind(leftType, TypeFlags.BytesLike, /*strict*/ true) && isTypeAssignableToKind(rightType, TypeFlags.BytesLike, /*strict*/ true)) {
                    // No implicit conversion for bytes type - both operands must be bytes
                    resultType = bytesType;
                }
                else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                    // Otherwise, the result is of type Any.
                    // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                    resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;
                }
                else if (isArrayType(leftType) && isArrayType(rightType)) {
                    // LPC allows array addition and subtraction
                    const leftElementType = first(leftType.resolvedTypeArguments);
                    const rightElementType = first(rightType.resolvedTypeArguments);               
                    if (areTypesComparable(leftElementType, rightElementType)) {
                        resultType = leftType;
                    }                                        
                } 
                else if (isMappingType(leftType) && isMappingType(rightType)) {
                    resultType = leftType;
                }
                // Symbols are not allowed at all in arithmetic expressions
                // if (resultType) {// && !checkForDisallowedESSymbolOperand(operator)) {
                //     return resultType;
                // }

                if (!resultType) {
                    // Types that have a reasonably good chance of being a valid operand type.
                    // If both types have an awaited type of one of these, we'll assume the user
                    // might be missing an await without doing an exhaustive check that inserting
                    // await(s) will actually be a completely valid binary expression.
                    const closeEnoughKind = TypeFlags.NumberLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;
                    reportOperatorError((left, right) =>
                        isTypeAssignableToKind(left, closeEnoughKind) &&
                        isTypeAssignableToKind(right, closeEnoughKind)
                    );                    
                    return anyType;
                }

                if (operator === SyntaxKind.PlusEqualsToken) {
                    checkAssignmentOperator(resultType);
                }
                return resultType;
            case SyntaxKind.LessThanToken:
            case SyntaxKind.GreaterThanToken:
            case SyntaxKind.LessThanEqualsToken:
            case SyntaxKind.GreaterThanEqualsToken:
                // if (checkForDisallowedESSymbolOperand(operator)) {
                //     leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));
                //     rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));
                //     reportOperatorErrorUnless((left, right) => {
                //         if (isTypeAny(left) || isTypeAny(right)) {
                //             return true;
                //         }
                //         const leftAssignableToNumber = isTypeAssignableTo(left, numberType);
                //         const rightAssignableToNumber = isTypeAssignableTo(right, numberType);
                //         return leftAssignableToNumber && rightAssignableToNumber ||
                //             !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right);
                //     });
                // }
                return booleanType;
            case SyntaxKind.EqualsEqualsToken:
            case SyntaxKind.ExclamationEqualsToken:
            case SyntaxKind.EqualsEqualsEqualsToken:
            case SyntaxKind.ExclamationEqualsEqualsToken:
                // We suppress errors in CheckMode.TypeOnly (meaning the invocation came from getTypeOfExpression). During
                // control flow analysis it is possible for operands to temporarily have narrower types, and those narrower
                // types may cause the operands to not be comparable. We don't want such errors reported (see #46475).
                if (!(checkMode && checkMode & CheckMode.TypeOnly)) {
                    if (
                        (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) &&
                        // only report for === and !== in JS, not == or !=
                        (!isInJSFile(left) || (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken))
                    ) {
                        const eqType = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;
                        error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");
                    }
                    checkNaNEquality(errorNode, operator, left, right);
                    reportOperatorErrorUnless((left, right) => isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left));
                }
                return booleanType;            
            case SyntaxKind.InKeyword:
                return checkInExpression(left, right, leftType, rightType);
            case SyntaxKind.AmpersandAmpersandToken:
            case SyntaxKind.AmpersandAmpersandEqualsToken: {
                const resultType = hasTypeFacts(leftType, TypeFacts.Truthy) ?
                    getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :
                    leftType;
                if (operator === SyntaxKind.AmpersandAmpersandEqualsToken) {
                    checkAssignmentOperator(rightType);
                }
                return resultType;
            }
            case SyntaxKind.BarBarToken:
            case SyntaxKind.BarBarEqualsToken: {
                const resultType = hasTypeFacts(leftType, TypeFacts.Falsy) ?
                    getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) :
                    leftType;
                if (operator === SyntaxKind.BarBarEqualsToken) {
                    checkAssignmentOperator(rightType);
                }
                return resultType;
            }
            case SyntaxKind.QuestionQuestionToken:
            case SyntaxKind.QuestionQuestionEqualsToken: {
                const resultType = hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ?
                    getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) :
                    leftType;
                if (operator === SyntaxKind.QuestionQuestionEqualsToken) {
                    checkAssignmentOperator(rightType);
                }
                return resultType;
            }
            case SyntaxKind.EqualsToken:
                const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None;
                checkAssignmentDeclaration(declKind, rightType);
                if (isAssignmentDeclaration(declKind)) {
                    if (
                        !(rightType.flags & TypeFlags.Object) ||
                        declKind !== AssignmentDeclarationKind.ModuleExports &&
                            declKind !== AssignmentDeclarationKind.Prototype &&
                            !isEmptyObjectType(rightType) &&
                            //!isFunctionObjectType(rightType as ObjectType) &&
                            !(getObjectFlags(rightType) & ObjectFlags.Class)
                    ) {
                        // don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete
                        checkAssignmentOperator(rightType);
                    }
                    return leftType;
                }
                else {
                    checkAssignmentOperator(rightType);
                    return rightType;
                }
            case SyntaxKind.CommaToken:
                if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) 
                    && !isIndirectCall(left.parent as BinaryExpression)
                    && !isForEachStatement(left.parent.parent)
                    // TODO - commas in element access really shouldn't be parsed a binary expression anyway
                    && !findAncestor(left.parent, isElementAccessExpression)
                ) {
                    const sf = getSourceFileOfNode(left);
                    const sourceText = sf.text;
                    const start = skipTrivia(sourceText, left.pos);
                    error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                }
                return rightType;

            default:
                return Debug.fail();
        }

        function bothAreFloat(left: Type, right: Type): boolean {
            return isTypeAssignableToKind(left, TypeFlags.FloatLiteral) && isTypeAssignableToKind(right, TypeFlags.FloatLiteral);
        }

        function checkAssignmentDeclaration(kind: AssignmentDeclarationKind, rightType: Type) {
            if (kind === AssignmentDeclarationKind.ModuleExports) {
                for (const prop of getPropertiesOfObjectType(rightType)) {
                    const propType = getTypeOfSymbol(prop);
                    if (propType.symbol && propType.symbol.flags & SymbolFlags.Class) {
                        const name = prop.name;
                        const symbol = resolveName(prop.valueDeclaration, name, SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
                        if (symbol?.declarations && symbol.declarations.some(isJSDocTypedefTag)) {
                            addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, (name), prop);
                            addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, (name), symbol);
                        }
                    }
                }
            }
        }

        // Return true for "indirect calls", (i.e. `(0, x.f)(...)` or `(0, eval)(...)`), which prevents passing `this`.
        function isIndirectCall(node: BinaryExpression): boolean {
            return node.parent.kind === SyntaxKind.ParenthesizedExpression &&
                isIntLiteral(node.left) &&
                node.left.text === "0" &&
                (isCallExpression(node.parent.parent) && node.parent.parent.expression === node.parent ) &&
                // special-case for "eval" because it's the only non-access case where an indirect call actually affects behavior.
                (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.text === "eval");
        }

        function getSuggestedBooleanOperator(operator: SyntaxKind): PunctuationSyntaxKind | undefined {
            switch (operator) {
                case SyntaxKind.BarToken:
                case SyntaxKind.BarEqualsToken:
                    return SyntaxKind.BarBarToken;
                case SyntaxKind.CaretToken:
                case SyntaxKind.CaretEqualsToken:
                    return SyntaxKind.ExclamationEqualsEqualsToken;
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AmpersandEqualsToken:
                    return SyntaxKind.AmpersandAmpersandToken;
                default:
                    return undefined;
            }
        }

        function checkAssignmentOperator(valueType: Type): void {
            if (isAssignmentOperator(operator)) {
                addLazyDiagnostic(checkAssignmentOperatorWorker);
            }

            function checkAssignmentOperatorWorker() {
                let assigneeType = leftType;

                // getters can be a subtype of setters, so to check for assignability we use the setter's type instead
                // if (isCompoundAssignment(operatorToken.kind) && left.kind === SyntaxKind.PropertyAccessExpression) {
                //     assigneeType = checkPropertyAccessExpression(left as PropertyAccessExpression, /*checkMode*/ undefined, /*writeOnly*/ true);
                // }

                // TypeScript 1.0 spec (April 2014): 4.17
                // An assignment of the form
                //    VarExpr = ValueExpr
                // requires VarExpr to be classified as a reference
                // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
                // and the type of the non-compound operation to be assignable to the type of VarExpr.

                if (checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access)) {
                    let headMessage: DiagnosticMessage | undefined;
                    // if (exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlags.Undefined)) {
                    //     const target = getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.text);
                    //     if (isExactOptionalPropertyMismatch(valueType, target)) {
                    //         headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target;
                    //     }
                    // }
                    // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                    checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage);
                }
            }
        }

        function isAssignmentDeclaration(kind: AssignmentDeclarationKind) {
            switch (kind) {
                case AssignmentDeclarationKind.ModuleExports:
                    return true;
                case AssignmentDeclarationKind.ExportsProperty:
                case AssignmentDeclarationKind.Property:
                case AssignmentDeclarationKind.Prototype:
                case AssignmentDeclarationKind.PrototypeProperty:
                case AssignmentDeclarationKind.ThisProperty:
                    const symbol = getSymbolOfNode(left);
                    //const init = getAssignedExpandoInitializer(right);
                    return false;
                    // return !!init && isObjectLiteralExpression(init) &&
                    //     !!symbol?.exports?.size;
                default:
                    return false;
            }
        }

        /**
         * Returns true if an error is reported
         */
        function reportOperatorErrorUnless(typesAreCompatible: (left: Type, right: Type) => boolean): boolean {
            if (!typesAreCompatible(leftType, rightType)) {
                reportOperatorError(typesAreCompatible);
                return true;
            }            
            return false;
        }

        function reportOperatorError(isRelated?: (left: Type, right: Type) => boolean) {
            let wouldWorkWithAwait = false;
            const errNode = errorNode || operatorToken;
            if (isRelated) {
                const awaitedLeftType = getAwaitedTypeNoAlias(leftType);
                const awaitedRightType = getAwaitedTypeNoAlias(rightType);
                wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType)
                    && !!(awaitedLeftType && awaitedRightType)
                    && isRelated(awaitedLeftType, awaitedRightType);
            }

            let effectiveLeft = leftType;
            let effectiveRight = rightType;
            if (!wouldWorkWithAwait && isRelated) {
                [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated);
            }
            const [leftStr, rightStr] = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight);
            if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr)) {
                errorAndMaybeSuggestAwait(
                    errNode,
                    wouldWorkWithAwait,
                    Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2,
                    tokenToString(operatorToken.kind),
                    leftStr,
                    rightStr,
                );
            }
        }

        function tryGiveBetterPrimaryError(errNode: Node, maybeMissingAwait: boolean, leftStr: string, rightStr: string) {
            switch (operatorToken.kind) {
                case SyntaxKind.EqualsEqualsEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                    return errorAndMaybeSuggestAwait(
                        errNode,
                        maybeMissingAwait,
                        Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap,
                        leftStr,
                        rightStr,
                    );
                default:
                    return undefined;
            }
        }

        function checkNaNEquality(errorNode: Node | undefined, operator: SyntaxKind, left: Expression, right: Expression) {
            const isLeftNaN = isGlobalNaN(skipParentheses(left));
            const isRightNaN = isGlobalNaN(skipParentheses(right));
            if (isLeftNaN || isRightNaN) {
                const err = error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString(operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword));
                if (isLeftNaN && isRightNaN) return;
                const operatorString = operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "";
                const location = isLeftNaN ? right : left;
                const expression = skipParentheses(location);
                addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})`));
            }
        }

        function isGlobalNaN(expr: Expression): boolean {
            // if (isIdentifier(expr) && expr.text === "NaN") {
            //     const globalNaNSymbol = getGlobalNaNSymbol();
            //     return !!globalNaNSymbol && globalNaNSymbol === getResolvedSymbol(expr);
            // }
            return false;
        }
    }

    function isTypeAssertion(node: Expression) {
        node = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        return node.kind === SyntaxKind.TypeAssertionExpression ||
            node.kind === SyntaxKind.CastExpression || isJSDocTypeAssertion(node);
    }

    function checkInExpression(left: Expression, right: Expression, leftType: Type, rightType: Type): Type {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }
        
        // The type of the lef operand must be assignable to string, number, or symbol.
        checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left);
        
        // The type of the right operand must be assignable to 'object'.
        if (checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right)) {
            // The {} type is assignable to the object type, yet {} might represent a primitive type. Here we
            // detect and error on {} that results from narrowing the unknown type, as well as intersections
            // that include {} (we know that the other types in such intersections are assignable to object
            // since we already checked for that).
            if (hasEmptyObjectIntersection(rightType)) {
                error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType));
            }
        }
        // The result is always of the Boolean primitive type.
        return booleanType;
    }

    function hasEmptyObjectIntersection(type: Type): boolean {
        return someType(type, t => t === unknownEmptyObjectType || !!(t.flags & TypeFlags.Intersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t)));
    }

    function checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(condExpr: Expression, condType: Type, body?: Statement | Expression) {
        if (!strictNullChecks) return;
        bothHelper(condExpr, body);

        function bothHelper(condExpr: Expression, body: Expression | Statement | undefined) {
            condExpr = skipParentheses(condExpr);

            helper(condExpr, body);

            while (isBinaryExpression(condExpr) && (condExpr.operatorToken.kind === SyntaxKind.BarBarToken)) {
                condExpr = skipParentheses(condExpr.left);
                helper(condExpr, body);
            }
        }

        function helper(condExpr: Expression, body: Expression | Statement | undefined) {
            const location = isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr;
            // if (isModuleExportsAccessExpression(location)) {
            //     return;
            // }
            if (isLogicalOrCoalescingBinaryExpression(location)) {
                bothHelper(location, body);
                return;
            }
            const type = location === condExpr ? condType : checkTruthinessExpression(location);
            if (type.flags & TypeFlags.EnumLiteral && isPropertyAccessExpression(location) && (getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol).flags & SymbolFlags.Enum) {
                // EnumLiteral type at condition with known value is always truthy or always falsy, likely an error
                error(location, Diagnostics.This_condition_will_always_return_0, !!(type as LiteralType).value ? "true" : "false");
                return;
            }
            const isPropertyExpressionCast = isPropertyAccessExpression(location) && isTypeAssertion(location.expression);
            if (!hasTypeFacts(type, TypeFacts.Truthy) || isPropertyExpressionCast) return;

            // While it technically should be invalid for any known-truthy value
            // to be tested, we de-scope to functions and Promises unreferenced in
            // the block as a heuristic to identify the most common bugs. There
            // are too many false positives for values sourced from type
            // definitions without strictNullChecks otherwise.
            const callSignatures = getSignaturesOfType(type, SignatureKind.Call);
            // const isPromise = !!getAwaitedTypeOfPromise(type);
            if (callSignatures.length === 0) {
                return;
            }

            const testedNode = isIdentifier(location) ? location
                : isPropertyAccessExpression(location) ? location.name
                : undefined;
            const testedSymbol = testedNode && getSymbolAtLocation(testedNode);
            if (!testedSymbol) {
                return;
            }

            const isUsed = testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol)
                || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol);
            if (!isUsed) {
                // if (isPromise) {
                //     errorAndMaybeSuggestAwait(
                //         location,
                //         /*maybeMissingAwait*/ true,
                //         Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined,
                //         getTypeNameForErrorDisplay(type),
                //     );
                // }
                // else {
                    error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead);
                //}
            }
        }
    }

    function isSymbolUsedInConditionBody(expr: Expression, body: Statement | Expression, testedNode: Node, testedSymbol: Symbol): boolean {
        return !!forEachChild(body, function check(childNode): boolean | undefined {
            if (isIdentifier(childNode)) {
                const childSymbol = getSymbolAtLocation(childNode);
                if (childSymbol && childSymbol === testedSymbol) {
                    // If the test was a simple identifier, the above check is sufficient
                    if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {
                        return true;
                    }
                    // Otherwise we need to ensure the symbol is called on the same target
                    let testedExpression = testedNode.parent;
                    let childExpression = childNode.parent;
                    while (testedExpression && childExpression) {
                        if (
                            isIdentifier(testedExpression) && isIdentifier(childExpression)
                        ) {
                            return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
                        }
                        else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {
                            if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {
                                return false;
                            }
                            childExpression = childExpression.expression;
                            testedExpression = testedExpression.expression;
                        }
                        else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {
                            childExpression = childExpression.expression;
                            testedExpression = testedExpression.expression;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            return forEachChild(childNode, check);
        });
    }

    function isSymbolUsedInBinaryExpressionChain(node: Node, testedSymbol: Symbol): boolean {
        while (isBinaryExpression(node) && node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {
            const isUsed = forEachChild(node.right, function visit(child): boolean | undefined {
                if (isIdentifier(child)) {
                    const symbol = getSymbolAtLocation(child);
                    if (symbol && symbol === testedSymbol) {
                        return true;
                    }
                }
                return forEachChild(child, visit);
            });
            if (isUsed) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }

    function hasTypeFacts(type: Type, mask: TypeFacts): boolean {
        return getTypeFacts(type, mask) !== 0;
    }

    function checkSourceFileWithEagerDiagnostics(sourceFile: SourceFile, nodesToCheck?: Node[]) {
        ensurePendingDiagnosticWorkComplete();
        // then setup diagnostics for immediate invocation (as we are about to collect them, and
        // this avoids the overhead of longer-lived callbacks we don't need to allocate)
        // This also serves to make the shift to possibly lazy diagnostics transparent to serial command-line scenarios
        // (as in those cases, all the diagnostics will still be computed as the appropriate place in the tree,
        // thus much more likely retaining the same union ordering as before we had lazy diagnostics)
        const oldAddLazyDiagnostics = addLazyDiagnostic;
        addLazyDiagnostic = cb => cb();
        checkSourceFile(sourceFile, nodesToCheck);
        addLazyDiagnostic = oldAddLazyDiagnostics;
    }
    
    function ensurePendingDiagnosticWorkComplete() {
        // Invoke any existing lazy diagnostics to add them, clear the backlog of diagnostics
        for (const cb of deferredDiagnosticsCallbacks) {
            cb();
        }
        deferredDiagnosticsCallbacks = [];
    }

    function createSymbol(flags: SymbolFlags, name: string, checkFlags?: CheckFlags): TransientSymbol {
        symbolCount++;
        const symbol = new Symbol(flags | SymbolFlags.Transient, name) as TransientSymbol;
        symbol.links = new SymbolLinks() as TransientSymbolLinks;
        symbol.links.checkFlags = checkFlags || CheckFlags.None;
        return symbol;
    }

    function signatureToString(signature: Signature, enclosingDeclaration?: Node, flags = TypeFormatFlags.None, kind?: SignatureKind, writer?: EmitTextWriter): string {
        return writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker);

        function signatureToStringWorker(writer: EmitTextWriter) {
            let sigOutput: SyntaxKind;
            if (flags & TypeFormatFlags.WriteArrowStyleSignature) {
                sigOutput = SyntaxKind.FunctionType;
            }
            else {
                sigOutput = SyntaxKind.CallSignature;
            }
            const sig = nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName);
            const printer = createPrinterWithRemoveCommentsOmitTrailingSemicolon();
            const sourceFile = enclosingDeclaration && getSourceFileOrIncludeOfNode(enclosingDeclaration);
            printer.writeNode(EmitHint.Unspecified, sig!, /*sourceFile*/ sourceFile, getTrailingSemicolonDeferringWriter(writer)); // TODO: GH#18217
            return writer;
        }
    }

    function createSignature(
        declaration: SignatureDeclaration | JSDocSignature | undefined,
        typeParameters: readonly TypeParameter[] | undefined,
        thisParameter: Symbol | undefined,
        parameters: readonly Symbol[],
        resolvedReturnType: Type | undefined,        
        resolvedTypePredicate: TypePredicate | undefined,
        minArgumentCount: number,
        flags: SignatureFlags,
    ): Signature {
        const sig = new Signature(checker, flags);
        sig.declaration = declaration;
        sig.typeParameters = typeParameters;
        sig.parameters = parameters;
        sig.thisParameter = thisParameter;
        sig.resolvedReturnType = resolvedReturnType;
        sig.resolvedTypePredicate = resolvedTypePredicate;
        sig.minArgumentCount = minArgumentCount;
        sig.resolvedMinArgumentCount = undefined;
        sig.target = undefined;
        sig.mapper = undefined;
        sig.compositeSignatures = undefined;
        sig.compositeKind = undefined;
        return sig;
    }

    function createAnonymousType(symbol: Symbol | undefined, members: SymbolTable, callSignatures: readonly Signature[], constructSignatures: readonly Signature[], indexInfos: readonly IndexInfo[]): ResolvedType {
        return setStructuredTypeMembers(createObjectType(ObjectFlags.Anonymous, symbol), members, callSignatures, constructSignatures, indexInfos);
    }

    function setStructuredTypeMembers(type: StructuredType, members: SymbolTable, callSignatures: readonly Signature[], constructSignatures: readonly Signature[], indexInfos: readonly IndexInfo[]): ResolvedType {
        const resolved = type as ResolvedType;
        resolved.members = members;
        resolved.properties = emptyArray;
        resolved.callSignatures = callSignatures;
        resolved.constructSignatures = constructSignatures;
        resolved.indexInfos = indexInfos;
        // This can loop back to getPropertyOfType() which would crash if `callSignatures` & `constructSignatures` are not initialized.
        if (members !== emptySymbols) resolved.properties = getNamedMembers(members);
        return resolved;
    }

    function createGenericType(objectFlags: ObjectFlags, name: string): GenericType {
        const symbol = createSymbol(SymbolFlags.Type, name)
        const type = createTypeWithSymbol(TypeFlags.Object, symbol) as GenericType;
        type.objectFlags = objectFlags;
        type.instantiations = new Map<string, TypeReference>();
        type.resolvedBaseTypes = [];
        type.members = createSymbolTable();
        return type;
    }

    function createObjectType(objectFlags: ObjectFlags, symbol?: Symbol): ObjectType {
        const type = createTypeWithSymbol(TypeFlags.Object, symbol!) as ObjectType;
        type.objectFlags = objectFlags;
        type.members = undefined;
        type.properties = undefined;
        type.callSignatures = undefined;
        type.constructSignatures = undefined;
        type.indexInfos = undefined;
        return type;
    }

    function getNamedMembers(members: SymbolTable): Symbol[] {
        let result: Symbol[] | undefined;
        members.forEach((symbol, id) => {
            if (isNamedMember(symbol, id)) {
                (result || (result = [])).push(symbol);
            }
        });
        return result || emptyArray;
    }

    function createTypeWithSymbol(flags: TypeFlags, symbol: Symbol): Type {
        const result = createType(flags);
        result.symbol = symbol;
        return result;
    }

    function isNamedMember(member: Symbol, name: string) {
        return symbolIsValue(member);
    }

    function symbolIsValue(symbol: Symbol, includeTypeOnlyMembers?: boolean): boolean {
        return !!(
            symbol.flags & SymbolFlags.Value ||
            symbol.flags & SymbolFlags.Alias && getSymbolFlags(symbol, !includeTypeOnlyMembers) & SymbolFlags.Value
        );
    }

    /**
     * Gets combined flags of a `symbol` and all alias targets it resolves to. `resolveAlias`
     * is typically recursive over chains of aliases, but stops mid-chain if an alias is merged
     * with another exported symbol, e.g.
     * ```ts
     * // a.ts
     * export const a = 0;
     * // b.ts
     * export { a } from "./a";
     * export type a = number;
     * // c.ts
     * import { a } from "./b";
     * ```
     * Calling `resolveAlias` on the `a` in c.ts would stop at the merged symbol exported
     * from b.ts, even though there is still more alias to resolve. Consequently, if we were
     * trying to determine if the `a` in c.ts has a value meaning, looking at the flags on
     * the local symbol and on the symbol returned by `resolveAlias` is not enough.
     * @returns SymbolFlags.All if `symbol` is an alias that ultimately resolves to `unknown`;
     * combined flags of all alias targets otherwise.
     */
    function getSymbolFlags(symbol: Symbol, excludeTypeOnlyMeanings?: boolean, excludeLocalMeanings?: boolean): SymbolFlags {
        // LPC does not have aliases
        return symbol.flags;
        // const typeOnlyDeclaration = excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol);
        // const typeOnlyDeclarationIsExportStar = typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration);
        // const typeOnlyResolution = typeOnlyDeclaration && (
        //     typeOnlyDeclarationIsExportStar
        //         ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors*/ true)
        //         : resolveAlias(typeOnlyDeclaration.symbol)
        // );
        // const typeOnlyExportStarTargets = typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined;
        // let flags = excludeLocalMeanings ? SymbolFlags.None : symbol.flags;
        // let seenSymbols;
        // while (symbol.flags & SymbolFlags.Alias) {
        //     const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));
        //     if (
        //         !typeOnlyDeclarationIsExportStar && target === typeOnlyResolution ||
        //         typeOnlyExportStarTargets?.get(target.name) === target
        //     ) {
        //         break;
        //     }
        //     if (target === unknownSymbol) {
        //         return SymbolFlags.All;
        //     }

        //     // Optimizations - try to avoid creating or adding to
        //     // `seenSymbols` if possible
        //     if (target === symbol || seenSymbols?.has(target)) {
        //         break;
        //     }
        //     if (target.flags & SymbolFlags.Alias) {
        //         if (seenSymbols) {
        //             seenSymbols.add(target);
        //         }
        //         else {
        //             seenSymbols = new Set([symbol, target]);
        //         }
        //     }
        //     flags |= target.flags;
        //     symbol = target;
        // }
        // return flags;
    }

    function checkAndReportErrorForMissingPrefix(errorLocation: Node, name: string, nameArg: string | Identifier): boolean {
        if (!isIdentifier(errorLocation) || errorLocation.text !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation)) {
            return false;
        }        
        
        return false;
    }
    
    function isPrimitiveTypeName(name: string) {
        return name === "string" || name === "int" || name === "object" || name === "float" || name === "mixed" || name === "mapping" || name === "unknown" || name === "bytes" || name === "buffer";
    }

    /**
     * Indicates that a symbol is an alias that does not merge with a local declaration.
     * OR Is a JSContainer which may merge an alias with a local declaration
     */
    function isNonLocalAlias(symbol: Symbol | undefined, excludes = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace): symbol is Symbol {
        if (!symbol) return false;
        return (symbol.flags & (SymbolFlags.Alias | excludes)) === SymbolFlags.Alias || !!(symbol.flags & SymbolFlags.Alias && symbol.flags & SymbolFlags.Assignment);
    }

    function resolveSymbol(symbol: Symbol, dontResolveAlias?: boolean): Symbol;
    function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined;
    function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined {
        return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
    }

    function resolveAlias(symbol: Symbol): Symbol {
        Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here.");
        const links = getSymbolLinks(symbol);
        if (!links.aliasTarget) {
            links.aliasTarget = resolvingSymbol;
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            const target = getTargetOfAliasDeclaration(node);
            if (links.aliasTarget === resolvingSymbol) {
                links.aliasTarget = target || unknownSymbol;
            }
            else {
                error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
            }
        }
        else if (links.aliasTarget === resolvingSymbol) {
            links.aliasTarget = unknownSymbol;
        }
        return links.aliasTarget;
    }

    function tryResolveAlias(symbol: Symbol): Symbol | undefined {
        const links = getSymbolLinks(symbol);
        if (links.aliasTarget !== resolvingSymbol) {
            return resolveAlias(symbol);
        }

        return undefined;
    }

    function symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags: SymbolFormatFlags = SymbolFormatFlags.AllowAnyNodeKind, writer?: EmitTextWriter): string {
        //Debug.fail("Implement me - symbolToString");
        let nodeFlags = NodeBuilderFlags.IgnoreErrors;
        if (flags & SymbolFormatFlags.UseOnlyExternalAliasing) {
            nodeFlags |= NodeBuilderFlags.UseOnlyExternalAliasing;
        }
        if (flags & SymbolFormatFlags.WriteTypeParametersOrArguments) {
            nodeFlags |= NodeBuilderFlags.WriteTypeParametersInQualifiedName;
        }
        if (flags & SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope) {
            nodeFlags |= NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope;
        }
        if (flags & SymbolFormatFlags.DoNotIncludeSymbolChain) {
            nodeFlags |= NodeBuilderFlags.DoNotIncludeSymbolChain;
        }
        if (flags & SymbolFormatFlags.WriteComputedProps) {
            nodeFlags |= NodeBuilderFlags.WriteComputedProps;
        }
        
        const builder = flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName;
        return writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker);

        function symbolToStringWorker(writer: EmitTextWriter) {
            const entity = builder(symbol, meaning!, enclosingDeclaration, nodeFlags)!; // TODO: GH#18217
            // add neverAsciiEscape for GH#39027
            const printer = enclosingDeclaration?.kind === SyntaxKind.SourceFile
                ? createPrinterWithRemoveCommentsNeverAsciiEscape()
                : createPrinterWithRemoveComments();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(EmitHint.Unspecified, entity, /*sourceFile*/ sourceFile, writer);
            return writer;
        }
    }
    
    

    function lookupSymbolChain(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, yieldModuleSymbol?: boolean) {
        context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning);
        return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol);
    }

    function lookupSymbolChainWorker(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, yieldModuleSymbol?: boolean) {
        // Try to get qualified name if the symbol is not a type parameter and there is an enclosing declaration.
        let chain: Symbol[];
        const isTypeParameter = symbol.flags & SymbolFlags.TypeParameter;
        if (!isTypeParameter && (context.enclosingDeclaration || context.flags & NodeBuilderFlags.UseFullyQualifiedType) && !(context.flags & NodeBuilderFlags.DoNotIncludeSymbolChain)) {
            chain = Debug.checkDefined(getSymbolChain(symbol, meaning, /*endOfChain*/ true));
            Debug.assert(chain && chain.length > 0);
        }
        else {
            chain = [symbol];
        }
        return chain;

        /** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */
        function getSymbolChain(symbol: Symbol, meaning: SymbolFlags, endOfChain: boolean): Symbol[] | undefined {            
            let accessibleSymbolChain = getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlags.UseOnlyExternalAliasing));
            let parentSpecifiers: (string | undefined)[];
            if (
                !accessibleSymbolChain ||
                needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))
            ) {
                // Go up and add our parent.
                const parents = getContainersOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol, context.enclosingDeclaration, meaning);
                if (length(parents)) {
                    parentSpecifiers = parents!.map(symbol => undefined);
                    // TODO
                    //     some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)
                    //         ? getSpecifierForModuleSymbol(symbol, context)
                    //         : undefined
                    // );
                    const indices = parents!.map((_, i) => i);
                    indices.sort(sortByBestName);
                    const sortedParents = indices.map(i => parents![i]);
                    for (const parent of sortedParents) {
                        const parentChain = getSymbolChain(parent, getQualifiedLeftMeaning(meaning), /*endOfChain*/ false);
                        if (parentChain) {
                            if (
                                parent.exports && parent.exports.get(InternalSymbolName.ExportEquals) &&
                                getSymbolIfSameReference(parent.exports.get(InternalSymbolName.ExportEquals)!, symbol)
                            ) {
                                // parentChain root _is_ symbol - symbol is a module export=, so it kinda looks like it's own parent
                                // No need to lookup an alias for the symbol in itself
                                accessibleSymbolChain = parentChain;
                                break;
                            }
                            accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [getAliasForSymbolInContainer(parent, symbol) || symbol]);
                            break;
                        }
                    }
                }
            }

            if (accessibleSymbolChain) {
                return accessibleSymbolChain;
            }
            if (
                // If this is the last part of outputting the symbol, always output. The cases apply only to parent symbols.
                endOfChain ||
                // If a parent symbol is an anonymous type, don't write it.
                !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral))
            ) {
                // If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
                if (!endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    return;
                }
                return [symbol];
            }

            function sortByBestName(a: number, b: number) {
                const specifierA = parentSpecifiers[a];
                const specifierB = parentSpecifiers[b];
                if (specifierA && specifierB) {
                    const isBRelative = pathIsRelative(specifierB);
                    if (pathIsRelative(specifierA) === isBRelative) {
                        // Both relative or both non-relative, sort by number of parts
                        return moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB);
                    }
                    if (isBRelative) {
                        // A is non-relative, B is relative: prefer A
                        return -1;
                    }
                    // A is relative, B is non-relative: prefer B
                    return 1;
                }
                return 0;
            }
        }
    }


    
    function getNameOfSymbolFromNameType(symbol: Symbol, context?: NodeBuilderContext) {
        const nameType = getSymbolLinks(symbol).nameType;
        if (nameType) {
            if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
                const name = "" + (nameType as StringLiteralType | IntLiteralType).value;
                if (!isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name)) {
                    return `"${escapeString(name, CharacterCodes.doubleQuote)}"`;
                }
                if (isNumericLiteralName(name) && startsWith(name, "-")) {
                    return `[${name}]`;
                }
                return name;
            }
            // if (nameType.flags & TypeFlags.UniqueESSymbol) {
            //     return `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]`;
            // }
        }
    }

    /**
     * Gets a human-readable name for a symbol.
     * Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
     *
     * Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
     * It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
     */
    function getNameOfSymbolAsWritten(symbol: Symbol, context?: NodeBuilderContext): string {
        if (context?.remappedSymbolReferences?.has(getSymbolId(symbol))) {
            symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))!;
        }
        if (
            context && symbol.name === InternalSymbolName.Default && !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) &&
            // If it's not the first part of an entity name, it must print as `default`
            (!(context.flags & NodeBuilderFlags.InInitialEntityName) ||
                // if the symbol is synthesized, it will only be referenced externally it must print as `default`
                !symbol.declarations
                // if not in the same binding context (source file, module declaration), it must print as `default`
                // || (context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) !== findAncestor(context.enclosingDeclaration, isDefaultBindingContext))
                )
        ) {
            return "default";
        }
        if (symbol.declarations && symbol.declarations.length) {
            let declaration = firstDefined(symbol.declarations, d => getNameOfDeclaration(d) ? d : undefined); // Try using a declaration with a name, first
            const name = declaration && getNameOfDeclaration(declaration);
            if (declaration && name) {
                // if (isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration)) {
                //     return symbolName(symbol);
                // }
                if (isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlags.Late)) {
                    const nameType = getSymbolLinks(symbol).nameType;
                    if (nameType && nameType.flags & TypeFlags.StringOrNumberLiteral) {
                        // Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
                        const result = getNameOfSymbolFromNameType(symbol, context);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                }
                return declarationNameToString(name);
            }
            if (!declaration) {
                declaration = symbol.declarations[0]; // Declaration may be nameless, but we'll try anyway
            }
            if (declaration.parent && declaration.parent.kind === SyntaxKind.VariableDeclaration) {
                return declarationNameToString((declaration.parent as VariableDeclaration).name);
            }
            switch (declaration.kind) {
                case SyntaxKind.ClassExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.InlineClosureExpression:
                    if (context && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {
                        context.encounteredError = true;
                    }
                    return declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)";
            }
        }
        const name = getNameOfSymbolFromNameType(symbol, context);
        return name !== undefined ? name : symbolName(symbol);
    }

    function hasNonGlobalAugmentationExternalModuleSymbol(declaration: Node) {
        return false;//TODO return isModuleWithStringLiteralName(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile));
    }
    
    // The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
    // its locally declared type parameters.
    function getTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] | undefined {
        return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
    }

    // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
    function getOuterTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] | undefined {
        const declaration = (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function)
            ? symbol.valueDeclaration
            : symbol.declarations?.find(decl => {
                if (decl.kind === SyntaxKind.InterfaceDeclaration) {
                    return true;
                }
                if (decl.kind !== SyntaxKind.VariableDeclaration) {
                    return false;
                }
                const initializer = (decl as VariableDeclaration).initializer;
                return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.InlineClosureExpression);
            })!;
        Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations");
        return getOuterTypeParameters(declaration);
    }

    function getExportsOfSymbol(symbol: Symbol): SymbolTable {
        return symbol?.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedExports) :
            symbol?.exports ?? emptySymbols;
        //symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) :
    }

    function getExportsOfModule(moduleSymbol: Symbol): SymbolTable {
        const links = getSymbolLinks(moduleSymbol);
        if (!links.resolvedExports) {
            const { exports } = getExportsOfModuleWorker(moduleSymbol);
            links.resolvedExports = exports;            
        }
        return links.resolvedExports;
    }

    function checkExternalModuleExports(node: SourceFile) {
        const moduleSymbol = getSymbolOfDeclaration(node);
        const links = getSymbolLinks(moduleSymbol);
        if (!links.exportsChecked) {
            const exports = getExportsOfModule(moduleSymbol);
            // TODO do more checks here
            
            links.exportsChecked = true;
        }
    }

   

    /**
     * Checks if two symbols, through aliasing and/or merging, refer to the same thing
     */
    function getSymbolIfSameReference(s1: Symbol, s2: Symbol) {
        if (getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(resolveSymbol(getMergedSymbol(s2)))) {
            return s1;
        }
    }

    function isValueSymbolAccessible(typeSymbol: Symbol, enclosingDeclaration: Node | undefined): boolean {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlags.Value, /*shouldComputeAliasesToMakeVisible*/ false, /*allowModules*/ true);
        return access.accessibility === SymbolAccessibility.Accessible;
    }

    function forEachSymbolTableInScope<T>(enclosingDeclaration: Node | undefined, callback: (symbolTable: SymbolTable, ignoreQualification?: boolean, isLocalNameLookup?: boolean, scopeNode?: Node) => T): T {
        let result: T;
        for (let location = enclosingDeclaration; location; location = location.parent) {
            // Locals of a source file are not in scope (because they get merged into the global symbol table)
            if (canHaveLocals(location) && location.locals) {//} && !isGlobalSourceFile(location)) {
                if (result = callback(location.locals, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ true, location)) {
                    return result;
                }
            }
            switch (location.kind) {
                case SyntaxKind.SourceFile:
                    // if (!isExternalOrCommonJsModule(location as SourceFile)) {
                    //     break;
                    // }
                    // falls through
                // case SyntaxKind.ModuleDeclaration:
                    const sym = getSymbolOfDeclaration(location as Declaration);
                    // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten
                    // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred
                    // to one another anyway)
                    if (result = callback(sym?.exports || emptySymbols, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ true, location)) {
                        return result;
                    }
                    break;
                // case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                // case SyntaxKind.InterfaceDeclaration:
                    // Type parameters are bound into `members` lists so they can merge across declarations
                    // This is troublesome, since in all other respects, they behave like locals :cries:
                    // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol
                    // lookup logic in terms of `resolveName` would be nice
                    // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals
                    // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would
                    // trigger resolving late-bound names, which we may already be in the process of doing while we're here!
                    let table: Map<string, Symbol> | undefined;
                    // TODO: Should this filtered table be cached in some way?
                    (getSymbolOfDeclaration(location as ClassLikeDeclaration | SourceFile).members || emptySymbols).forEach((memberSymbol, key) => {
                        if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) {
                            (table || (table = createSymbolTable())).set(key, memberSymbol);
                        }
                    });
                    if (table && (result = callback(table, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ false, location))) {
                        return result;
                    }
                    break;
            }
        }

        return callback(globals, /*ignoreQualification*/ undefined, /*isLocalNameLookup*/ true);
    }
    
    function needsQualification(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags) {
        let qualify = false;
        forEachSymbolTableInScope(enclosingDeclaration, symbolTable => {
            // If symbol of this name is not available in the symbol table we are ok
            let symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.name));
            if (!symbolFromSymbolTable) {
                // Continue to the next symbol table
                return false;
            }
            // If the symbol with this name is present it should refer to the symbol
            if (symbolFromSymbolTable === symbol) {
                // No need to qualify
                return true;
            }

            // Qualify if the symbol from symbol table has same meaning as expected
            const shouldResolveAlias = symbolFromSymbolTable.flags & SymbolFlags.Alias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier);
            symbolFromSymbolTable = shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
            const flags = shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags;
            if (flags & meaning) {
                qualify = true;
                return true;
            }

            // Continue to the next symbol table
            return false;
        });

        return qualify;
    }

    function isPropertyOrMethodDeclarationSymbol(symbol: Symbol) {
        if (symbol.declarations && symbol.declarations.length) {
            for (const declaration of symbol.declarations) {
                switch (declaration.kind) {
                    case SyntaxKind.PropertyDeclaration:
                    // case SyntaxKind.MethodDeclaration:
                    // case SyntaxKind.GetAccessor:
                    // case SyntaxKind.SetAccessor:
                        continue;
                    default:
                        return false;
                }
            }
            return true;
        }
        return false;
    }

    function getQualifiedLeftMeaning(rightMeaning: SymbolFlags) {
        // If we are looking in value space, the parent meaning is value, other wise it is namespace
        return rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;
    }
    
    function getAccessibleSymbolChain(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean, visitedSymbolTablesMap = new Map<SymbolId, SymbolTable[]>()): Symbol[] | undefined {
        if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
            return undefined;
        }
        const links = getSymbolLinks(symbol);
        const cache = (links.accessibleChainCache ||= new Map());
        // Go from enclosingDeclaration to the first scope we check, so the cache is keyed off the scope and thus shared more
        const firstRelevantLocation = forEachSymbolTableInScope(enclosingDeclaration, (_, __, ___, node) => node);
        const key = `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}`;
        if (cache.has(key)) {
            return cache.get(key);
        }

        const id = getSymbolId(symbol);
        let visitedSymbolTables = visitedSymbolTablesMap.get(id);
        if (!visitedSymbolTables) {
            visitedSymbolTablesMap.set(id, visitedSymbolTables = []);
        }
        const result = forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
        cache.set(key, result);
        return result;

        /**
         * @param {ignoreQualification} boolean Set when a symbol is being looked for through the exports of another symbol (meaning we have a route to qualify it already)
         */
        function getAccessibleSymbolChainFromSymbolTable(symbols: SymbolTable, ignoreQualification?: boolean, isLocalNameLookup?: boolean): Symbol[] | undefined {
            if (!pushIfUnique(visitedSymbolTables!, symbols)) {
                return undefined;
            }

            const result = trySymbolTable(symbols, ignoreQualification, isLocalNameLookup);
            visitedSymbolTables!.pop();
            return result;
        }

        function canQualifySymbol(symbolFromSymbolTable: Symbol, meaning: SymbolFlags) {
            // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
            return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||
                // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap);
        }

        function isAccessible(symbolFromSymbolTable: Symbol, resolvedAliasSymbol?: Symbol, ignoreQualification?: boolean) {
            return (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) &&
                // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                // and if symbolFromSymbolTable or alias resolution matches the symbol,
                // check the symbol can be qualified, it is only then this symbol is accessible
                !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) &&
                (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning));
        }

        function trySymbolTable(symbols: SymbolTable, ignoreQualification: boolean | undefined, isLocalNameLookup: boolean | undefined): Symbol[] | undefined {
            // If symbol is directly available by its name in the symbol table
            if (isAccessible(symbols.get(symbol!.name)!, /*resolvedAliasSymbol*/ undefined, ignoreQualification)) {
                return [symbol!];
            }

            // Check if symbol is any of the aliases in scope
            const result = forEachEntry(symbols, symbolFromSymbolTable => {
                if (
                    symbolFromSymbolTable.flags & SymbolFlags.Alias
                    && symbolFromSymbolTable.name !== InternalSymbolName.ExportEquals
                    && symbolFromSymbolTable.name !== InternalSymbolName.Default
                    //&& !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration)))
                    // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name
                    // && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration))
                    // // If we're looking up a local name to reference directly, omit namespace reexports, otherwise when we're trawling through an export list to make a dotted name, we can keep it
                    // && (isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true)
                    // While exports are generally considered to be in scope, export-specifier declared symbols are _not_
                    // See similar comment in `resolveName` for details
                    && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier))
                ) {
                    const resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
                    const candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
                    if (candidate) {
                        return candidate;
                    }
                }
                if (symbolFromSymbolTable.name === symbol!.name && symbolFromSymbolTable.exportSymbol) {
                    if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), /*resolvedAliasSymbol*/ undefined, ignoreQualification)) {
                        return [symbol!];
                    }
                }
            });

            // If there's no result and we're looking at the global symbol table, treat `globalThis` like an alias and try to lookup thru that
            return result || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined);
        }

        function getCandidateListForSymbol(symbolFromSymbolTable: Symbol, resolvedImportedSymbol: Symbol, ignoreQualification: boolean | undefined) {
            if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)) {
                return [symbolFromSymbolTable];
            }

            // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
            // but only if the symbolFromSymbolTable can be qualified
            const candidateTable = getExportsOfSymbol(resolvedImportedSymbol);
            const accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, /*ignoreQualification*/ true);
            if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
            }
        }
    }


    function hasVisibleDeclarations(symbol: Symbol, shouldComputeAliasToMakeVisible: boolean): SymbolVisibilityResult | undefined {
        let aliasesToMakeVisible: LateVisibilityPaintedStatement[] | undefined;
        if (!every(filter(symbol.declarations, d => d.kind !== SyntaxKind.Identifier), getIsDeclarationVisible)) {
            return undefined;
        }
        return { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible };

        function getIsDeclarationVisible(declaration: Declaration) {
            if (!isDeclarationVisible(declaration)) {
                // Mark the unexported alias as visible if its parent is visible
                // because these kind of aliases can be used to name types in declaration file

                // const anyImportSyntax = getAnyImportSyntax(declaration);
                // if (
                //     anyImportSyntax &&
                //     !hasSyntacticModifier(anyImportSyntax, ModifierFlags.Export) && // import clause without export
                //     isDeclarationVisible(anyImportSyntax.parent)
                // ) {
                //     return addVisibleAlias(declaration, anyImportSyntax);
                // } else
                if (
                    isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) &&
                    !hasSyntacticModifier(declaration.parent.parent, ModifierFlags.Export) && // unexported variable statement
                    isDeclarationVisible(declaration.parent.parent.parent)
                ) {
                    return addVisibleAlias(declaration, declaration.parent.parent);
                }
                else if (
                    isLateVisibilityPaintedStatement(declaration) // unexported top-level statement
                    && !hasSyntacticModifier(declaration, ModifierFlags.Export)
                    && isDeclarationVisible(declaration.parent)
                ) {
                    return addVisibleAlias(declaration, declaration);
                }
                else if (isBindingElement(declaration)) {
                    if (
                        symbol.flags & SymbolFlags.Alias && isInJSFile(declaration) && declaration.parent?.parent // exported import-like top-level JS require statement
                        && isVariableDeclaration(declaration.parent.parent)
                        && declaration.parent.parent.parent?.parent && isVariableStatement(declaration.parent.parent.parent.parent)
                        && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlags.Export)
                        && declaration.parent.parent.parent.parent.parent // check if the thing containing the variable statement is visible (ie, the file)
                        && isDeclarationVisible(declaration.parent.parent.parent.parent.parent)
                    ) {
                        return addVisibleAlias(declaration, declaration.parent.parent.parent.parent);
                    }
                    else if (symbol.flags & SymbolFlags.BlockScopedVariable) {
                        const variableStatement = findAncestor(declaration, isVariableStatement)!;
                        if (hasSyntacticModifier(variableStatement, ModifierFlags.Export)) {
                            return true;
                        }
                        if (!isDeclarationVisible(variableStatement.parent)) {
                            return false;
                        }
                        return addVisibleAlias(declaration, variableStatement);
                    }
                }

                // Declaration is not visible
                return false;
            }

            return true;
        }

        function addVisibleAlias(declaration: Declaration, aliasingStatement: LateVisibilityPaintedStatement) {
            // In function "buildTypeDisplay" where we decide whether to write type-alias or serialize types,
            // we want to just check if type- alias is accessible or not but we don't care about emitting those alias at that time
            // since we will do the emitting later in trackSymbol.
            if (shouldComputeAliasToMakeVisible) {
                getNodeLinks(declaration).isVisible = true;
                aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement);
            }
            return true;
        }
    }

    
    function isAnySymbolAccessible(symbols: Symbol[] | undefined, enclosingDeclaration: Node | undefined, initialSymbol: Symbol, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean, allowModules: boolean): SymbolAccessibilityResult | undefined {
        if (!length(symbols)) return;

        let hadAccessibleChain: Symbol | undefined;
        let earlyModuleBail = false;
        for (const symbol of symbols!) {
            // Symbol is accessible if it by itself is accessible
            const accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, /*useOnlyExternalAliasing*/ false);
            if (accessibleSymbolChain) {
                hadAccessibleChain = symbol;
                const hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
                if (hasAccessibleDeclarations) {
                    return hasAccessibleDeclarations;
                }
            }
            if (allowModules) {
                if (some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    if (shouldComputeAliasesToMakeVisible) {
                        earlyModuleBail = true;
                        // Generally speaking, we want to use the aliases that already exist to refer to a module, if present
                        // In order to do so, we need to find those aliases in order to retain them in declaration emit; so
                        // if we are in declaration emit, we cannot use the fast path for module visibility until we've exhausted
                        // all other visibility options (in order to capture the possible aliases used to reference the module)
                        continue;
                    }
                    // Any meaning of a module symbol is always accessible via an `import` type
                    return {
                        accessibility: SymbolAccessibility.Accessible,
                    };
                }
            }

            // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
            // It could be a qualified symbol and hence verify the path
            // e.g.:
            // module m {
            //     export class c {
            //     }
            // }
            // const x: typeof m.c
            // In the above example when we start with checking if typeof m.c symbol is accessible,
            // we are going to see if c can be accessed in scope directly.
            // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
            // It is accessible if the parent m is accessible because then m.c can be accessed through qualification

            const containers = getContainersOfSymbol(symbol, enclosingDeclaration, meaning);
            const parentResult = isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning, shouldComputeAliasesToMakeVisible, allowModules);
            if (parentResult) {
                return parentResult;
            }
        }

        if (earlyModuleBail) {
            return {
                accessibility: SymbolAccessibility.Accessible,
            };
        }

        if (hadAccessibleChain) {
            return {
                accessibility: SymbolAccessibility.NotAccessible,
                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined,
            };
        }
    }

    function getAliasForSymbolInContainer(container: Symbol, symbol: Symbol) {
        if (container === getParentOfSymbol(symbol)) {
            // fast path, `symbol` is either already the alias or isn't aliased
            return symbol;
        }
        // Check if container is a thing with an `export=` which points directly at `symbol`, and if so, return
        // the container itself as the alias for the symbol
        const exportEquals = container.exports && container.exports.get(InternalSymbolName.ExportEquals);
        if (exportEquals && getSymbolIfSameReference(exportEquals, symbol)) {
            return container;
        }
        const exports = getExportsOfSymbol(container);
        const quick = exports.get(symbol.name);
        if (quick && getSymbolIfSameReference(quick, symbol)) {
            return quick;
        }
        return forEachEntry(exports, exported => {
            if (getSymbolIfSameReference(exported, symbol)) {
                return exported;
            }
        });
    }

    function getVariableDeclarationOfObjectLiteral(symbol: Symbol, meaning: SymbolFlags) {
        // If we're trying to reference some object literal in, eg `var a = { x: 1 }`, the symbol for the literal, `__object`, is distinct
        // from the symbol of the declaration it is being assigned to. Since we can use the declaration to refer to the literal, however,
        // we'd like to make that connection here - potentially causing us to paint the declaration's visibility, and therefore the literal.
        const firstDecl: Node | false = !!length(symbol.declarations) && first(symbol.declarations!);
        if (meaning & SymbolFlags.Value && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent)) {
            if (isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl === firstDecl.parent.type) {
                return getSymbolOfDeclaration(firstDecl.parent);
            }
        }
    }
    
    /**
     * Attempts to find the symbol corresponding to the container a symbol is in - usually this
     * is just its' `.parent`, but for locals, this value is `undefined`
     */
    function getContainersOfSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): Symbol[] | undefined {
        const container = getParentOfSymbol(symbol);
        // Type parameters end up in the `members` lists but are not externally visible
        if (container && !(symbol.flags & SymbolFlags.TypeParameter)) {
            return getWithAlternativeContainers(container);
        }
        const candidates = mapDefined(symbol.declarations, d => {
            if (d.parent) {
            //if (!isAmbientModule(d) && d.parent) {
                // direct children of a module
                if (hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {
                    return getSymbolOfDeclaration(d.parent as Declaration);
                }
                // export ='d member of an ambient module
                // if (isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) === symbol) {
                //     return getSymbolOfDeclaration(d.parent.parent);
                // }
            }
            // if (isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind === SyntaxKind.EqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression)) {
            //     if (isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression)) {
            //         return getSymbolOfDeclaration(getSourceFileOfNode(d));
            //     }
            //     checkExpressionCached(d.parent.left.expression);
            //     return getNodeLinks(d.parent.left.expression).resolvedSymbol;
            // }
        });
        if (!length(candidates)) {
            return undefined;
        }
        const containers = mapDefined(candidates, candidate => getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined);

        let bestContainers: Symbol[] = [];
        let alternativeContainers: Symbol[] = [];

        for (const container of containers) {
            const [bestMatch, ...rest] = getWithAlternativeContainers(container);
            bestContainers = append(bestContainers, bestMatch);
            alternativeContainers = addRange(alternativeContainers, rest);
        }

        return concatenate(bestContainers, alternativeContainers);

        function getWithAlternativeContainers(container: Symbol) {
            const additionalContainers = mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer);
            const reexportContainers = enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration);
            const objectLiteralContainer = getVariableDeclarationOfObjectLiteral(container, meaning);
            if (
                enclosingDeclaration &&
                container.flags & getQualifiedLeftMeaning(meaning) &&
                getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlags.Namespace, /*useOnlyExternalAliasing*/ false)
            ) {
                return append(concatenate(concatenate([container], additionalContainers), reexportContainers), objectLiteralContainer); // This order expresses a preference for the real container if it is in scope
            }
            // we potentially have a symbol which is a member of the instance side of something - look for a variable in scope with the container's type
            // which may be acting like a namespace (eg, `Symbol` acts like a namespace when looking up `Symbol.toStringTag`)
            const firstVariableMatch = !(container.flags & getQualifiedLeftMeaning(meaning))
                    && container.flags & SymbolFlags.Type
                    && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object
                    && meaning === SymbolFlags.Value
                ? forEachSymbolTableInScope(enclosingDeclaration, t => {
                    return forEachEntry(t, s => {
                        if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {
                            return s;
                        }
                    });
                }) : undefined;
            let res = firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container];
            res = append(res, objectLiteralContainer);
            res = addRange(res, reexportContainers);
            return res;
        }

        function fileSymbolIfFileSymbolExportEqualsContainer(d: Declaration) {
            return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
        }
    }

    function getFileSymbolIfFileSymbolExportEqualsContainer(d: Declaration, container: Symbol) {
        return undefined;
        // TODO
        // const fileSymbol = getExternalModuleContainer(d);
        // const exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolName.ExportEquals);
        // return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined;
    }


    function getAlternativeContainingModules(symbol: Symbol, enclosingDeclaration: Node): Symbol[] {
        const containingFile = getSourceFileOfNode(enclosingDeclaration);
        const id = getNodeId(containingFile);
        const links = getSymbolLinks(symbol);
        let results: Symbol[] | undefined;
        if (links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id))) {
            return results;
        }
        // TODO _ handle imported files here
        // if (containingFile && containingFile.imports) {
        //     // Try to make an import using an import already in the enclosing file, if possible
        //     for (const importRef of containingFile.imports) {
        //         if (nodeIsSynthesized(importRef)) continue; // Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
        //         const resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, /*ignoreErrors*/ true);
        //         if (!resolvedModule) continue;
        //         const ref = getAliasForSymbolInContainer(resolvedModule, symbol);
        //         if (!ref) continue;
        //         results = append(results, resolvedModule);
        //     }
        //     if (length(results)) {
        //         (links.extendedContainersByFile || (links.extendedContainersByFile = new Map())).set(id, results!);
        //         return results!;
        //     }
        // }
        if (links.extendedContainers) {
            return links.extendedContainers;
        }
        // No results from files already being imported by this file - expand search (expensive, but not location-specific, so cached)
        const otherFiles = host.getSourceFiles();
        for (const file of otherFiles) {
            //if (!isExternalModule(file)) continue;
            const sym = getSymbolOfDeclaration(file);
            const ref = getAliasForSymbolInContainer(sym, symbol);
            if (!ref) continue;
            results = append(results, sym);
        }
        return links.extendedContainers = results || emptyArray;
    }

    function isSymbolAccessibleWorker(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean, allowModules: boolean): SymbolAccessibilityResult {
        if (symbol && enclosingDeclaration) {
            const result = isAnySymbolAccessible([symbol], enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules);
            if (result) {
                return result;
            }

            // This could be a symbol that is not exported in the external module
            // or it could be a symbol from different external module that is not aliased and hence cannot be named
            // TODO
            // const symbolExternalModule = forEach(symbol.declarations, getExternalModuleContainer);
            // if (symbolExternalModule) {
            //     const enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
            //     if (symbolExternalModule !== enclosingExternalModule) {
            //         // name from different external module that is not visible
            //         return {
            //             accessibility: SymbolAccessibility.CannotBeNamed,
            //             errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
            //             errorModuleName: symbolToString(symbolExternalModule),
            //             errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,
            //         };
            //     }
            // }

            // Just a local name that is not accessible
            return {
                accessibility: SymbolAccessibility.NotAccessible,
                errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
            };
        }

        return { accessibility: SymbolAccessibility.Accessible };
    }

    function isTypeSymbolAccessible(typeSymbol: Symbol, enclosingDeclaration: Node | undefined): boolean {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlags.Type, /*shouldComputeAliasesToMakeVisible*/ false, /*allowModules*/ true);
        return access.accessibility === SymbolAccessibility.Accessible;
    }

    // A reserved member name starts with two underscores, but the third character cannot be an underscore,
    // @, or #. A third underscore indicates an escaped form of an identifier that started
    // with at least two underscores. The @ character indicates that the name is denoted by a well known ES
    // Symbol instance and the # character indicates that the name is a PrivateIdentifier.
    function isReservedMemberName(name: string) {
        return (name as string).charCodeAt(0) === CharacterCodes._ &&
            (name as string).charCodeAt(1) === CharacterCodes._ &&
            (name as string).charCodeAt(2) !== CharacterCodes._ &&
            (name as string).charCodeAt(2) !== CharacterCodes.at &&
            (name as string).charCodeAt(2) !== CharacterCodes.hash;
    }

    function formatUnionTypes(types: readonly Type[]): Type[] {
        const result: Type[] = [];
        let flags = 0 as TypeFlags;
        for (let i = 0; i < types.length; i++) {
            const t = types[i];
            flags |= t.flags;
            if (!(t.flags & TypeFlags.Nullable)) {
                // if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLike)) {
                //     const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType);
                //     if (baseType.flags & TypeFlags.Union) {
                //         const count = (baseType as UnionType).types.length;
                //         if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((baseType as UnionType).types[count - 1])) {
                //             result.push(baseType);
                //             i += count - 1;
                //             continue;
                //         }
                //     }
                // }
                result.push(t);
            }
        }
        //if (flags & TypeFlags.Null) result.push(nullType);
        if (flags & TypeFlags.Undefined) result.push(undefinedType);
        // @ts-ignore
        return result || types;
    }

    function getHomomorphicTypeVariable(type: MappedType) {
        console.debug("TODO - getHomomorphicTypeVariable");
        // const constraintType = getConstraintTypeFromMappedType(type);
        // if (constraintType.flags & TypeFlags.Index) {
        //     const typeVariable = getActualTypeVariable((constraintType as IndexType).type);
        //     if (typeVariable.flags & TypeFlags.TypeParameter) {
        //         return typeVariable as TypeParameter;
        //     }
        // }
        return undefined;
    }

    function getTypeAliasForTypeLiteral(type: Type): Symbol | undefined {
        if (type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && type.symbol.declarations) {
            const node = walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
            // if (isTypeAliasDeclaration(node)) {
            //     return getSymbolOfDeclaration(node);
            // }
        }
        return undefined;
    }
    
    function getOrCreateTypeFromSignature(signature: Signature, outerTypeParameters?: TypeParameter[]): ObjectType {
        // There are two ways to declare a construct signature, one is by declaring a class constructor
        // using the constructor keyword, and the other is declaring a bare construct signature in an
        // object type literal or interface (using the new keyword). Each way of declaring a constructor
        // will result in a different declaration kind.
        if (!signature.isolatedSignatureType) {
            const kind = signature.declaration?.kind;

            // If declaration is undefined, it is likely to be the signature of the default constructor.
            const isConstructor = false;// kind === undefined || kind === SyntaxKind.Constructor || kind === SyntaxKind.ConstructSignature || kind === SyntaxKind.ConstructorType;

            // The type must have a symbol with a `Function` flag and a declaration in order to be correctly flagged as possibly containing
            // type variables by `couldContainTypeVariables`
            const type = createObjectType(ObjectFlags.Anonymous | ObjectFlags.SingleSignatureType, createSymbol(SymbolFlags.Function, InternalSymbolName.Function)) as SingleSignatureType;
            if (signature.declaration && !nodeIsSynthesized(signature.declaration)) { // skip synthetic declarations - keeping those around could be bad, since they lack a parent pointer
                type.symbol.declarations = [signature.declaration];
                type.symbol.valueDeclaration = signature.declaration;
            }
            outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes*/ true);
            type.outerTypeParameters = outerTypeParameters;

            type.members = emptySymbols;
            type.properties = emptyArray;
            type.callSignatures = !isConstructor ? [signature] : emptyArray;
            type.constructSignatures = isConstructor ? [signature] : emptyArray;
            type.indexInfos = emptyArray;
            signature.isolatedSignatureType = type;
        }

        return signature.isolatedSignatureType;
    }
    
    function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember): string;
    function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index: number, restParameterName?: string): string;
    function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index?: number, restParameterName = "arg" as string) {
        if (!d) {
            return `${restParameterName}_${index}` as string;
        }
        Debug.assert(isIdentifier(d.name)); // Parameter declarations could be binding patterns, but we only allow identifier names
        return d.name.text;
    }

    function getExpandedParameters(sig: Signature, skipUnionExpanding?: boolean): readonly (readonly Symbol[])[] {
        if (signatureHasRestParameter(sig)) {
            const restIndex = sig.parameters.length - 1;
            const restName = sig.parameters[restIndex].name;
            const restType = getTypeOfSymbol(sig.parameters[restIndex]);
            if (isTupleType(restType)) {
                return [expandSignatureParametersWithTupleMembers(restType, restIndex, restName)];
            }
            else if (!skipUnionExpanding && restType.flags & TypeFlags.Union && every((restType as UnionType).types, isTupleType)) {
                return map((restType as UnionType).types, t => expandSignatureParametersWithTupleMembers(t as TupleTypeReference, restIndex, restName));
            }
        }
        return [sig.parameters];
        
        function expandSignatureParametersWithTupleMembers(restType: TupleTypeReference, restIndex: number, restName: string) {
            const elementTypes = getTypeArguments(restType);
            const associatedNames = getUniqAssociatedNamesFromTupleType(restType, restName);
            const restParams = map(elementTypes, (t, i) => {
                // Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
                const name = associatedNames && associatedNames[i] ? associatedNames[i] :
                    getParameterNameAtPosition(sig, restIndex + i, restType);
                const flags = restType.target.elementFlags[i];
                const checkFlags = flags & ElementFlags.Variable ? CheckFlags.RestParameter :
                    flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0;
                const symbol = createSymbol(SymbolFlags.FunctionScopedVariable, name, checkFlags);
                symbol.links.type = flags & ElementFlags.Rest ? createArrayType(t) : t;
                return symbol;
            });
            return concatenate(sig.parameters.slice(0, restIndex), restParams);
        }

        function getUniqAssociatedNamesFromTupleType(type: TupleTypeReference, restName: string) {
            const associatedNamesMap = new Map<string, number>();
            return map(type.target.labeledElementDeclarations, (labeledElement, i) => {
                const name = getTupleElementLabel(labeledElement, i, restName);
                const prevCounter = associatedNamesMap.get(name);
                if (prevCounter === undefined) {
                    associatedNamesMap.set(name, 1);
                    return name;
                }
                else {
                    associatedNamesMap.set(name, prevCounter + 1);
                    return `${name}_${prevCounter}` as string;
                }
            });
        }
    }

    function getReferencedValueSymbol(reference: Identifier, startInDeclarationContainer?: boolean): Symbol | undefined {
        const resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
        if (resolvedSymbol) {
            return resolvedSymbol;
        }

        let location: Node = reference;
        if (startInDeclarationContainer) {
            // When resolving the name of a declaration as a value, we need to start resolution
            // at a point outside of the declaration.
            const parent = reference.parent;
            if (isDeclaration(parent) && reference === parent.name) {
                location = getDeclarationContainer(parent);
            }
        }

        return resolveName(location, reference.text, SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
    }


    // When resolved as an expression identifier, if the given node references an exported entity, return the declaration
    // node of the exported entity's container. Otherwise, return undefined.
    function getReferencedExportContainer(nodeIn: Identifier, prefixLocals?: boolean): SourceFile | /*ModuleDeclaration |*/ undefined {
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (node) {
            // When resolving the export container for the name of a module or enum
            // declaration, we need to start resolution at the declaration's container.
            // Otherwise, we could incorrectly resolve the export container as the
            // declaration if it contains an exported member with the same name.
            let symbol = getReferencedValueSymbol(node, false);///*startInDeclarationContainer*/ isNameOfModuleOrEnumDeclaration(node));
            if (symbol) {
                if (symbol.flags & SymbolFlags.ExportValue) {
                    // If we reference an exported entity within the same module declaration, then whether
                    // we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
                    // kinds that we do NOT prefix.
                    const exportSymbol = getMergedSymbol(symbol.exportSymbol!);
                    if (!prefixLocals && exportSymbol.flags & SymbolFlags.ExportHasLocal && !(exportSymbol.flags & SymbolFlags.Variable)) {
                        return undefined;
                    }
                    symbol = exportSymbol;
                }
                const parentSymbol = getParentOfSymbol(symbol);
                if (parentSymbol) {
                    if (parentSymbol.flags & SymbolFlags.ValueModule && parentSymbol.valueDeclaration?.kind === SyntaxKind.SourceFile) {
                        const symbolFile = parentSymbol.valueDeclaration as SourceFile;
                        const referenceFile = getSourceFileOfNode(node);
                        // If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
                        const symbolIsUmdExport = symbolFile !== referenceFile;
                        return symbolIsUmdExport ? undefined : symbolFile;
                    }
                    Debug.fail("not implemented");
                    //return findAncestor(node.parent, (n): n is ModuleDeclaration | EnumDeclaration => isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) === parentSymbol);
                }
            }
        }
    }

    function hasGlobalName(name: string): boolean {
        return globals.has((name));
    }

    function createResolver(): EmitResolver {
        return {
            getReferencedExportContainer,
            // getReferencedImportDeclaration,
            // getReferencedDeclarationWithCollidingName,
            // isDeclarationWithCollidingName,
            // isValueAliasDeclaration: nodeIn => {
            //     const node = getParseTreeNode(nodeIn);
            //     // Synthesized nodes are always treated like values.
            //     return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true;
            // },
            hasGlobalName,
            // isReferencedAliasDeclaration: (nodeIn, checkChildren?) => {
            //     const node = getParseTreeNode(nodeIn);
            //     // Synthesized nodes are always treated as referenced.
            //     return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true;
            // },
            // hasNodeCheckFlag: (nodeIn, flag) => {
            //     const node = getParseTreeNode(nodeIn);
            //     if (!node) return false;
            //     return hasNodeCheckFlag(node, flag);
            // },
            // isTopLevelValueImportEqualsWithEntityName,
            // isDeclarationVisible,
            // isImplementationOfOverload,
            // requiresAddingImplicitUndefined,
            // isExpandoFunctionDeclaration,
            // getPropertiesOfContainerFunction,
            // createTypeOfDeclaration,
            // createReturnTypeOfSignatureDeclaration,
            // createTypeOfExpression,
            // createLiteralConstValue,
            // isSymbolAccessible,
            // isEntityNameVisible,
            // getConstantValue: nodeIn => {
            //     const node = getParseTreeNode(nodeIn, canHaveConstantValue);
            //     return node ? getConstantValue(node) : undefined;
            // },
            // getEnumMemberValue: nodeIn => {
            //     const node = getParseTreeNode(nodeIn, isEnumMember);
            //     return node ? getEnumMemberValue(node) : undefined;
            // },
            // collectLinkedAliases,
            // markLinkedReferences: nodeIn => {
            //     const node = getParseTreeNode(nodeIn);
            //     return node && markLinkedReferences(node, ReferenceHint.Unspecified);
            // },
            // getReferencedValueDeclaration,
            // getReferencedValueDeclarations,
            // getTypeReferenceSerializationKind,
            // isOptionalParameter,
            // isArgumentsLocalBinding,
            // getExternalModuleFileFromDeclaration: nodeIn => {
            //     const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);
            //     return node && getExternalModuleFileFromDeclaration(node);
            // },
            // isLiteralConstDeclaration,
            // isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {
            //     const node = getParseTreeNode(nodeIn, isDeclaration);
            //     const symbol = node && getSymbolOfDeclaration(node);
            //     return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);
            // },
            // getJsxFactoryEntity,
            // getJsxFragmentFactoryEntity,
            // isBindingCapturedByNode: (node, decl) => {
            //     const parseNode = getParseTreeNode(node);
            //     const parseDecl = getParseTreeNode(decl);
            //     return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);
            // },
            // getDeclarationStatementsForSourceFile: (node, flags, tracker) => {
            //     const n = getParseTreeNode(node) as SourceFile;
            //     Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile");
            //     const sym = getSymbolOfDeclaration(node);
            //     if (!sym) {
            //         return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, tracker);
            //     }
            //     resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup
            //     return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, tracker);
            // },
            // isImportRequiredByAugmentation,
            // isDefinitelyReferenceToGlobalSymbolObject,
        };

        // function isImportRequiredByAugmentation(node: ImportDeclaration) {
        //     const file = getSourceFileOfNode(node);
        //     if (!file.symbol) return false;
        //     const importTarget = getExternalModuleFileFromDeclaration(node);
        //     if (!importTarget) return false;
        //     if (importTarget === file) return false;
        //     const exports = getExportsOfModule(file.symbol);
        //     for (const s of arrayFrom(exports.values())) {
        //         if (s.mergeId) {
        //             const merged = getMergedSymbol(s);
        //             if (merged.declarations) {
        //                 for (const d of merged.declarations) {
        //                     const declFile = getSourceFileOfNode(d);
        //                     if (declFile === importTarget) {
        //                         return true;
        //                     }
        //                 }
        //             }
        //         }
        //     }
        //     return false;
        // }
    }

    /**
     * Same as getTypeFromTypeNode, but for use in createNodeBuilder
     * Inside createNodeBuilder we shadow getTypeFromTypeNode to make sure anyone using this function will call the local version that does type mapping if appropriate
     * This function is used to still be able to call the original getTypeFromTypeNode from the local scope version of getTypeFromTypeNode
     */
    function getTypeFromTypeNodeWithoutContext(node: TypeNode) {
        return getTypeFromTypeNode(node);
    }

    /**
     * Gets the default type for a type parameter.
     *
     * If the type parameter is the result of an instantiation, this gets the instantiated
     * default type of its target. If the type parameter has no default type or the default is
     * circular, `undefined` is returned.
     */
    function getDefaultFromTypeParameter(typeParameter: TypeParameter): Type | undefined {
        const defaultType = getResolvedTypeParameterDefault(typeParameter);
        return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
    }

    function getResolvedTypeParameterDefault(typeParameter: TypeParameter): Type | undefined {
        if (!typeParameter.default) {
            if (typeParameter.target) {
                const targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
            }
            else {
                // To block recursion, set the initial value to the resolvingDefaultType.
                typeParameter.default = resolvingDefaultType;
                const defaultDeclaration = typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default);
                const defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                if (typeParameter.default === resolvingDefaultType) {
                    // If we have not been called recursively, set the correct default type.
                    typeParameter.default = defaultType;
                }
            }
        }
        else if (typeParameter.default === resolvingDefaultType) {
            // If we are called recursively for this type parameter, mark the default as circular.
            typeParameter.default = circularConstraintType;
        }
        return typeParameter.default;
    }

    function getNonlocalEffectiveTypeAnnotationNode(node: Node) {
        const direct = getEffectiveTypeAnnotationNode(node);
        if (direct) {
            return direct;
        }        
        return undefined;
    }

    function declaredParameterTypeContainsUndefined(parameter: ParameterDeclaration | JSDocParameterTag) {
        const typeNode = getNonlocalEffectiveTypeAnnotationNode(parameter);
        if (!typeNode) return false;
        const type = getTypeFromTypeNode(typeNode);
        return containsUndefinedType(type);
    }

    function getMeaningOfEntityNameReference(entityName: EntityNameOrEntityNameExpression): SymbolFlags {
        // get symbol of the first identifier of the entityName
        let meaning: SymbolFlags;
        if (
            // entityName.parent.kind === SyntaxKind.TypeQuery ||
            entityName.parent.kind === SyntaxKind.ExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) ||
            entityName.parent.kind === SyntaxKind.ComputedPropertyName ||
            entityName.parent.kind === SyntaxKind.TypePredicate && (entityName.parent as TypePredicateNode).parameterName === entityName
        ) {
            // Typeof value
            meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
        }
        else if (
            entityName.kind === SyntaxKind.QualifiedName || entityName.kind === SyntaxKind.PropertyAccessExpression ||
            // entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration ||
            (entityName.parent.kind === SyntaxKind.QualifiedName && (entityName.parent as QualifiedName).left === entityName) ||
            (entityName.parent.kind === SyntaxKind.PropertyAccessExpression && (entityName.parent as PropertyAccessExpression).expression === entityName) ||
            (entityName.parent.kind === SyntaxKind.ElementAccessExpression && (entityName.parent as ElementAccessExpression).expression === entityName)
        ) {
            // Left identifier from type reference or TypeAlias
            // Entity name of the import declaration
            meaning = SymbolFlags.Namespace;
        }
        else {
            // Type Reference or TypeAlias entity = Identifier
            meaning = SymbolFlags.Type;
        }
        return meaning;
    }

    function isExpandoFunctionDeclaration(node: Declaration): boolean { return false; }    

    function isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node, shouldComputeAliasToMakeVisible = true): SymbolVisibilityResult {
        const meaning = getMeaningOfEntityNameReference(entityName);
        const firstIdentifier = getFirstIdentifier(entityName);
        const symbol = resolveName(enclosingDeclaration, firstIdentifier.text, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
        if (symbol && symbol.flags & SymbolFlags.TypeParameter && meaning & SymbolFlags.Type) {
            return { accessibility: SymbolAccessibility.Accessible };
        }
        // if (!symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false)), firstIdentifier, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility === SymbolAccessibility.Accessible) {
        //     return { accessibility: SymbolAccessibility.Accessible };
        // }

        if (!symbol) {
            return {
                accessibility: SymbolAccessibility.NotResolved,
                errorSymbolName: getTextOfNode(firstIdentifier),
                errorNode: firstIdentifier,
            };
        }
        // Verify if the symbol is accessible
        return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || {
            accessibility: SymbolAccessibility.NotAccessible,
            errorSymbolName: getTextOfNode(firstIdentifier),
            errorNode: firstIdentifier,
        };
    }

    function isDefinitelyReferenceToGlobalSymbolObject(node: Node): boolean {
        if (!isPropertyAccessExpression(node)) return false;
        if (!isIdentifier(node.name)) return false;
        if (!isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression)) return false;
        if (isIdentifier(node.expression)) {
            // Exactly `Symbol.something` and `Symbol` either does not resolve or definitely resolves to the global Symbol
            return idText(node.expression) === "Symbol" && getResolvedSymbol(node.expression) === (getGlobalSymbol("Symbol" as string, SymbolFlags.Value | SymbolFlags.ExportValue, /*diagnostic*/ undefined) || unknownSymbol);
        }
        if (!isIdentifier(node.expression.expression)) return false;
        // Exactly `globalThis.Symbol.something` and `globalThis` resolves to the global `globalThis`
        return isIdentifier(node.expression.name) && idText(node.expression.name) === "Symbol" && idText(node.expression.expression) === "globalThis" && getResolvedSymbol(node.expression.expression) === globalThisSymbol;
    }

    function requiresAddingImplicitUndefined(parameter: ParameterDeclaration | JSDocParameterTag) {
        return (isRequiredInitializedParameter(parameter) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter);
    }

    function isOptionalParameter(node: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag) {        
        if (!isParameter(node)) {
            return false;
        }
        if (node.initializer) {
            const signature = getSignatureFromDeclaration(node.parent);
            const parameterIndex = node.parent.parameters.indexOf(node);
            Debug.assert(parameterIndex >= 0);
            // Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
            // in grammar checks and checking for `void` too early results in parameter types widening too early
            // and causes some noImplicitAny errors to be lost.
            return parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlags.StrongArityForUntypedJS | MinArgumentCountFlags.VoidIsNonOptional);
        }
        const iife = getImmediatelyInvokedFunctionExpression(node.parent);
        if (iife) {
            return !node.type &&
                !node.dotDotDotToken &&
                node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length;
        }

        return false;
    }


    function isRequiredInitializedParameter(parameter: ParameterDeclaration | JSDocParameterTag): boolean {
        return !!strictNullChecks &&
            !isOptionalParameter(parameter) &&
            !isJSDocParameterTag(parameter) &&
            !!parameter.initializer &&
            !hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier);
    }

    function isOptionalUninitializedParameterProperty(parameter: ParameterDeclaration | JSDocParameterTag) {
        return strictNullChecks &&
            isOptionalParameter(parameter) &&
            (isJSDocParameterTag(parameter) || !parameter.initializer) &&
            hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier);
    }

    type DeclarationWithPotentialInnerNodeReuse =
        | SignatureDeclaration
        | JSDocSignature
        | VariableLikeDeclaration
        | PropertyAccessExpression
        ;

    function isDeclarationWithPossibleInnerTypeNodeReuse(declaration: Declaration): declaration is DeclarationWithPotentialInnerNodeReuse {
        return isFunctionLike(declaration) || isVariableLike(declaration);
    }

    function getPossibleTypeNodeReuseExpression(declaration: DeclarationWithPotentialInnerNodeReuse) {
        return isFunctionLike(declaration) 
            ? getSingleReturnExpression(declaration)
            : !!(declaration as HasInitializer).initializer
            ? (declaration as HasInitializer & typeof declaration).initializer
            : undefined;
    }

    function getSingleReturnExpression(declaration: SignatureDeclaration | undefined): Expression | undefined {
        let candidateExpr: Expression | undefined;
        if (declaration && !nodeIsMissing((declaration as FunctionLikeDeclaration).body)) {
            if (getFunctionFlags(declaration) & FunctionFlags.AsyncGenerator) return undefined;
            const body = (declaration as FunctionLikeDeclaration).body;
            if (body && isBlock(body)) {
                forEachReturnStatement(body, s => {
                    if (!candidateExpr) {
                        candidateExpr = s.expression;
                    }
                    else {
                        candidateExpr = undefined;
                        return true;
                    }
                });
            }
            else {
                candidateExpr = body as Expression;
            }
        }
        return candidateExpr;
    }

    function containsNonMissingUndefinedType(type: Type) {
        const candidate = type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type;
        return !!(candidate.flags & TypeFlags.Undefined) && candidate !== missingType;
    }
    
    function getNonlocalEffectiveReturnTypeAnnotationNode(node: SignatureDeclaration | JSDocSignature) {
        const direct = getEffectiveReturnTypeNode(node);
        if (direct) {
            return direct;
        }        
        return undefined;
    }

    function getInferTypeParameters(node: ConditionalTypeNode): TypeParameter[] | undefined {
        let result: TypeParameter[] | undefined;
        if (node.locals) {
            node.locals.forEach(symbol => {
                if (symbol.flags & SymbolFlags.TypeParameter) {
                    result = append(result, getDeclaredTypeOfSymbol(symbol));
                }
            });
        }
        return result;
    }

    /**
     * Check if the given symbol in given enclosing declaration is accessible and mark all associated alias to be visible if requested
     *
     * @param symbol a Symbol to check if accessible
     * @param enclosingDeclaration a Node containing reference to the symbol
     * @param meaning a SymbolFlags to check if such meaning of the symbol is accessible
     * @param shouldComputeAliasToMakeVisible a boolean value to indicate whether to return aliases to be mark visible in case the symbol is accessible
     */
    function isSymbolAccessible(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean): SymbolAccessibilityResult {
        return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, /*allowModules*/ true);
    }

    function createNodeBuilder() {
        return {            
            symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToExpression(symbol, context, meaning)),
            symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToName(symbol, context, meaning, /*expectsIdentifier*/ false)),            
            symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToNode(symbol, context, meaning)),
            typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => typeToTypeNodeHelper(type, context)),            
            symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)),
            signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)),
            symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToParameterDeclaration(symbol, context)),
            typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, tracker, context => typeParameterToDeclaration(parameter, context)),
        };

        function typeToTypeNodeHelper(type: Type, context: NodeBuilderContext): TypeNode {
            const savedFlags = context.flags;
            const typeNode = typeToTypeNodeWorker(type, context);
            context.flags = savedFlags;
            return typeNode;
        }

        function symbolToEntityNameNode(symbol: Symbol): EntityName {
            const identifier = factory.createIdentifier((symbol.name));
            return symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier;
        }

        /**
         * Unlike the utilities `setTextRange`, this checks if the `location` we're trying to set on `range` is within the
         * same file as the active context. If not, the range is not applied. This prevents us from copying ranges across files,
         * which will confuse the node printer (as it assumes all node ranges are within the current file).
         * Additionally, if `range` _isn't synthetic_, or isn't in the current file, it will _copy_ it to _remove_ its' position
         * information.
         *
         * It also calls `setOriginalNode` to setup a `.original` pointer, since you basically *always* want these in the node builder.
         */
        function setTextRange<T extends Node>(context: NodeBuilderContext, range: T, location: Node | undefined): T {
            if (!nodeIsSynthesized(range) || !(range.flags & NodeFlags.Synthesized) || !context.enclosingFile || context.enclosingFile !== getSourceFileOfNode(getOriginalNode(range))) {
                range = factory.cloneNode(range); // if `range` is synthesized or originates in another file, copy it so it definitely has synthetic positions
            }
            if (range === location) return range;
            if (!location) {
                return range;
            }
            if (!context.enclosingFile || context.enclosingFile !== getSourceFileOfNode(getOriginalNode(location))) {
                return setOriginalNode(range, location); // if `location` is from another file, only set/update original pointer, and not positions, since copying text across files isn't supported by the emitter
            }
            return setTextRangeWorker(setOriginalNode(range, location), location);
        }

        function mapToTypeNodes(types: readonly Type[] | undefined, context: NodeBuilderContext, isBareList?: boolean): TypeNode[] | undefined {
            if (some(types)) {
                if (checkTruncationLength(context)) {
                    if (!isBareList) {
                        return [factory.createTypeReferenceNode("...", /*typeArguments*/ undefined)];
                    }
                    else if (types.length > 2) {
                        return [
                            typeToTypeNodeHelper(types[0], context),
                            factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, /*typeArguments*/ undefined),
                            typeToTypeNodeHelper(types[types.length - 1], context),
                        ];
                    }
                }
                const mayHaveNameCollisions = !(context.flags & NodeBuilderFlags.UseFullyQualifiedType);
                /** Map from type reference identifier text to [type, index in `result` where the type node is] */
                const seenNames = mayHaveNameCollisions ? createMultiMap<string, [Type, number]>() : undefined;
                const result: TypeNode[] = [];
                let i = 0;
                for (const type of types) {
                    i++;
                    if (checkTruncationLength(context) && (i + 2 < types.length - 1)) {
                        result.push(factory.createTypeReferenceNode(`... ${types.length - i} more ...`, /*typeArguments*/ undefined));
                        const typeNode = typeToTypeNodeHelper(types[types.length - 1], context);
                        if (typeNode) {
                            result.push(typeNode);
                        }
                        break;
                    }
                    context.approximateLength += 2; // Account for whitespace + separator
                    const typeNode = typeToTypeNodeHelper(type, context);
                    if (typeNode) {
                        result.push(typeNode);
                        if (seenNames && isIdentifierTypeReference(typeNode)) {
                            seenNames.add(typeNode.typeName.text, [type, result.length - 1]);
                        }
                    }
                }

                if (seenNames) {
                    // To avoid printing types like `[Foo, Foo]` or `Bar & Bar` where
                    // occurrences of the same name actually come from different
                    // namespaces, go through the single-identifier type reference nodes
                    // we just generated, and see if any names were generated more than
                    // once while referring to different types. If so, regenerate the
                    // type node for each entry by that name with the
                    // `UseFullyQualifiedType` flag enabled.
                    const saveContextFlags = context.flags;
                    context.flags |= NodeBuilderFlags.UseFullyQualifiedType;
                    seenNames.forEach(types => {
                        if (!arrayIsHomogeneous(types, ([a], [b]) => typesAreSameReference(a, b))) {
                            for (const [type, resultIndex] of types) {
                                result[resultIndex] = typeToTypeNodeHelper(type, context);
                            }
                        }
                    });
                    context.flags = saveContextFlags;
                }

                return result;
            }
        }

        function checkTruncationLength(context: NodeBuilderContext): boolean {
            if (context.truncating) return context.truncating;
            return context.truncating = context.approximateLength > ((context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength);
        }
        
        function typesAreSameReference(a: Type, b: Type): boolean {
            return a === b
                || !!a.symbol && a.symbol === b.symbol
                || !!a.aliasSymbol && a.aliasSymbol === b.aliasSymbol;
        }

        function lookupTypeParameterNodes(chain: Symbol[], index: number, context: NodeBuilderContext) {
            Debug.assert(chain && 0 <= index && index < chain.length);
            const symbol = chain[index];
            const symbolId = getSymbolId(symbol);
            if (context.typeParameterSymbolList?.has(symbolId)) {
                return undefined;
            }
            if (context.mustCreateTypeParameterSymbolList) {
                context.mustCreateTypeParameterSymbolList = false;
                context.typeParameterSymbolList = new Set(context.typeParameterSymbolList);
            }
            context.typeParameterSymbolList!.add(symbolId);
            let typeParameterNodes: readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined;
            if (context.flags & NodeBuilderFlags.WriteTypeParametersInQualifiedName && index < (chain.length - 1)) {
                const parentSymbol = symbol;
                const nextSymbol = chain[index + 1];
                if (getCheckFlags(nextSymbol) & CheckFlags.Instantiated) {
                    const params = getTypeParametersOfClassOrInterface(
                        parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol,
                    );
                    // NOTE: cast to TransientSymbol should be safe because only TransientSymbol can have CheckFlags.Instantiated
                    typeParameterNodes = mapToTypeNodes(map(params, t => getMappedType(t, (nextSymbol as TransientSymbol).links.mapper!)), context);
                }
                else {
                    typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context);
                }
            }
            return typeParameterNodes;
        }

        function typeParametersToTypeParameterDeclarations(symbol: Symbol, context: NodeBuilderContext) {
            return undefined;
            // let typeParameterNodes: NodeArray<TypeParameterDeclaration> | undefined;
            // const targetSymbol = getTargetSymbol(symbol);
            // if (targetSymbol.flags & (SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeAlias)) {
            //     typeParameterNodes = factory.createNodeArray(map(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), tp => typeParameterToDeclaration(tp, context)));
            // }
            // return typeParameterNodes;
        }        
        
        function symbolToTypeNode(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, overrideTypeArguments?: readonly TypeNode[]): TypeNode {
            const chain = lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope)); // If we're using aliases outside the current scope, dont bother with the module

            const isTypeOf = meaning === SymbolFlags.Value;
            // if (some(chain[0].declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
            //     // module is root, must use `ImportTypeNode`
            //     const nonRootParts = chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined;
            //     const typeParameterNodes = overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context);
            //     const contextFile = getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration));
            //     const targetFile = getSourceFileOfModule(chain[0]);
            //     let specifier: string | undefined;
            //     let attributes: ImportAttributes | undefined;
            //     if (getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node16 || getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeNext) {
            //         // An `import` type directed at an esm format file is only going to resolve in esm mode - set the esm mode assertion
            //         if (targetFile?.impliedNodeFormat === ModuleKind.ESNext && targetFile.impliedNodeFormat !== contextFile?.impliedNodeFormat) {
            //             specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKind.ESNext);
            //             attributes = factory.createImportAttributes(
            //                 factory.createNodeArray([
            //                     factory.createImportAttribute(
            //                         factory.createStringLiteral("resolution-mode"),
            //                         factory.createStringLiteral("import"),
            //                     ),
            //                 ]),
            //             );
            //         }
            //     }
            //     if (!specifier) {
            //         specifier = getSpecifierForModuleSymbol(chain[0], context);
            //     }
            //     if (!(context.flags & NodeBuilderFlags.AllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Classic && specifier.includes("/node_modules/")) {
            //         const oldSpecifier = specifier;
            //         if (getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node16 || getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeNext) {
            //             // We might be able to write a portable import type using a mode override; try specifier generation again, but with a different mode set
            //             const swappedMode = contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext;
            //             specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode);

            //             if (specifier.includes("/node_modules/")) {
            //                 // Still unreachable :(
            //                 specifier = oldSpecifier;
            //             }
            //             else {
            //                 attributes = factory.createImportAttributes(
            //                     factory.createNodeArray([
            //                         factory.createImportAttribute(
            //                             factory.createStringLiteral("resolution-mode"),
            //                             factory.createStringLiteral(swappedMode === ModuleKind.ESNext ? "import" : "require"),
            //                         ),
            //                     ]),
            //                 );
            //             }
            //         }

            //         if (!attributes) {
            //             // If ultimately we can only name the symbol with a reference that dives into a `node_modules` folder, we should error
            //             // since declaration files with these kinds of references are liable to fail when published :(
            //             context.encounteredError = true;
            //             if (context.tracker.reportLikelyUnsafeImportRequiredError) {
            //                 context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier);
            //             }
            //         }
            //     }
            //     const lit = factory.createLiteralTypeNode(factory.createStringLiteral(specifier));
            //     context.approximateLength += specifier.length + 10; // specifier + import("")
            //     if (!nonRootParts || isEntityName(nonRootParts)) {
            //         if (nonRootParts) {
            //             const lastId = isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right;
            //             setIdentifierTypeArguments(lastId, /*typeArguments*/ undefined);
            //         }
            //         return factory.createImportTypeNode(lit, attributes, nonRootParts as EntityName, typeParameterNodes as readonly TypeNode[], isTypeOf);
            //     }
            //     else {
            //         const splitNode = getTopmostIndexedAccessType(nonRootParts);
            //         const qualifier = (splitNode.objectType as TypeReferenceNode).typeName;
            //         return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes as readonly TypeNode[], isTypeOf), splitNode.indexType);
            //     }
            // }

            const entityName = createAccessFromSymbolChain(chain, chain.length - 1, 0);
            if (isIndexedAccessTypeNode(entityName)) {
                return entityName; // Indexed accesses can never be `typeof`
            }
            // if (isTypeOf) {
            //     return factory.createTypeQueryNode(entityName);
            // }
            // else {
                const lastId = isIdentifier(entityName) ? entityName : entityName.right;
                const lastTypeArgs = getIdentifierTypeArguments(lastId);
                setIdentifierTypeArguments(lastId, /*typeArguments*/ undefined);
                return factory.createTypeReferenceNode(entityName, lastTypeArgs as NodeArray<TypeNode>);
            // }

            function createAccessFromSymbolChain(chain: Symbol[], index: number, stopper: number): EntityName | IndexedAccessTypeNode {
                const typeParameterNodes = index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context);
                const symbol = chain[index];
                const parent = chain[index - 1];

                let symbolName: string | undefined;
                if (index === 0) {
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                    symbolName = getNameOfSymbolAsWritten(symbol, context);
                    context.approximateLength += (symbolName ? symbolName.length : 0) + 1;
                    context.flags ^= NodeBuilderFlags.InInitialEntityName;
                }
                else {
                    if (parent && getExportsOfSymbol(parent)) {
                        const exports = getExportsOfSymbol(parent);
                        forEachEntry(exports, (ex, name) => {
                            if (getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name !== InternalSymbolName.ExportEquals) {
                                symbolName = (name);
                                return true;
                            }
                        });
                    }
                }

                if (symbolName === undefined) {
                    const name = firstDefined(symbol.declarations, getNameOfDeclaration);
                    if (name && isComputedPropertyName(name) && isEntityName(name.expression)) {
                        const LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                        if (isEntityName(LHS)) {
                            Debug.fail("implement me");
                            //return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression));
                        }
                        return LHS;
                    }
                    symbolName = getNameOfSymbolAsWritten(symbol, context);
                }
                context.approximateLength += symbolName.length + 1;

                if (
                    !(context.flags & NodeBuilderFlags.ForbidIndexedAccessSymbolReferences) && parent &&
                    getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.name) &&
                    getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.name)!, symbol)
                ) {
                    // Should use an indexed access
                    const LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                    if (isIndexedAccessTypeNode(LHS)) {
                        Debug.fail("implement me");
                        // return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)));
                    }
                    else {
                        Debug.fail("implement me");
                        // return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes as readonly TypeNode[]), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)));
                    }
                }

                const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                identifier.symbol = symbol;

                if (index > stopper) {
                    const LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                    if (!isEntityName(LHS)) {
                        return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable");
                    }
                    return factory.createQualifiedName(LHS, identifier);
                }
                return identifier;
            }
        }

        function typeParameterToDeclaration(type: TypeParameter, context: NodeBuilderContext, constraint = getConstraintOfTypeParameter(type)): TypeParameterDeclaration {
            const constraintNode = constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type), context);
            return typeParameterToDeclarationWithConstraint(type, context, constraintNode);
        }

        function typeParameterToDeclarationWithConstraint(type: TypeParameter, context: NodeBuilderContext, constraintNode: TypeNode | undefined): TypeParameterDeclaration {
            const savedContextFlags = context.flags;
            context.flags &= ~NodeBuilderFlags.WriteTypeParametersInQualifiedName; // Avoids potential infinite loop when building for a claimspace with a generic
            const modifiers = factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type));
            const name = typeParameterToName(type, context);
            const defaultParameter = getDefaultFromTypeParameter(type);
            const defaultParameterNode = defaultParameter && typeToTypeNodeHelper(defaultParameter, context);
            context.flags = savedContextFlags;
            return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode);
        }

        function getTypeParameterModifiers(tp: TypeParameter): ModifierFlags {            
            return ModifierFlags.None;//return reduceLeft(tp.symbol?.declarations, (modifiers, d) => modifiers | getEffectiveModifierFlags(d), ModifierFlags.None) & (ModifierFlags.In | ModifierFlags.Out | ModifierFlags.Const);
        }
        
        function getConstraintDeclaration(type: TypeParameter): TypeNode | undefined {
            return mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0];
        }

        function typeToTypeNodeHelperWithPossibleReusableTypeNode(type: Type, typeNode: TypeNode | undefined, context: NodeBuilderContext) {
            return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type) || typeToTypeNodeHelper(type, context);
        }

        function typeNodeIsEquivalentToType(annotatedDeclaration: Node | undefined, type: Type, typeFromTypeNode: Type) {
            if (typeFromTypeNode === type) {
                return true;
            }
            // if (annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken) {
            //     return getTypeWithFacts(type, TypeFacts.NEUndefined) === typeFromTypeNode;
            // }
            return false;
        }

        function existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing: TypeNode, type: Type) {
            // In JS, you can say something like `Foo` and get a `Foo<any>` implicitly - we don't want to preserve that original `Foo` in these cases, though.
            if (!(getObjectFlags(type) & ObjectFlags.Reference)) return true;
            if (!isTypeReferenceNode(existing)) return true;
            // `type` is a reference type, and `existing` is a type reference node, but we still need to make sure they refer to the _same_ target type
            // before we go comparing their type argument counts.
            void getTypeFromTypeReference(existing); // call to ensure symbol is resolved
            const symbol = getNodeLinks(existing).resolvedSymbol;
            const existingTarget = symbol && getDeclaredTypeOfSymbol(symbol);
            if (!existingTarget || existingTarget !== (type as TypeReference).target) return true;
            return length(existing.typeArguments) >= getMinTypeArgumentCount((type as TypeReference).target.typeParameters);
        }
        
        function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: false): Type;
        function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes: true): Type | undefined;
        function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: boolean): Type | undefined {
            const type = getTypeFromTypeNodeWithoutContext(node);
            if (!context.mapper) return type;

            const mappedType = instantiateType(type, context.mapper);
            return noMappedTypes && mappedType !== type ? undefined : mappedType;
        }
        
        function getEffectiveParameterDeclaration(parameterSymbol: Symbol): ParameterDeclaration | JSDocParameterTag | undefined {
            const parameterDeclaration: ParameterDeclaration | JSDocParameterTag | undefined = getDeclarationOfKind<ParameterDeclaration>(parameterSymbol, SyntaxKind.Parameter);
            if (parameterDeclaration) {
                return parameterDeclaration;
            }
            if (!isTransientSymbol(parameterSymbol)) {
                return getDeclarationOfKind<JSDocParameterTag>(parameterSymbol, SyntaxKind.JSDocParameterTag);
            }
        }

        function tryReuseExistingNonParameterTypeNode(
            context: NodeBuilderContext,
            existing: TypeNode,
            type: Type,
            host = context.enclosingDeclaration,
            annotationType = getTypeFromTypeNode(context, existing, /*noMappedTypes*/ true),
        ) {            
            if (annotationType && typeNodeIsEquivalentToType(host, type, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type)) {
                const result = tryReuseExistingTypeNodeHelper(context, existing);
                if (result) {
                    return result;
                }
            }
            return undefined;
        }

        function isNewScopeNode(node: Node): node is IntroducesNewScopeNode {
            return isFunctionLike(node)
                || isJSDocSignature(node);
                // || isMappedTypeNode(node);
        }

        function serializeExistingTypeNode(context: NodeBuilderContext, typeNode: TypeNode) {
            const type = getTypeFromTypeNode(context, typeNode);
            return typeToTypeNodeHelper(type, context);
        }
        
        function getParametersInScope(node: IntroducesNewScopeNode | ConditionalTypeNode) {
            return isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).parameters : undefined;
        }
        
        function getTypeParametersInScope(node: IntroducesNewScopeNode | ConditionalTypeNode) {
            return isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).typeParameters :
                isConditionalTypeNode(node) ? getInferTypeParameters(node) :
                [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))];
        }
        
        function canReuseTypeNode(context: NodeBuilderContext, existing: TypeNode) {
            // if (isInJSFile(existing)) {
            //     if (isLiteralImportTypeNode(existing)) {
            //         // Ensure resolvedSymbol is present
            //         void getTypeFromImportTypeNode(existing);
            //         const nodeSymbol = getNodeLinks(existing).resolvedSymbol;
            //         return (
            //             !nodeSymbol ||
            //             !(
            //                 // The import type resolved using jsdoc fallback logic
            //                 (!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||
            //                 // The import type had type arguments autofilled by js fallback logic
            //                 !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))
            //             )
            //         );
            //     }
            // }
            if (isThisTypeNode(existing)) {
                if (context.mapper === undefined) return true;
                const type = getTypeFromTypeNode(context, existing, /*noMappedTypes*/ true);
                return !!type;
            }
            if (isTypeReferenceNode(existing)) {
                // if (isConstTypeReference(existing)) return false;
                const type = getTypeFromTypeReference(existing);
                const symbol = getNodeLinks(existing).resolvedSymbol;
                if (!symbol) return false;
                if (symbol.flags & SymbolFlags.TypeParameter) {
                    const type = getDeclaredTypeOfSymbol(symbol);
                    if (context.mapper && getMappedType(type, context.mapper) !== type) {
                        return false;
                    }
                }
                if (isInJSDoc(existing)) {
                    return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type)
                        && !getIntendedTypeFromJSDocTypeReference(existing) // We should probably allow the reuse of JSDoc reference types such as String Number etc
                        && (symbol.flags & SymbolFlags.Type); // JSDoc type annotations can reference values (meaning typeof value) as well as types. We only reuse type nodes
                }
            }
            // if (
            //     isTypeOperatorNode(existing) &&
            //     existing.operator === SyntaxKind.UniqueKeyword &&
            //     existing.type.kind === SyntaxKind.SymbolKeyword
            // ) {
            //     const effectiveEnclosingContext = context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration);
            //     return !!findAncestor(existing, n => n === effectiveEnclosingContext);
            // }
            return true;
        }

        function trackExistingEntityName<T extends EntityNameOrEntityNameExpression>(node: T, context: NodeBuilderContext) {
            let introducesError = false;
            const leftmost = getFirstIdentifier(node);
            // if (isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right)))) {
            //     introducesError = true;
            //     return { introducesError, node };
            // }
            const meaning = getMeaningOfEntityNameReference(node);
            let sym: Symbol | undefined;
            if (isThisIdentifier(leftmost)) {
                // `this` isn't a bindable identifier - skip resolution, find a relevant `this` symbol directly and avoid exhaustive scope traversal
                sym = getSymbolOfDeclaration(getThisContainer(leftmost, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false));
                if (isSymbolAccessible(sym, leftmost, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible) {
                    introducesError = true;
                    context.tracker.reportInaccessibleThisError();
                }
                return { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T };
            }
            sym = resolveEntityName(leftmost, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true);
            if (
                context.enclosingDeclaration &&
                !(sym && sym.flags & SymbolFlags.TypeParameter)
            ) {
                sym = getExportSymbolOfValueSymbolIfExported(sym);
                // Some declarations may be transplanted to a new location.
                // When this happens we need to make sure that the name has the same meaning at both locations
                // We also check for the unknownSymbol because when we create a fake scope some parameters may actually not be usable
                // either because they are the expanded rest parameter,
                // or because they are the newly added parameters from the tuple, which might have different meanings in the original context
                const symAtLocation = resolveEntityName(leftmost, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, context.enclosingDeclaration);
                if (
                    // Check for unusable parameters symbols
                    symAtLocation === unknownSymbol ||
                    // If the symbol is not found, but was not found in the original scope either we probably have an error, don't reuse the node
                    (symAtLocation === undefined && sym !== undefined) ||
                    // If the symbol is found both in declaration scope and in current scope then it shoudl point to the same reference
                    (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym))
                ) {
                    // In isolated declaration we will not do rest parameter expansion so there is no need to report on these.
                    if (symAtLocation !== unknownSymbol) {
                        context.tracker.reportInferenceFallback(node);
                    }
                    introducesError = true;
                    return { introducesError, node, sym };
                }
                else {
                    sym = symAtLocation;
                }
            }

            if (sym) {
                // If a parameter is resolvable in the current context it is also visible, so no need to go to symbol accesibility
                if (
                    sym.flags & SymbolFlags.FunctionScopedVariable
                    && sym.valueDeclaration
                ) {
                    if (isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration)) {
                        return { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T };
                    }
                }
                if (
                    !(sym.flags & SymbolFlags.TypeParameter) && // Type parameters are visible in the current context if they are are resolvable
                    !isDeclarationName(node) &&
                    isSymbolAccessible(sym, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible
                ) {
                    context.tracker.reportInferenceFallback(node);
                    introducesError = true;
                }
                else {
                    context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning);
                }
                return { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T };
            }

            return { introducesError, node };

            /**
             * Attaches a `.symbol` member to an identifier, cloning it to do so, so symbol information
             * is smuggled out for symbol display information.
             */
            function attachSymbolToLeftmostIdentifier(node: Node): Node {
                if (node === leftmost) {
                    const type = getDeclaredTypeOfSymbol(sym!);
                    const name = sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier);
                    name.symbol = sym!; // for quickinfo, which uses identifier symbol information
                    return setTextRange(context, setEmitFlags(name, EmitFlags.NoAsciiEscaping), node);
                }
                const updated = visitEachChildWorker(node, c => attachSymbolToLeftmostIdentifier(c), /*context*/ undefined);
                if (updated !== node) {
                    setTextRange(context, updated, node);
                }
                return updated;
            }
        }

        function serializeTypeName(context: NodeBuilderContext, node: EntityName, isTypeOf?: boolean, typeArguments?: readonly TypeNode[]) {
            const meaning = isTypeOf ? SymbolFlags.Value : SymbolFlags.Type;
            const symbol = resolveEntityName(node, meaning, /*ignoreErrors*/ true);
            if (!symbol) return undefined;
            const resolvedSymbol = symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol;
            if (isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible) return undefined;
            return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments);
        }
        
        /**
         * Do you mean to call this directly? You probably should use `tryReuseExistingTypeNode` instead,
         * which performs sanity checking on the type before doing this.
         */
        function tryReuseExistingTypeNodeHelper(context: NodeBuilderContext, existing: TypeNode) {
            if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                cancellationToken.throwIfCancellationRequested();
            }
            let hadError = false;
            const { finalizeBoundary, startRecoveryScope } = createRecoveryBoundary();
            const transformed = visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode);
            if (!finalizeBoundary()) {
                return undefined;
            }

            // here we handle a special case in LPC where the type is a LiteralTypeNode and the type is a BinaryExpression
            // this happens in jsdoc tags where the type is set to a define which expands to a string concatenation
            if (isLiteralTypeNode(transformed) && isBinaryExpression(transformed.literal)) {
                // convert the binary expression to a fake stringliteral and set the type.literal to that
                const fullString = evaluate(transformed.literal).value as string;
                (transformed as Mutable<LiteralTypeNode>).literal = factory.createStringLiteral(fullString);
            }

            context.approximateLength += existing.end - existing.pos;
            return transformed;

            function visitExistingNodeTreeSymbols(node: Node): Node | undefined {
                // If there was an error in a sibling node bail early, the result will be discarded anyway
                if (hadError) return node;
                const recover = startRecoveryScope();
                const onExitNewScope = isNewScopeNode(node) ? onEnterNewScope(node) : undefined;
                const result = visitExistingNodeTreeSymbolsWorker(node);
                onExitNewScope?.();

                // If there was an error, maybe we can recover by serializing the actual type of the node
                if (hadError) {
                    if (isTypeNode(node) && !isTypePredicateNode(node)) {
                        recover();
                        return serializeExistingTypeNode(context, node);
                    }
                    return node;
                }
                // We want to clone the subtree, so when we mark it up with __pos and __end in quickfixes,
                //  we don't get odd behavior because of reused nodes. We also need to clone to _remove_
                //  the position information if the node comes from a different file than the one the node builder
                //  is set to build for (even though we are reusing the node structure, the position information
                //  would make the printer print invalid spans for literals and identifiers, and the formatter would
                //  choke on the mismatched positonal spans between a parent and an injected child from another file).
                return result ? setTextRange(context, result, node) : undefined;
            }

            function createRecoveryBoundary() {
                let trackedSymbols: TrackedSymbol[];
                let unreportedErrors: (() => void)[];
                const oldTracker = context.tracker;
                const oldTrackedSymbols = context.trackedSymbols;
                context.trackedSymbols = undefined;
                const oldEncounteredError = context.encounteredError;
                context.tracker = new SymbolTrackerImpl(context, {
                    ...oldTracker.inner,
                    reportCyclicStructureError() {
                        markError(() => oldTracker.reportCyclicStructureError());
                    },
                    reportInaccessibleThisError() {
                        markError(() => oldTracker.reportInaccessibleThisError());
                    },
                    reportInaccessibleUniqueSymbolError() {
                        markError(() => oldTracker.reportInaccessibleUniqueSymbolError());
                    },
                    reportLikelyUnsafeImportRequiredError(specifier) {
                        markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier));
                    },
                    reportNonSerializableProperty(name) {
                        markError(() => oldTracker.reportNonSerializableProperty(name));
                    },
                    trackSymbol(sym, decl, meaning) {
                        (trackedSymbols ??= []).push([sym, decl, meaning]);
                        return false;
                    },
                    moduleResolverHost: context.tracker.moduleResolverHost,
                }, context.tracker.moduleResolverHost);

                return {
                    startRecoveryScope,
                    finalizeBoundary,
                };

                function markError(unreportedError: () => void) {
                    hadError = true;
                    (unreportedErrors ??= []).push(unreportedError);
                }

                function startRecoveryScope() {
                    const trackedSymbolsTop = trackedSymbols?.length ?? 0;
                    const unreportedErrorsTop = unreportedErrors?.length ?? 0;
                    return () => {
                        hadError = false;
                        // Reset the tracked symbols to before the error
                        if (trackedSymbols) {
                            trackedSymbols.length = trackedSymbolsTop;
                        }
                        if (unreportedErrors) {
                            unreportedErrors.length = unreportedErrorsTop;
                        }
                    };
                }

                function finalizeBoundary() {
                    context.tracker = oldTracker;
                    context.trackedSymbols = oldTrackedSymbols;
                    context.encounteredError = oldEncounteredError;

                    unreportedErrors?.forEach(fn => fn());
                    if (hadError) {
                        return false;
                    }
                    trackedSymbols?.forEach(
                        ([symbol, enclosingDeclaration, meaning]) =>
                            context.tracker.trackSymbol(
                                symbol,
                                enclosingDeclaration,
                                meaning,
                            ),
                    );
                    return true;
                }
            }
            function onEnterNewScope(node: IntroducesNewScopeNode | ConditionalTypeNode) {
                return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node));
            }

            function tryVisitSimpleTypeNode(node: TypeNode): TypeNode | undefined {
                const innerNode = skipTypeParentheses(node);
                switch (innerNode.kind) {
                    case SyntaxKind.TypeReference:
                        return tryVisitTypeReference(innerNode as TypeReferenceNode);
                    // case SyntaxKind.TypeQuery:
                    //     return tryVisitTypeQuery(innerNode as TypeQueryNode);
                    case SyntaxKind.IndexedAccessType:
                        return tryVisitIndexedAccess(innerNode as IndexedAccessTypeNode);
                    // case SyntaxKind.TypeOperator:
                    //     const typeOperatorNode = innerNode as TypeOperatorNode;
                    //     if (typeOperatorNode.operator === SyntaxKind.KeyOfKeyword) {
                    //         return tryVisitKeyOf(typeOperatorNode);
                    //     }
                }
                return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode);
            }

            function tryVisitIndexedAccess(node: IndexedAccessTypeNode): TypeNode | undefined {
                const resultObjectType = tryVisitSimpleTypeNode(node.objectType);
                if (resultObjectType === undefined) {
                    return undefined;
                }
                Debug.fail("todo - update indexed access type node");
                // return factory.updateIndexedAccessTypeNode(node, resultObjectType, visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode)!);
            }

            function tryVisitTypeReference(node: TypeReferenceNode): TypeNode | undefined {
                if (canReuseTypeNode(context, node)) {
                    const { introducesError, node: newName } = trackExistingEntityName(node.typeName, context);
                    const typeArguments = visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode);

                    if (!introducesError) {
                        const updated = factory.updateTypeReferenceNode(
                            node,
                            newName,
                            typeArguments,
                        );
                        return setTextRange(context, updated, node);
                    }
                    else {
                        const serializedName = serializeTypeName(context, node.typeName, /*isTypeOf*/ false, typeArguments);
                        if (serializedName) {
                            return setTextRange(context, serializedName, node.typeName);
                        }
                    }
                }
            }

            function visitExistingNodeTreeSymbolsWorker(node: Node): Node | undefined {
                if (isJSDocTypeExpression(node)) {
                    // Unwrap JSDocTypeExpressions
                    return visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode);
                }
                // We don't _actually_ support jsdoc namepath types, emit `any` instead
                if (isJSDocAllType(node) || node.kind === SyntaxKind.JSDocNamepathType) {
                    return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
                }
                if (isJSDocUnknownType(node)) {
                    return factory.createKeywordTypeNode(SyntaxKind.UnknownKeyword);
                }
                // if (isJSDocNullableType(node)) {
                //     return factory.createUnionTypeNode([visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createLiteralTypeNode(factory.createNull())]);
                // }
                // if (isJSDocOptionalType(node)) {
                //     return factory.createUnionTypeNode([visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)]);
                // }
                // if (isJSDocNonNullableType(node)) {
                //     return visitNode(node.type, visitExistingNodeTreeSymbols);
                // }
                if (isJSDocVariadicType(node)) {
                    return factory.createArrayTypeNode(visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!);
                }
                if (isJSDocTypeLiteral(node)) {
                    return factory.createTypeLiteralNode(map(node.jsDocPropertyTags, t => {
                        const name = visitNode(isIdentifier(t.name) ? t.name : t.name.right, visitExistingNodeTreeSymbols, isIdentifier)!;
                        const typeViaParent = getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.text);
                        const overrideTypeNode = typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined;

                        return factory.createPropertySignature(
                            /*modifiers*/ undefined,
                            name,
                            // t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                            overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
                        );
                    }));
                }
                if (isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.text === "") {
                    return setOriginalNode(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), node);
                }
                if ((isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node)) {
                    return factory.createTypeLiteralNode([factory.createIndexSignature(
                        /*modifiers*/ undefined,
                        [factory.createParameterDeclaration(
                            /*modifiers*/ undefined,
                            /*dotDotDotToken*/ undefined,
                            "x",
                            /*questionToken*/ undefined,
                            visitNode(node.typeArguments![0], visitExistingNodeTreeSymbols, isTypeNode),
                        )],
                        visitNode(node.typeArguments![1], visitExistingNodeTreeSymbols, isTypeNode),
                    )]);
                }
                if (isJSDocFunctionType(node)) {
                    // if (isJSDocConstructSignature(node)) {
                    //     let newTypeNode: TypeNode | undefined;
                    //     return factory.createConstructorTypeNode(
                    //         /*modifiers*/ undefined,
                    //         visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration),
                    //         mapDefined(node.parameters, (p, i) =>
                    //             p.name && isIdentifier(p.name) && p.name.text === "new" ? (newTypeNode = p.type, undefined) : factory.createParameterDeclaration(
                    //                 /*modifiers*/ undefined,
                    //                 getEffectiveDotDotDotForParameter(p),
                    //                 setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),
                    //                 factory.cloneNode(p.questionToken),
                    //                 visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),
                    //                 /*initializer*/ undefined,
                    //             )),
                    //         visitNode(newTypeNode || node.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
                    //     );
                    // }
                    // else {
                        return factory.createFunctionTypeNode(
                            visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration),
                            map(node.parameters, (p, i) =>
                                factory.createParameterDeclaration(
                                    /*modifiers*/ undefined,
                                    getEffectiveDotDotDotForParameter(p),
                                    setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),
                                    factory.cloneNode(p.ampToken),
                                    visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),
                                    /*initializer*/ undefined,
                                )),
                            visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),
                        );
                    // }
                }
                if (isThisTypeNode(node)) {
                    if (canReuseTypeNode(context, node)) {
                        return node;
                    }
                    hadError = true;
                    return node;
                }
                if (isTypeParameterDeclaration(node)) {
                    return factory.updateTypeParameterDeclaration(
                        node,
                        visitNodes(node.modifiers, visitExistingNodeTreeSymbols, isModifier),
                        setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node),
                        visitNode(node.constraint, visitExistingNodeTreeSymbols, isTypeNode),
                        visitNode(node.default, visitExistingNodeTreeSymbols, isTypeNode),
                    );
                }

                if (isIndexedAccessTypeNode(node)) {
                    const result = tryVisitIndexedAccess(node);
                    if (!result) {
                        hadError = true;
                        return node;
                    }
                    return result;
                }

                if (isTypeReferenceNode(node)) {
                    const result = tryVisitTypeReference(node);
                    if (result) {
                        return result;
                    }
                    hadError = true;
                    return node;
                }
                // if (isLiteralImportTypeNode(node)) {
                //     const nodeSymbol = getNodeLinks(node).resolvedSymbol;
                //     if (
                //         isInJSDoc(node) &&
                //         nodeSymbol &&
                //         (
                //             // The import type resolved using jsdoc fallback logic
                //             (!node.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||
                //             // The import type had type arguments autofilled by js fallback logic
                //             !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))
                //         )
                //     ) {
                //         return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node);
                //     }
                //     return factory.updateImportTypeNode(
                //         node,
                //         factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)),
                //         visitNode(node.attributes, visitExistingNodeTreeSymbols, isImportAttributes),
                //         visitNode(node.qualifier, visitExistingNodeTreeSymbols, isEntityName),
                //         visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode),
                //         node.isTypeOf,
                //     );
                // }
                if (isNamedDeclaration(node) && node.name.kind === SyntaxKind.ComputedPropertyName && !isLateBindableName(node.name)) {
                    if (!hasDynamicName(node)) {
                        return visitEachChild(node, visitExistingNodeTreeSymbols);
                    }
                    if (!(context.flags & NodeBuilderFlags.AllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags & TypeFlags.Any)) {
                        return undefined;
                    }
                }
                if (
                    (isFunctionLike(node) && !node.type)
                    || (isPropertyDeclaration(node) && !node.type && !node.initializer)
                    || (isPropertySignature(node) && !node.type && !node.initializer)
                    || (isParameter(node) && !node.type && !node.initializer)
                ) {
                    let visited = visitEachChild(node, visitExistingNodeTreeSymbols);
                    if (visited === node) {
                        visited = setTextRange(context, factory.cloneNode(node), node);
                    }
                    (visited as Mutable<typeof visited>).type = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
                    if (isParameter(node)) {
                        (visited as Mutable<ParameterDeclaration>).modifiers = undefined;
                    }
                    return visited;
                }
                // if (isTypeQueryNode(node)) {
                //     const result = tryVisitTypeQuery(node);
                //     if (!result) {
                //         hadError = true;
                //         return node;
                //     }
                //     return result;
                // }
                if (isComputedPropertyName(node) && isEntityNameExpression(node.expression)) {
                    const { node: result, introducesError } = trackExistingEntityName(node.expression, context);
                    if (!introducesError) {
                        return factory.updateComputedPropertyName(node, result);
                    }
                    else {
                        const type = getWidenedType(getRegularTypeOfExpression(node.expression));
                        const computedPropertyNameType = typeToTypeNodeHelper(type, context);
                        let literal;
                        if (isLiteralTypeNode(computedPropertyNameType)) {
                            literal = computedPropertyNameType.literal;
                        }
                        else {
                            const evaluated = evaluateEntityNameExpression(node.expression);
                            const literalNode = typeof evaluated.value === "string" ? factory.createStringLiteral(evaluated.value, /*isSingleQuote*/ undefined) :
                                typeof evaluated.value === "number" ? factory.createIntLiteral(evaluated.value, /*numericLiteralFlags*/ 0) :
                                undefined;
                            if (!literalNode) {
                                // if (isImportTypeNode(computedPropertyNameType)) {
                                //     trackComputedName(node.expression, context.enclosingDeclaration, context);
                                // }
                                return node;
                            }
                            literal = literalNode;
                        }
                        if (literal.kind === SyntaxKind.StringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(compilerOptions))) {
                            return factory.createIdentifier(literal.text);
                        }
                        if (literal.kind === SyntaxKind.NumericLiteral && !literal.text.startsWith("-")) {
                            return literal;
                        }
                        return factory.updateComputedPropertyName(node, literal);
                    }
                }
                if (isTypePredicateNode(node)) {
                    let parameterName;
                    if (isIdentifier(node.parameterName)) {
                        const { node: result, introducesError } = trackExistingEntityName(node.parameterName, context);
                        // Should not usually happen the only case is when a type predicate comes from a JSDoc type annotation with it's own parameter symbol definition.
                        // /** @type {(v: unknown) => v is undefined} */
                        // const isUndef = v => v === undefined;
                        hadError = hadError || introducesError;
                        parameterName = result;
                    }
                    else {
                        parameterName = factory.cloneNode(node.parameterName);
                    }
                    return factory.updateTypePredicateNode(node, undefined, parameterName, visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode));
                }

                if (isTypeLiteralNode(node)) {// || isTupleTypeNode(node) || isMappedTypeNode(node)) {
                    const visited = visitEachChild(node, visitExistingNodeTreeSymbols);
                    const clone = setTextRange(context, visited === node ? factory.cloneNode(node) : visited, node);
                    const flags = getEmitFlags(clone);
                    setEmitFlags(clone, flags | (context.flags & NodeBuilderFlags.MultilineObjectLiterals && isTypeLiteralNode(node) ? 0 : EmitFlags.SingleLine));
                    return clone;
                }
                if (isStringLiteral(node) && !!(context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType) && !node.singleQuote) {
                    const clone = factory.cloneNode(node);
                    (clone as Mutable<typeof clone>).singleQuote = true;
                    return clone;
                }
                if (isConditionalTypeNode(node)) {
                    const checkType = visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)!;

                    const disposeScope = onEnterNewScope(node);
                    const extendType = visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)!;
                    const trueType = visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)!;
                    disposeScope();
                    const falseType = visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)!;
                    Debug.fail("todo - update conditional type node");
                    // return factory.updateConditionalTypeNode(
                    //     node,
                    //     checkType,
                    //     extendType,
                    //     trueType,
                    //     falseType,
                    // );
                }

                // if (isTypeOperatorNode(node)) {
                //     if (node.operator === SyntaxKind.UniqueKeyword && node.type.kind === SyntaxKind.SymbolKeyword) {
                //         if (!canReuseTypeNode(context, node)) {
                //             hadError = true;
                //             return node;
                //         }
                //     }
                //     else if (node.operator === SyntaxKind.KeyOfKeyword) {
                //         const result = tryVisitKeyOf(node);
                //         if (!result) {
                //             hadError = true;
                //             return node;
                //         }
                //         return result;
                //     }
                // }

                return visitEachChild(node, visitExistingNodeTreeSymbols);

                function visitEachChild<T extends Node>(node: T, visitor: Visitor): T;
                function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor): T | undefined;
                function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor): T | undefined {
                    const nonlocalNode = !context.enclosingFile || context.enclosingFile !== getSourceFileOfNode(node);
                    return visitEachChildWorker(node, visitor, /*context*/ undefined, nonlocalNode ? visitNodesWithoutCopyingPositions : undefined);
                }

                function visitNodesWithoutCopyingPositions(
                    nodes: NodeArray<Node> | undefined,
                    visitor: Visitor,
                    test?: (node: Node) => boolean,
                    start?: number,
                    count?: number,
                ): NodeArray<Node> | undefined {
                    let result = visitNodes(nodes, visitor, test, start, count);
                    if (result) {
                        if (result.pos !== -1 || result.end !== -1) {
                            if (result === nodes) {
                                result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma);
                            }
                            setTextRangePosEnd(result, -1, -1);
                        }
                    }
                    return result;
                }

                function getEffectiveDotDotDotForParameter(p: ParameterDeclaration) {
                    return p.dotDotDotToken || (p.type && isJSDocVariadicType(p.type) ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined);
                }

                /** Note that `new:T` parameters are not handled, but should be before calling this function. */
                function getNameForJSDocFunctionParameter(p: ParameterDeclaration, index: number) {
                    return p.name && isIdentifier(p.name) && p.name.text === "this" ? "this"
                        : getEffectiveDotDotDotForParameter(p) ? `args`
                        : `arg${index}`;
                }                
            }
        }
        
        function getDeclarationWithTypeAnnotation(symbol: Symbol, enclosingDeclaration?: Node | undefined) {
            return symbol.declarations && find(symbol.declarations, s => !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, n => n === enclosingDeclaration)));
        }
        
        function tryReuseExistingTypeNode(
            context: NodeBuilderContext,
            typeNode: TypeNode,
            type: Type,
            host: Node,
            addUndefined?: boolean,
        ) {
            const originalType = type;
            if (addUndefined) {
                type = getOptionalType(type, !isParameter(host));
            }
            const clone = tryReuseExistingNonParameterTypeNode(context, typeNode, type, host);
            if (clone) {
                // explicitly add `| undefined` if it's missing from the input type nodes and the type contains `undefined` (and not the missing type)
                if (addUndefined && containsNonMissingUndefinedType(type) && !someType(getTypeFromTypeNode(context, typeNode), t => !!(t.flags & TypeFlags.Undefined))) {
                    return factory.createUnionTypeNode([clone, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)]);
                }
                return clone;
            }
            if (addUndefined && originalType !== type) {
                const cloneMissingUndefined = tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host);
                if (cloneMissingUndefined) {
                    return factory.createUnionTypeNode([cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)]);
                }
            }
            return undefined;
        }

        /**
         * Unlike `typeToTypeNodeHelper`, this handles setting up the `AllowUniqueESSymbolType` flag
         * so a `unique symbol` is returned when appropriate for the input symbol, rather than `typeof sym`
         * @param context - The node builder context. Any reused nodes are checked to be pulled from within the scope of the context's enclosingDeclaration.
         * @param declaration - The preferred declaration to pull existing type nodes from (the symbol will be used as a fallback to find any annotated declaration)
         * @param type - The type to write; an existing annotation must match this type if it's used, otherwise this is the type serialized as a new type node
         * @param symbol - The symbol is used both to find an existing annotation if declaration is not provided, and to determine if `unique symbol` should be printed
         */
        function serializeTypeForDeclaration(context: NodeBuilderContext, declaration: Declaration | undefined, type: Type, symbol: Symbol) {
            const addUndefinedForParameter = declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration);
            const enclosingDeclaration = context.enclosingDeclaration;
            const oldFlags = context.flags;
            if (declaration && hasInferredType(declaration) && !(context.flags & NodeBuilderFlags.NoSyntacticPrinter)) {                
                syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context);
            }
            context.flags |= NodeBuilderFlags.NoSyntacticPrinter;
            if (enclosingDeclaration && (!isErrorType(type) || (context.flags & NodeBuilderFlags.AllowUnresolvedNames))) {
                const declWithExistingAnnotation = declaration && getNonlocalEffectiveTypeAnnotationNode(declaration)
                    ? declaration
                    : getDeclarationWithTypeAnnotation(symbol);
                if (declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation)) {
                    // try to reuse the existing annotation
                    const existing = getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)!;
                    // explicitly add `| undefined` to optional mapped properties whose type contains `undefined` (and not `missing`)
                    const addUndefined = addUndefinedForParameter || !!(symbol.flags & SymbolFlags.Property && symbol.flags & SymbolFlags.Optional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol as MappedSymbol).links?.mappedType && containsNonMissingUndefinedType(type));
                    const result = !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type, declWithExistingAnnotation, addUndefined);
                    if (result) {
                        context.flags = oldFlags;
                        return result;
                    }
                }
            }
            
            const decl = declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0];
            const expr = decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl) ? getPossibleTypeNodeReuseExpression(decl) : undefined;

            const result = expressionOrTypeToTypeNode(context, expr, type, addUndefinedForParameter);
            context.flags = oldFlags;
            return result;
        }

        /**
         * Same as expressionOrTypeToTypeNodeHelper, but also checks if the expression can be syntactically typed.
         */
        function expressionOrTypeToTypeNode(context: NodeBuilderContext, expr: Expression | undefined, type: Type, addUndefined?: boolean) {
            const oldFlags = context.flags;
            if (expr && !(context.flags & NodeBuilderFlags.NoSyntacticPrinter)) {
                syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined);
            }
            context.flags |= NodeBuilderFlags.NoSyntacticPrinter;
            const result = expressionOrTypeToTypeNodeHelper(context, expr, type, addUndefined);
            context.flags = oldFlags;
            return result;
        }

        function expressionOrTypeToTypeNodeHelper(context: NodeBuilderContext, expr: Expression | undefined, type: Type, addUndefined?: boolean) {
            if (expr) {
                const typeNode = isAssertionExpression(expr) ? expr.type
                    : isJSDocTypeAssertion(expr) ? getJSDocTypeAssertionType(expr)
                    : undefined;
                if (typeNode) {
                    const result = tryReuseExistingTypeNode(context, typeNode, type, expr.parent, addUndefined);
                    if (result) {
                        return result;
                    }
                }
            }

            if (addUndefined) {
                type = getOptionalType(type);
            }

            return typeToTypeNodeHelper(type, context);
        }

        function parameterToParameterDeclarationName(parameterSymbol: Symbol, parameterDeclaration: ParameterDeclaration | JSDocParameterTag | undefined, context: NodeBuilderContext) {
            return parameterDeclaration ? parameterDeclaration.name ?
                parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlags.NoAsciiEscaping) :
                    parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlags.NoAsciiEscaping) :
                    cloneBindingName(parameterDeclaration.name) :
                symbolName(parameterSymbol) :
                symbolName(parameterSymbol);

            function cloneBindingName(node: BindingName): BindingName {
                return elideInitializerAndSetEmitFlags(node) as BindingName;
                function elideInitializerAndSetEmitFlags(node: Node): Node {
                    if (context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node)) {
                        trackComputedName(node.expression, context.enclosingDeclaration, context);
                    }
                    let visited = visitEachChildWorker(node, elideInitializerAndSetEmitFlags, /*context*/ undefined, /*nodesVisitor*/ undefined, elideInitializerAndSetEmitFlags);
                    if (isBindingElement(visited)) {
                        visited = factory.updateBindingElement(
                            visited,
                            visited.dotDotDotToken,
                            visited.propertyName,
                            visited.name,
                            /*initializer*/ undefined,
                        );
                    }
                    if (!nodeIsSynthesized(visited)) {
                        visited = factory.cloneNode(visited);
                    }
                    return setEmitFlags(visited, EmitFlags.SingleLine | EmitFlags.NoAsciiEscaping);
                }
            }
        }

        function trackComputedName(accessExpression: EntityNameOrEntityNameExpression, enclosingDeclaration: Node | undefined, context: NodeBuilderContext) {
            if (!context.tracker.canTrackSymbol) return;
            // get symbol of the first identifier of the entityName
            const firstIdentifier = getFirstIdentifier(accessExpression);
            const name = resolveName(firstIdentifier, firstIdentifier.text, SymbolFlags.Value | SymbolFlags.ExportValue, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
            if (name) {
                context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlags.Value);
            }
        }

        function symbolToParameterDeclaration(parameterSymbol: Symbol, context: NodeBuilderContext, preserveModifierFlags?: boolean): ParameterDeclaration {
            const parameterDeclaration = getEffectiveParameterDeclaration(parameterSymbol);

            const parameterType = getTypeOfSymbol(parameterSymbol);
            const parameterTypeNode = serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol);

            const modifiers = !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined;
            const isRest = parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & CheckFlags.RestParameter;
            const dotDotDotToken = isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined;
            const name = parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context);
            const isOptional = parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & CheckFlags.OptionalParameter;
            // const questionToken = isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined;
            const ampToken = isByRefParameterDeclaration(parameterDeclaration) ? factory.createToken(parameterDeclaration.ampToken.kind) : undefined;            
            const parameterNode = factory.createParameterDeclaration(
                modifiers,
                dotDotDotToken,
                name,
                ampToken,
                parameterTypeNode,
                /*initializer*/ undefined,
            );
            context.approximateLength += symbolName(parameterSymbol).length + 3;
            return parameterNode;
        }


        function tryGetThisParameterDeclaration(signature: Signature, context: NodeBuilderContext) {
            if (signature.thisParameter) {
                return symbolToParameterDeclaration(signature.thisParameter, context);
            }
            if (signature.declaration && isInJSFile(signature.declaration)) {
                const thisTag = getJSDocThisTag(signature.declaration);
                if (thisTag && thisTag.typeExpression) {
                    return factory.createParameterDeclaration(
                        /*modifiers*/ undefined,
                        /*dotDotDotToken*/ undefined,
                        "this",
                        /*questionToken*/ undefined,
                        typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context),
                    );
                }
            }
        }

        function serializeReturnTypeForSignature(context: NodeBuilderContext, signature: Signature) {
            const suppressAny = context.flags & NodeBuilderFlags.SuppressAnyReturnType;
            const flags = context.flags;
            if (suppressAny) context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; // suppress only toplevel `any`s
            let returnTypeNode: TypeNode | undefined;
            const returnType = getReturnTypeOfSignature(signature);
            if (returnType && !(suppressAny && isTypeAny(returnType))) {
                if (signature.declaration && !(context.flags & NodeBuilderFlags.NoSyntacticPrinter)) {                    
                    syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context);
                }
                context.flags |= NodeBuilderFlags.NoSyntacticPrinter;
                returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature);
            }
            else if (!suppressAny) {
                returnTypeNode = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
            }
            context.flags = flags;
            return returnTypeNode;
        }

        function typePredicateToTypePredicateNodeHelper(typePredicate: TypePredicate, context: NodeBuilderContext): TypePredicateNode {
            const parameterName = typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?
                setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) :
                undefined;
            const typeNode = typePredicate.type && typeToTypeNodeHelper(typePredicate.type, context);
            return factory.createTypePredicateNode(undefined, parameterName, typeNode);
        }

        function serializeReturnTypeForSignatureWorker(context: NodeBuilderContext, signature: Signature) {
            const typePredicate = getTypePredicateOfSignature(signature);
            const type = getReturnTypeOfSignature(signature);
            if (context.enclosingDeclaration && (!isErrorType(type) || (context.flags & NodeBuilderFlags.AllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration)) {
                const annotation = getNonlocalEffectiveReturnTypeAnnotationNode(signature.declaration);
                if (annotation) {
                    const result = tryReuseExistingTypeNode(context, annotation, type, context.enclosingDeclaration);
                    if (result) {
                        return result;
                    }
                }
            }
            if (typePredicate) {
                return typePredicateToTypePredicateNodeHelper(typePredicate, context);
            }
            const expr = signature.declaration && getPossibleTypeNodeReuseExpression(signature.declaration);
            return expressionOrTypeToTypeNode(context, expr, type);
        }
        

        function signatureToSignatureDeclarationHelper(signature: Signature, kind: SignatureDeclaration["kind"], context: NodeBuilderContext, options?: SignatureToSignatureDeclarationOptions): SignatureDeclaration {
            let typeParameters: TypeParameterDeclaration[] | undefined;
            let typeArguments: TypeNode[] | undefined;

            const expandedParams = getExpandedParameters(signature, /*skipUnionExpanding*/ true)[0];
            const cleanup = enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper);
            context.approximateLength += 3; // Usually a signature contributes a few more characters than this, but 3 is the minimum

            if (context.flags & NodeBuilderFlags.WriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters) {
                typeArguments = signature.target.typeParameters.map(parameter => typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context));
            }
            else {
                typeParameters = signature.typeParameters && signature.typeParameters.map(parameter => typeParameterToDeclaration(parameter, context));
            }

            const flags = context.flags;
            context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; // SuppressAnyReturnType should only apply to the signature `return` position
            // If the expanded parameter list had a variadic in a non-trailing position, don't expand it
            const parameters = (some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams).map(parameter => symbolToParameterDeclaration(parameter, context, false /*kind === SyntaxKind.Constructor*/));
            // const thisParameter = context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context);
            // if (thisParameter) {
            //     parameters.unshift(thisParameter);
            // }
            context.flags = flags;

            const returnTypeNode = serializeReturnTypeForSignature(context, signature);

            let modifiers = options?.modifiers;
            
            const node = kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :
                kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), undefined, typeParameters, parameters, returnTypeNode) :
                kind === SyntaxKind.MethodDeclaration ? Debug.fail("todo-method decl") ://factory.createMethodDeclaration(modifiers, /*asteriskToken*/ undefined, options?.name ?? factory.createIdentifier(""), /*questionToken*/ undefined, typeParameters, parameters, returnTypeNode, /*body*/ undefined) :                
                kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :                
                kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), parameters, returnTypeNode, /*body*/ undefined) :
                kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), parameters, returnTypeNode, factory.createBlock([])) :
                kind === SyntaxKind.ArrowFunction ? Debug.fail("todo-arrow") : //factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken*/ undefined, factory.createBlock([])) :
                kind === SyntaxKind.JSDocFunctionType ? Debug.fail("todo-jsdoc function") :
                kind === SyntaxKind.InlineClosureExpression ? factory.createInlineClosure(factory.createBlock([])) :
                kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode) :                                
                Debug.assertNever(kind as never);

            if (typeArguments) {
                node.typeArguments = factory.createNodeArray(typeArguments);
            }
            if (signature.declaration?.kind === SyntaxKind.JSDocSignature && signature.declaration.parent.kind === SyntaxKind.JSDocOverloadTag) {
                const comment = getTextOfNode(signature.declaration.parent.parent, /*includeTrivia*/ true).slice(2, -2).split(/\r\n|\n|\r/).map(line => line.replace(/^\s+/, " ")).join("\n");
                addSyntheticLeadingComment(node, SyntaxKind.MultiLineCommentTrivia, comment, /*hasTrailingNewLine*/ true);
            }

            cleanup?.();
            return node;
        }


        function typeToTypeNodeWorker(type: Type, context: NodeBuilderContext): TypeNode {
            if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                cancellationToken.throwIfCancellationRequested();
            }
            const inTypeAlias = context.flags & NodeBuilderFlags.InTypeAlias;
            context.flags &= ~NodeBuilderFlags.InTypeAlias;

            if (!type) {
                if (!(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection)) {
                    context.encounteredError = true;
                    return undefined!; // TODO: GH#18217
                }
                context.approximateLength += 3;
                return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
            }

            if (!(context.flags & NodeBuilderFlags.NoTypeReduction)) {
                type = getReducedType(type);
            }

            if (type.flags & TypeFlags.Any) {
                if (type.aliasSymbol) {
                    return factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
                }
                if (type === unresolvedType) {
                    return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.AnyKeyword), SyntaxKind.MultiLineCommentTrivia, "unresolved");
                }
                context.approximateLength += 3;                
                return factory.createKeywordTypeNode(type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword);
            }
            // if (type.flags & TypeFlags.Object) {
            //     // if (type.aliasSymbol) {
            //     //     return factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
            //     // }
            //     if (type === unresolvedType) {
            //         return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword), SyntaxKind.MultiLineCommentTrivia, "unresolved");
            //     }
            //     if (isArrayType(type)) {
            //         const elementType = typeToTypeNodeWorker(first(type.resolvedTypeArguments), context);
            //         return factory.createArrayTypeNode(elementType);
            //     }
            //     if (isMappingType(type)) {
            //         context.approximateLength += 3;
            //         return factory.createKeywordTypeNode(SyntaxKind.MappingKeyword);
            //     }
            //     context.approximateLength += 3;                
            //     return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
            // }
            if (type.flags & TypeFlags.Unknown) {
                return factory.createKeywordTypeNode(SyntaxKind.UnknownKeyword);
            }
            if (type.flags & TypeFlags.Bytes) {
                context.approximateLength += 5;
                return factory.createKeywordTypeNode(SyntaxKind.BytesKeyword);
            }
            if (type.flags & TypeFlags.String) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.StringKeyword);
            }
            if (type.flags & TypeFlags.Number) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.IntKeyword);
            }
            if (type.flags & TypeFlags.Float) {
                context.approximateLength += 5;
                return factory.createKeywordTypeNode(SyntaxKind.FloatKeyword);
            }
            // if (type.flags & TypeFlags.Boolean && !type.aliasSymbol) {
            //     context.approximateLength += 7;
            //     return factory.createKeywordTypeNode(SyntaxKind.BooleanKeyword);
            // }
            if (type.flags & TypeFlags.EnumLike) {
                if (type.symbol.flags & SymbolFlags.EnumMember) {
                    const parentSymbol = getParentOfSymbol(type.symbol)!;
                    const parentName = symbolToTypeNode(parentSymbol, context, SymbolFlags.Type);
                    if (getDeclaredTypeOfSymbol(parentSymbol) === type) {
                        return parentName;
                    }
                    const memberName = symbolName(type.symbol);
                    if (isIdentifierText(memberName, ScriptTarget.LPC)) {
                        return appendReferenceToType(
                            parentName as TypeReferenceNode ,//| ImportTypeNode,
                            factory.createTypeReferenceNode(memberName, /*typeArguments*/ undefined),
                        );
                    }
                    // if (isImportTypeNode(parentName)) {
                    //     (parentName as any).isTypeOf = true; // mutably update, node is freshly manufactured anyhow
                    //     return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)));
                    // }
                    // else if (isTypeReferenceNode(parentName)) {
                    //     return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)));
                    // }
                    else {
                        return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.");
                    }
                }
                return symbolToTypeNode(type.symbol, context, SymbolFlags.Type);
            }
            if (type.flags & TypeFlags.BytesLiteral) {
                context.approximateLength += (type as BytesLiteralType).value.length + 3;
                return factory.createLiteralTypeNode(setEmitFlags(factory.createBytesLiteral((type as BytesLiteralType).value), EmitFlags.NoAsciiEscaping));
            }
            if (type.flags & TypeFlags.StringLiteral) {
                context.approximateLength += (type as StringLiteralType).value.length + 2;
                return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type as StringLiteralType).value), EmitFlags.NoAsciiEscaping));
            }
            if (type.flags & TypeFlags.IntLiteral) {
                const value = (type as IntLiteralType).value;
                context.approximateLength += ("" + value).length;
                return factory.createLiteralTypeNode(value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createIntLiteral(-value)) : factory.createIntLiteral(value));
            }
            if (type.flags & TypeFlags.FloatLiteral) {
                const value = (type as FloatLiteralType).value;
                context.approximateLength += ("" + value.toFixed()).length
                return factory.createLiteralTypeNode(value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createFloatLiteral(-value)) : factory.createFloatLiteral(value));
            }
            if (type.flags & TypeFlags.BooleanLiteral) {
                context.approximateLength += (type as IntrinsicType).intrinsicName.length;
                //return factory.createLiteralTypeNode((type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse());
                return factory.createLiteralTypeNode((type as IntrinsicType).intrinsicName === "true" ? factory.createIntLiteral(1) : factory.createIntLiteral(0));
            }
            // if (type.flags & TypeFlags.UniqueESSymbol) {
            //     if (!(context.flags & NodeBuilderFlags.AllowUniqueESSymbolType)) {
            //         if (isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
            //             context.approximateLength += 6;
            //             return symbolToTypeNode(type.symbol, context, SymbolFlags.Value);
            //         }
            //         if (context.tracker.reportInaccessibleUniqueSymbolError) {
            //             context.tracker.reportInaccessibleUniqueSymbolError();
            //         }
            //     }
            //     context.approximateLength += 13;
            //     return factory.createTypeOperatorNode(SyntaxKind.UniqueKeyword, factory.createKeywordTypeNode(SyntaxKind.SymbolKeyword));
            // }
            if (type.flags & TypeFlags.Void) {
                context.approximateLength += 4;
                return factory.createKeywordTypeNode(SyntaxKind.VoidKeyword);
            }
            if (type.flags & TypeFlags.Undefined) {
                context.approximateLength += 9;
                return factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword);
            }
            // if (type.flags & TypeFlags.Null) {
            //     context.approximateLength += 4;
            //     return factory.createLiteralTypeNode(factory.createNull());
            // }
            if (type.flags & TypeFlags.Never) {
                context.approximateLength += 5;
                return factory.createKeywordTypeNode(SyntaxKind.NeverKeyword);
            }
            // if (type.flags & TypeFlags.ESSymbol) {
            //     context.approximateLength += 6;
            //     return factory.createKeywordTypeNode(SyntaxKind.SymbolKeyword);
            // }
            if (type.flags & TypeFlags.NonPrimitive) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
            }
            // if (isThisTypeParameter(type)) {
            //     if (context.flags & NodeBuilderFlags.InObjectTypeLiteral) {
            //         if (!context.encounteredError && !(context.flags & NodeBuilderFlags.AllowThisInObjectLiteral)) {
            //             context.encounteredError = true;
            //         }
            //         context.tracker.reportInaccessibleThisError?.();
            //     }
            //     context.approximateLength += 4;
            //     return factory.createThisTypeNode();
            // }

            if (!inTypeAlias && type.aliasSymbol && (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration))) {
                const typeArgumentNodes = mapToTypeNodes(type.aliasTypeArguments, context);
                if (isReservedMemberName(type.aliasSymbol.name) && !(type.aliasSymbol.flags & SymbolFlags.Class)) return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes);
                if (length(typeArgumentNodes) === 1 && type.aliasSymbol === globalArrayType.symbol) {
                    return factory.createArrayTypeNode(typeArgumentNodes![0]);
                }
                return symbolToTypeNode(type.aliasSymbol, context, SymbolFlags.Type, typeArgumentNodes);
            }

            const objectFlags = getObjectFlags(type);

            if (objectFlags & ObjectFlags.Reference) {
                Debug.assert(!!(type.flags & TypeFlags.Object));
                return (type as TypeReference).node ? visitAndTransformType(type as TypeReference, typeReferenceToTypeNode) : typeReferenceToTypeNode(type as TypeReference);
            }
            if (type.flags & TypeFlags.TypeParameter || objectFlags & ObjectFlags.ClassOrInterface) {
                if (type.flags & TypeFlags.TypeParameter && contains(context.inferTypeParameters, type)) {
                    // context.approximateLength += symbolName(type.symbol).length + 6;
                    // let constraintNode: TypeNode | undefined;
                    // const constraint = getConstraintOfTypeParameter(type as TypeParameter);
                    // if (constraint) {
                    //     // If the infer type has a constraint that is not the same as the constraint
                    //     // we would have normally inferred based on context, we emit the constraint
                    //     // using `infer T extends ?`. We omit inferred constraints from type references
                    //     // as they may be elided.
                    //     const inferredConstraint = getInferredTypeParameterConstraint(type as TypeParameter, /*omitTypeReferences*/ true);
                    //     if (!(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint))) {
                    //         context.approximateLength += 9;
                    //         constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
                    //     }
                    // }
                    // return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type as TypeParameter, context, constraintNode));
                    return Debug.fail("implement");
                }
                if (
                    context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams &&
                    type.flags & TypeFlags.TypeParameter
                ) {
                    const name = typeParameterToName(type, context);
                    context.approximateLength += idText(name).length;
                    return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)), /*typeArguments*/ undefined);
                }
                // Ignore constraint/default when creating a usage (as opposed to declaration) of a type parameter.
                if (type.symbol) {
                    return symbolToTypeNode(type.symbol, context, SymbolFlags.Type);
                }
                const name = (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ?
                    (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?";
                return factory.createTypeReferenceNode(factory.createIdentifier(name), /*typeArguments*/ undefined);
            }
            if (type.flags & TypeFlags.Union && (type as UnionType).origin) {
                type = (type as UnionType).origin!;
            }
            if (type.flags & (TypeFlags.Union | TypeFlags.Intersection)) {
                const types = formatUnionTypes((type as UnionType).types) ;
                if (length(types) === 1) {
                    return typeToTypeNodeHelper(types[0], context);
                }
                const typeNodes = mapToTypeNodes(types, context, /*isBareList*/ true);
                if (typeNodes && typeNodes.length > 0) {
                    return factory.createUnionTypeNode(typeNodes) ;
                }
                else {
                    if (!context.encounteredError && !(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection)) {
                        context.encounteredError = true;
                    }
                    return undefined!; // TODO: GH#18217
                }
            }
            if (objectFlags & (ObjectFlags.Anonymous | ObjectFlags.Mapped)) {
                Debug.assert(!!(type.flags & TypeFlags.Object));

                 // if (type.flags & TypeFlags.Object) {
                //     // if (type.aliasSymbol) {
                //     //     return factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
                //     // }
                //     if (type === unresolvedType) {
                //         return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword), SyntaxKind.MultiLineCommentTrivia, "unresolved");
                //     }
                //     if (isArrayType(type)) {
                //         const elementType = typeToTypeNodeWorker(first(type.resolvedTypeArguments), context);
                //         return factory.createArrayTypeNode(elementType);
                //     }
                //     if (isMappingType(type)) {
                //         context.approximateLength += 3;
                //         return factory.createKeywordTypeNode(SyntaxKind.MappingKeyword);
                //     }
                //     context.approximateLength += 3;                
                //     return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
                // }

                if (!type.aliasSymbol) {
                    // this is a named object symbol
                    // display the filename as part of the type name
                    context.approximateLength += 3;                                                  
                    return factory.createNamedObjectTypeNode(factory.createStringLiteral(trimQuotes(type.symbol.name)), factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword));
                    // return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
                }

                // The type is an object literal type.
                return createAnonymousTypeNode(type as ObjectType);
            }
            if (type.flags & TypeFlags.Index) {
                Debug.fail("implement");
                // const indexedType = (type as IndexType).type;
                // context.approximateLength += 6;
                // const indexTypeNode = typeToTypeNodeHelper(indexedType, context);
                // return factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, indexTypeNode);
            }
            if (type.flags & TypeFlags.TemplateLiteral) {
                // const texts = (type as TemplateLiteralType).texts;
                // const types = (type as TemplateLiteralType).types;
                // const templateHead = factory.createTemplateHead(texts[0]);
                // const templateSpans = factory.createNodeArray(
                //     map(types, (t, i) =>
                //         factory.createTemplateLiteralTypeSpan(
                //             typeToTypeNodeHelper(t, context),
                //             (i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(texts[i + 1]),
                //         )),
                // );
                // context.approximateLength += 2;
                // return factory.createTemplateLiteralType(templateHead, templateSpans);
                return Debug.fail("Should be unreachable.");
            }
            if (type.flags & TypeFlags.StringMapping) {
                // const typeNode = typeToTypeNodeHelper((type as StringMappingType).type, context);
                // return symbolToTypeNode((type as StringMappingType).symbol, context, SymbolFlags.Type, [typeNode]);
                return Debug.fail("Should be unreachable.");
            }
            if (type.flags & TypeFlags.IndexedAccess) {
                // const objectTypeNode = typeToTypeNodeHelper((type as IndexedAccessType).objectType, context);
                // const indexTypeNode = typeToTypeNodeHelper((type as IndexedAccessType).indexType, context);
                // context.approximateLength += 2;
                // return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode);
                return Debug.fail("Should be unreachable.");
            }
            if (type.flags & TypeFlags.Conditional) {
                // return visitAndTransformType(type, type => conditionalTypeToTypeNode(type as ConditionalType));
                return Debug.fail("Should be unreachable.");
            }
            if (type.flags & TypeFlags.Substitution) {
                // const typeNode = typeToTypeNodeHelper((type as SubstitutionType).baseType, context);
                // const noInferSymbol = isNoInferType(type) && getGlobalTypeSymbol("NoInfer" as string, /*reportErrors*/ false);
                // return noInferSymbol ? symbolToTypeNode(noInferSymbol, context, SymbolFlags.Type, [typeNode]) : typeNode;
                return Debug.fail("Should be unreachable.");
            }
            if (type.flags & TypeFlags.Object) {
                // fallback for untyped objects
                return factory.createKeywordTypeNode(SyntaxKind.ObjectKeyword);
            }
            return undefined;

            // function conditionalTypeToTypeNode(type: ConditionalType) {
            //     const checkTypeNode = typeToTypeNodeHelper(type.checkType, context);
            //     context.approximateLength += 15;
            //     if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && type.root.isDistributive && !(type.checkType.flags & TypeFlags.TypeParameter)) {
            //         const newParam = createTypeParameter(createSymbol(SymbolFlags.TypeParameter, "T" as string));
            //         const name = typeParameterToName(newParam, context);
            //         const newTypeVariable = factory.createTypeReferenceNode(name);
            //         context.approximateLength += 37; // 15 each for two added conditionals, 7 for an added infer type
            //         const newMapper = prependTypeMapping(type.root.checkType, newParam, type.mapper);
            //         const saveInferTypeParameters = context.inferTypeParameters;
            //         context.inferTypeParameters = type.root.inferTypeParameters;
            //         const extendsTypeNode = typeToTypeNodeHelper(instantiateType(type.root.extendsType, newMapper), context);
            //         context.inferTypeParameters = saveInferTypeParameters;
            //         const trueTypeNode = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type.root.node.trueType), newMapper));
            //         const falseTypeNode = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type.root.node.falseType), newMapper));

            //         // outermost conditional makes `T` a type parameter, allowing the inner conditionals to be distributive
            //         // second conditional makes `T` have `T & checkType` substitution, so it is correctly usable as the checkType
            //         // inner conditional runs the check the user provided on the check type (distributively) and returns the result
            //         // checkType extends infer T ? T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never : never;
            //         // this is potentially simplifiable to
            //         // checkType extends infer T ? T extends checkType & extendsType<T> ? trueType<T> : falseType<T> : never;
            //         // but that may confuse users who read the output more.
            //         // On the other hand,
            //         // checkType extends infer T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never;
            //         // may also work with `infer ... extends ...` in, but would produce declarations only compatible with the latest TS.
            //         return factory.createConditionalTypeNode(
            //             checkTypeNode,
            //             factory.createInferTypeNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, factory.cloneNode(newTypeVariable.typeName) as Identifier)),
            //             factory.createConditionalTypeNode(
            //                 factory.createTypeReferenceNode(factory.cloneNode(name)),
            //                 typeToTypeNodeHelper(type.checkType, context),
            //                 factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode),
            //                 factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
            //             ),
            //             factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
            //         );
            //     }
            //     const saveInferTypeParameters = context.inferTypeParameters;
            //     context.inferTypeParameters = type.root.inferTypeParameters;
            //     const extendsTypeNode = typeToTypeNodeHelper(type.extendsType, context);
            //     context.inferTypeParameters = saveInferTypeParameters;
            //     const trueTypeNode = typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type));
            //     const falseTypeNode = typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type));
            //     return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode);
            // }

            function typeToTypeNodeOrCircularityElision(type: Type) {
                if (type.flags & TypeFlags.Union) {
                    if (context.visitedTypes?.has(getTypeId(type))) {
                        if (!(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {
                            context.encounteredError = true;
                            context.tracker?.reportCyclicStructureError?.();
                        }
                        return createElidedInformationPlaceholder(context);
                    }
                    return visitAndTransformType(type, type => typeToTypeNodeHelper(type, context));
                }
                return typeToTypeNodeHelper(type, context);
            }

            function isMappedTypeHomomorphic(type: MappedType) {
                return !!getHomomorphicTypeVariable(type);
            }

            function isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type: MappedType) {
                return !!type.target && isMappedTypeHomomorphic(type.target as MappedType) && !isMappedTypeHomomorphic(type);
            }

            function createMappedTypeNodeFromType(type: MappedType) {
                Debug.fail("implement me");
                // Debug.assert(!!(type.flags & TypeFlags.Object));
                // //const readonlyToken = type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined;
                // //const questionToken = type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined;
                // let appropriateConstraintTypeNode: TypeNode;
                // let newTypeVariable: TypeReferenceNode | undefined;
                // // If the mapped type isn't `keyof` constraint-declared, _but_ still has modifiers preserved, and its naive instantiation won't preserve modifiers because its constraint isn't `keyof` constrained, we have work to do
                // const needsModifierPreservingWrapper = !isMappedTypeWithKeyofConstraintDeclaration(type)
                //     && !(getModifiersTypeFromMappedType(type).flags & TypeFlags.Unknown)
                //     && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams
                //     && !(getConstraintTypeFromMappedType(type).flags & TypeFlags.TypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type))?.flags! & TypeFlags.Index);
                // if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                //     // We have a { [P in keyof T]: X }
                //     // We do this to ensure we retain the toplevel keyof-ness of the type which may be lost due to keyof distribution during `getConstraintTypeFromMappedType`
                //     if (isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type) && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
                //         const newParam = createTypeParameter(createSymbol(SymbolFlags.TypeParameter, "T" as string));
                //         const name = typeParameterToName(newParam, context);
                //         newTypeVariable = factory.createTypeReferenceNode(name);
                //     }
                //     appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context));
                // }
                // else if (needsModifierPreservingWrapper) {
                //     // So, step 1: new type variable
                //     const newParam = createTypeParameter(createSymbol(SymbolFlags.TypeParameter, "T" as string));
                //     const name = typeParameterToName(newParam, context);
                //     newTypeVariable = factory.createTypeReferenceNode(name);
                //     // step 2: make that new type variable itself the constraint node, making the mapped type `{[K in T_1]: Template}`
                //     appropriateConstraintTypeNode = newTypeVariable;
                // }
                // else {
                //     appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context);
                // }
                // const typeParameterNode = typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type), context, appropriateConstraintTypeNode);
                // const nameTypeNode = type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined;
                // const templateTypeNode = typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type), !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), context);
                // const mappedTypeNode = factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, /*members*/ undefined);
                // context.approximateLength += 10;
                // const result = setEmitFlags(mappedTypeNode, EmitFlags.SingleLine);
                // if (isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type) && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
                //     // homomorphic mapped type with a non-homomorphic naive inlining
                //     // wrap it with a conditional like `SomeModifiersType extends infer U ? {..the mapped type...} : never` to ensure the resulting
                //     // type stays homomorphic
                //     const originalConstraint = instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type.declaration.typeParameter.constraint! as TypeOperatorNode).type) as TypeParameter) || unknownType, type.mapper);
                //     return factory.createConditionalTypeNode(
                //         typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context),
                //         factory.createInferTypeNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, factory.cloneNode(newTypeVariable!.typeName) as Identifier, originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context))),
                //         result,
                //         factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
                //     );
                // }
                // else if (needsModifierPreservingWrapper) {
                //     // and step 3: once the mapped type is reconstructed, create a `ConstraintType extends infer T_1 extends keyof ModifiersType ? {[K in T_1]: Template} : never`
                //     // subtly different from the `keyof` constraint case, by including the `keyof` constraint on the `infer` type parameter, it doesn't rely on the constraint type being itself
                //     // constrained to a `keyof` type to preserve its modifier-preserving behavior. This is all basically because we preserve modifiers for a wider set of mapped types than
                //     // just homomorphic ones.
                //     return factory.createConditionalTypeNode(
                //         typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context),
                //         factory.createInferTypeNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, factory.cloneNode(newTypeVariable!.typeName) as Identifier, factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context)))),
                //         result,
                //         factory.createKeywordTypeNode(SyntaxKind.NeverKeyword),
                //     );
                // }
                // return result;
            }

            function createAnonymousTypeNode(type: ObjectType): TypeNode {
                const typeId = type.id;
                const symbol = type.symbol;
                if (symbol) {
                    const isInstantiationExpressionType = !!(getObjectFlags(type) & ObjectFlags.InstantiationExpressionType);
                    if (isInstantiationExpressionType) {
                        const instantiationExpressionType = type as InstantiationExpressionType;
                        const existing = instantiationExpressionType.node;
                        // if (isTypeQueryNode(existing)) {
                        //     const typeNode = tryReuseExistingNonParameterTypeNode(context, existing, type);
                        //     if (typeNode) {
                        //         return typeNode;
                        //     }
                        // }
                        if (context.visitedTypes?.has(typeId)) {
                            return createElidedInformationPlaceholder(context);
                        }
                        return visitAndTransformType(type, createTypeNodeFromObjectType);
                    }
                    // const isInstanceType = isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value;
                    // if (isJSConstructor(symbol.valueDeclaration)) {
                    //     // Instance and static types share the same symbol; only add 'typeof' for the static side.
                    //     return symbolToTypeNode(symbol, context, isInstanceType);
                    // } else
                    // Always use 'typeof T' for type of class, enum, and module objects
                    // if (
                    //     symbol.flags & SymbolFlags.Class
                    //         && !getBaseTypeVariableOfClass(symbol)
                    //         && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, /*shouldComputeAliasesToMakeVisible*/ false).accessibility !== SymbolAccessibility.Accessible)) ||
                    //     symbol.flags & (SymbolFlags.Enum | SymbolFlags.ValueModule) ||
                    //     shouldWriteTypeOfFunctionSymbol()
                    // ) {
                    //     return symbolToTypeNode(symbol, context, isInstanceType);
                    // } else
                    if (context.visitedTypes?.has(typeId)) {
                        // If type is an anonymous type literal in a type alias declaration, use type alias name
                        const typeAlias = getTypeAliasForTypeLiteral(type);
                        if (typeAlias) {
                            // The specified symbol flags need to be reinterpreted as type flags
                            return symbolToTypeNode(typeAlias, context, SymbolFlags.Type);
                        }
                        else {
                            return createElidedInformationPlaceholder(context);
                        }
                    }
                    else {
                        return visitAndTransformType(type, createTypeNodeFromObjectType);
                    }
                }
                else {
                    // Anonymous types without a symbol are never circular.
                    return createTypeNodeFromObjectType(type);
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    // const isStaticMethodSymbol = !!(symbol.flags & SymbolFlags.Method) && // typeof static method
                    //     some(symbol.declarations, declaration => isStatic(declaration));
                    const isNonLocalFunctionSymbol = !!(symbol.flags & SymbolFlags.Function) &&
                        (symbol.parent || // is exported function symbol
                            forEach(symbol.declarations, declaration => declaration.parent.kind === SyntaxKind.SourceFile));// || declaration.parent.kind === SyntaxKind.ModuleBlock));
                    if (isNonLocalFunctionSymbol) {
                        // typeof is allowed only for static/non local functions
                        return (!!(context.flags & NodeBuilderFlags.UseTypeOfFunction) || (context.visitedTypes?.has(typeId))) && // it is type of the symbol uses itself recursively
                            (!(context.flags & NodeBuilderFlags.UseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration)); // And the build is going to succeed without visibility error or there is no structural fallback allowed
                    }
                }
            }

            function visitAndTransformType<T extends Type>(type: T, transform: (type: T) => TypeNode) {
                const typeId = type.id;
                const isConstructorObject = getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & SymbolFlags.Class;
                const id = getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) :
                    type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) :
                    type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :
                    undefined;
                // Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
                // of types allows us to catch circular references to instantiations of the same anonymous type
                if (!context.visitedTypes) {
                    context.visitedTypes = new Set();
                }
                if (id && !context.symbolDepth) {
                    context.symbolDepth = new Map();
                }

                const links = context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration);
                const key = `${getTypeId(type)}|${context.flags}`;
                if (links) {
                    links.serializedTypes ||= new Map();
                }
                const cachedResult = links?.serializedTypes?.get(key);
                if (cachedResult) {
                    // TODO:: check if we instead store late painted statements associated with this?
                    cachedResult.trackedSymbols?.forEach(
                        ([symbol, enclosingDeclaration, meaning]) =>
                            context.tracker.trackSymbol(
                                symbol,
                                enclosingDeclaration,
                                meaning,
                            ),
                    );
                    if (cachedResult.truncating) {
                        context.truncating = true;
                    }
                    context.approximateLength += cachedResult.addedLength;
                    return deepCloneOrReuseNode(cachedResult.node);
                }

                let depth: number | undefined;
                if (id) {
                    depth = context.symbolDepth!.get(id) || 0;
                    if (depth > 10) {
                        return createElidedInformationPlaceholder(context);
                    }
                    context.symbolDepth!.set(id, depth + 1);
                }
                context.visitedTypes.add(typeId);
                const prevTrackedSymbols = context.trackedSymbols;
                context.trackedSymbols = undefined;
                const startLength = context.approximateLength;
                const result = transform(type);
                const addedLength = context.approximateLength - startLength;
                if (!context.reportedDiagnostic && !context.encounteredError) {
                    links?.serializedTypes?.set(key, {
                        node: result,
                        truncating: context.truncating,
                        addedLength,
                        trackedSymbols: context.trackedSymbols,
                    });
                }
                context.visitedTypes.delete(typeId);
                if (id) {
                    context.symbolDepth!.set(id, depth!);
                }
                context.trackedSymbols = prevTrackedSymbols;
                return result;

                function deepCloneOrReuseNode<T extends Node>(node: T): T {
                    if (!nodeIsSynthesized(node) && getParseTreeNode(node) === node) {
                        return node;
                    }                    
                    return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode, /*context*/ undefined, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node);
                }

                function deepCloneOrReuseNodes(
                    nodes: NodeArray<Node> | undefined,
                    visitor: Visitor,
                    test?: (node: Node) => boolean,
                    start?: number,
                    count?: number,
                ): NodeArray<Node> | undefined {
                    if (nodes && nodes.length === 0) {
                        // Ensure we explicitly make a copy of an empty array; visitNodes will not do this unless the array has elements,
                        // which can lead to us reusing the same empty NodeArray more than once within the same AST during type noding.
                        return setTextRangeWorker(factory.createNodeArray(/*elements*/ undefined, nodes.hasTrailingComma), nodes);
                    }
                    return visitNodes(nodes, visitor, test, start, count);
                }
            }

            function createTypeNodeFromObjectType(type: ObjectType): TypeNode {
                // if (isGenericMappedType(type) || (type as MappedType).containsError) {
                //     return createMappedTypeNodeFromType(type as MappedType);
                // }

                const resolved = resolveStructuredTypeMembers(type);
                if (!resolved.properties.length && !resolved.indexInfos.length) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        context.approximateLength += 2;
                        return setEmitFlags(factory.createTypeLiteralNode(/*members*/ undefined), EmitFlags.SingleLine);
                    }

                    if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                        const signature = resolved.callSignatures[0];
                        const signatureNode = signatureToSignatureDeclarationHelper(signature, SyntaxKind.FunctionType, context) as FunctionTypeNode;
                        return signatureNode;
                    }

                    // if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                    //     const signature = resolved.constructSignatures[0];
                    //     const signatureNode = signatureToSignatureDeclarationHelper(signature, SyntaxKind.ConstructorType, context) as ConstructorTypeNode;
                    //     return signatureNode;
                    // }
                }

                const abstractSignatures = filter(resolved.constructSignatures, signature => !!(signature.flags & SignatureFlags.Abstract));
                if (some(abstractSignatures)) {
                    const types = map(abstractSignatures, s => getOrCreateTypeFromSignature(s));
                    // count the number of type elements excluding abstract constructors
                    const typeElementCount = resolved.callSignatures.length +
                        (resolved.constructSignatures.length - abstractSignatures.length) +
                        resolved.indexInfos.length +
                        // exclude `prototype` when writing a class expression as a type literal, as per
                        // the logic in `createTypeNodesFromResolvedType`.
                        (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ?
                            countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) :
                            length(resolved.properties));
                    // don't include an empty object literal if there were no other static-side
                    // properties to write, i.e. `abstract class C { }` becomes `abstract new () => {}`
                    // and not `(abstract new () => {}) & {}`
                    // if (typeElementCount) {
                    //     // create a copy of the object type without any abstract construct signatures.
                    //     types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved));
                    // }
                    Debug.fail("not supported");
                    // return typeToTypeNodeHelper(getIntersectionType(types), context);
                }

                const savedFlags = context.flags;
                context.flags |= NodeBuilderFlags.InObjectTypeLiteral;
                const members = createTypeNodesFromResolvedType(resolved);
                context.flags = savedFlags;
                const typeLiteralNode = factory.createTypeLiteralNode(members);
                context.approximateLength += 2;
                setEmitFlags(typeLiteralNode, (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine);
                return typeLiteralNode;
            }

            function typeReferenceToTypeNode(type: TypeReference) {
                let typeArguments: readonly Type[] = getTypeArguments(type);
                
                if (type.target === globalMappingType) {
                    return factory.createTypeReferenceNode("mapping");
                }                
                else if (type.target === globalArrayType || type.target === globalReadonlyArrayType) {
                    if (context.flags & NodeBuilderFlags.WriteArrayAsGenericType) {
                        const typeArgumentNode = typeToTypeNodeHelper(typeArguments[0], context);
                        return factory.createTypeReferenceNode(type.target === globalArrayType ? "Array" : "ReadonlyArray", [typeArgumentNode]);
                    }
                    const elementType = typeToTypeNodeHelper(typeArguments[0], context);
                    const arrayType = factory.createArrayTypeNode(elementType);
                    // Debug.fail("not supported");
                    // return type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, arrayType);
                    return arrayType;
                }
                else if (type.target.objectFlags & ObjectFlags.Tuple) {
                    typeArguments = sameMap(typeArguments, (t, i) => removeMissingType(t, !!((type.target as TupleType).elementFlags[i] & ElementFlags.Optional)));
                    console.debug("todo - tuple type");
                    // if (typeArguments.length > 0) {
                    //     const arity = getTypeReferenceArity(type);
                    //     const tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, arity), context);
                    //     if (tupleConstituentNodes) {
                    //         const { labeledElementDeclarations } = type.target as TupleType;
                    //         for (let i = 0; i < tupleConstituentNodes.length; i++) {
                    //             const flags = (type.target as TupleType).elementFlags[i];
                    //             const labeledElementDeclaration = labeledElementDeclarations?.[i];

                    //             if (labeledElementDeclaration) {
                    //                 tupleConstituentNodes[i] = factory.createNamedTupleMember(
                    //                     flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined,
                    //                     factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))),
                    //                     flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,
                    //                     flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) :
                    //                         tupleConstituentNodes[i],
                    //                 );
                    //             }
                    //             else {
                    //                 tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :
                    //                     flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) :
                    //                     tupleConstituentNodes[i];
                    //             }
                    //         }
                    //         const tupleTypeNode = setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlags.SingleLine);
                    //         return (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode;
                    //     }
                    // }
                    // if (context.encounteredError || (context.flags & NodeBuilderFlags.AllowEmptyTuple)) {
                    //     const tupleTypeNode = setEmitFlags(factory.createTupleTypeNode([]), EmitFlags.SingleLine);
                    //     return (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode;
                    // }
                    context.encounteredError = true;
                    return undefined!; // TODO: GH#18217
                }
                else if (
                    context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral &&
                    type.symbol.valueDeclaration &&
                    isClassLike(type.symbol.valueDeclaration) &&
                    !isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)
                ) {
                    return createAnonymousTypeNode(type);
                }
                else {
                    const outerTypeParameters = type.target.outerTypeParameters;
                    let i = 0;
                    let resultType: TypeReferenceNode | undefined;
                    if (outerTypeParameters) {
                        const length = outerTypeParameters.length;
                        while (i < length) {
                            // Find group of type arguments for type parameters with the same declaring container.
                            const start = i;
                            const parent = getParentSymbolOfTypeParameter(outerTypeParameters[i])!;
                            do {
                                i++;
                            }
                            while (i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);
                            // When type parameters are their own type arguments for the whole group (i.e. we have
                            // the default outer type arguments), we don't show the group.
                            if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                const typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);
                                const flags = context.flags;
                                context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;
                                const ref = symbolToTypeNode(parent, context, SymbolFlags.Type, typeArgumentSlice) as TypeReferenceNode;
                                context.flags = flags;
                                resultType = !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode);
                            }
                        }
                    }
                    let typeArgumentNodes: readonly TypeNode[] | undefined;
                    if (typeArguments.length > 0) {
                        const typeParameterCount = (type.target.typeParameters || emptyArray).length;
                        typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context);
                    }
                    const flags = context.flags;
                    context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;
                    const finalRef = symbolToTypeNode(type.symbol, context, SymbolFlags.Type, typeArgumentNodes);
                    context.flags = flags;
                    return !resultType ? finalRef : appendReferenceToType(resultType, finalRef as TypeReferenceNode);
                }
            }

            function appendReferenceToType(root: TypeReferenceNode, ref: TypeReferenceNode): TypeReferenceNode {
                // if (isImportTypeNode(root)) {
                //     // first shift type arguments
                //     let typeArguments = root.typeArguments;
                //     let qualifier = root.qualifier;
                //     if (qualifier) {
                //         if (isIdentifier(qualifier)) {
                //             if (typeArguments !== getIdentifierTypeArguments(qualifier)) {
                //                 qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments);
                //             }
                //         }
                //         else {
                //             if (typeArguments !== getIdentifierTypeArguments(qualifier.right)) {
                //                 qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments));
                //             }
                //         }
                //     }
                //     typeArguments = ref.typeArguments;
                //     // then move qualifiers
                //     const ids = getAccessStack(ref);
                //     for (const id of ids) {
                //         qualifier = qualifier ? factory.createQualifiedName(qualifier, id) : id;
                //     }
                //     return factory.updateImportTypeNode(
                //         root,
                //         root.argument,
                //         root.attributes,
                //         qualifier,
                //         typeArguments,
                //         root.isTypeOf,
                //     );
                // } else 
                {
                    // first shift type arguments
                    let typeArguments = root.typeArguments;
                    let typeName = root.typeName;
                    if (isIdentifier(typeName)) {
                        if (typeArguments !== getIdentifierTypeArguments(typeName)) {
                            typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments);
                        }
                    }
                    else {
                        Debug.fail("implement me");
                        // if (typeArguments !== getIdentifierTypeArguments(typeName.right)) {
                        //     typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments));
                        // }
                    }
                    typeArguments = ref.typeArguments;
                    // then move qualifiers
                    const ids = getAccessStack(ref);
                    for (const id of ids) {
                        typeName = factory.createQualifiedName(typeName, id);
                    }
                    Debug.fail("implement me");                    
                }
            }

            function getAccessStack(ref: TypeReferenceNode): Identifier[] {
                let state = ref.typeName;
                const ids = [];
                while (!isIdentifier(state)) {
                    ids.unshift(state.right);
                    state = state.left;
                }
                ids.unshift(state);
                return ids;
            }

            function createTypeNodesFromResolvedType(resolvedType: ResolvedType): TypeElement[] | undefined {
                if (checkTruncationLength(context)) {
                    return [factory.createPropertySignature(/*modifiers*/ undefined, "...", /*type*/ undefined)];
                }
                const typeElements: TypeElement[] = [];                
                for (const signature of resolvedType.callSignatures) {
                    console.debug("todo - callsig");
                    // typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKind.CallSignature, context) as CallSignatureDeclaration);
                }
                // for (const signature of resolvedType.constructSignatures) {
                //     if (signature.flags & SignatureFlags.Abstract) continue;
                //     typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKind.ConstructSignature, context) as ConstructSignatureDeclaration);
                // }
                for (const info of resolvedType.indexInfos) {
                    typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined));
                }

                const properties = resolvedType.properties;
                if (!properties) {
                    return typeElements;
                }

                let i = 0;
                for (const propertySymbol of properties) {
                    i++;
                    if (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral) {
                        if (propertySymbol.flags & SymbolFlags.Prototype) {
                            continue;
                        }
                        if (getDeclarationModifierFlagsFromSymbol(propertySymbol) & (ModifierFlags.Private | ModifierFlags.Protected) && context.tracker.reportPrivateInBaseOfClassExpression) {
                            context.tracker.reportPrivateInBaseOfClassExpression((propertySymbol.name));
                        }
                    }
                    if (checkTruncationLength(context) && (i + 2 < properties.length - 1)) {
                        typeElements.push(factory.createPropertySignature(/*modifiers*/ undefined, `... ${properties.length - i} more ...`,  /*type*/ undefined));
                        addPropertyToElementList(properties[properties.length - 1], context, typeElements);
                        break;
                    }
                    addPropertyToElementList(propertySymbol, context, typeElements);
                }
                return typeElements.length ? typeElements : undefined;
            }
        }

        function shouldUsePlaceholderForProperty(propertySymbol: Symbol, context: NodeBuilderContext) {
            // Use placeholders for reverse mapped types we've either
            // (1) already descended into, or
            // (2) are nested reverse mappings within a mapping over a non-anonymous type, or
            // (3) are deeply nested properties that originate from the same mapped type.
            // Condition (2) is a restriction mostly just to
            // reduce the blowup in printback size from doing, eg, a deep reverse mapping over `Window`.
            // Since anonymous types usually come from expressions, this allows us to preserve the output
            // for deep mappings which likely come from expressions, while truncating those parts which
            // come from mappings over library functions.
            // Condition (3) limits printing of possibly infinitely deep reverse mapped types.
            const depth = 3;
            return !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped)
                && (
                    contains(context.reverseMappedStack, propertySymbol as ReverseMappedSymbol)
                    || (
                        context.reverseMappedStack?.[0]
                        && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlags.Anonymous)
                    )
                    || isDeeplyNestedReverseMappedTypeProperty()
                );
            function isDeeplyNestedReverseMappedTypeProperty() {
                if ((context.reverseMappedStack?.length ?? 0) < depth) {
                    return false;
                }
                for (let i = 0; i < depth; i++) {
                    const prop = context.reverseMappedStack![context.reverseMappedStack!.length - 1 - i];
                    if (prop.links.mappedType.symbol !== (propertySymbol as ReverseMappedSymbol).links.mappedType.symbol) {
                        return false;
                    }
                }
                return true;
            }
        }
        
        function isStringNamed(d: Declaration) {
            const name = getNameOfDeclaration(d);
            if (!name) {
                return false;
            }
            if (isComputedPropertyName(name)) {
                const type = checkExpression(name.expression);
                return !!(type.flags & TypeFlags.StringLike);
            }
            if (isElementAccessExpression(name)) {
                const type = checkExpression(name.argumentExpression);
                return !!(type.flags & TypeFlags.StringLike);
            }
            return isStringLiteral(name);
        }

        function isSingleQuotedStringNamed(d: Declaration) {
            const name = getNameOfDeclaration(d);
            return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, /*includeTrivia*/ false), "'")));
        }


        function getPropertyNameNodeForSymbol(symbol: Symbol, context: NodeBuilderContext) {
            const stringNamed = !!length(symbol.declarations) && every(symbol.declarations, isStringNamed);
            const singleQuote = !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed);
            const isMethod = !!(symbol.flags & SymbolFlags.Method);
            const fromNameType = getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod);
            if (fromNameType) {
                return fromNameType;
            }
            const rawName = (symbol.name);
            return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod);
        }

        // See getNameForSymbolFromNameType for a stringy equivalent
        function getPropertyNameNodeForSymbolFromNameType(symbol: Symbol, context: NodeBuilderContext, singleQuote: boolean, stringNamed: boolean, isMethod: boolean) {
            const nameType = getSymbolLinks(symbol).nameType;
            if (nameType) {
                if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
                    const name = "" + (nameType as StringLiteralType | IntLiteralType).value;
                    if (!isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name))) {
                        return factory.createStringLiteral(name, !!singleQuote);
                    }
                    if (isNumericLiteralName(name) && startsWith(name, "-")) {
                        return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createIntLiteral(-name)));
                    }
                    return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod);
                }                
            }
        }

        function addPropertyToElementList(propertySymbol: Symbol, context: NodeBuilderContext, typeElements: TypeElement[]) {
            const propertyIsReverseMapped = !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped);
            const propertyType = shouldUsePlaceholderForProperty(propertySymbol, context) ?
                anyType : getNonMissingTypeOfSymbol(propertySymbol);
            const saveEnclosingDeclaration = context.enclosingDeclaration;
            context.enclosingDeclaration = undefined;
            if (context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.name)) {
                if (propertySymbol.declarations) {
                    const decl = first(propertySymbol.declarations);
                    if (hasLateBindableName(decl)) {
                        if (isBinaryExpression(decl)) {
                            const name = getNameOfDeclaration(decl);
                            if (name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression)) {
                                trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context);
                            }
                        }
                        else {
                            trackComputedName(decl.name.expression, saveEnclosingDeclaration, context);
                        }
                    }
                }
                else {
                    context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol));
                }
            }
            context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations?.[0] || saveEnclosingDeclaration;
            const propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
            context.enclosingDeclaration = saveEnclosingDeclaration;
            context.approximateLength += symbolName(propertySymbol).length + 1;
            
            const optionalToken = propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined;
            if (propertySymbol.flags & (SymbolFlags.Function | SymbolFlags.Method) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol)) {
                const signatures = getSignaturesOfType(filterType(propertyType, t => !(t.flags & TypeFlags.Undefined)), SignatureKind.Call);
                for (const signature of signatures) {
                    const methodDeclaration = signatureToSignatureDeclarationHelper(signature, SyntaxKind.MethodSignature, context, { name: propertyName/*, questionToken: optionalToken*/ }) as MethodSignature;
                    typeElements.push(preserveCommentsOn(methodDeclaration));
                }
                if (signatures.length || !optionalToken) {
                    return;
                }
            }
            let propertyTypeNode: TypeNode;
            if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
                propertyTypeNode = createElidedInformationPlaceholder(context);
            }
            else {
                if (propertyIsReverseMapped) {
                    context.reverseMappedStack ||= [];
                    context.reverseMappedStack.push(propertySymbol as ReverseMappedSymbol);
                }
                propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, /*declaration*/ undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
                if (propertyIsReverseMapped) {
                    context.reverseMappedStack!.pop();
                }
            }

            const modifiers = undefined;// isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined;
            if (modifiers) {
                context.approximateLength += 9;
            }
            const propertySignature = factory.createPropertySignature(
                modifiers,
                propertyName,
                // optionalToken,
                propertyTypeNode,
            );

            typeElements.push(preserveCommentsOn(propertySignature));

            function preserveCommentsOn<T extends Node>(node: T) {
                const jsdocPropertyTag = propertySymbol.declarations?.find((d): d is JSDocPropertyTag => d.kind === SyntaxKind.JSDocPropertyTag);
                if (jsdocPropertyTag) {
                    const commentText = getTextOfJSDocComment(jsdocPropertyTag.comment);
                    if (commentText) {
                        setSyntheticLeadingComments(node, [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]);
                    }
                }
                else if (propertySymbol.valueDeclaration) {
                    // Copy comments to node for declaration emit
                    setCommentRange(context, node, propertySymbol.valueDeclaration);
                }
                return node;
            }
        }

        function setCommentRange<T extends Node>(context: NodeBuilderContext, node: T, range: Node): T {
            if (context.enclosingFile && context.enclosingFile === getSourceFileOfNode(range)) {
                // Copy comments to node for declaration emit
                return setCommentRangeWorker(node, range);
            }
            return node;
        }
        
        function indexInfoToIndexSignatureDeclarationHelper(indexInfo: IndexInfo, context: NodeBuilderContext, typeNode: TypeNode | undefined): IndexSignatureDeclaration {
            const name = getNameFromIndexInfo(indexInfo) || "x";
            const indexerTypeNode = typeToTypeNodeHelper(indexInfo.keyType, context);

            const indexingParameter = factory.createParameterDeclaration(
                /*modifiers*/ undefined,
                /*dotDotDotToken*/ undefined,
                name,
                /*questionToken*/ undefined,
                indexerTypeNode,
                /*initializer*/ undefined,
            );
            if (!typeNode) {
                typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context);
            }
            if (!indexInfo.type && !(context.flags & NodeBuilderFlags.AllowEmptyIndexInfoType)) {
                context.encounteredError = true;
            }
            context.approximateLength += name.length + 4;
            return factory.createIndexSignature(
                undefined,
                [indexingParameter],
                typeNode,
            );
        }

        function createElidedInformationPlaceholder(context: NodeBuilderContext) {
            context.approximateLength += 3;
            if (!(context.flags & NodeBuilderFlags.NoTruncation)) {
                return factory.createTypeReferenceNode(factory.createIdentifier("..."), /*typeArguments*/ undefined);
            }
            return factory.createKeywordTypeNode(SyntaxKind.AnyKeyword);
        }

        interface SignatureToSignatureDeclarationOptions {
            modifiers?: readonly Modifier[];
            name?: PropertyName;
            //questionToken?: QuestionToken;
        }

        function cloneNodeBuilderContext(context: NodeBuilderContext) {
            // Make type parameters created within this context not consume the name outside this context
            // The symbol serializer ends up creating many sibling scopes that all need "separate" contexts when
            // it comes to naming things - within a normal `typeToTypeNode` call, the node builder only ever descends
            // through the type tree, so the only cases where we could have used distinct sibling scopes was when there
            // were multiple generic overloads with similar generated type parameter names
            // The effect:
            // When we write out
            // export const x: <T>(x: T) => T
            // export const y: <T>(x: T) => T
            // we write it out like that, rather than as
            // export const x: <T>(x: T) => T
            // export const y: <T_1>(x: T_1) => T_1
            const oldMustCreateTypeParameterSymbolList = context.mustCreateTypeParameterSymbolList;
            const oldMustCreateTypeParametersNamesLookups = context.mustCreateTypeParametersNamesLookups;
            context.mustCreateTypeParameterSymbolList = true;
            context.mustCreateTypeParametersNamesLookups = true;
            const oldTypeParameterNames = context.typeParameterNames;
            const oldTypeParameterNamesByText = context.typeParameterNamesByText;
            const oldTypeParameterNamesByTextNextNameCount = context.typeParameterNamesByTextNextNameCount;
            const oldTypeParameterSymbolList = context.typeParameterSymbolList;
            return () => {
                context.typeParameterNames = oldTypeParameterNames;
                context.typeParameterNamesByText = oldTypeParameterNamesByText;
                context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount;
                context.typeParameterSymbolList = oldTypeParameterSymbolList;
                context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList;
                context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups;
            };
        }

        function typeParameterShadowsOtherTypeParameterInScope(escapedName: string, context: NodeBuilderContext, type: TypeParameter) {
            const result = resolveName(context.enclosingDeclaration, escapedName, SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
            if (result && result.flags & SymbolFlags.TypeParameter) {
                return result !== type.symbol;
            }
            return false;
        }

        function typeParameterToName(type: TypeParameter, context: NodeBuilderContext) {
            if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && context.typeParameterNames) {
                const cached = context.typeParameterNames.get(getTypeId(type));
                if (cached) {
                    return cached;
                }
            }
            let result = symbolToName(type.symbol, context, SymbolFlags.Type, /*expectsIdentifier*/ true);
            if (!(result.kind & SyntaxKind.Identifier)) {
                return factory.createIdentifier("(Missing type parameter)");
            }
            const decl = type.symbol?.declarations?.[0];
            if (decl && isTypeParameterDeclaration(decl)) {
                result = setTextRange(context, result, decl.name);
            }
            if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams) {
                const rawtext = result.text as string;
                let i = context.typeParameterNamesByTextNextNameCount?.get(rawtext) || 0;
                let text = rawtext;
                while (context.typeParameterNamesByText?.has(text) || typeParameterShadowsOtherTypeParameterInScope(text as string, context, type)) {
                    i++;
                    text = `${rawtext}_${i}`;
                }
                if (text !== rawtext) {
                    const typeArguments = getIdentifierTypeArguments(result);
                    result = factory.createIdentifier(text);
                    setIdentifierTypeArguments(result, typeArguments);
                }
                if (context.mustCreateTypeParametersNamesLookups) {
                    context.mustCreateTypeParametersNamesLookups = false;
                    context.typeParameterNames = new Map(context.typeParameterNames);
                    context.typeParameterNamesByTextNextNameCount = new Map(context.typeParameterNamesByTextNextNameCount);
                    context.typeParameterNamesByText = new Set(context.typeParameterNamesByText);
                }
                // avoiding iterations of the above loop turns out to be worth it when `i` starts to get large, so we cache the max
                // `i` we've used thus far, to save work later
                context.typeParameterNamesByTextNextNameCount!.set(rawtext, i);
                context.typeParameterNames!.set(getTypeId(type), result);
                context.typeParameterNamesByText!.add(text);
            }
            return result;
        }
        
        type IntroducesNewScopeNode = SignatureDeclaration | JSDocSignature | MappedTypeNode;

        function enterNewScope(
            context: NodeBuilderContext,
            declaration: IntroducesNewScopeNode | ConditionalTypeNode | undefined,
            expandedParams: readonly Symbol[] | undefined,
            typeParameters: readonly TypeParameter[] | undefined,
            originalParameters?: readonly Symbol[] | undefined,
            mapper?: TypeMapper,
        ) {
            const cleanupContext = cloneNodeBuilderContext(context);
            // For regular function/method declarations, the enclosing declaration will already be signature.declaration,
            // so this is a no-op, but for arrow functions and function expressions, the enclosing declaration will be
            // the declaration that the arrow function / function expression is assigned to.
            //
            // If the parameters or return type include "typeof globalThis.paramName", using the wrong scope will lead
            // us to believe that we can emit "typeof paramName" instead, even though that would refer to the parameter,
            // not the global. Make sure we are in the right scope by changing the enclosingDeclaration to the function.
            //
            // We can't use the declaration directly; it may be in another file and so we may lose access to symbols
            // accessible to the current enclosing declaration, or gain access to symbols not accessible to the current
            // enclosing declaration. To keep this chain accurate, insert a fake scope into the chain which makes the
            // function's parameters visible.
            let cleanupParams: (() => void) | undefined;
            let cleanupTypeParams: (() => void) | undefined;
            const oldEnclosingDecl = context.enclosingDeclaration;
            const oldMapper = context.mapper;
            if (mapper) {
                context.mapper = mapper;
            }
            if (context.enclosingDeclaration && declaration) {
                // As a performance optimization, reuse the same fake scope within this chain.
                // This is especially needed when we are working on an excessively deep type;
                // if we don't do this, then we spend all of our time adding more and more
                // scopes that need to be searched in isSymbolAccessible later. Since all we
                // really want to do is to mark certain names as unavailable, we can just keep
                // all of the names we're introducing in one large table and push/pop from it as
                // needed; isSymbolAccessible will walk upward and find the closest "fake" scope,
                // which will conveniently report on any and all faked scopes in the chain.
                //
                // It'd likely be better to store this somewhere else for isSymbolAccessible, but
                // since that API _only_ uses the enclosing declaration (and its parents), this is
                // seems like the best way to inject names into that search process.
                //
                // Note that we only check the most immediate enclosingDeclaration; the only place we
                // could potentially add another fake scope into the chain is right here, so we don't
                // traverse all ancestors.
                cleanupParams = !some(expandedParams) ? undefined : pushFakeScope(
                    "params",
                    add => {
                        if (!expandedParams) return;
                        for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) {
                            const param = expandedParams[pIndex];
                            const originalParam = originalParameters?.[pIndex];
                            if (originalParameters && originalParam !== param) {
                                // Can't reference parameters that come from an expansion
                                add(param.name, unknownSymbol);
                                // Can't reference the original expanded parameter either
                                if (originalParam) {
                                    add(originalParam.name, unknownSymbol);
                                }
                            }
                            else if (
                                !forEach(param.declarations, d => {
                                    if (isParameter(d) && isBindingPattern(d.name)) {
                                        bindPattern(d.name);
                                        return true;
                                    }
                                    return undefined;
                                    function bindPattern(p: BindingPattern): void {
                                        forEach(p.elements, e => {
                                            switch (e.kind) {
                                                // case SyntaxKind.OmittedExpression:
                                                //     return;
                                                case SyntaxKind.BindingElement:
                                                    return bindElement(e);
                                                default:
                                                    return Debug.assertNever(e as never);
                                            }
                                        });
                                    }
                                    function bindElement(e: BindingElement): void {
                                        if (isBindingPattern(e.name)) {
                                            return bindPattern(e.name);
                                        }
                                        const symbol = getSymbolOfDeclaration(e);
                                        add(symbol.name, symbol);
                                    }
                                })
                            ) {
                                add(param.name, param);
                            }
                        }
                    },
                );

                if (context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && some(typeParameters)) {
                    cleanupTypeParams = pushFakeScope(
                        "typeParams",
                        add => {
                            for (const typeParam of typeParameters ?? emptyArray) {
                                const typeParamName = typeParameterToName(typeParam, context).text;
                                add(typeParamName, typeParam.symbol);
                            }
                        },
                    );
                }

                function pushFakeScope(kind: "params" | "typeParams", addAll: (addSymbol: (name: string, symbol: Symbol) => void) => void) {
                    // We only ever need to look two declarations upward.
                    Debug.assert(context.enclosingDeclaration);
                    let existingFakeScope: Node | undefined;
                    if (getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration === kind) {
                        existingFakeScope = context.enclosingDeclaration;
                    }
                    else if (context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration === kind) {
                        existingFakeScope = context.enclosingDeclaration.parent;
                    }
                    Debug.assertOptionalNode(existingFakeScope, isBlock);

                    const locals = existingFakeScope?.locals ?? createSymbolTable();
                    let newLocals: string[] | undefined;
                    let oldLocals: { name: string; oldSymbol: Symbol; }[] | undefined;
                    addAll((name, symbol) => {
                        // Add cleanup information only if we don't own the fake scope
                        if (existingFakeScope) {
                            const oldSymbol = locals.get(name);
                            if (!oldSymbol) {
                                newLocals = append(newLocals, name);
                            }
                            else {
                                oldLocals = append(oldLocals, { name, oldSymbol });
                            }
                        }
                        locals.set(name, symbol);
                    });

                    if (!existingFakeScope) {
                        // Use a Block for this; the type of the node doesn't matter so long as it
                        // has locals, and this is cheaper/easier than using a function-ish Node.
                        const fakeScope = factory.createBlock(emptyArray);
                        getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind;
                        fakeScope.locals = locals;

                        setParent(fakeScope, context.enclosingDeclaration);
                        context.enclosingDeclaration = fakeScope;
                    }
                    else {
                        // We did not create the current scope, so we have to clean it up
                        return function undo() {
                            forEach(newLocals, s => locals.delete(s));
                            forEach(oldLocals, s => locals.set(s.name, s.oldSymbol));
                        };
                    }
                }
            }

            return () => {
                cleanupParams?.();
                cleanupTypeParams?.();
                cleanupContext();
                context.enclosingDeclaration = oldEnclosingDecl;
                context.mapper = oldMapper;
            };
        }

        // function typeParameterToDeclarationWithConstraint(type: TypeParameter, context: NodeBuilderContext, constraintNode: TypeNode | undefined): TypeParameterDeclaration {
        //     const savedContextFlags = context.flags;
        //     context.flags &= ~NodeBuilderFlags.WriteTypeParametersInQualifiedName; // Avoids potential infinite loop when building for a claimspace with a generic
        //     const modifiers = factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type));
        //     const name = typeParameterToName(type, context);
        //     const defaultParameter = getDefaultFromTypeParameter(type);
        //     const defaultParameterNode = defaultParameter && typeToTypeNodeHelper(defaultParameter, context);
        //     context.flags = savedContextFlags;
        //     return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode);
        // }
        
        // function signatureToSignatureDeclarationHelper(signature: Signature, kind: SignatureDeclaration["kind"], context: NodeBuilderContext, options?: SignatureToSignatureDeclarationOptions): SignatureDeclaration {
        //     let typeParameters: TypeParameterDeclaration[] | undefined;
        //     let typeArguments: TypeNode[] | undefined;

        //     const expandedParams = getExpandedParameters(signature, /*skipUnionExpanding*/ true)[0];
        //     const cleanup = enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper);
        //     context.approximateLength += 3; // Usually a signature contributes a few more characters than this, but 3 is the minimum

        //     if (context.flags & NodeBuilderFlags.WriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters) {
        //         typeArguments = signature.target.typeParameters.map(parameter => typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context));
        //     }
        //     else {
        //         typeParameters = signature.typeParameters && signature.typeParameters.map(parameter => typeParameterToDeclaration(parameter, context));
        //     }

        //     const flags = context.flags;
        //     context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; // SuppressAnyReturnType should only apply to the signature `return` position
        //     // If the expanded parameter list had a variadic in a non-trailing position, don't expand it
        //     const parameters = (some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams).map(parameter => symbolToParameterDeclaration(parameter, context, kind === SyntaxKind.Constructor));
        //     const thisParameter = context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context);
        //     if (thisParameter) {
        //         parameters.unshift(thisParameter);
        //     }
        //     context.flags = flags;

        //     const returnTypeNode = serializeReturnTypeForSignature(context, signature);

        //     let modifiers = options?.modifiers;
        //     if ((kind === SyntaxKind.ConstructorType) && signature.flags & SignatureFlags.Abstract) {
        //         const flags = modifiersToFlags(modifiers);
        //         modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlags.Abstract);
        //     }

        //     const node = kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :
        //         kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :
        //         kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) :
        //         kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken*/ undefined, options?.name ?? factory.createIdentifier(""), /*questionToken*/ undefined, typeParameters, parameters, returnTypeNode, /*body*/ undefined) :
        //         kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body*/ undefined) :
        //         kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body*/ undefined) :
        //         kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body*/ undefined) :
        //         kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :
        //         kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) :
        //         kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :
        //         kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :
        //         kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken*/ undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body*/ undefined) :
        //         kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken*/ undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) :
        //         kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken*/ undefined, factory.createBlock([])) :
        //         Debug.assertNever(kind);

        //     if (typeArguments) {
        //         node.typeArguments = factory.createNodeArray(typeArguments);
        //     }
        //     if (signature.declaration?.kind === SyntaxKind.JSDocSignature && signature.declaration.parent.kind === SyntaxKind.JSDocOverloadTag) {
        //         const comment = getTextOfNode(signature.declaration.parent.parent, /*includeTrivia*/ true).slice(2, -2).split(/\r\n|\n|\r/).map(line => line.replace(/^\s+/, " ")).join("\n");
        //         addSyntheticLeadingComment(node, SyntaxKind.MultiLineCommentTrivia, comment, /*hasTrailingNewLine*/ true);
        //     }

        //     cleanup?.();
        //     return node;
        // }
        
        function symbolToExpression(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags) {
            const chain = lookupSymbolChain(symbol, context, meaning);

            return createExpressionFromSymbolChain(chain, chain.length - 1);

            function createExpressionFromSymbolChain(chain: Symbol[], index: number): Expression {
                //const typeParameterNodes = lookupTypeParameterNodes(chain, index, context);
                const symbol = chain[index];

                if (index === 0) {
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                }
                let symbolName = getNameOfSymbolAsWritten(symbol, context);
                if (index === 0) {
                    context.flags ^= NodeBuilderFlags.InInitialEntityName;
                }
                let firstChar = symbolName.charCodeAt(0);

                // if (isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                //     return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context));
                // }
                if (index === 0 || canUsePropertyAccess(symbolName, languageVersion)) {
                    const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                    //if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                    identifier.symbol = symbol;

                    return index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier;
                }
                else {
                    if (firstChar === CharacterCodes.openBracket) {
                        symbolName = symbolName.substring(1, symbolName.length - 1);
                        firstChar = symbolName.charCodeAt(0);
                    }
                    let expression: Expression | undefined;
                    if (isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlags.EnumMember)) {
                        expression = factory.createStringLiteral(stripQuotes(symbolName).replace(/\\./g, s => s.substring(1)), firstChar === CharacterCodes.singleQuote);
                    }
                    else if (("" + +symbolName) === symbolName) {
                        expression = factory.createIntLiteral(+symbolName);
                    }
                    if (!expression) {
                        const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                        //if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                        identifier.symbol = symbol;
                        expression = identifier;
                    }
                    return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain, index - 1), expression);
                }
            }
        }

        function symbolToNode(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags) {
            if (context.flags & NodeBuilderFlags.WriteComputedProps) {
                if (symbol.valueDeclaration) {
                    const name = getNameOfDeclaration(symbol.valueDeclaration);
                    if (name && isComputedPropertyName(name)) return name;
                }
                const nameType = getSymbolLinks(symbol).nameType;
                // if (nameType && nameType.flags & (TypeFlags.EnumLiteral | TypeFlags.UniqueESSymbol)) {
                //     context.enclosingDeclaration = nameType.symbol.valueDeclaration;
                //     return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning));
                // }
            }
            return symbolToExpression(symbol, context, meaning);
        }

        function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: true): Identifier;
        function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: false): EntityName;
        function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: boolean): EntityName {
            const chain = lookupSymbolChain(symbol, context, meaning);

            if (
                expectsIdentifier && chain.length !== 1
                && !context.encounteredError
                && !(context.flags & NodeBuilderFlags.AllowQualifiedNameInPlaceOfIdentifier)
            ) {
                context.encounteredError = true;
            }
            return createEntityNameFromSymbolChain(chain, chain.length - 1);

            function createEntityNameFromSymbolChain(chain: Symbol[], index: number): EntityName {
                //const typeParameterNodes = lookupTypeParameterNodes(chain, index, context);
                const symbol = chain[index];

                if (index === 0) {
                    context.flags |= NodeBuilderFlags.InInitialEntityName;
                }
                const symbolName = getNameOfSymbolAsWritten(symbol, context);
                if (index === 0) {
                    context.flags ^= NodeBuilderFlags.InInitialEntityName;
                }

                const identifier = setEmitFlags(factory.createIdentifier(symbolName), EmitFlags.NoAsciiEscaping);
                //if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes));
                identifier.symbol = symbol;

                return index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier;
            }
        }

    
        function withContext<T>(enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker: SymbolTracker | undefined, cb: (context: NodeBuilderContext) => T): T | undefined {
            const moduleResolverHost = tracker?.trackSymbol ? tracker.moduleResolverHost :
                flags! & NodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) :
                undefined;
            const context: NodeBuilderContext = {
                enclosingDeclaration,
                enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),
                flags: flags || NodeBuilderFlags.None,
                tracker: undefined!,
                encounteredError: false,
                reportedDiagnostic: false,
                visitedTypes: undefined,
                symbolDepth: undefined,
                inferTypeParameters: undefined,
                approximateLength: 0,
                trackedSymbols: undefined,
                bundled: false,
                truncating: false,
                usedSymbolNames: undefined,
                remappedSymbolNames: undefined,
                remappedSymbolReferences: undefined,
                reverseMappedStack: undefined,
                mustCreateTypeParameterSymbolList: true,
                typeParameterSymbolList: undefined,
                mustCreateTypeParametersNamesLookups: true,
                typeParameterNames: undefined,
                typeParameterNamesByText: undefined,
                typeParameterNamesByTextNextNameCount: undefined,
                mapper: undefined,
            };
            context.tracker = new SymbolTrackerImpl(context, tracker, moduleResolverHost);
            const resultingNode = cb(context);
            if (context.truncating && context.flags & NodeBuilderFlags.NoTruncation) {
                context.tracker.reportTruncationError();
            }
            return context.encounteredError ? undefined : resultingNode;
        }
    }

    function resolveExternalModuleName(location: Node, moduleReferenceExpression: Expression, expressionType: Type | undefined, ignoreErrors?: boolean): Symbol | undefined {
        const errorMessage = Diagnostics.Cannot_find_object_0;
        return resolveExternalModuleNameWorker(location, moduleReferenceExpression, expressionType, ignoreErrors ? undefined : errorMessage);
    }

    function resolveExternalModuleNameWorker(location: Node, moduleReferenceExpression: Expression, expressionType: Type | undefined, moduleNotFoundError: DiagnosticMessage | undefined, isForAugmentation = false): Symbol | undefined {
        let moduleRef = isStringLiteral(moduleReferenceExpression) ? moduleReferenceExpression.text : 
            isCallExpression(moduleReferenceExpression) && expressionType && isStringLiteralType(expressionType) ? expressionType.value :
            evaluate(moduleReferenceExpression)?.value as string ?? "";
        if (moduleRef === "") {
            return anyType.getSymbol();
        } else {
            return resolveExternalModule(location, moduleRef, moduleNotFoundError, moduleReferenceExpression, isForAugmentation);
        }
    }

    function resolveExternalModule(location: Node, moduleReference: string, moduleNotFoundError: DiagnosticMessage | undefined, errorNode: Node, isForAugmentation = false): Symbol | undefined {
        // if (startsWith(moduleReference, "@types/")) {
        //     const diag = Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
        //     const withoutAtTypePrefix = removePrefix(moduleReference, "@types/");
        //     error(errorNode, diag, withoutAtTypePrefix, moduleReference);
        // }

        // const ambientModule = tryFindAmbientModule(moduleReference, /*withAugmentations*/ true);
        // if (ambientModule) {
        //     return ambientModule;
        // }
        const currentSourceFile = getSourceFileOfNode(location);
        // const contextSpecifier = isStringLiteral(location)
        //     ? location
        //     : findAncestor(location, isCloneObjectExpression)?.arguments[0];
            
        //     // : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name ||
        //     //     (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal ||
        //     //     (isInJSFile(location) && isJSDocImportTag(location) ? location.moduleSpecifier : undefined) ||
        //     //     (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument*/ true) ? location.initializer.arguments[0] : undefined) ||
        //     //     findAncestor(location, isImportCall)?.arguments[0] ||
        //     //     findAncestor(location, isImportDeclaration)?.moduleSpecifier ||
        //     //     findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression ||
        //     //     findAncestor(location, isExportDeclaration)?.moduleSpecifier;
        // Debug.assertIsDefined(contextSpecifier, "contextSpecifier should be defined");
        const mode: ResolutionMode = ModuleKind.LPC;
        const moduleResolutionKind = ModuleResolutionKind.Classic;// getEmitModuleResolutionKind(compilerOptions);
        const resolvedModule = host.getResolvedModule(currentSourceFile, moduleReference, mode)?.resolvedModule;
        const resolutionDiagnostic = resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile);
        const sourceFile = resolvedModule
            && !resolutionDiagnostic 
            && host.getSourceFile(resolvedModule.resolvedFileName);
        if (sourceFile) {
            // If there's a resolutionDiagnostic we need to report it even if a sourceFile is found.
            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            }
                        
            if (sourceFile.symbol) {
                // get the base type, which will force the source file type to be resolved
                const type = getTypeOfSymbol(sourceFile.symbol) as InterfaceType;                                
                resolveClassOrInterfaceMembers(type);
                
                // if (moduleResolutionKind === ModuleResolutionKind.Node16 || moduleResolutionKind === ModuleResolutionKind.NodeNext) {
                //     const isSyncImport = (currentSourceFile.impliedNodeFormat === ModuleKind.CommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration);
                //     const overrideHost = findAncestor(location, l => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l)) as ImportTypeNode | ImportDeclaration | ExportDeclaration | JSDocImportTag | undefined;
                //     // An override clause will take effect for type-only imports and import types, and allows importing the types across formats, regardless of
                //     // normal mode restrictions
                //     if (isSyncImport && sourceFile.impliedNodeFormat === ModuleKind.ESNext && !hasResolutionModeOverride(overrideHost)) {
                //         if (findAncestor(location, isImportEqualsDeclaration)) {
                //             // ImportEquals in a ESM file resolving to another ESM file
                //             error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference);
                //         }
                //         else {
                //             // CJS file resolving to an ESM file
                //             let diagnosticDetails;
                //             const ext = tryGetExtensionFromPath(currentSourceFile.fileName);
                //             if (ext === Extension.Ts || ext === Extension.Js || ext === Extension.Tsx || ext === Extension.Jsx) {
                //                 const scope = currentSourceFile.packageJsonScope;
                //                 const targetExt = ext === Extension.Ts ? Extension.Mts : ext === Extension.Js ? Extension.Mjs : undefined;
                //                 if (scope && !scope.contents.packageJsonContent.type) {
                //                     if (targetExt) {
                //                         diagnosticDetails = chainDiagnosticMessages(
                //                             /*details*/ undefined,
                //                             Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1,
                //                             targetExt,
                //                             combinePaths(scope.packageDirectory, "package.json"),
                //                         );
                //                     }
                //                     else {
                //                         diagnosticDetails = chainDiagnosticMessages(
                //                             /*details*/ undefined,
                //                             Diagnostics.To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0,
                //                             combinePaths(scope.packageDirectory, "package.json"),
                //                         );
                //                     }
                //                 }
                //                 else {
                //                     if (targetExt) {
                //                         diagnosticDetails = chainDiagnosticMessages(
                //                             /*details*/ undefined,
                //                             Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module,
                //                             targetExt,
                //                         );
                //                     }
                //                     else {
                //                         diagnosticDetails = chainDiagnosticMessages(
                //                             /*details*/ undefined,
                //                             Diagnostics.To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module,
                //                         );
                //                     }
                //                 }
                //             }
                //             diagnostics.add(createDiagnosticForNodeFromMessageChain(
                //                 getSourceFileOfNode(errorNode),
                //                 errorNode,
                //                 chainDiagnosticMessages(
                //                     diagnosticDetails,
                //                     Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead,
                //                     moduleReference,
                //                 ),
                //             ));
                //         }
                //     }
                // }
                // merged symbol is module declaration symbol combined with all augmentations
                return getMergedSymbol(sourceFile.symbol);
            }
            if (moduleNotFoundError) {
                // report errors only if it was requested
                error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName);
            }
            return undefined;
        }
               
        if (moduleNotFoundError) {
            // See if this was possibly a projectReference redirect
            // if (resolvedModule) {
            //     const redirect = host.getProjectReferenceRedirect(resolvedModule.resolvedFileName);
            //     if (redirect) {
            //         error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName);
            //         return undefined;
            //     }
            // }

            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            }
            else {
                const isExtensionlessRelativePathImport = pathIsRelative(moduleReference) && !hasExtension(moduleReference);
                // const resolutionIsNode16OrNext = moduleResolutionKind === ModuleResolutionKind.Node16 ||
                //     moduleResolutionKind === ModuleResolutionKind.NodeNext;
                // if (
                //     !getResolveJsonModule(compilerOptions) &&
                //     fileExtensionIs(moduleReference, Extension.Json) &&
                //     moduleResolutionKind !== ModuleResolutionKind.Classic &&
                //     hasJsonModuleEmitEnabled(compilerOptions)
                // ) {
                //     error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference);
                // }
                // else if (mode === ModuleKind.ESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport) {
                //     const absoluteRef = getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path));
                //     const suggestedExt = suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))?.[1];
                //     if (suggestedExt) {
                //         error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference + suggestedExt);
                //     }
                //     else {
                //         error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path);
                //     }
                // }
                // else {
                    // if (host.getResolvedModule(currentSourceFile, moduleReference, mode)?.alternateResult) {
                    //     const errorInfo = createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference);
                    //     errorOrSuggestion(/*isError*/ true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference));
                    // }
                    // else {
                        error(errorNode, moduleNotFoundError, moduleReference);
                    // }
                // }
            }
        }
        return undefined;

        function getSuggestedImportSource(tsExtension: string) {
            const importSourceWithoutExtension = removeExtension(moduleReference, tsExtension);
            /**
             * Direct users to import source with .js extension if outputting an ES module.
             * @see https://github.com/microsoft/TypeScript/issues/42151
             */
            // if (emitModuleKindIsNonNodeESM(moduleKind) || mode === ModuleKind.ESNext) {
            //     const preferTs = isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions);
            //     const ext = tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" :
            //         tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" :
            //         preferTs ? ".ts" : ".js";
            //     return importSourceWithoutExtension + ext;
            // }
            return importSourceWithoutExtension;
        }
    }

    function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol;
    function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined;
    function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined {
        return moduleSymbol;
        // if (moduleSymbol?.exports) {
        //     const exportEquals = resolveSymbol(moduleSymbol.exports.get(InternalSymbolName.ExportEquals), dontResolveAlias);
        //     const exported = getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol));
        //     return getMergedSymbol(exported) || moduleSymbol;
        // }
        // return undefined;
    }

    function getTargetOfAliasDeclaration(node: Declaration, dontRecursivelyResolve = false): Symbol | undefined {        
        // TODO        
        switch (node.kind) {
            case SyntaxKind.CloneObjectExpression:
            case SyntaxKind.NewExpression:
                Debug.fail("not implemented yet");           
        //     //case SyntaxKind.ImportEqualsDeclaration:
        //     case SyntaxKind.VariableDeclaration:
        //         return getTargetOfImportEqualsDeclaration(node as ImportEqualsDeclaration | VariableDeclaration, dontRecursivelyResolve);
        //     case SyntaxKind.ImportClause:
        //         return getTargetOfImportClause(node as ImportClause, dontRecursivelyResolve);
        //     case SyntaxKind.NamespaceImport:
        //         return getTargetOfNamespaceImport(node as NamespaceImport, dontRecursivelyResolve);
        //     case SyntaxKind.NamespaceExport:
        //         return getTargetOfNamespaceExport(node as NamespaceExport, dontRecursivelyResolve);
        //     case SyntaxKind.ImportSpecifier:
        //     case SyntaxKind.BindingElement:
        //         return getTargetOfImportSpecifier(node as ImportSpecifier | BindingElement, dontRecursivelyResolve);
        //     case SyntaxKind.ExportSpecifier:
        //         return getTargetOfExportSpecifier(node as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);
        //     case SyntaxKind.ExportAssignment:
        //     case SyntaxKind.BinaryExpression:
        //         return getTargetOfExportAssignment(node as ExportAssignment | BinaryExpression, dontRecursivelyResolve);
        //     case SyntaxKind.NamespaceExportDeclaration:
        //         return getTargetOfNamespaceExportDeclaration(node as NamespaceExportDeclaration, dontRecursivelyResolve);
            case SyntaxKind.ShorthandPropertyAssignment:
                return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ true, dontRecursivelyResolve);
            case SyntaxKind.PropertyAssignment:
                return getTargetOfAliasLikeExpression((node as PropertyAssignment).initializer, dontRecursivelyResolve);
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.PropertyAccessExpression:
                return getTargetOfAccessExpression(node as AccessExpression, dontRecursivelyResolve);
            default:
                return Debug.fail();
        }
    }

    function getTargetOfAliasLikeExpression(expression: Expression, dontResolveAlias: boolean) {
        // if (isClassExpression(expression)) {
        //     return checkExpressionCached(expression).symbol;
        // }
        if (!isEntityName(expression) && !isEntityNameExpression(expression)) {
            return undefined;
        }
        const aliasLike = resolveEntityName(expression, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ true, dontResolveAlias);
        if (aliasLike) {
            return aliasLike;
        }
        checkExpressionCached(expression);
        return getNodeLinks(expression).resolvedSymbol;
    }

    function getTargetOfAccessExpression(node: AccessExpression, dontRecursivelyResolve: boolean): Symbol | undefined {
        if (!(isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === SyntaxKind.EqualsToken)) {
            return undefined;
        }

        return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve);
    }

    function getDeclarationOfAliasSymbol(symbol: Symbol): Declaration | undefined {
        return symbol.declarations && findLast<Declaration>(symbol.declarations, isAliasSymbolDeclaration);
    }

    /**
     * An alias symbol is created by one of the following declarations:
     * import <symbol> = ...
     * import <symbol> from ...
     * import * as <symbol> from ...
     * import { x as <symbol> } from ...
     * export { x as <symbol> } from ...
     * export * as ns <symbol> from ...
     * export = <EntityNameExpression>
     * export default <EntityNameExpression>
     * module.exports = <EntityNameExpression>
     * {<Identifier>}
     * {name: <EntityNameExpression>}
     * const { x } = require ...
     */
    function isAliasSymbolDeclaration(node: Node): boolean {
        // return node.kind === SyntaxKind.ImportEqualsDeclaration
        //     || node.kind === SyntaxKind.NamespaceExportDeclaration
        //     || node.kind === SyntaxKind.ImportClause && !!(node as ImportClause).name
        //     || node.kind === SyntaxKind.NamespaceImport
        //     || node.kind === SyntaxKind.NamespaceExport
        //     || node.kind === SyntaxKind.ImportSpecifier
        //     || node.kind === SyntaxKind.ExportSpecifier
        //     || node.kind === SyntaxKind.ExportAssignment && exportAssignmentIsAlias(node as ExportAssignment)
        //     || isBinaryExpression(node) && getAssignmentDeclarationKind(node) === AssignmentDeclarationKind.ModuleExports && exportAssignmentIsAlias(node)
        return isAccessExpression(node)
                && isBinaryExpression(node.parent)
                && node.parent.left === node
                && node.parent.operatorToken.kind === SyntaxKind.EqualsToken
                && isAliasableOrJsExpression(node.parent.right)
            || node.kind === SyntaxKind.ShorthandPropertyAssignment
            || node.kind === SyntaxKind.PropertyAssignment && isAliasableOrJsExpression((node as PropertyAssignment).initializer)
            || node.kind === SyntaxKind.VariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node)
            //|| node.kind === SyntaxKind.BindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent);
            ;
    }

    function isAliasableOrJsExpression(e: Expression) {
        return isAliasableExpression(e);// || isFunctionExpression(e) && isJSConstructor(e);
    }

    function checkAndReportErrorForUsingTypeAsValue(errorLocation: Node, name: string, meaning: SymbolFlags): boolean {
        if (meaning & SymbolFlags.Value) {
            if (isPrimitiveTypeName(name)) {
                const grandparent = errorLocation.parent.parent;
                // if (grandparent && grandparent.parent && isHeritageClause(grandparent)) {
                //     const heritageKind = grandparent.token;
                //     const containerKind = grandparent.parent.kind;
                //     if (containerKind === SyntaxKind.InterfaceDeclaration && heritageKind === SyntaxKind.ExtendsKeyword) {
                //         error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name));
                //     }
                //     else if (containerKind === SyntaxKind.ClassDeclaration && heritageKind === SyntaxKind.ExtendsKeyword) {
                //         error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name));
                //     }
                //     else if (containerKind === SyntaxKind.ClassDeclaration && heritageKind === SyntaxKind.ImplementsKeyword) {
                //         error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name));
                //     }
                // }
                // else {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, (name));
                //}
                return true;
            }
            const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Type & ~SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            const allFlags = symbol && getSymbolFlags(symbol);
            if (symbol && allFlags !== undefined && !(allFlags & SymbolFlags.Value)) {
                const rawName = (name);
                // if (maybeMappedType(errorLocation, symbol)) {
                //     error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, rawName === "K" ? "P" : "K");
                // }
                // else {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName);
                //}
                return true;
            }
        }
        return false;
    }

    function evaluateEntityNameExpression(expr: EntityNameExpression, location?: Declaration) {
        const symbol = resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors*/ true);
        if (!symbol) return evaluatorResult(/*value*/ undefined);

        if (expr.kind === SyntaxKind.Identifier) {
            const identifier = expr;
            if (isInfinityOrNaNString(identifier.text) && (symbol === getGlobalSymbol(identifier.text, SymbolFlags.Value, /*diagnostic*/ undefined))) {
                // Technically we resolved a global lib file here, but the decision to treat this as numeric
                // is more predicated on the fact that the single-file resolution *didn't* resolve to a
                // different meaning of `Infinity` or `NaN`. Transpilers handle this no problem.
                return evaluatorResult(+(identifier.text), /*isSyntacticallyString*/ false);
            }
        }
        if (isVariable(symbol)) {
            const declaration = symbol.valueDeclaration;
            if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && (!location || declaration !== location && isBlockScopedNameDeclaredBeforeUse(declaration, location))) {
                const result = evaluate(declaration.initializer, declaration);
                if (location && getSourceFileOfNode(location) !== getSourceFileOfNode(declaration)) {
                    return evaluatorResult(
                        result.value,
                        /*isSyntacticallyString*/ false,
                        /*resolvedOtherFiles*/ true,
                        /*hasExternalReferences*/ true,
                    );
                }
                return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles, /*hasExternalReferences*/ true);
            }
        }
                
        return evaluatorResult(/*value*/ undefined);
    }

    function isVariable(symbol: Symbol) {
        return (symbol.flags & SymbolFlags.Variable) !== 0;
    }

    function evaluateElementAccessExpression(expr: ElementAccessExpression, location?: Declaration) {
        const root = expr.expression;
        if (isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression)) {
            const rootSymbol = resolveEntityName(root, SymbolFlags.Value, /*ignoreErrors*/ true);
            if (rootSymbol && rootSymbol.flags & SymbolFlags.Enum) {
                const name = (expr.argumentExpression.text);
                const member = rootSymbol.exports!.get(name);
                if (member) {
                    Debug.fail("no enum members");
                    // Debug.assert(getSourceFileOfNode(member.valueDeclaration) === getSourceFileOfNode(rootSymbol.valueDeclaration));
                    // return location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration as EnumMember);
                }
            }
        }
        return evaluatorResult(/*value*/ undefined);
    }
    
    function checkAndReportErrorForUsingValueAsType(errorLocation: Node, name: string, meaning: SymbolFlags): boolean {
        if (meaning & (SymbolFlags.Type & ~SymbolFlags.Namespace)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, ~SymbolFlags.Type & SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false));
            if (symbol && !(symbol.flags & SymbolFlags.Namespace)) {
                error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, (name));
                return true;
            }
        }
        return false;
    }

    /* Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
     * If at any point current node is equal to 'parent' node - return true.
     * If current node is an IIFE, continue walking up.
     * Return false if 'stopAt' node is reached or isFunctionLike(current) === true.
     */
    function isSameScopeDescendentOf(initial: Node, parent: Node | undefined, stopAt: Node): boolean {
        return !!parent && !!findAncestor(initial, n =>
            n === parent
            || (n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false));
    }

    function isBlockScopedNameDeclaredBeforeUse(declaration: Declaration, usage: Node): boolean {        
        const declarationFile = getSourceFileOfNode(declaration);
        const useFile = getSourceFileOfNode(usage);
        const declContainer = getEnclosingBlockScopeContainer(declaration);
        if (declarationFile !== useFile) {
            if (
                // (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||
                // (!compilerOptions.outFile) ||
                // isInTypeQuery(usage) ||
                declaration.flags & NodeFlags.Ambient
            ) {
                // nodes are in different files and order cannot be determined
                return true;
            }
            // declaration is after usage
            // can be legal if usage is deferred (i.e. inside function or in initializer of instance property)
            if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                return true;
            }
            const sourceFiles = host.getSourceFiles();
            return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile);
        }

        // deferred usage in a type context is always OK regardless of the usage position:
        if (!!(usage.flags & NodeFlags.JSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage)) {
            return true;
        }

        if (declaration.pos <= usage.pos) {// && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken)) {
            // declaration is before usage
            if (declaration.kind === SyntaxKind.BindingElement) {
                // still might be illegal if declaration and usage are both binding elements (eg var [a = b, b = b] = [1, 2])
                const errorBindingElement = getAncestor(usage, SyntaxKind.BindingElement) as BindingElement;
                if (errorBindingElement) {
                    return findAncestor(errorBindingElement, isBindingElement) !== findAncestor(declaration, isBindingElement) ||
                        declaration.pos < errorBindingElement.pos;
                }
                // or it might be illegal if usage happens before parent variable is declared (eg var [a] = a)
                return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKind.VariableDeclaration) as Declaration, usage);
            }
            else if (declaration.kind === SyntaxKind.VariableDeclaration) {
                // still might be illegal if usage is in the initializer of the variable declaration (eg var a = a)
                return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration as VariableDeclaration, usage);
            }
            else if (isClassLike(declaration)) {
                // still might be illegal if the usage is within a computed property name in the class (eg class A { static p = "a"; [A.p]() {} })
                // or when used within a decorator in the class (e.g. `@dec(A.x) class A { static x = "x" }`),
                // except when used in a function that is not an IIFE (e.g., `@dec(() => A.x) class A { ... }`)
                const container = findAncestor(usage, n =>
                    n === declaration ? "quit" :
                        isComputedPropertyName(n) ? n.parent.parent === declaration : "quit");/* :
                        !legacyDecorators && isDecorator(n) && (n.parent === declaration ||
                            isMethodDeclaration(n.parent) && n.parent.parent === declaration ||
                            isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration ||
                            isPropertyDeclaration(n.parent) && n.parent.parent === declaration ||
                            isParameter(n.parent) && n.parent.parent.parent === declaration))*/
                if (!container) {
                    return true;
                }                
                return false;
            }
            else if (isPropertyDeclaration(declaration)) {
                // still might be illegal if a self-referencing property initializer (eg private x = this.x)
                return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, /*stopAtAnyPropertyDeclaration*/ false);
            }
            // else if (isParameterPropertyDeclaration(declaration, declaration.parent)) {
            //     // foo = this.bar is illegal in emitStandardClassFields when bar is a parameter property
            //     return !(emitStandardClassFields
            //         && getContainingClass(declaration) === getContainingClass(usage)
            //         && isUsedInFunctionOrInstanceProperty(usage, declaration));
            // }
            return true;
        }

        // declaration is after usage, but it can still be legal if usage is deferred:
        // 1. inside an export specifier
        // 2. inside a function
        // 3. inside an instance property initializer, a reference to a non-instance property
        //    (except when emitStandardClassFields: true and the reference is to a parameter property)
        // 4. inside a static property initializer, a reference to a static method in the same class
        // 5. inside a TS export= declaration (since we will move the export statement during emit to avoid TDZ)
        // if (usage.parent.kind === SyntaxKind.ExportSpecifier || (usage.parent.kind === SyntaxKind.ExportAssignment && (usage.parent as ExportAssignment).isExportEquals)) {
        //     // export specifiers do not use the variable, they only make it available for use
        //     return true;
        // }
        // When resolving symbols for exports, the `usage` location passed in can be the export site directly
        // if (usage.kind === SyntaxKind.ExportAssignment && (usage as ExportAssignment).isExportEquals) {
        //     return true;
        // }

        if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
            // if (
            //     emitStandardClassFields
            //     && getContainingClass(declaration)
            //     && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent))
            // ) {
            //     return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, /*stopAtAnyPropertyDeclaration*/ true);
            // }
            // else {
                return true;
            // }
        }
        return false;

        function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration: VariableDeclaration, usage: Node): boolean {
            switch (declaration.parent.parent.kind) {
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForEachStatement:
                    // variable statement/for/for-of statement case,
                    // use site should not be inside variable declaration (initializer of declaration or binding element)
                    if (isSameScopeDescendentOf(usage, declaration, declContainer)) {
                        return true;
                    }
                    break;
            }

            // ForIn/ForOf case - use site should not be used in expression part
            const grandparent = declaration.parent.parent;
            return isForEachStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer);
        }

        function isUsedInFunctionOrInstanceProperty(usage: Node, declaration: Node): boolean {
            return !!findAncestor(usage, current => {
                if (current === declContainer) {
                    return "quit";
                }
                if (isFunctionLike(current)) {
                    return true;
                }                

                const propertyDeclaration = tryCast(current.parent, isPropertyDeclaration);
                if (propertyDeclaration) {
                    const initializerOfProperty = propertyDeclaration.initializer === current;
                    if (initializerOfProperty) {                       
                        const isDeclarationInstanceProperty = declaration.kind === SyntaxKind.PropertyDeclaration && !isStatic(declaration);
                        if (!isDeclarationInstanceProperty) {// || getContainingClass(usage) !== getContainingClass(declaration)) {
                            return true;
                        }                    
                    }
                }
                return false;
            });
        }

        /** stopAtAnyPropertyDeclaration is used for detecting ES-standard class field use-before-def errors */
        function isPropertyImmediatelyReferencedWithinDeclaration(declaration: PropertyDeclaration, usage: Node, stopAtAnyPropertyDeclaration: boolean) {
            // always legal if usage is after declaration
            if (usage.end > declaration.end) {
                return false;
            }

            // still might be legal if usage is deferred (e.g. x: any = () => this.x)
            // otherwise illegal if immediately referenced within the declaration (e.g. x: any = this.x)
            const ancestorChangingReferenceScope = findAncestor(usage, (node: Node) => {
                if (node === declaration) {
                    return "quit";
                }

                switch (node.kind) {
                    case SyntaxKind.ArrowFunction:
                        return true;
                    case SyntaxKind.PropertyDeclaration:
                        // even when stopping at any property declaration, they need to come from the same class
                        return stopAtAnyPropertyDeclaration &&
                                (isPropertyDeclaration(declaration) && node.parent === declaration.parent)
                            ? "quit" : true;
                    case SyntaxKind.Block:
                        switch (node.parent.kind) {                            
                            case SyntaxKind.MethodDeclaration:                            
                                return true;
                            default:
                                return false;
                        }
                    default:
                        return false;
                }
            });

            return ancestorChangingReferenceScope === undefined;
        }
    }

    function getSuggestedSymbolForNonexistentSymbol(location: Node | undefined, outerName: string, meaning: SymbolFlags): Symbol | undefined {
        Debug.assert(outerName !== undefined, "outername should always be defined");
        const result = resolveNameForSymbolSuggestion(location, outerName, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ false, /*excludeGlobals*/ false);
        return result;
    }

    function getSuggestionForSymbolNameLookup(symbols: SymbolTable, name: string, meaning: SymbolFlags) {
        const symbol = getSymbol(symbols, name, meaning);
        // Sometimes the symbol is found when location is a return type of a function: `typeof x` and `x` is declared in the body of the function
        // So the table *contains* `x` but `x` isn't actually in scope.
        // However, resolveNameHelper will continue and call this callback again, so we'll eventually get a correct suggestion.
        if (symbol) return symbol;
        let candidates: Symbol[];
        if (symbols === globals) {
            const primitives = mapDefined(
                ["string", "number", "boolean", "object", "bigint", "symbol"],
                s => symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as string)
                    ? createSymbol(SymbolFlags.TypeAlias, s as string) as Symbol
                    : undefined,
            );
            candidates = primitives.concat(arrayFrom(symbols.values()));
        }
        else {
            candidates = arrayFrom(symbols.values());
        }
        return getSpellingSuggestionForName((name), candidates, meaning);
    }

    /**
     * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
     * Names less than length 3 only check for case-insensitive equality, not levenshtein distance.
     *
     * If there is a candidate that's the same except for case, return that.
     * If there is a candidate that's within one edit of the name, return that.
     * Otherwise, return the candidate with the smallest Levenshtein distance,
     *    except for candidates:
     *      * With no name
     *      * Whose meaning doesn't match the `meaning` parameter.
     *      * Whose length differs from the target name by more than 0.34 of the length of the name.
     *      * Whose levenshtein distance is more than 0.4 of the length of the name
     *        (0.4 allows 1 substitution/transposition for every 5 characters,
     *         and 1 insertion/deletion at 3 characters)
     */
    function getSpellingSuggestionForName(name: string, symbols: Symbol[], meaning: SymbolFlags): Symbol | undefined {
        return getSpellingSuggestion(name, symbols, getCandidateName);

        function getCandidateName(candidate: Symbol) {
            const candidateName = symbolName(candidate);
            if (startsWith(candidateName, '"')) {
                return undefined;
            }

            if (candidate.flags & meaning) {
                return candidateName;
            }

            if (candidate.flags & SymbolFlags.Alias) {
                const alias = tryResolveAlias(candidate);
                if (alias && alias.flags & meaning) {
                    return candidateName;
                }
            }

            return undefined;
        }
    }

    /**
     * Declares a Symbol for the node and adds it to symbols. Reports errors for conflicting identifier names.
     * @param symbolTable - The symbol table which node will be added to.
     * @param parent - node's parent declaration.
     * @param node - The declaration to be added to the symbol table
     * @param includes - The SymbolFlags that node has in addition to its declaration type (eg: export, ambient, etc.)
     * @param excludes - The flags which node cannot be declared alongside in a symbol table. Used to report forbidden declarations.
     */
    function lateBindBinaryExpressionDeclaration(symbolTable: SymbolTable, parent: Symbol | undefined, node: BinaryExpression, includes: SymbolFlags, excludes: SymbolFlags, isReplaceableByMethod?: boolean): Symbol {
        Debug.assertIsDefined(symbolTable);
        //Debug.assert(isComputedName || !hasDynamicName(node));

        // The exported symbol for an export default function/class node is always named "default"

        const name = isIdentifier(node.left) ? node.left.text : undefined;
       
        let symbol: Symbol | undefined;
        if (name === undefined) {
            symbol = createSymbol(SymbolFlags.None, InternalSymbolName.Missing);
        }
        else {
            // Check and see if the symbol table already has a symbol with this name.  If not,
            // create a new symbol with this name and add it to the table.  Note that we don't
            // give the new symbol any flags *yet*.  This ensures that it will not conflict
            // with the 'excludes' flags we pass in.
            //
            // If we do get an existing symbol, see if it conflicts with the new symbol we're
            // creating.  For example, a 'var' symbol and a 'class' symbol will conflict within
            // the same symbol table.  If we have a conflict, report the issue on each
            // declaration we have for this symbol, and then create a new symbol for this
            // declaration.
            //
            // Note that when properties declared in Javascript constructors
            // (marked by isReplaceableByMethod) conflict with another symbol, the property loses.
            // Always. This allows the common Javascript pattern of overwriting a prototype method
            // with an bound instance method of the same type: `this.method = this.method.bind(this)`
            //
            // If we created a new symbol, either because we didn't have a symbol with this name
            // in the symbol table, or we conflicted with an existing symbol, then just add this
            // node as the sole declaration of the new symbol.
            //
            // Otherwise, we'll be merging into a compatible existing symbol (for example when
            // you have multiple 'vars' with the same name in the same container).  In this case
            // just add this node into the declarations list of the symbol.
            symbol = symbolTable.get(name);            

            if (!symbol) {
                symbolTable.set(name, symbol = createSymbol(SymbolFlags.BlockScopedVariable, name, CheckFlags.Late));
                if (isReplaceableByMethod) symbol.isReplaceableByMethod = true;
            }
            else if (isReplaceableByMethod && !symbol.isReplaceableByMethod) {
                // A symbol already exists, so don't add this as a declaration.
                return symbol;
            }
            else if (symbol.flags & excludes) {
                if (symbol.isReplaceableByMethod) {
                    // Javascript constructor-declared symbols can be discarded in favor of
                    // prototype symbols like methods.
                    symbolTable.set(name, symbol = createSymbol(SymbolFlags.None, name));
                }
                else if (!(includes & SymbolFlags.Variable && symbol.flags & SymbolFlags.Assignment)) {
                    // Assignment declarations are allowed to merge with variables, no matter what other flags they have.
                    if (isNamedDeclaration(node)) {
                        setParent(node.name, node);
                    }
                    // Report errors every position with duplicate declaration
                    // Report errors on previous encountered declarations
                    let message = symbol.flags & SymbolFlags.BlockScopedVariable
                        ? Diagnostics.Cannot_redeclare_block_scoped_variable_0
                        : Diagnostics.Duplicate_identifier_0;
                    let messageNeedsName = true;
                    
                    let multipleDefaultExports = false;
                    if (length(symbol.declarations)) {
                        // // If the current node is a default export of some sort, then check if
                        // // there are any other default exports that we need to error on.
                        // // We'll know whether we have other default exports depending on if `symbol` already has a declaration list set.
                        // if (isDefaultExport) {
                        //     message = Diagnostics.A_module_cannot_have_multiple_default_exports;
                        //     messageNeedsName = false;
                        //     multipleDefaultExports = true;
                        // }
                        // else {
                        //     // This is to properly report an error in the case "export default { }" is after export default of class declaration or function declaration.
                        //     // Error on multiple export default in the following case:
                        //     // 1. multiple export default of class declaration or function declaration by checking NodeFlags.Default
                        //     // 2. multiple export default of export assignment. This one doesn't have NodeFlags.Default on (as export default doesn't considered as modifiers)
                        //     if (
                        //         symbol.declarations && symbol.declarations.length &&
                        //         (node.kind === SyntaxKind.ExportAssignment && !(node as ExportAssignment).isExportEquals)
                        //     ) {
                        //         message = Diagnostics.A_module_cannot_have_multiple_default_exports;
                        //         messageNeedsName = false;
                        //         multipleDefaultExports = true;
                        //     }
                        // }
                    }

                    const relatedInformation: DiagnosticRelatedInformation[] = [];
                   
                    const declarationName = getNameOfDeclaration(node) || node;
                    forEach(symbol.declarations, (declaration, index) => {
                        const decl = getNameOfDeclaration(declaration) || declaration;
                        const diag = messageNeedsName ? createDiagnosticForNode(decl, message, declarationNameToString(declarationName)) : createDiagnosticForNode(decl, message);
                        // file.bindDiagnostics.push(
                        //     multipleDefaultExports ? addRelatedInfo(diag, createDiagnosticForNode(declarationName, index === 0 ? Diagnostics.Another_export_default_is_here : Diagnostics.and_here)) : diag,
                        // );
                        // if (multipleDefaultExports) {
                        //     relatedInformation.push(createDiagnosticForNode(decl, Diagnostics.The_first_export_default_is_here));
                        // }
                    });

                    const diag = messageNeedsName ? createDiagnosticForNode(declarationName, message, declarationNameToString(node)) : createDiagnosticForNode(declarationName, message);
                    diagnostics.add(addRelatedInfo(diag, ...relatedInformation));

                    symbol = createSymbol(SymbolFlags.None, name);
                }
            }
        }
        
        node.symbol = symbol;
        if (symbol.name !== InternalSymbolName.Missing) {
            addDeclarationToLateBoundSymbol(symbol, node, SymbolFlags.BlockScopedVariable);
        }
        setValueDeclaration(symbol, node);
        
        if (symbol.parent) {
            Debug.assert(symbol.parent === parent, "Existing symbol parent should match new one");
        }
        else {
            symbol.parent = parent;
        }

        return symbol;
    }

    function onFailedToResolveSymbol(
        errorLocation: Node | undefined,
        nameArg: string | Identifier,
        meaning: SymbolFlags,
        nameNotFoundMessage: DiagnosticMessage,
    ): Symbol | undefined {
        Debug.assert(!errorLocation || errorLocation.parent);        
        const name = isString(nameArg) ? nameArg : (nameArg as Identifier).text;

        if (errorLocation?.parent && isAssignmentExpression(errorLocation.parent) && errorLocation.parent.left === nameArg) {
            const nodeToBind = errorLocation.parent;
            // if we didn't find a symbol and original location was an assignment expression, and pragma strict types is not on
            // then we treat the first instance as a variable declaration and create a symbol for it
            
            // if (!isStrictCompilerOptionEnabled(compilerOptions, "strictTypes")) {
            const container = getEnclosingLocalsContainer(errorLocation.parent);
            if (!container.locals) container.locals = createSymbolTable();

            const containerSymbol = getSymbolOfNode(container);
            const symbol = lateBindBinaryExpressionDeclaration(container.locals, containerSymbol, nodeToBind, SymbolFlags.Variable, SymbolFlags.None);
            
            return symbol;
        } 

        addLazyDiagnostic(() => {
            if (
                !errorLocation ||
                errorLocation.parent.kind !== SyntaxKind.JSDocLink &&
                    !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&
                    !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
                    !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)
            ) {
                let suggestion: Symbol | undefined;
                let suggestedLib: string | undefined;
                // Report missing lib first
                if (nameArg) {
                    // TODO
                    // suggestedLib = getSuggestedLibForNonExistentName(nameArg);
                    // if (suggestedLib) {
                    //     error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib);
                    // }
                }
                // then spelling suggestions
                if (!suggestedLib && suggestionCount < maximumSuggestionCount) {
                    suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning);
                    // const isGlobalScopeAugmentationDeclaration = suggestion?.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration);
                    // if (isGlobalScopeAugmentationDeclaration) {
                    //     suggestion = undefined;
                    // }
                    if (suggestion) {
                        const suggestionName = symbolToString(suggestion);
                        //const isUncheckedJS = isUncheckedJSSuggestion(errorLocation, suggestion, /*excludeClasses*/ false);
                        const message = Diagnostics.Cannot_find_name_0_Did_you_mean_1;
                        const diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);
                        diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg));
                        addErrorOrSuggestion(true, diagnostic);
                        if (suggestion.valueDeclaration) {
                            addRelatedInfo(
                                diagnostic,
                                createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName),
                            );
                        }
                    }
                }
                // And then fall back to unspecified "not found"
                if (!suggestion && !suggestedLib && nameArg) {
                    error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
                }
                suggestionCount++;
            }
        });

        return undefined;
    }

    function addErrorOrSuggestion(isError: boolean, diagnostic: Diagnostic) {
        if (isError) {
            diagnostics.add(diagnostic);
        }
        else {
            suggestionDiagnostics.add({ ...diagnostic, category: DiagnosticCategory.Suggestion });
        }
    }
    
    function diagnosticName(nameArg: string | Identifier /*| PrivateIdentifier*/) {
        return isString(nameArg) ? (nameArg as string) : declarationNameToString(nameArg as Identifier);
    }

    function getExportSymbolOfValueSymbolIfExported(symbol: Symbol): Symbol;
    function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined;
    function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined {
        return getMergedSymbol(symbol && (symbol.flags & SymbolFlags.ExportValue) !== 0 && symbol.exportSymbol || symbol);
    }

    function checkResolvedBlockScopedVariable(result: Symbol, errorLocation: Node): void {
        Debug.assert(!!(result.flags & SymbolFlags.Variable || result.flags & SymbolFlags.Class || result.flags & SymbolFlags.Enum));
        if (result.flags & (SymbolFlags.Function | SymbolFlags.FunctionScopedVariable | SymbolFlags.Assignment) && result.flags & SymbolFlags.Class) {
            // constructor functions aren't block scoped
            return;
        }
        // Block-scoped variables cannot be used before their definition
        const declaration = result.declarations?.find(
            d => isBlockOrCatchScoped(d) || isAssignmentExpression(d) ,//TODO || isClassLike(d),
        );

        if (declaration === undefined) return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration");
        
        if (!(declaration.flags & NodeFlags.Ambient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
            let diagnosticMessage;
            const declarationName = declarationNameToString(getNameOfDeclaration(declaration));
            if (result.flags & SymbolFlags.Variable) {
                diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName);
            }
            else if (result.flags & SymbolFlags.Class) {
                diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName);
            }            
            
            if (diagnosticMessage) {
                addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName));
            }
        }
    }
    
    function onSuccessfullyResolvedSymbol(
        errorLocation: Node | undefined,
        result: Symbol,
        meaning: SymbolFlags,
        lastLocation: Node | undefined,
        associatedDeclarationForContainingInitializerOrBindingName: ParameterDeclaration | BindingElement | undefined,
        withinDeferredContext: boolean,
    ) {
        addLazyDiagnostic(() => {
            const name = result.name;
            const isInExternalModule = lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation);
            // Only check for block-scoped variable if we have an error location and are looking for the
            // name with variable meaning
            //      For example,
            //          declare module foo {
            //              interface bar {}
            //          }
            //      const foo/*1*/: foo/*2*/.bar;
            // The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
            // block-scoped variable and namespace module. However, only when we
            // try to resolve name in /*1*/ which is used in variable position,
            // we want to check for block-scoped
            if (
                errorLocation &&
                (meaning & SymbolFlags.BlockScopedVariable ||
                    ((meaning & SymbolFlags.Class || meaning & SymbolFlags.Enum) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))
            ) {
                const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
                if (exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags.Class || exportOrLocalSymbol.flags & SymbolFlags.Enum) {
                    checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                }
            }

            // // If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right
            // if (associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {
            //     const candidate = getMergedSymbol(getLateBoundSymbol(result));
            //     const root = getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) as ParameterDeclaration;
            //     // A parameter initializer or binding pattern initializer within a parameter cannot refer to itself
            //     if (candidate === getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName)) {
            //         error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
            //     }
            //     // And it cannot refer to any declarations which come after it
            //     else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.name, meaning) === candidate) {
            //         error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation as Identifier));
            //     }
            // }
            
            // No type-only imports in LPC
            // if (errorLocation && meaning & SymbolFlags.Value && result.flags & SymbolFlags.Alias && !(result.flags & SymbolFlags.Value) && !isValidTypeOnlyAliasUseSite(errorLocation)) {
            //     const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(result, SymbolFlags.Value);
            //     if (typeOnlyDeclaration) {
            //         const message = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport
            //             ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type
            //             : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
            //         const unname = unescapeLeadingUnderscores(name);
            //         addTypeOnlyDeclarationRelatedInfo(
            //             error(errorLocation, message, unname),
            //             typeOnlyDeclaration,
            //             unname,
            //         );
            //     }
            // }

            // Not used in LPC
            // // Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
            // // here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
            // if (compilerOptions.isolatedModules && result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {
            //     const isGlobal = getSymbol(globals, name, meaning) === result;
            //     const nonValueSymbol = isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlags.Value);
            //     if (nonValueSymbol) {
            //         // TODO : do we need this?
            //         // const importDecl = nonValueSymbol.declarations?.find(d => d.kind === SyntaxKind.ImportSpecifier || d.kind === SyntaxKind.ImportClause || d.kind === SyntaxKind.NamespaceImport || d.kind === SyntaxKind.ImportEqualsDeclaration);
            //         // if (importDecl && !isTypeOnlyImportDeclaration(importDecl)) {
            //         //     error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name));
            //         // }
            //     }
            // }
        });
    }

    function getCannotFindNameDiagnosticForName(node: Identifier): DiagnosticMessage {
        switch (node.text) {
            case "bytes":
            case "buffer":
                return Diagnostics.Cannot_find_0_Do_you_need_to_change_your_driver_type;
            // case "document":
            // case "console":
            //     return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;
            // case "$":
            //     return compilerOptions.types
            //         ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig
            //         : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;
            // case "describe":
            // case "suite":
            // case "it":
            // case "test":
            //     return compilerOptions.types
            //         ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig
            //         : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;
            // case "process":
            // case "require":
            // case "Buffer":
            // case "module":
            //     return compilerOptions.types
            //         ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig
            //         : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;
            // case "Bun":
            //     return compilerOptions.types
            //         ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig
            //         : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun;
            // case "Map":
            // case "Set":
            // case "Promise":
            // case "Symbol":
            // case "WeakMap":
            // case "WeakSet":
            // case "Iterator":
            // case "AsyncIterator":
            // case "SharedArrayBuffer":
            // case "Atomics":
            // case "AsyncIterable":
            // case "AsyncIterableIterator":
            // case "AsyncGenerator":
            // case "AsyncGeneratorFunction":
            // case "BigInt":
            // case "Reflect":
            // case "BigInt64Array":
            // case "BigUint64Array":
            //     return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;
            // case "await":
            //     if (isCallExpression(node.parent)) {
            //         return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;
            //     }
            //     // falls through
            default:
                if (node.parent?.kind === SyntaxKind.ShorthandPropertyAssignment) {
                    return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;
                }
                else {
                    return Diagnostics.Cannot_find_name_0;
                }
        }
    }
    
    function getResolvedSymbol(node: Identifier, symbolFlags = SymbolFlags.Value | SymbolFlags.ExportValue): Symbol {
        const links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            links.resolvedSymbol = !nodeIsMissing(node) &&
                    resolveName(
                        node,
                        node,
                        symbolFlags,
                        getCannotFindNameDiagnosticForName(node),
                        !isWriteOnlyAccess(node),
                        /*excludeGlobals*/ false,
                    ) || unknownSymbol;
        }
        return links.resolvedSymbol;
    }
    
    function getParentOfSymbol(symbol: Symbol): Symbol | undefined {
        return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent));
    }

    function getCombinedNodeFlagsCached(node: Node) {
        // we hold onto the last node and result to speed up repeated lookups against the same node.
        if (lastGetCombinedNodeFlagsNode === node) {
            return lastGetCombinedNodeFlagsResult;
        }
        lastGetCombinedNodeFlagsNode = node;
        lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node);
        return lastGetCombinedNodeFlagsResult;
    }
    
    function isDeprecatedDeclaration(declaration: Declaration) {
        return !!(getCombinedNodeFlagsCached(declaration) & NodeFlags.Deprecated);
    }

    function isDeprecatedSymbol(symbol: Symbol) {
        const parentSymbol = getParentOfSymbol(symbol);
        if (parentSymbol && length(symbol.declarations) > 1) {
            return parentSymbol.flags & SymbolFlags.Interface ? some(symbol.declarations, isDeprecatedDeclaration) : every(symbol.declarations, isDeprecatedDeclaration);
        }
        return !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration)
            || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration);
    }

    function getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined {
        Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here.");
        const links = getSymbolLinks(symbol);
        if (!links.immediateTarget) {
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            links.immediateTarget = getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true);
        }

        return links.immediateTarget;
    }

    function addDeprecatedSuggestion(location: Node, declarations: Node[], deprecatedEntity: string) {
        const diagnostic = createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity);
        return addDeprecatedSuggestionWorker(declarations, diagnostic);
    }

    function addDeprecatedSuggestionWorker(declarations: Node | Node[], diagnostic: DiagnosticWithLocation) {
        const deprecatedTag = Array.isArray(declarations) ? forEach(declarations, getDeprecatedModifierOrJSDocTag) : getDeprecatedModifierOrJSDocTag(declarations);        
        if (deprecatedTag) {
            addRelatedInfo(
                diagnostic,
                createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here),
            );
        }
        // We call `addRelatedInfo()` before adding the diagnostic to prevent duplicates.
        suggestionDiagnostics.add(diagnostic);
        return diagnostic;
    }

    function resolveAliasWithDeprecationCheck(symbol: Symbol, location: Node) {
        if (!(symbol.flags & SymbolFlags.Alias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol)) {
            return symbol;
        }

        const targetSymbol = resolveAlias(symbol);
        if (targetSymbol === unknownSymbol) return targetSymbol;

        while (symbol.flags & SymbolFlags.Alias) {
            const target = getImmediateAliasedSymbol(symbol);
            if (target) {
                if (target === targetSymbol) break;
                if (target.declarations && length(target.declarations)) {
                    if (isDeprecatedSymbol(target)) {
                        addDeprecatedSuggestion(location, target.declarations, target.name as string);
                        break;
                    }
                    else {
                        if (symbol === targetSymbol) break;
                        symbol = target;
                    }
                }
            }
            else {
                break;
            }
        }
        return targetSymbol;
    }

    function isMatchingReference(source: Node, target: Node): boolean {
        switch (target.kind) {
            case SyntaxKind.ParenthesizedExpression:            
                return isMatchingReference(source, (target as ParenthesizedExpression).expression);
            case SyntaxKind.BinaryExpression:
                return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) ||
                    (isBinaryExpression(target) && target.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source, target.right));
        }
        switch (source.kind) {            
            case SyntaxKind.Identifier:
            //case SyntaxKind.PrivateIdentifier:
                return target.kind === SyntaxKind.Identifier && getResolvedSymbol(source as Identifier) === getResolvedSymbol(target as Identifier) ||
                    (isVariableDeclaration(target) || isBindingElement(target)) 
                        // TS checked the export symbol here, but since our SourceFile level 
                        // vars can impact flow nodes, we don't want to do that
                        && getSymbolOfDeclaration(firstOrUndefined(getResolvedSymbol(source as Identifier).declarations)) === getSymbolOfDeclaration(target);                                    
            case SyntaxKind.SuperKeyword:
                return target.kind === SyntaxKind.SuperKeyword;            
            case SyntaxKind.ParenthesizedExpression:
                return isMatchingReference((source as ParenthesizedExpression).expression, target);
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:                
                const sourcePropertyName = getAccessedPropertyName(source as AccessExpression);
                if (sourcePropertyName !== undefined) {
                    const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : undefined;
                    if (targetPropertyName !== undefined) {
                        return targetPropertyName === sourcePropertyName && isMatchingReference((source as AccessExpression).expression, (target as AccessExpression).expression);
                    }
                }
                if (isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression)) {
                    const symbol = getResolvedSymbol(source.argumentExpression);
                    if (symbol === getResolvedSymbol(target.argumentExpression) && (isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol))) {
                        return isMatchingReference(source.expression, target.expression);
                    }
                }
                break;
            // case SyntaxKind.QualifiedName:
            //     return isAccessExpression(target) &&
            //         (source as QualifiedName).right.text === getAccessedPropertyName(target) &&
            //         isMatchingReference((source as QualifiedName).left, target.expression);
            case SyntaxKind.BinaryExpression:
                return (isBinaryExpression(source) && source.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source.right, target));
        }
        return false;
    }

    // Check if a parameter or catch variable is assigned anywhere
    function isSymbolAssigned(symbol: Symbol) {
        return !isPastLastAssignment(symbol, /*location*/ undefined);
    }

    function containsMatchingReference(source: Node, target: Node) {
        while (isAccessExpression(source)) {
            source = source.expression;
            if (isMatchingReference(source, target)) {
                return true;
            }
        }
        return false;
    }
    
    function isOrContainsMatchingReference(source: Node, target: Node) {
        return isMatchingReference(source, target) || containsMatchingReference(source, target);
    }

    function hasMatchingArgument(expression: CallExpression /*| NewExpression*/, reference: Node) {
        if (expression.arguments) {
            for (const argument of expression.arguments) {
                if (isOrContainsMatchingReference(reference, argument)) {
                    return true;
                }
            }
        }
        if (
            expression.expression.kind === SyntaxKind.PropertyAccessExpression &&
            isOrContainsMatchingReference(reference, (expression.expression as PropertyAccessExpression).expression)
        ) {
            return true;
        }
        return false;
    }

    function isUncalledFunctionReference(node: Node, symbol: Symbol) {
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {
            const parent = findAncestor(node.parent, n => !isAccessExpression(n)) || node.parent;
            if (isCallLikeExpression(parent)) {
                return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node);
            }
            return every(symbol.declarations, d => !isFunctionLike(d) || isDeprecatedDeclaration(d));
        }
        return true;
    }
    
    /**
     * This part of `checkIdentifier` is kept seperate from the rest, so `NodeCheckFlags` (and related diagnostics) can be lazily calculated
     * without calculating the flow type of the identifier.
     */
    function checkIdentifierCalculateNodeCheckFlags(node: Identifier, symbol: Symbol) {       
        const localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
        const targetSymbol = resolveAliasWithDeprecationCheck(localOrExportSymbol, node);
        if (isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations) {
            addDeprecatedSuggestion(node, targetSymbol.declarations, node.text as string);
        }

        const declaration = localOrExportSymbol.valueDeclaration;
        if (declaration && localOrExportSymbol.flags & SymbolFlags.Class) {
            // When we downlevel classes we may emit some code outside of the class body. Due to the fact the
            // class name is double-bound, we must ensure we mark references to the class name so that we can
            // emit an alias to the class later.
            if (isClassLike(declaration) && declaration.name !== node) {
                let container = getThisContainer(node, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
                while (container.kind !== SyntaxKind.SourceFile && container.parent !== declaration) {
                    container = getThisContainer(container, /*includeArrowFunctions*/ false, /*includeClassComputedPropertyName*/ false);
                }

                if (container.kind !== SyntaxKind.SourceFile) {
                    getNodeLinks(declaration).flags |= NodeCheckFlags.ContainsConstructorReference;
                    getNodeLinks(container).flags |= NodeCheckFlags.ContainsConstructorReference;
                    getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReference;
                }
            }
        }

        checkNestedBlockScopedBinding(node, symbol);
    }

    function isInsideFunctionOrInstancePropertyInitializer(node: Node, threshold: Node): boolean {
        return !!findAncestor(node, n =>
            n === threshold ? "quit" : isFunctionLike(n) || (
                n.parent && isPropertyDeclaration(n.parent) && n.parent.initializer === n
            ));
    }
    
    function getEnclosingIterationStatement(node: Node): Node | undefined {
        return findAncestor(node, n => (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(n, /*lookInLabeledStatements*/ false));
    }
    
    function getPartOfForStatementContainingNode(node: Node, container: ForStatement) {
        return findAncestor(node, n => n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement);
    }
    
    function checkNestedBlockScopedBinding(node: Identifier, symbol: Symbol): void {
        if (            
            (symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.Class)) === 0 ||
            !symbol.valueDeclaration ||
            isSourceFile(symbol.valueDeclaration) ||
            symbol.valueDeclaration.parent.kind === SyntaxKind.CatchStatement
        ) {
            return;
        }

        // 1. walk from the use site up to the declaration and check
        // if there is anything function like between declaration and use-site (is binding/class is captured in function).
        // 2. walk from the declaration up to the boundary of lexical environment and check
        // if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)

        const container = getEnclosingBlockScopeContainer(symbol.valueDeclaration);
        const isCaptured = isInsideFunctionOrInstancePropertyInitializer(node, container);

        const enclosingIterationStatement = getEnclosingIterationStatement(container);
        if (enclosingIterationStatement) {
            if (isCaptured) {
                // mark iteration statement as containing block-scoped binding captured in some function
                let capturesBlockScopeBindingInLoopBody = true;
                if (isForStatement(container)) {
                    const varDeclList = getAncestor(symbol.valueDeclaration, SyntaxKind.VariableDeclarationList);
                    if (varDeclList && varDeclList.parent === container) {
                        const part = getPartOfForStatementContainingNode(node.parent, container);
                        if (part) {
                            const links = getNodeLinks(part);
                            links.flags |= NodeCheckFlags.ContainsCapturedBlockScopeBinding;

                            const capturedBindings = links.capturedBlockScopeBindings || (links.capturedBlockScopeBindings = []);
                            pushIfUnique(capturedBindings, symbol);

                            if (part === container.initializer) {
                                capturesBlockScopeBindingInLoopBody = false; // Initializer is outside of loop body
                            }
                        }
                    }
                }
                if (capturesBlockScopeBindingInLoopBody) {
                    getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
                }
            }

            // mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
            // if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
            if (isForStatement(container)) {
                const varDeclList = getAncestor(symbol.valueDeclaration, SyntaxKind.VariableDeclarationList);
                if (varDeclList && varDeclList.parent === container && isAssignedInBodyOfForStatement(node, container)) {
                    getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.NeedsLoopOutParameter;
                }
            }

            // set 'declared inside loop' bit on the block-scoped binding
            getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
        }

        if (isCaptured) {
            getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.CapturedBlockScopedBinding;
        }
    }

    function isAssignedInBodyOfForStatement(node: Identifier, container: ForStatement): boolean {
        // skip parenthesized nodes
        let current: Node = node;
        while (current.parent.kind === SyntaxKind.ParenthesizedExpression) {
            current = current.parent;
        }

        // check if node is used as LHS in some assignment expression
        let isAssigned = false;
        if (isAssignmentTarget(current)) {
            isAssigned = true;
        }
        else if ((current.parent.kind === SyntaxKind.PrefixUnaryExpression || current.parent.kind === SyntaxKind.PostfixUnaryExpression)) {
            const expr = current.parent as PrefixUnaryExpression | PostfixUnaryExpression;
            isAssigned = expr.operator === SyntaxKind.PlusPlusToken || expr.operator === SyntaxKind.MinusMinusToken;
        }

        if (!isAssigned) {
            return false;
        }

        // at this point we know that node is the target of assignment
        // now check that modification happens inside the statement part of the ForStatement
        return !!findAncestor(current, n => n === container ? "quit" : n === container.statement);
    }
    
    
    function isInPropertyInitializerOrClassStaticBlock(node: Node): boolean {
        return !!findAncestor(node, node => {
            switch (node.kind) {
                case SyntaxKind.PropertyDeclaration:
                    return true;
                case SyntaxKind.PropertyAssignment:
                case SyntaxKind.InheritDeclaration:
                //case SyntaxKind.MethodDeclaration:                
                //case SyntaxKind.SpreadAssignment:                
                    return false;
                case SyntaxKind.InlineClosureExpression:
                case SyntaxKind.ExpressionStatement:
                    return "quit";
                default:
                    return isExpressionNode(node) ? false : "quit";
            }
        });
    }

    function isParameterOfContextSensitiveSignature(symbol: Symbol) {
        let decl = symbol.valueDeclaration;
        if (!decl) {
            return false;
        }
        if (isBindingElement(decl)) {
            decl = walkUpBindingElementsAndPatterns(decl);
        }
        if (isParameter(decl)) {
            return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent);
        }
        return false;
    }

    function getTypeOfInstantiatedSymbol(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        return links.type || (links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper));
    }

    function getTypeOfReverseMappedSymbol(symbol: ReverseMappedSymbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            links.type = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType;
        }
        return links.type;
    }

    function getTypeOfMappedSymbol(symbol: MappedSymbol) {
        if (!symbol.links.type) {
            const mappedType = symbol.links.mappedType;
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
                mappedType.containsError = true;
                return errorType;
            }
            const templateType = getTemplateTypeFromMappedType(mappedType.target as MappedType || mappedType);
            const mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType);
            const propType = instantiateType(templateType, mapper);
            // When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
            // type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
            // mode, if the underlying property is optional we remove 'undefined' from the type.
            let type = strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty*/ true) :
                symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) :
                propType;
            if (!popTypeResolution()) {
                error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                type = errorType;
            }
            symbol.links.type ??= type;
        }
        return symbol.links.type;
    }

    function getTypeOfVariableOrParameterOrProperty(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);

        if (links.localVarType && currentFile) {
            // once we have one LpcDocVariable type, then we need to cache everything else
            // even if they aren't from @var tags
            let type = links.localVarType.get(currentFile?.fileName)
            if (!type) {
                type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
                links.localVarType.set(currentFile?.fileName, type);                
            }         
            return type;
        }

        if (!links.type) {            
            const type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);

            // if the type came from an lpc doc var tag, that can't be cached for the
            // entire symbol - it has to be file specific
            if (type?.flags & TypeFlags.LpcDocVariable && currentFile) {
                (links.localVarType ||= new Map()).set(currentFile.fileName, type);
                return type;
            }

            // For a contextually typed parameter it is possible that a type has already
            // been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
            // to preserve this type. In fact, we need to _prefer_ that type, but it won't
            // be assigned until contextual typing is complete, so we need to defer in
            // cases where contextual typing may take place.                        
            if (!links.type && !isParameterOfContextSensitiveSignature(symbol)) {
                links.type = type;
            }
            return type;
        }
        return links.type;
    }

    function getWidenedTypeForAssignmentDeclaration(symbol: Symbol, resolvedSymbol?: Symbol) {
        // function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
        // const container = getAssignedExpandoInitializer(symbol.valueDeclaration);
        // if (container) {
        //     const tag = isInJSFile(container) ? getJSDocTypeTag(container) : undefined;
        //     if (tag && tag.typeExpression) {
        //         return getTypeFromTypeNode(tag.typeExpression);
        //     }
        //     const containerObjectType = symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container);
        //     return containerObjectType || getWidenedLiteralType(checkExpressionCached(container));
        // }
        let type;
        let definedInConstructor = false;
        let definedInMethod = false;
        // We use control flow analysis to determine the type of the property if the property qualifies as a constructor
        // declared property and the resulting control flow type isn't just undefined or null.
        // if (isConstructorDeclaredProperty(symbol)) {
        //     type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol)!);
        // }
        if (!type) {
            let types: Type[] | undefined;
            if (symbol.declarations) {
                let jsdocType: Type | undefined;
                for (const declaration of symbol.declarations) {
                    const expression = (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration :
                        isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration :
                        undefined;
                    if (!expression) {
                        continue; // Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
                    }

                    const kind = isAccessExpression(expression)
                        ? getAssignmentDeclarationPropertyAccessKind(expression)
                        : getAssignmentDeclarationKind(expression);
                    if (kind === AssignmentDeclarationKind.ThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind)) {
                        // if (isDeclarationInConstructor(expression)) {
                        //     definedInConstructor = true;
                        // }
                        // else {
                            definedInMethod = true;
                        // }
                    }
                    if (!isCallExpression(expression)) {
                        jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);
                    }
                    if (!jsdocType) {
                        (types || (types = [])).push((isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType);
                    }
                }
                type = jsdocType;
            }
            if (!type) {
                if (!length(types)) {
                    return errorType; // No types from any declarations :(
                }
                let constructorTypes: Type[] | undefined = undefined;//definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined;
                // use only the constructor types unless they were only assigned null | undefined (including widening variants)
                if (definedInMethod) {
                    const propType = getTypeOfPropertyInBaseClass(symbol);
                    if (propType) {
                        (constructorTypes || (constructorTypes = [])).push(propType);
                        definedInConstructor = true;
                    }
                }
                const sourceTypes = some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types; // TODO: GH#18217
                type = getUnionType(sourceTypes);
            }
        }
        const widened = getWidenedType(addOptionality(type, /*isProperty*/ false, definedInMethod && !definedInConstructor));
        if (symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, t => !!(t.flags & ~TypeFlags.Nullable)) === neverType) {
            reportImplicitAny(symbol.valueDeclaration, anyType);
            return anyType;
        }
        return widened;
    }

    // Return the type of the given property in the given type, or undefined if no such property exists
    function getTypeOfPropertyOfType(type: Type, name: string): Type | undefined {
        const prop = getPropertyOfType(type, name);
        return prop ? getTypeOfSymbol(prop) : undefined;
    }

    // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
    function getSingleCallSignature(type: Type): Signature | undefined {
        return getSingleSignature(type, SignatureKind.Call, /*allowMembers*/ false);
    }

    function getTypeOfFirstParameterOfSignature(signature: Signature) {
        return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType);
    }

    function getTypeOfFirstParameterOfSignatureWithFallback(signature: Signature, fallbackType: Type) {
        return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
    }

    function containsSameNamedThisProperty(thisProperty: Expression, expression: Expression) {
        return false;
        // return isPropertyAccessExpression(thisProperty)
        //     && thisProperty.expression.kind === SyntaxKind.ThisKeyword
        //     && forEachChildRecursively(expression, n => isMatchingReference(thisProperty, n));
    }

    /** If we don't have an explicit JSDoc type, get the type from the initializer. */
    function getInitializerTypeFromAssignmentDeclaration(symbol: Symbol, resolvedSymbol: Symbol | undefined, expression: BinaryExpression | CallExpression, kind: AssignmentDeclarationKind) {
        if (isCallExpression(expression)) {
            if (resolvedSymbol) {
                return getTypeOfSymbol(resolvedSymbol); // This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
            }
            const objectLitType = checkExpressionCached((expression as BindableObjectDefinePropertyCall).arguments[2]);
            const valueType = getTypeOfPropertyOfType(objectLitType, "value" as string);
            if (valueType) {
                return valueType;
            }
            const getFunc = getTypeOfPropertyOfType(objectLitType, "get" as string);
            if (getFunc) {
                const getSig = getSingleCallSignature(getFunc);
                if (getSig) {
                    return getReturnTypeOfSignature(getSig);
                }
            }
            const setFunc = getTypeOfPropertyOfType(objectLitType, "set" as string);
            if (setFunc) {
                const setSig = getSingleCallSignature(setFunc);
                if (setSig) {
                    return getTypeOfFirstParameterOfSignature(setSig);
                }
            }
            return anyType;
        }
        if (containsSameNamedThisProperty(expression.left, expression.right)) {
            return anyType;
        }
        //const isDirectExport = kind === AssignmentDeclarationKind.ExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)));
        const type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)
            //: isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))
            : getWidenedLiteralType(checkExpressionCached(expression.right));
        if (
            type.flags & TypeFlags.Object &&
            kind === AssignmentDeclarationKind.ModuleExports &&
            symbol.name === InternalSymbolName.ExportEquals
        ) {
            const exportedType = resolveStructuredTypeMembers(type as ObjectType);
            const members = createSymbolTable();
            copyEntries(exportedType.members, members);
            const initialSize = members.size;
            if (resolvedSymbol && !resolvedSymbol.exports) {
                resolvedSymbol.exports = createSymbolTable();
            }
            (resolvedSymbol || symbol).exports!.forEach((s, name) => {
                const exportedMember = members.get(name)!;
                if (exportedMember && exportedMember !== s && !(s.flags & SymbolFlags.Alias)) {
                    if (s.flags & SymbolFlags.Value && exportedMember.flags & SymbolFlags.Value) {
                        // If the member has an additional value-like declaration, union the types from the two declarations,
                        // but issue an error if they occurred in two different files. The purpose is to support a JS file with
                        // a pattern like:
                        //
                        // module.exports = { a: true };
                        // module.exports.a = 3;
                        //
                        // but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
                        // declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
                        // it's unclear what that's supposed to mean, so it's probably a mistake.
                        if (s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) !== getSourceFileOfNode(exportedMember.valueDeclaration)) {
                            const unname = (s.name);
                            const exportedMemberName = tryCast(exportedMember.valueDeclaration, isNamedDeclaration)?.name || exportedMember.valueDeclaration;
                            addRelatedInfo(
                                error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unname),
                                createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unname),
                            );
                            addRelatedInfo(
                                error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unname),
                                createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unname),
                            );
                        }
                        const union = createSymbol(s.flags | exportedMember.flags, name);
                        union.links.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);
                        union.valueDeclaration = exportedMember.valueDeclaration;
                        union.declarations = concatenate(exportedMember.declarations, s.declarations);
                        members.set(name, union);
                    }
                    else {
                        members.set(name, mergeSymbol(s, exportedMember));
                    }
                }
                else {
                    members.set(name, s);
                }
            });
            const result = createAnonymousType(
                initialSize !== members.size ? undefined : exportedType.symbol, // Only set the type's symbol if it looks to be the same as the original type
                members,
                exportedType.callSignatures,
                exportedType.constructSignatures,
                exportedType.indexInfos,
            );
            if (initialSize === members.size) {
                if (type.aliasSymbol) {
                    result.aliasSymbol = type.aliasSymbol;
                    result.aliasTypeArguments = type.aliasTypeArguments;
                }
                if (getObjectFlags(type) & ObjectFlags.Reference) {
                    result.aliasSymbol = (type as TypeReference).symbol;
                    const args = getTypeArguments(type as TypeReference);
                    result.aliasTypeArguments = length(args) ? args : undefined;
                }
            }
            result.objectFlags |= getPropagatingFlagsOfTypes([type]) | getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.ArrayLiteral | ObjectFlags.ObjectLiteral);
            if (result.symbol && result.symbol.flags & SymbolFlags.Class && type === getDeclaredTypeOfClassOrInterface(result.symbol)) {
                result.objectFlags |= ObjectFlags.IsClassInstanceClone; // Propagate the knowledge that this type is equivalent to the symbol's class instance type
            }
            return result;
        }
        if (isEmptyArrayLiteralType(type)) {
            reportImplicitAny(expression, anyArrayType);
            return anyArrayType;
        }        
        return type;
    }

    function mergeJSSymbols(target: Symbol, source: Symbol | undefined) {
        if (source) {
            const links = getSymbolLinks(source);
            if (!links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target))) {
                const inferred = isTransientSymbol(target) ? target : cloneSymbol(target);
                inferred.exports = inferred.exports || createSymbolTable();
                inferred.members = inferred.members || createSymbolTable();
                inferred.flags |= source.flags & SymbolFlags.Class;
                if (source.exports?.size) {
                    mergeSymbolTable(inferred.exports, source.exports);
                }
                if (source.members?.size) {
                    mergeSymbolTable(inferred.members, source.members);
                }
                (links.inferredClassSymbol || (links.inferredClassSymbol = new Map())).set(getSymbolId(inferred), inferred);
                return inferred;
            }
            return links.inferredClassSymbol.get(getSymbolId(target));
        }
    }

    function getAssignedClassSymbol(decl: Declaration): Symbol | undefined {
        return undefined;
        // const assignmentSymbol = decl && getSymbolOfExpando(decl, /*allowDeclaration*/ true);
        // const prototype = assignmentSymbol?.exports?.get("prototype" as string);
        // const init = prototype?.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration);
        // return init ? getSymbolOfDeclaration(init) : undefined;
    }

    function getFakeGlobalInterfaceType(symbol: Symbol): InterfaceType {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.declaredType) {            
            const kind = symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface;
            const merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
            if (merged) {
                // note:we overwrite links because we just cloned the symbol
                symbol = merged;
                links = merged.links;
            }

            const type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType;
            // const outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
            const localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
            // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
            // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
            // property types inferred from initializers and method return types inferred from return statements are very hard
            // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
            // "this" references.
            // if (outerTypeParameters || localTypeParameters || kind === ObjectFlags.Class) {
                type.objectFlags |= ObjectFlags.Reference;
                type.typeParameters = localTypeParameters;//concatenate(outerTypeParameters, localTypeParameters);
                // type.outerTypeParameters = outerTypeParameters;
                type.localTypeParameters = localTypeParameters;
                (type as GenericType).instantiations = new Map<string, TypeReference>();
                (type as GenericType).instantiations.set(getTypeListId(type.typeParameters), type as GenericType);
                (type as GenericType).target = type as GenericType;
                (type as GenericType).resolvedTypeArguments = type.typeParameters;                
                type.thisType = createTypeParameter(symbol);
                type.thisType.isThisType = true;
                type.thisType.constraint = type;
            // }
        }
        return links.declaredType as InterfaceType;
    }

    function getDeclaredTypeOfClassOrInterface(symbol: Symbol): InterfaceType {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.declaredType) {            
            const kind = symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface;
            const merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
            if (merged) {
                // note:we overwrite links because we just cloned the symbol
                symbol = merged;
                links = merged.links;
            }

            const type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType;
            const outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
            const localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
            // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
            // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
            // property types inferred from initializers and method return types inferred from return statements are very hard
            // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
            // "this" references.
            if (outerTypeParameters || localTypeParameters || kind === ObjectFlags.Class) {
                type.objectFlags |= ObjectFlags.Reference;
                type.typeParameters = concatenate(outerTypeParameters, localTypeParameters);
                type.outerTypeParameters = outerTypeParameters;
                type.localTypeParameters = localTypeParameters;
                (type as GenericType).instantiations = new Map<string, TypeReference>();
                (type as GenericType).instantiations.set(getTypeListId(type.typeParameters), type as GenericType);
                (type as GenericType).target = type as GenericType;
                (type as GenericType).resolvedTypeArguments = type.typeParameters;
                type.thisType = createTypeParameter(symbol);
                type.thisType.isThisType = true;
                type.thisType.constraint = type;
            }
        }
        return links.declaredType as InterfaceType;
    }

    
    function getAnnotatedTypeForAssignmentDeclaration(declaredType: Type | undefined, expression: Expression, symbol: Symbol, declaration: Declaration) {
        const typeNode = getEffectiveTypeAnnotationNode(expression.parent);
        if (typeNode) {
            const type = getWidenedType(getTypeFromTypeNode(typeNode));
            if (!declaredType) {
                return type;
            }
            else if (!isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(declaredType, type)) {
                errorNextVariableOrPropertyDeclarationMustHaveSameType(/*firstDeclaration*/ undefined, declaredType, declaration, type);
            }
        }
        if (symbol.parent?.valueDeclaration) {
            const possiblyAnnotatedSymbol = getFunctionExpressionParentSymbolOrSymbol(symbol.parent);
            if (possiblyAnnotatedSymbol.valueDeclaration) {
                const typeNode = getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration);
                if (typeNode) {
                    const annotationSymbol = getPropertyOfType(getTypeFromTypeNode(typeNode), symbol.name);
                    if (annotationSymbol) {
                        return getNonMissingTypeOfSymbol(annotationSymbol);
                    }
                }
            }
        }

        return declaredType;
    }


    function getTypeOfVariableOrParameterOrPropertyWorker(symbol: Symbol): Type {
        // Handle prototype property
        // if (symbol.flags & SymbolFlags.Prototype) {
        //     return getTypeOfPrototypeProperty(symbol);
        // }
        // CommonsJS require and module both have type any.
        if (symbol === requireSymbol) {
            return anyType;
        }
        if (symbol.flags & SymbolFlags.ModuleExports && symbol.valueDeclaration) {
            const fileSymbol = getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration));
            const result = createSymbol(fileSymbol.flags, "exports" as string);
            result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
            result.parent = symbol;
            result.links.target = fileSymbol;
            if (fileSymbol.valueDeclaration) result.valueDeclaration = fileSymbol.valueDeclaration;
            if (fileSymbol.members) result.members = new Map(fileSymbol.members);
            if (fileSymbol.exports) result.exports = new Map(fileSymbol.exports);
            const members = createSymbolTable();
            members.set("exports" as string, result);
            return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
        }
        Debug.assertIsDefined(symbol.valueDeclaration);
        const declaration = symbol.valueDeclaration;
        // Handle export default expressions
        // if (isSourceFile(declaration) && isJsonSourceFile(declaration)) {
        //     if (!declaration.statements.length) {
        //         return emptyObjectType;
        //     }
        //     return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
        // }
        // if (isAccessor(declaration)) {
        //     // Binding of certain patterns in JS code will occasionally mark symbols as both properties
        //     // and accessors. Here we dispatch to accessor resolution if needed.
        //     return getTypeOfAccessors(symbol);
        // }

        // Handle variable, parameter or property
        if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            if (symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            return reportCircularityError(symbol);            
        }
        let type: Type;
        // if (declaration.kind === SyntaxKind.ExportAssignment) {
        //     type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration as ExportAssignment).expression), declaration);
        // } else
        if (
            isBinaryExpression(declaration) ||
            (isInJSFile(declaration) &&
                (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) /*|| isBindableStaticElementAccessExpression(declaration)*/) && isBinaryExpression(declaration.parent)))
        ) {
            type = getWidenedTypeForAssignmentDeclaration(symbol);
        }
        else if (
            isPropertyAccessExpression(declaration)
            || isElementAccessExpression(declaration)
            || isIdentifier(declaration)
            || isStringLiteral(declaration)
            || isIntLiteral(declaration)
            || isFloatLiteral(declaration)
            // || isClassDeclaration(declaration)
            || isFunctionDeclaration(declaration)
            // || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration))
            // || isMethodSignature(declaration)
            || isSourceFile(declaration)
        ) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }            
            type = declaration.parent && isBinaryExpression(declaration.parent) ?
                getWidenedTypeForAssignmentDeclaration(symbol) :
                tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
        }
        else if (isPropertyAssignment(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration);
        }
        // else if (isJsxAttribute(declaration)) {
        //     type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration);
        // }
        else if (isShorthandPropertyAssignment(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckMode.Normal);
        }
        // else if (isObjectLiteralMethod(declaration)) {
        //     type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckMode.Normal);
        // }
        else if (
            isParameter(declaration)
            || isPropertyDeclaration(declaration)
            || isPropertySignature(declaration)
            || isVariableDeclaration(declaration)
            || isBindingElement(declaration)
            || isJSDocPropertyLikeTag(declaration)
        ) {
            type = getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors*/ true);
        }
        // getTypeOfSymbol dispatches some JS merges incorrectly because their symbol flags are not mutually exclusive.
        // Re-dispatch based on valueDeclaration.kind instead.
        // else if (isEnumDeclaration(declaration)) {
        //     type = getTypeOfFuncClassEnumModule(symbol);
        // }
        // else if (isEnumMember(declaration)) {
        //     type = getTypeOfEnumMember(symbol);
        // }
        else if (isDefineDirective(declaration)) {
            // this is needed for the completion provider    
            type = anyType;
        }
        else {
            return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol));
        }

        if (!popTypeResolution()) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            if (symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            return reportCircularityError(symbol);            
        }
        return type;
    }

    function reportCircularityError(symbol: Symbol) {
        const declaration = symbol.valueDeclaration;
        // Check if variable has type annotation that circularly references the variable itself
        if (declaration) {
            if (getEffectiveTypeAnnotationNode(declaration)) {
                error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                return errorType;
            }
            // Check if variable has initializer that circularly references the variable itself
            if (noImplicitAny && (declaration.kind !== SyntaxKind.Parameter || (declaration as HasInitializer).initializer)) {
                error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol));
            }
        }
        else if (symbol.flags & SymbolFlags.Alias) {
            const node = getDeclarationOfAliasSymbol(symbol);
            if (node) {
                error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
            }
        }
        // Circularities could also result from parameters in function expressions that end up
        // having themselves as contextual types following type argument inference. In those cases
        // we have already reported an implicit any error so we don't report anything here.
        return anyType;
    }

    function checkEvaluateExpression(node: EvaluateExpression, checkMode?: CheckMode): Type {
        const type = checkExpression(node.expression, checkMode);
        node.arguments?.forEach(a => checkExpression(a, checkMode));
        
        return type;
    }

    function checkPropertyAssignment(node: PropertyAssignment, checkMode?: CheckMode): Type {
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        // if (node.name.kind === SyntaxKind.ComputedPropertyName) {
        //     checkComputedPropertyName(node.name);
        // }

        const intializerType = checkExpressionForMutableLocation(node.initializer, checkMode);

        // check if this is a new class expression
        if (isNewClassExpression(node.parent)) {
            // find the property on the struct declaration and check it
            const propName = node.name as Identifier;
            const structType = getTypeFromTypeNode(node.parent.expression as TypeNode) as AnonymousType;
            const structProp = structType.properties && find(structType.properties, p => p.name == propName.text);
            if (structProp) {
                const structPropType = getTypeOfSymbol(structProp);
                if (!isTypeAssignableTo(intializerType, structPropType)) {
                    error(node, Diagnostics.Type_0_is_not_assignable_to_type_1, typeToString(intializerType), typeToString(structPropType));
                }
            }
        }

        return intializerType;
    }

    function checkExpressionForMutableLocation(node: Expression, checkMode: CheckMode | undefined, forceTuple?: boolean): Type {
        const type = checkExpression(node, checkMode, forceTuple);
        if (isLiteralType(type)) {
            const reg = getRegularTypeOfLiteralType(type);
            if (reg.isIntLiteral() && reg.value === 0) {
                return reg;
            }
        } 
        // return isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) :        
        return isTypeAssertion(node) ? type : getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType(node, /*contextFlags*/ undefined), node, /*contextFlags*/ undefined));
    }

    function getTypeOfSymbol(symbol: Symbol, checkMode?: CheckMode): Type {        
        const checkFlags = getCheckFlags(symbol);
        if (checkFlags & CheckFlags.DeferredType) {
            Debug.fail("TODO - getTypeOfSymbol");
            // return getTypeOfSymbolWithDeferredType(symbol);
        }
        if (checkFlags & CheckFlags.Instantiated) {
            return getTypeOfInstantiatedSymbol(symbol);
        }
        if (checkFlags & CheckFlags.Mapped) {
            return getTypeOfMappedSymbol(symbol as MappedSymbol);
        }
        if (checkFlags & CheckFlags.ReverseMapped) {
            return getTypeOfReverseMappedSymbol(symbol as ReverseMappedSymbol);
        }
        if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
            return getTypeOfVariableOrParameterOrProperty(symbol);
        }
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) {
            return getTypeOfFuncClassEnumModule(symbol);
        }                
        if (symbol.flags & SymbolFlags.Alias) {
            return getTypeOfAlias(symbol);
        }
        return errorType;
    }

    function getTypeOfAlias(symbol: Symbol): Type {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
                return errorType;
            }
            const targetSymbol = resolveAlias(symbol);
            const exportSymbol = symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol)!, /*dontRecursivelyResolve*/ true);
            const declaredType = firstDefined(exportSymbol?.declarations, d => isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined);

            // It only makes sense to get the type of a value symbol. If the result of resolving
            // the alias is not a value, then it has no type. To get the type associated with a
            // type symbol, call getDeclaredTypeOfSymbol.
            // This check is important because without it, a call to getTypeOfSymbol could end
            // up recursively calling getTypeOfAlias, causing a stack overflow.
            links.type ??= /*exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol)
                : isDuplicatedCommonJSExport(symbol.declarations) ? autoType
                :*/ declaredType ? declaredType
                : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol)
                : errorType;

            if (!popTypeResolution()) {
                reportCircularityError(exportSymbol ?? symbol);
                return links.type ??= errorType;
            }
        }
        return links.type;
    }

    function getTypeOfFuncClassEnumModule(symbol: Symbol): Type {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.type) {            
            // no expandos in LPC

            // const expando = symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, /*allowDeclaration*/ false);
            // if (expando) {
            //     const merged = mergeJSSymbols(symbol, expando);
            //     if (merged) {
            //         // note:we overwrite links because we just cloned the symbol
            //         symbol = merged;
            //         links = merged.links;
            //     }
            // }
            originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol);
        }
        return links.type;
    }

    function getTypeOfFuncClassEnumModuleWorker(symbol: Symbol): Type {
        const declaration = symbol.valueDeclaration;
        // if (symbol.flags & SymbolFlags.Module && isShorthandAmbientModuleSymbol(symbol)) {
        //     return anyType;
        // } else
        if (
            declaration && (declaration.kind === SyntaxKind.BinaryExpression ||
                isAccessExpression(declaration) &&
                    declaration.parent.kind === SyntaxKind.BinaryExpression)
        ) {
            return getWidenedTypeForAssignmentDeclaration(symbol);
        }        
        // else if (symbol.flags & SymbolFlags.ValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator) {
        //     const resolvedModule = resolveExternalModuleSymbol(symbol);
        //     if (resolvedModule !== symbol) {
        //         if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
        //             return errorType;
        //         }
        //         const exportEquals = getMergedSymbol(symbol.exports!.get(InternalSymbolName.ExportEquals)!);
        //         const type = getWidenedTypeForAssignmentDeclaration(exportEquals, exportEquals === resolvedModule ? undefined : resolvedModule);
        //         if (!popTypeResolution()) {
        //             return reportCircularityError(symbol);
        //         }
        //         return type;
        //     }
        // }
        const type = createObjectType(ObjectFlags.Anonymous, symbol);
        if (symbol.flags & SymbolFlags.Class) {
            const baseTypeVariable = getBaseTypeVariableOfClass(symbol);
            return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
        }
        else {
            return strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type, /*isProperty*/ true) : type;
        }
    }

    function getBaseTypeVariableOfClass(symbol: Symbol) {
        const baseConstructorType = getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol));
        return baseConstructorType?.flags & TypeFlags.TypeVariable ? baseConstructorType :
            baseConstructorType?.flags & TypeFlags.Intersection ? find((baseConstructorType as IntersectionType).types, t => !!(t.flags & TypeFlags.TypeVariable)) :
            undefined;
    }

    function hasHeritageClauses(node: SourceFile): boolean {
        return node.heritageClauses.length > 0;
    }
    
    /**
     * The base constructor of a class can resolve to
     * * undefinedType if the class has no extends clause,
     * * errorType if an error occurred during resolution of the extends expression,
     * * nullType if the extends expression is the null value,
     * * anyType if the extends expression has type any, or
     * * an object type with at least one construct signature.
     */
    function getBaseConstructorTypeOfClass(type: InterfaceType): Type {
        if (!type.resolvedBaseConstructorType) {
            const decl = getClassLikeDeclarationOfSymbol(type.symbol);
            const extended = decl && getEffectiveBaseTypeNode(decl);            
            const baseTypeNode = getBaseTypeNodeOfClass(type);
            if (!baseTypeNode) {
                return type.resolvedBaseConstructorType = undefinedType;
            }
            if (!pushTypeResolution(type, TypeSystemPropertyName.ResolvedBaseConstructorType)) {
                return errorType;
            }
            const baseConstructorType = checkExpression(baseTypeNode.expression);
            if (extended && baseTypeNode !== extended) {
                Debug.assert(!extended.typeArguments); // Because this is in a JS file, and baseTypeNode is in an @extends tag
                checkExpression(extended.expression);
            }
            if (baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection)) {
                // Resolving the members of a class requires us to resolve the base class of that class.
                // We force resolution here such that we catch circularities now.
                resolveStructuredTypeMembers(baseConstructorType as ObjectType);
            }
            if (!popTypeResolution()) {
                error(type.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
                return type.resolvedBaseConstructorType ??= errorType;
            }
            if (!(baseConstructorType.flags & TypeFlags.Any) && baseConstructorType !== nullWideningType /*&& !isConstructorType(baseConstructorType)*/) {
                console.debug("todo - implement this");
            //     const err = error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
            //     if (baseConstructorType.flags & TypeFlags.TypeParameter) {
            //         const constraint = getConstraintFromTypeParameter(baseConstructorType);
            //         let ctorReturn: Type = unknownType;
            //         if (constraint) {
            //             const ctorSig = getSignaturesOfType(constraint, SignatureKind.Construct);
            //             if (ctorSig[0]) {
            //                 ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
            //             }
            //         }
            //         if (baseConstructorType.symbol.declarations) {
            //             addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
            //         }
            //     }
            //     return type.resolvedBaseConstructorType ??= errorType;
            }
            type.resolvedBaseConstructorType ??= baseConstructorType;
        }
        return type.resolvedBaseConstructorType;
    }
    
    function shouldMarkIdentifierAliasReferenced(node: Identifier): boolean {
        const parent = node.parent;
        if (parent) {
            // A property access expression LHS? checkPropertyAccessExpression will handle that.
            if (isPropertyAccessExpression(parent) && parent.expression === node) {
                return false;
            }
            // Next two check for an identifier inside a type only export.
            // if (isExportSpecifier(parent) && parent.isTypeOnly) {
            //     return false;
            // }
            const greatGrandparent = parent.parent?.parent;
            // if (greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly) {
            //     return false;
            // }
        }
        return true;
    }

    function markAliasReferenced(symbol: Symbol, location: Node) {
        // if (!canCollectSymbolAliasAccessabilityData) {
        //     return;
        // }
        if (isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value)) {
            const target = resolveAlias(symbol);
            if (getSymbolFlags(symbol, /*excludeTypeOnlyMeanings*/ true) & (SymbolFlags.Value | SymbolFlags.ExportValue)) {
                // An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
                // (because the const enum value will not be inlined), or if (2) the alias is an export
                // of a const enum declaration that will be preserved.
                // if (
                //     getIsolatedModules(compilerOptions) ||
                //     shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) ||
                //     !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target))
                // ) {
                    markAliasSymbolAsReferenced(symbol);
                //}
            }
        }
    }


    // When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
    // we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
    // the alias as an expression (which recursively takes us back here if the target references another alias).
    function markAliasSymbolAsReferenced(symbol: Symbol) {
        //Debug.assert(canCollectSymbolAliasAccessabilityData);
        const links = getSymbolLinks(symbol);
        if (!links.referenced) {
            links.referenced = true;
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            // We defer checking of the reference of an `import =` until the import itself is referenced,
            // This way a chain of imports can be elided if ultimately the final input is only used in a type
            // position.

            //TODO
            // if (isInternalModuleImportEqualsDeclaration(node)) {
            //     if (getSymbolFlags(resolveSymbol(symbol)) & SymbolFlags.Value) {
            //         // import foo = <symbol>
            //         const left = getFirstIdentifier(node.moduleReference as EntityNameExpression);
            //         markIdentifierAliasReferenced(left);
            //     }
            // }
        }
    }


    function markIdentifierAliasReferenced(location: Identifier) {
        const symbol = getResolvedSymbol(location);
        if (symbol && symbol !== argumentsSymbol && symbol !== unknownSymbol) {
            markAliasReferenced(symbol, location);
        }
    }

    /**
     * This function marks all the imports the given location refers to as `.referenced` in `NodeLinks` (transitively through local import aliases).
     * (This corresponds to not getting elided in JS emit.)
     * It can be called on *most* nodes in the AST with `ReferenceHint.Unspecified` and will filter its inputs, but care should be taken to avoid calling it on the RHS of an `import =` or specifiers in a `import {} from "..."`,
     * unless you *really* want to *definitely* mark those as referenced.
     * These shouldn't be directly marked, and should only get marked transitively by the internals of this function.
     *
     * @param location The location to mark js import refernces for
     * @param hint The kind of reference `location` has already been checked to be
     * @param propSymbol The optional symbol of the property we're looking up - this is used for property accesses when `const enum`s do not count as references (no `isolatedModules`, no `preserveConstEnums` + export). It will be calculated if not provided.
     * @param parentType The optional type of the parent of the LHS of the property access - this will be recalculated if not provided (but is costly).
     */
    function markLinkedReferences(location: PropertyAccessExpression | QualifiedName, hint: ReferenceHint.Property, propSymbol: Symbol | undefined, parentType: Type): void;
    function markLinkedReferences(location: Identifier, hint: ReferenceHint.Identifier): void;
    //function markLinkedReferences(location: ExportAssignment, hint: ReferenceHint.ExportAssignment): void;    
    function markLinkedReferences(location: FunctionLikeDeclaration /*| MethodSignature*/, hint: ReferenceHint.AsyncFunction): void;
    // function markLinkedReferences(location: ImportEqualsDeclaration, hint: ReferenceHint.ExportImportEquals): void;        
    function markLinkedReferences(location: Node, hint: ReferenceHint.Unspecified, propSymbol?: Symbol, parentType?: Type): void;
    function markLinkedReferences(location: Node, hint: ReferenceHint, propSymbol?: Symbol, parentType?: Type) {        
        if (location.flags & NodeFlags.Ambient) {
            return; // References within types and declaration files are never going to contribute to retaining a JS import
        }
        //Debug.fail("Implement me - markLinkedReferences");
        switch (hint) {
            case ReferenceHint.Identifier:
                return markIdentifierAliasReferenced(location as Identifier);
            case ReferenceHint.Property:
                return markPropertyAliasReferenced(location as PropertyAccessExpression | QualifiedName, propSymbol, parentType);
        //     case ReferenceHint.ExportAssignment:
        //         return markExportAssignmentAliasReferenced(location as ExportAssignment);        
        //     case ReferenceHint.AsyncFunction:
        //         return markAsyncFunctionAliasReferenced(location as FunctionLikeDeclaration | MethodSignature);
        //     case ReferenceHint.ExportImportEquals:
        //         return markImportEqualsAliasReferenced(location as ImportEqualsDeclaration);
        //     case ReferenceHint.ExportSpecifier:
        //         return markExportSpecifierAliasReferenced(location as ExportSpecifier);        
            case ReferenceHint.Unspecified: {
                // Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used
                // Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`
                // This is the exception, rather than the rule - most non-expression identifiers are declaration names.
                if (isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) /*|| (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference === location)*/) && shouldMarkIdentifierAliasReferenced(location)) {
                    if (isPropertyAccessOrQualifiedName(location.parent)) {
                        const left = isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left;
                        if (left !== location) return; // Only mark the LHS (the RHS is a property lookup)
                    }
                    markIdentifierAliasReferenced(location);
                    return;
                }
                if (isPropertyAccessOrQualifiedName(location)) {
                    let topProp: Node | undefined = location;
                    while (isPropertyAccessOrQualifiedName(topProp)) {
                        // if (isPartOfTypeNode(topProp)) return;
                        topProp = topProp.parent;
                    }
                    return markPropertyAliasReferenced(location);
                }
                // if (isExportAssignment(location)) {
                //     return markExportAssignmentAliasReferenced(location);
                // }                
                // if (isImportEqualsDeclaration(location)) {
                //     if (isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location)) {
                //         return markImportEqualsAliasReferenced(location);
                //     }
                //     return;
                // }
                // if (isExportSpecifier(location)) {
                //     return markExportSpecifierAliasReferenced(location);
                // }
                if (isFunctionLikeDeclaration(location)/* || isMethodSignature(location)*/) {
                    //markAsyncFunctionAliasReferenced(location);
                    // Might be decorated, fall through to decorator final case
                }
                return;
            }
            default:
                Debug.assertNever(hint as never, `Unhandled reference hint: ${hint}`);
        }
    }
    
    function markPropertyAliasReferenced(location: PropertyAccessExpression | QualifiedName, propSymbol?: Symbol, parentType?: Type) {
        const left = isPropertyAccessExpression(location) ? location.expression : location.left;
        if (!isIdentifier(left)) {
            return;
        }
        const parentSymbol = getResolvedSymbol(left);
        if (!parentSymbol || parentSymbol === unknownSymbol) {
            return;
        }
        // In `Foo.Bar.Baz`, 'Foo' is not referenced if 'Bar' is a const enum or a module containing only const enums.
        // `Foo` is also not referenced in `enum FooCopy { Bar = Foo.Bar }`, because the enum member value gets inlined
        // here even if `Foo` is not a const enum.
        //
        // The exceptions are:
        //   1. if 'isolatedModules' is enabled, because the const enum value will not be inlined, and
        //   2. if 'preserveConstEnums' is enabled and the expression is itself an export, e.g. `export = Foo.Bar.Baz`.
        //
        // The property lookup is deferred as much as possible, in as many situations as possible, to avoid alias marking
        // pulling on types/symbols it doesn't strictly need to.
        // if (getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location))) {
        //     markAliasReferenced(parentSymbol, location);
        //     return;
        // }
        // Hereafter, this relies on type checking - but every check prior to this only used symbol information
        const leftType = parentType || checkExpressionCached(left);
        if (isTypeAny(leftType) || leftType === silentNeverType) {
            markAliasReferenced(parentSymbol, location);
            return;
        }
        let prop = propSymbol;
        if (!prop && !parentType) {
            const right = isPropertyAccessExpression(location) ? location.name : location.right;
            const lexicallyScopedSymbol = false;// isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.text, right);
            const assignmentKind = getAssignmentTargetKind(location);
            const apparentType = getApparentType(assignmentKind !== AssignmentKind.None /*|| isMethodAccessForCall(location)*/ ? getWidenedType(leftType) : leftType);
            prop = /*isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined :*/ getPropertyOfType(apparentType, (right as Identifier).text);
        }
        // if (
        //     !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags & SymbolFlags.EnumMember && location.parent.kind === SyntaxKind.EnumMember))
        // ) {
        //     markAliasReferenced(parentSymbol, location);
        // }
        return;
    }

    function getWidenedType(type: Type) {
        return getWidenedTypeWithContext(type, /*context*/ undefined);
    }

    function createWideningContext(parent: WideningContext | undefined, propertyName: string | undefined, siblings: Type[] | undefined): WideningContext {
        return { parent, propertyName, siblings, resolvedProperties: undefined };
    }

    function getSiblingsOfContext(context: WideningContext): Type[] {
        if (!context.siblings) {
            const siblings: Type[] = [];
            for (const type of getSiblingsOfContext(context.parent!)) {
                if (isObjectLiteralType(type)) {
                    const prop = getPropertyOfObjectType(type, context.propertyName!);
                    if (prop) {
                        forEachType(getTypeOfSymbol(prop), t => {
                            siblings.push(t);
                        });
                    }
                }
            }
            context.siblings = siblings;
        }
        return context.siblings;
    }

    function getPropertiesOfUnionOrIntersectionType(type: UnionOrIntersectionType): Symbol[] {
        if (!type.resolvedProperties) {
            const members = createSymbolTable();
            for (const current of type.types) {
                for (const prop of getPropertiesOfType(current)) {
                    if (!members.has(prop.name)) {
                        const combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.name, /*skipObjectFunctionPropertyAugment*/ !!(type.flags & TypeFlags.Intersection));
                        if (combinedProp) {
                            members.set(prop.name, combinedProp);
                        }
                    }
                }
                // The properties of a union type are those that are present in all constituent types, so
                // we only need to check the properties of the first type without index signature
                if (type.flags & TypeFlags.Union && getIndexInfosOfType(current).length === 0) {
                    break;
                }
            }
            type.resolvedProperties = getNamedMembers(members);
        }
        return type.resolvedProperties;
    }

    function getPropertiesOfType(type: Type): Symbol[] {
        type = getReducedApparentType(type);
        return type.flags & TypeFlags.UnionOrIntersection ?
            getPropertiesOfUnionOrIntersectionType(type as UnionType) :
            getPropertiesOfObjectType(type) ?? emptyArray;
    }

    function getPropertiesOfContext(context: WideningContext): Symbol[] {
        if (!context.resolvedProperties) {
            const names = new Map<string, Symbol>();
            for (const t of getSiblingsOfContext(context)) {
                if (isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlags.ContainsSpread)) {
                    for (const prop of getPropertiesOfType(t)) {
                        names.set(prop.name, prop);
                    }
                }
            }
            context.resolvedProperties = arrayFrom(names.values());
        }
        return context.resolvedProperties;
    }

    function getWidenedProperty(prop: Symbol, context: WideningContext | undefined): Symbol {
        if (!(prop.flags & SymbolFlags.Property)) {
            // Since get accessors already widen their return value there is no need to
            // widen accessor based properties here.
            return prop;
        }
        const original = getTypeOfSymbol(prop);
        const propContext = context && createWideningContext(context, prop.name, /*siblings*/ undefined);
        const widened = getWidenedTypeWithContext(original, propContext);
        return widened === original ? prop : createSymbolWithType(prop, widened);
    }

    function getUndefinedProperty(prop: Symbol) {
        const cached = undefinedProperties.get(prop.name);
        if (cached) {
            return cached;
        }
        const result = createSymbolWithType(prop, undefinedOrMissingType);
        result.flags |= SymbolFlags.Optional;
        undefinedProperties.set(prop.name, result);
        return result;
    }


    function getWidenedTypeOfObjectLiteral(type: Type, context: WideningContext | undefined): Type {
        const members = createSymbolTable();
        for (const prop of getPropertiesOfObjectType(type)) {
            members.set(prop.name, getWidenedProperty(prop, context));
        }
        if (context) {
            for (const prop of getPropertiesOfContext(context)) {
                if (!members.has(prop.name)) {
                    members.set(prop.name, getUndefinedProperty(prop));
                }
            }
        }
        const result = createAnonymousType(type.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type), info => createIndexInfo(info.keyType, getWidenedType(info.type), info.isReadonly)));
        result.objectFlags |= getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.NonInferrableType); // Retain js literal flag through widening
        return result;
    }

    function createIndexInfo(keyType: Type, type: Type, isReadonly: boolean, declaration?: IndexSignatureDeclaration): IndexInfo {
        return { keyType, type, isReadonly, declaration };
    }

    function getWidenedTypeWithContext(type: Type, context: WideningContext | undefined): Type {
        if (getObjectFlags(type) & ObjectFlags.RequiresWidening) {
            if (context === undefined && type.widened) {
                return type.widened;
            }
            let result: Type | undefined;
            if (type.flags & (TypeFlags.Any | TypeFlags.Nullable)) {
                result = anyType;
            }
            else if (isObjectLiteralType(type)) {
                result = getWidenedTypeOfObjectLiteral(type, context);
            }
            else if (type.flags & TypeFlags.Union) {
                const unionContext = context || createWideningContext(/*parent*/ undefined, /*propertyName*/ undefined, (type as UnionType).types);
                const widenedTypes = sameMap((type as UnionType).types, t => t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext));
                // Widening an empty object literal transitions from a highly restrictive type to
                // a highly inclusive one. For that reason we perform subtype reduction here if the
                // union includes empty object types (e.g. reducing {} | string to just {}).
                result = getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal);
            }
            else if (type.flags & TypeFlags.Intersection) {
                result = getIntersectionType(sameMap((type as IntersectionType).types, getWidenedType));
            }
            else if (isArrayOrTupleType(type)) {
                result = createTypeReference(type.target, sameMap(getTypeArguments(type), getWidenedType));
            }
            if (result && context === undefined) {
                type.widened = result;
            }
            return result || type;
        }
        return type;
    }

    
    
    function checkExpressionCached(node: Expression | QualifiedName, checkMode?: CheckMode): Type {
        if (checkMode) {
            return checkExpression(node, checkMode);
        }
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            // When computing a type that we're going to cache, we need to ignore any ongoing control flow
            // analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
            // to the top of the stack ensures all transient types are computed from a known point.
            const saveFlowLoopStart = flowLoopStart;
            const saveFlowTypeCache = flowTypeCache;
            flowLoopStart = flowLoopCount;
            flowTypeCache = undefined;
            links.resolvedType = checkExpression(node, checkMode);
            flowTypeCache = saveFlowTypeCache;
            flowLoopStart = saveFlowLoopStart;
        }
        Debug.assertIsDefined(links.resolvedType);
        return links.resolvedType;
    }
    
    function getNarrowedTypeOfSymbol(symbol: Symbol, location: Identifier, checkMode?: CheckMode) {
        const type = getTypeOfSymbol(symbol, checkMode);
        const declaration = symbol.valueDeclaration;        
        if (declaration) {
            // If we have a non-rest binding element with no initializer declared as a const variable or a const-like
            // parameter (a parameter for which there are no assignments in the function body), and if the parent type
            // for the destructuring is a union type, one or more of the binding elements may represent discriminant
            // properties, and we want the effects of conditional checks on such discriminants to affect the types of
            // other binding elements from the same destructuring. Consider:
            //
            //   type Action =
            //       | { kind: 'A', payload: number }
            //       | { kind: 'B', payload: string };
            //
            //   function f({ kind, payload }: Action) {
            //       if (kind === 'A') {
            //           payload.toFixed();
            //       }
            //       if (kind === 'B') {
            //           payload.toUpperCase();
            //       }
            //   }
            //
            // Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
            // the binding pattern AST instance for '{ kind, payload }' as a pseudo-reference and narrow this reference
            // as if it occurred in the specified location. We then recompute the narrowed binding element type by
            // destructuring from the narrowed parent type.
            if (isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2) {
                const parent = declaration.parent.parent;
                const rootDeclaration = getRootDeclaration(parent);
                if (rootDeclaration.kind === SyntaxKind.Parameter) {
                    console.log("TODO - getNarrowedTypeOfSymbol");
                    // const links = getNodeLinks(parent);
                    // if (!(links.flags & NodeCheckFlags.InCheckIdentifier)) {
                    //     links.flags |= NodeCheckFlags.InCheckIdentifier;
                    //     const parentType = getTypeForBindingElementParent(parent, CheckMode.Normal);
                    //     const parentTypeConstraint = parentType && mapType(parentType, getBaseConstraintOrType);
                    //     links.flags &= ~NodeCheckFlags.InCheckIdentifier;
                    //     if (parentTypeConstraint && parentTypeConstraint.flags & TypeFlags.Union && !(rootDeclaration.kind === SyntaxKind.Parameter && isSomeSymbolAssigned(rootDeclaration))) {
                    //         const pattern = declaration.parent;
                    //         const narrowedType = getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, /*flowContainer*/ undefined, location.flowNode);
                    //         if (narrowedType.flags & TypeFlags.Never) {
                    //             return neverType;
                    //         }
                    //         // Destructurings are validated against the parent type elsewhere. Here we disable tuple bounds
                    //         // checks because the narrowed type may have lower arity than the full parent type. For example,
                    //         // for the declaration [x, y]: [1, 2] | [3], we may have narrowed the parent type to just [3].
                    //         return getBindingElementTypeFromParentType(declaration, narrowedType, /*noTupleBoundsCheck*/ true);
                    //     }
                    // }
                }
            }
            // If we have a const-like parameter with no type annotation or initializer, and if the parameter is contextually
            // typed by a signature with a single rest parameter of a union of tuple types, one or more of the parameters may
            // represent discriminant tuple elements, and we want the effects of conditional checks on such discriminants to
            // affect the types of other parameters in the same parameter list. Consider:
            //
            //   type Action = [kind: 'A', payload: number] | [kind: 'B', payload: string];
            //
            //   const f: (...args: Action) => void = (kind, payload) => {
            //       if (kind === 'A') {
            //           payload.toFixed();
            //       }
            //       if (kind === 'B') {
            //           payload.toUpperCase();
            //       }
            //   }
            //
            // Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
            // the arrow function AST node for '(kind, payload) => ...' as a pseudo-reference and narrow this reference as
            // if it occurred in the specified location. We then recompute the narrowed parameter type by indexing into the
            // narrowed tuple type.
            if (isParameter(declaration) && !declaration.type && !declaration.initializer && !declaration.dotDotDotToken) {
                const func = declaration.parent;
                if (func.parameters?.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                    const contextualSignature = getContextualSignature(func);
                    if (contextualSignature && contextualSignature.parameters.length === 1 && signatureHasRestParameter(contextualSignature)) {
                        const restType = getReducedApparentType(instantiateType(getTypeOfSymbol(contextualSignature.parameters[0]), getInferenceContext(func)?.nonFixingMapper));
                        console.debug("todo - getNarrowedTypeOfSymbol");
                        // if (restType.flags & TypeFlags.Union && everyType(restType, isTupleType) && !some(func.parameters, isSomeSymbolAssigned)) {
                        //     const narrowedType = getFlowTypeOfReference(func, restType, restType, /*flowContainer*/ undefined, location.flowNode);
                        //     const index = func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0);
                        //     return getIndexedAccessType(narrowedType, getNumberLiteralType(index));
                        // }
                    }
                }
            }
        }
        return type;
    }

    function getBaseTypeOfLiteralType(type: Type): Type {
        return type.flags & (TypeFlags.StringLiteral) ? stringType :
            type.flags & TypeFlags.IntLiteral ? intType :
            type.flags & TypeFlags.FloatLiteral ? floatType :
            //type.flags & TypeFlags.BooleanLiteral ? booleanType :
            type.flags & TypeFlags.Union ? getBaseTypeOfLiteralTypeUnion(type as UnionType) :
            type;
    }

    function getTypeId(type: Type): TypeId {
        return type.id;
    }

    function getCachedType(key: string | undefined) {
        return key ? cachedTypes.get(key) : undefined;
    }

    function setCachedType(key: string | undefined, type: Type) {
        if (key) cachedTypes.set(key, type);
        return type;
    }
    
    function getTypeListId(types: readonly Type[] | undefined) {
        let result = "";
        if (types) {
            const length = types.length;
            let i = 0;
            while (i < length) {
                Debug.assertIsDefined(types[i]);
                const startId = types[i].id;
                let count = 1;
                while (i + count < length && types[i + count].id === startId + count) {
                    count++;
                }
                if (result.length) {
                    result += ",";
                }
                result += startId;
                if (count > 1) {
                    result += ":" + count;
                }
                i += count;
            }
        }
        return result;
    }

    function getAliasId(aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined) {
        return aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "";
    }

    // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
    // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
    // of other types. Subtype reduction is expensive for large union types and is possible only when union
    // types are known not to circularly reference themselves (as is the case with union types created by
    // expression constructs such as array literals and the || and ?: operators). Named types can
    // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
    // For example, "type Item = string | (() => Item" is a named type that circularly references itself.
    function getUnionType(types: readonly Type[], unionReduction: UnionReduction = UnionReduction.Literal, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[], origin?: Type): Type {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        // We optimize for the common case of unioning a union type with some other type (such as `undefined`).
        if (types.length === 2 && !origin && (types[0].flags & TypeFlags.Union || types[1].flags & TypeFlags.Union)) {
            const infix = unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L";
            const index = types[0].id < types[1].id ? 0 : 1;
            const id = types[index].id + infix + types[1 - index].id + getAliasId(aliasSymbol, aliasTypeArguments);
            let type = unionOfUnionTypes.get(id);
            if (!type) {
                type = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, /*origin*/ undefined);
                unionOfUnionTypes.set(id, type);
            }
            return type;
        }
        return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin);
    }
    
    // Add the given types to the given type set. Order is preserved, duplicates are removed,
    // and nested types of the given kind are flattened into the set.
    function addTypesToUnion(typeSet: Type[], includes: TypeFlags, types: readonly Type[]): TypeFlags {
        let lastType: Type | undefined;
        for (const type of types) {
            // We skip the type if it is the same as the last type we processed. This simple test particularly
            // saves a lot of work for large lists of the same union type, such as when resolving `Record<A, B>[A]`,
            // where A and B are large union types.
            if (type !== lastType) {
                includes = type.flags & TypeFlags.Union ?
                    addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) :
                    addTypeToUnion(typeSet, includes, type);
                lastType = type;
            }
        }
        return includes;
    }

    function isNamedUnionType(type: Type) {
        return !!(type.flags & TypeFlags.Union && (type.aliasSymbol || (type as UnionType).origin));
    }

    function addTypeToUnion(typeSet: Type[], includes: TypeFlags, type: Type) {
        const flags = type.flags;
        // We ignore 'never' types in unions
        if (!(flags & TypeFlags.Never)) {
            includes |= flags & TypeFlags.IncludesMask;
            if (flags & TypeFlags.Instantiable) includes |= TypeFlags.IncludesInstantiable;
            if (flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) includes |= TypeFlags.IncludesConstrainedTypeVariable;
            if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
            if (isErrorType(type)) includes |= TypeFlags.IncludesError;
            if (!strictNullChecks && flags & TypeFlags.Nullable) {
                if (!(getObjectFlags(type) & ObjectFlags.ContainsWideningType)) includes |= TypeFlags.IncludesNonWideningType;
            }
            else {
                const len = typeSet.length;
                const index = len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues);
                if (index < 0) {
                    typeSet.splice(~index, 0, type);
                }
            }
        }
        return includes;
    }

    function removeRedundantLiteralTypes(types: Type[], includes: TypeFlags, reduceVoidUndefined: boolean) {
        let i = types.length;
        while (i > 0) {
            i--;
            const t = types[i];
            const flags = t.flags;
            const remove = flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.String ||
                flags & TypeFlags.IntLiteral && includes & TypeFlags.Number ||
                flags & TypeFlags.FloatLiteral && includes & TypeFlags.Float ||
                flags & TypeFlags.BytesLiteral && includes & TypeFlags.Bytes ||
                reduceVoidUndefined && flags & TypeFlags.Undefined && includes & TypeFlags.Void ||
                isFreshLiteralType(t) && containsType(types, (t as LiteralType).regularType);
            if (remove) {
                orderedRemoveItemAt(types, i);
            }
        }
    }

    function isGenericMappedType(type: Type): type is MappedType {        
        if (getObjectFlags(type) & ObjectFlags.Mapped) {
            const constraint = getConstraintTypeFromMappedType(type as MappedType);
            if (isGenericIndexType(constraint)) {
                return true;
            }
            // A mapped type is generic if the 'as' clause references generic types other than the iteration type.
            // To determine this, we substitute the constraint type (that we now know isn't generic) for the iteration
            // type and check whether the resulting type is generic.
            const nameType = getNameTypeFromMappedType(type as MappedType);
            if (nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type as MappedType), constraint)))) {
                return true;
            }
        }
        return false;
    }
    
    function removeSubtypes(types: Type[], hasObjectTypes: boolean): Type[] | undefined {
        // [] and [T] immediately reduce to [] and [T] respectively
        if (types.length < 2) {
            return types;
        }

        const id = getTypeListId(types);
        const match = subtypeReductionCache.get(id);
        if (match) {
            return match;
        }

        // We assume that redundant primitive types have already been removed from the types array and that there
        // are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
        // object types, and if none of those are present we can exclude primitive types from the subtype check.
        const hasEmptyObject = hasObjectTypes && some(types, t => !!(t.flags & TypeFlags.Object) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t as ObjectType)));
        const len = types.length;
        let i = len;
        let count = 0;
        while (i > 0) {
            i--;
            const source = types[i];
            if (hasEmptyObject || source.flags & TypeFlags.StructuredOrInstantiable) {
                // A type parameter with a union constraint may be a subtype of some union, but not a subtype of the
                // individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not
                // a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the
                // type parameter is a subtype of a union of all the other types.
                if (source.flags & TypeFlags.TypeParameter && getBaseConstraintOrType(source).flags & TypeFlags.Union) {
                    if (isTypeRelatedTo(source, getUnionType(map(types, t => t === source ? neverType : t)), strictSubtypeRelation)) {
                        orderedRemoveItemAt(types, i);
                    }
                    continue;
                }
                // Find the first property with a unit type, if any. When constituents have a property by the same name
                // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
                // reduction of large discriminated union types.
                const keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?
                    find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :
                    undefined;
                const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                for (const target of types) {
                    if (source !== target) {
                        if (count === 100000) {
                            // After 100000 subtype checks we estimate the remaining amount of work by assuming the
                            // same ratio of checks per element. If the estimated number of remaining type checks is
                            // greater than 1M we deem the union type too complex to represent. This for example
                            // caps union types at 1000 unique object types.
                            const estimatedCount = (count / (len - i)) * len;
                            if (estimatedCount > 1000000) {
                                tracing?.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", { typeIds: types.map(t => t.id) });
                                error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                return undefined;
                            }
                        }
                        count++;
                        if (keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {
                            const t = getTypeOfPropertyOfType(target, keyProperty.name);
                            if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                continue;
                            }
                        }
                        if (
                            isTypeRelatedTo(source, target, strictSubtypeRelation) && (
                                !(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) ||
                                !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) ||
                                isTypeDerivedFrom(source, target)
                            )
                        ) {
                            orderedRemoveItemAt(types, i);
                            break;
                        }
                    }
                }
            }
        }
        subtypeReductionCache.set(id, types);
        return types;
    }

    function addNamedUnions(namedUnions: Type[], types: readonly Type[]) {
        for (const t of types) {
            if (t.flags & TypeFlags.Union) {
                const origin = (t as UnionType).origin;
                if (t.aliasSymbol || origin && !(origin.flags & TypeFlags.Union)) {
                    pushIfUnique(namedUnions, t);
                }
                else if (origin && origin.flags & TypeFlags.Union) {
                    addNamedUnions(namedUnions, (origin as UnionType).types);
                }
            }
        }
    }

    function getUnionTypeWorker(types: readonly Type[], unionReduction: UnionReduction, aliasSymbol: Symbol | undefined, aliasTypeArguments: readonly Type[] | undefined, origin: Type | undefined): Type {        
        let typeSet: Type[] | undefined = [];
        const includes = addTypesToUnion(typeSet, 0 as TypeFlags, types);
        if (unionReduction !== UnionReduction.None) {
            if (includes & TypeFlags.AnyOrUnknown) {
                return includes & TypeFlags.Any ?
                    includes & TypeFlags.IncludesWildcard ? wildcardType :
                        includes & TypeFlags.IncludesError ? errorType : anyType :
                    unknownType;
            }
            if (includes & TypeFlags.Undefined) {
                // If type set contains both undefinedType and missingType, remove missingType
                if (typeSet.length >= 2 && typeSet[0] === undefinedType && typeSet[1] === missingType) {
                    orderedRemoveItemAt(typeSet, 1);
                }
            }
            if (includes & (TypeFlags.Enum | TypeFlags.Literal | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) || includes & TypeFlags.Void && includes & TypeFlags.Undefined) {
                removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReduction.Subtype));
            }
            // if (includes & TypeFlags.StringLiteral && includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping)) {
            //     removeStringLiteralsMatchedByTemplateLiterals(typeSet);
            // }
            if (includes & TypeFlags.IncludesConstrainedTypeVariable) {
                removeConstrainedTypeVariables(typeSet);
            }
            if (unionReduction === UnionReduction.Subtype) {
                typeSet = removeSubtypes(typeSet, !!(includes & TypeFlags.Object));
                if (!typeSet) {
                    return errorType;
                }
            }
            if (typeSet.length === 0) {
                return includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType :
                    includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType :
                    neverType;
            }
        }
        if (!origin && includes & TypeFlags.Union) {
            const namedUnions: Type[] = [];
            addNamedUnions(namedUnions, types);
            const reducedTypes: Type[] = [];
            for (const t of typeSet) {
                if (!some(namedUnions, union => containsType((union as UnionType).types, t))) {
                    reducedTypes.push(t);
                }
            }
            if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                return namedUnions[0];
            }
            // We create a denormalized origin type only when the union was created from one or more named unions
            // (unions with alias symbols or origins) and when there is no overlap between those named unions.
            const namedTypesCount = reduceLeft(namedUnions, (sum, union) => sum + (union as UnionType).types.length, 0);
            if (namedTypesCount + reducedTypes.length === typeSet.length) {
                for (const t of namedUnions) {
                    insertType(reducedTypes, t);
                }
                origin = createOriginUnionOrIntersectionType(TypeFlags.Union, reducedTypes);
            }
        }
        const objectFlags = (includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion) |
            (includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0);
        return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
    }

    function insertType(types: Type[], type: Type): boolean {
        const index = binarySearch(types, type, getTypeId, compareValues);
        if (index < 0) {
            types.splice(~index, 0, type);
            return true;
        }
        return false;
    }

    // Apply a mapping function to a type and return the resulting type. If the source type
    // is a union type, the mapping function is applied to each constituent type and a union
    // of the resulting types is returned.
    function mapType(type: Type, mapper: (t: Type) => Type, noReductions?: boolean): Type;
    function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined;
    function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined {
        if (type.flags & TypeFlags.Never) {
            return type;
        }
        if (!(type.flags & TypeFlags.Union)) {
            return mapper(type);
        }
        const origin = (type as UnionType).origin;
        const types = origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types;
        let mappedTypes: Type[] | undefined;
        let changed = false;
        for (const t of types) {
            const mapped = t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t);
            changed ||= t !== mapped;
            if (mapped) {
                if (!mappedTypes) {
                    mappedTypes = [mapped];
                }
                else {
                    mappedTypes.push(mapped);
                }
            }
        }
        return changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) : type;
    }

    function getBaseTypeOfLiteralTypeUnion(type: UnionType) {
        const key = `B${getTypeId(type)}`;
        return getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType));
    }

    function getNarrowableTypeForReference(type: Type, reference: Node, checkMode?: CheckMode) {        
        if (isNoInferType(type)) {
            type = (type as SubstitutionType).baseType;
        }
        // When the type of a reference is or contains an instantiable type with a union type constraint, and
        // when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
        // has a contextual type containing no top-level instantiables (meaning constraints will determine
        // assignability), we substitute constraints for all instantiables in the type of the reference to give
        // control flow analysis an opportunity to narrow it further. For example, for a reference of a type
        // parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
        // 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
        const substituteConstraints = !(checkMode && checkMode & CheckMode.Inferential) &&
            someType(type, isGenericTypeWithUnionConstraint) &&
            (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode));
        return substituteConstraints ? mapType(type, getBaseConstraintOrType) : type;
    }

    function isGenericTypeWithUnionConstraint(type: Type): boolean {
        return type.flags & TypeFlags.Intersection ?
            some((type as IntersectionType).types, isGenericTypeWithUnionConstraint) :
            !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(type).flags & (TypeFlags.Nullable | TypeFlags.Union));
    }

    function hasContextualTypeWithNoGenericTypes(node: Node, checkMode: CheckMode | undefined) {
        // Computing the contextual type for a child of a JSX element involves resolving the type of the
        // element's tag name, so we exclude that here to avoid circularities.
        // If check mode has `CheckMode.RestBindingElement`, we skip binding pattern contextual types,
        // as we want the type of a rest element to be generic when possible.
        const contextualType = (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) &&            
            (checkMode && checkMode & CheckMode.RestBindingElement ?
                getContextualType(node, ContextFlags.SkipBindingPatterns)
                : getContextualType(node, /*contextFlags*/ undefined));
        return contextualType && !isGenericType(contextualType);
    }


    function isConstraintPosition(type: Type, node: Node) {
        const parent = node.parent;
        // In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
        // a generic type without a nullable constraint and x is a generic type. This is because when both obj
        // and x are of generic types T and K, we want the resulting type to be T[K].
        return parent.kind === SyntaxKind.PropertyAccessExpression ||
            parent.kind === SyntaxKind.QualifiedName ||
            parent.kind === SyntaxKind.CallExpression && (parent as CallExpression).expression === node ||
            parent.kind === SyntaxKind.NewExpression && (parent as NewExpression).expression === node ||
            parent.kind === SyntaxKind.ElementAccessExpression && (parent as ElementAccessExpression).expression === node &&
                !(someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression)));
    }

    function isGenericTypeWithoutNullableConstraint(type: Type): boolean {
        return type.flags & TypeFlags.Intersection ?
            some((type as IntersectionType).types, isGenericTypeWithoutNullableConstraint) :
            !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(getBaseConstraintOrType(type), TypeFlags.Nullable));
    }

    function getControlFlowContainer(node: Node): Node {
        return findAncestor(node.parent, node =>
            isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) ||            
            node.kind === SyntaxKind.SourceFile ||
            node.kind === SyntaxKind.PropertyDeclaration)!;
    }

    function checkNonNullExpression(node: Expression | QualifiedName, checkMode?: CheckMode | undefined) {
        return checkNonNullType(checkExpression(node, checkMode), node);
    }
            
    function isMethodAccessForCall(node: Node) {
        while (node.parent.kind === SyntaxKind.ParenthesizedExpression) {
            node = node.parent;
        }
        return isCallOrNewExpression(node.parent) && node.parent.expression === node;
    }

    function checkQualifiedName(node: QualifiedName, checkMode: CheckMode | undefined) {
        const leftType = checkNonNullExpression(node.left);
        return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode);
    }
    
    function checkPropertyAccessExpressionOrQualifiedName(node: PropertyAccessExpression | QualifiedName, left: Expression | QualifiedName, leftType: Type, right: Identifier | ParenthesizedExpression, checkMode: CheckMode | undefined, writeOnly?: boolean) {
        const parentSymbol = getNodeLinks(left).resolvedSymbol;
        const assignmentKind = getAssignmentTargetKind(node);
        // if left is an array, then use its element type in fluffos
        const origLeftType = leftType;        
        leftType = languageVariant===LanguageVariant.FluffOS && isArrayType(leftType) ? getElementTypeOfArrayType(leftType) : leftType;
        const apparentType = getApparentType(assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType);
        const isAnyLike = isTypeAny(apparentType) || apparentType === silentNeverType;
        let prop: Symbol | undefined;       
            
        if (isAnyLike) {
            if (isIdentifier(left) && parentSymbol) {
                markLinkedReferences(node, ReferenceHint.Property, /*propSymbol*/ undefined, leftType);
            }
            return isErrorType(apparentType) ? errorType : apparentType;
        }
        
        if (isParenthesizedExpression(right)) {
            // if right is a parenthesized expr, we can shortcut this whole check and just return any
            // TODO - if right is a string literal - we can technically narrow validate the property access?            
            const rigthExprType = checkExpression(right); // check the expression - but don't use its type
            return anyType;
        }

        prop = getPropertyOfType(apparentType, right.text, /*skipObjectFunctionPropertyAugment*/ false, /*includeTypeOnlyMembers*/ node.kind === SyntaxKind.QualifiedName);
    
        if (!prop && isThisObjectExpression(left)) {
            // this is a special situation where prop access on this_object()-> are allowed to access protected props
            const leftSymbol = leftType.symbol;            
            prop = resolveName(first(leftSymbol.declarations), right.text, SymbolFlags.Function, undefined, false, true);
            if (prop) {
                // make sure its not private
                if (!prop.declarations.some(d => (getCombinedModifierFlagsCached(d) & ModifierFlags.Private) === 0)) {
                    // all declarations were private, so its not accessible
                    prop = undefined;
                }
            }            
        }

        markLinkedReferences(node, ReferenceHint.Property, prop, leftType);

        let propType: Type;
        if (!prop) {
            const indexInfo = !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None) ? getApplicableIndexInfoForName(apparentType, right.text) : undefined;
            if (!(indexInfo && indexInfo.type)) {
                const isUncheckedJS = false;// TODO: isUncheckedJSSuggestion(node, leftType.symbol, /*excludeClasses*/ true);
                if (!isUncheckedJS && isJSLiteralType(leftType)) {
                    return anyType;
                }
                // if (leftType.symbol === globalThisSymbol) {
                //     if (globalThisSymbol.exports!.has(right.text) && (globalThisSymbol.exports!.get(right.text)!.flags & SymbolFlags.BlockScoped)) {
                //         error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.text), typeToString(leftType));
                //     }
                //     else if (noImplicitAny) {
                //         error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType));
                //     }
                //     return anyType;
                // }
                if (right.text && !checkAndReportErrorForExtendingInterface(node)) {
                    reportNonexistentProperty(right, leftType, isUncheckedJS);
                }
                return errorType;
            }
            if (indexInfo.isReadonly && (isAssignmentTarget(node))) {
                error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
            }

            propType = indexInfo.type;
            // if (compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) !== AssignmentKind.Definite) {
            //     propType = getUnionType([propType, missingType]);
            // }
            // if (compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node)) {
            //     error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.text));
            // }
            if (indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration)) {
                addDeprecatedSuggestion(right, [indexInfo.declaration], right.text as string);
            }
        }
        else {
            const targetPropSymbol = resolveAliasWithDeprecationCheck(prop, right);
            if (isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations) {
                addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.text as string);
            }
            //checkPropertyNotUsedBeforeDeclaration(prop, node, right);
            markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol));
            getNodeLinks(node).resolvedSymbol = prop;
            checkPropertyAccessibility(node, left.kind === SyntaxKind.SuperKeyword, isWriteAccess(node), apparentType, prop);
            // TODO
            // if (isAssignmentToReadonlyEntity(node as Expression, prop, assignmentKind)) {
            //     error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right));
            //     return errorType;
            // }

            propType = /*isThisPropertyAccessInConstructor(node, prop) ? autoType : */ writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop);
        }

        return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode);
    }

    function reportNonexistentProperty(propNode: Identifier, containingType: Type, isUncheckedJS: boolean) {
        let errorInfo: DiagnosticMessageChain | undefined;
        let relatedInfo: Diagnostic | undefined;
        if (!isPrivateIdentifier(propNode) && containingType.flags & TypeFlags.Union && !(containingType.flags & TypeFlags.Primitive)) {
            for (const subtype of (containingType as UnionType).types) {
                if (!getPropertyOfType(subtype, propNode.text) && !getApplicableIndexInfoForName(subtype, propNode.text)) {
                    errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype));
                    break;
                }
            }
        }
        
        const missingProperty = declarationNameToString(propNode);
        const container = typeToString(containingType);
        // const libSuggestion = getSuggestedLibForNonExistentProperty(missingProperty, containingType);
        // if (libSuggestion !== undefined) {
        //     errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion);
        // }
        // else {
            const suggestion = getSuggestedSymbolForNonexistentProperty(propNode, containingType);
            if (suggestion !== undefined) {
                const suggestedName = symbolName(suggestion);
                const message = isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2;
                errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName);
                relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName);
            }
            else {
                const diagnostic = Diagnostics.Property_0_does_not_exist_on_type_1;
                errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container);
            }
        // }
            
        
        const resultDiagnostic = createDiagnosticForNodeFromMessageChain(getSourceFileOrIncludeOfNode(propNode, false), propNode, errorInfo);
        if (relatedInfo) {
            addRelatedInfo(resultDiagnostic, relatedInfo);
        }
        addErrorOrSuggestion(!isUncheckedJS || errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic);
    }

    function elaborateNeverIntersection(errorInfo: DiagnosticMessageChain | undefined, type: Type) {
        if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsNeverIntersection) {
            Debug.fail("never intersection");
            // const neverProp = find(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isDiscriminantWithNeverType);
            // if (neverProp) {
            //     return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.NoTypeReduction), symbolToString(neverProp));
            // }
            // const privateProp = find(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isConflictingPrivateProperty);
            // if (privateProp) {
            //     return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.NoTypeReduction), symbolToString(privateProp));
            // }
        }
        return errorInfo;
    }
    
    function checkAndReportErrorForExtendingInterface(errorLocation: Node): boolean {
        const expression = getEntityNameForExtendingInterface(errorLocation);
        // if (expression && resolveEntityName(expression, SymbolFlags.Interface, /*ignoreErrors*/ true)) {
        //     error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression));
        //     return true;
        // }
        return false;
    }

    /**
     * Climbs up parents to an ExpressionWithTypeArguments, and returns its expression,
     * but returns undefined if that expression is not an EntityNameExpression.
     */
    function getEntityNameForExtendingInterface(node: Node): EntityNameExpression | undefined {
        switch (node.kind) {
            case SyntaxKind.Identifier:
            case SyntaxKind.PropertyAccessExpression:
                return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
            // case SyntaxKind.ExpressionWithTypeArguments:
            //     if (isEntityNameExpression((node as ExpressionWithTypeArguments).expression)) {
            //         return (node as ExpressionWithTypeArguments).expression as EntityNameExpression;
            //     }
                // falls through
            default:
                return undefined;
        }
    }

    /** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
    function removeOptionalityFromDeclaredType(declaredType: Type, declaration: VariableLikeDeclaration): Type {
        const removeUndefined = strictNullChecks &&
            declaration.kind === SyntaxKind.Parameter &&
            declaration.initializer &&
            hasTypeFacts(declaredType, TypeFacts.IsUndefined) &&
            !parameterInitializerContainsUndefined(declaration);

        return removeUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType;
    }

    function parameterInitializerContainsUndefined(declaration: ParameterDeclaration): boolean {
        const links = getNodeLinks(declaration);

        if (links.parameterInitializerContainsUndefined === undefined) {
            if (!pushTypeResolution(declaration, TypeSystemPropertyName.ParameterInitializerContainsUndefined)) {
                reportCircularityError(declaration.symbol);
                return true;
            }

            const containsUndefined = !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined));

            if (!popTypeResolution()) {
                reportCircularityError(declaration.symbol);
                return true;
            }

            links.parameterInitializerContainsUndefined ??= containsUndefined;
        }

        return links.parameterInitializerContainsUndefined;
    }

    function checkIdentifier(node: Identifier, checkMode: CheckMode | undefined, symbolFlags?: SymbolFlags): Type {
        // if (isThisInTypeQuery(node)) {
        //     return checkThisExpression(node);
        // }

        const symbol = getResolvedSymbol(node, symbolFlags);
        if (symbol === unknownSymbol) {
            return errorType;
        }

        checkIdentifierCalculateNodeCheckFlags(node, symbol);

        if (symbol === argumentsSymbol) {
            if (isInPropertyInitializerOrClassStaticBlock(node)) {
                return errorType;
            }
            return getTypeOfSymbol(symbol);
        }

        if (shouldMarkIdentifierAliasReferenced(node)) {
            markLinkedReferences(node, ReferenceHint.Identifier);
        }

        const localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
        let declaration = localOrExportSymbol.valueDeclaration;

        let type = getNarrowedTypeOfSymbol(localOrExportSymbol, node, checkMode);
        const assignmentKind = getAssignmentTargetKind(node);

        if (assignmentKind) {
            if (
                !(localOrExportSymbol.flags & SymbolFlags.Variable)                
            ) {
                const assignmentError = localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function
                    //: localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import
                    : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable;

                error(node, assignmentError, symbolToString(symbol));
                return errorType;
            }
            // no readonly symbols in LPC
            // if (isReadonlySymbol(localOrExportSymbol)) {
            //     if (localOrExportSymbol.flags & SymbolFlags.Variable) {
            //         error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol));
            //     }
            //     else {
            //         error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol));
            //     }
            //     return errorType;
            // }
        }

        const isAlias = localOrExportSymbol.flags & SymbolFlags.Alias;

        // We only narrow variables and parameters occurring in a non-assignment position. For all other
        // entities we simply return the declared type.
        if (localOrExportSymbol.flags & SymbolFlags.Variable) {
            if (assignmentKind === AssignmentKind.Definite) {
                return isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(type) : type;
            }
        }
        else if (isAlias) {
            declaration = getDeclarationOfAliasSymbol(symbol);
        }
        else {
            return type;
        }

        if (!declaration) {
            return type;
        }

        type = getNarrowableTypeForReference(type, node, checkMode);

        // The declaration container is the innermost function that encloses the declaration of the variable
        // or parameter. The flow container is the innermost function starting with which we analyze the control
        // flow graph to determine the control flow based type.
        const isParameter = getRootDeclaration(declaration).kind === SyntaxKind.Parameter;
        const declarationContainer = getControlFlowContainer(declaration);
        let flowContainer = getControlFlowContainer(node);
        const isOuterVariable = flowContainer !== declarationContainer;        
        const isModuleExports = symbol.flags & SymbolFlags.ModuleExports;
        const typeIsAutomatic = type === autoType || type === autoArrayType;        
        // When the control flow originates in a function expression, arrow function, method, or accessor, and
        // we are referencing a closed-over const variable or parameter or mutable local variable past its last
        // assignment, we extend the origin of the control flow analysis to include the immediately enclosing
        // control flow container.
        while (
            flowContainer !== declarationContainer && (
                flowContainer.kind === SyntaxKind.FunctionExpression ||
                flowContainer.kind === SyntaxKind.InlineClosureExpression || 
                isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)
            ) && (           
                // TS limited this first condition to const vars only, but for LPC
                // we'll allow any var that is not auto array type
                type !== autoArrayType ||     
                isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)
            )
        ) {
            flowContainer = getControlFlowContainer(flowContainer);
        }
        // We only look for uninitialized variables in strict null checking mode, and only when we can analyze
        // the entire control flow graph from the variable's declaration (i.e. when the flow container and
        // declaration container are the same).
        const assumeInitialized = isParameter || isAlias || isOuterVariable || isModuleExports || isSameScopedBindingElement(node, declaration) ||
            type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0) ||                        
            declaration.flags & NodeFlags.Ambient;
        const initialType = 
            // isAutomaticTypeInNonNull ? undefinedType :
            assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) :
            typeIsAutomatic ? undefinedType : getOptionalType(type);
        const flowType = getFlowTypeOfReference(node, type, initialType, flowContainer);
        // A variable is considered uninitialized when it is possible to analyze the entire control flow graph
        // from declaration to use, and when the variable's declared type doesn't include undefined but the
        // control flow based type does include undefined.
        if (!isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType)) {
            if (flowType === autoType || flowType === autoArrayType) {                
                return convertAutoToAny(flowType);
            }
        }
        else if (!assumeInitialized && !containsUndefinedType(type) && containsUndefinedType(flowType)) {
            error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
            // Return the declared type to reduce follow-on errors
            return type;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }

    function containsUndefinedType(type: Type) {
        return !!((type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type).flags & TypeFlags.Undefined);
    }

    function convertAutoToAny(type: Type) {
        return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
    }

    function isSameScopedBindingElement(node: Identifier, declaration: Declaration) {
        if (isBindingElement(declaration)) {
            const bindingElement = findAncestor(node, isBindingElement);
            return bindingElement && getRootDeclaration(bindingElement) === getRootDeclaration(declaration);
        }
    }

    function getReferenceRoot(node: Node): Node {
        const { parent } = node;
        return parent.kind === SyntaxKind.ParenthesizedExpression ||
                parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken && (parent as BinaryExpression).left === node ||
                parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken && (parent as BinaryExpression).right === node ?
            getReferenceRoot(parent) : node;
    }

    function isFreshLiteralType(type: Type) {
        return !!(type.flags & TypeFlags.Freshable) && (type as LiteralType).freshType === type;
    }
    
    type ErrorReporter = (message: DiagnosticMessage, ...args: DiagnosticArguments) => void;

    function isSimpleTypeRelatedTo(source: Type, target: Type, relation: Map<string, RelationComparisonResult>, errorReporter?: ErrorReporter) {
        const s = source.flags;
        const t = target.flags;
        
        if (t & TypeFlags.Any || s & TypeFlags.Never) return true;
        if (t & TypeFlags.Unknown && !(relation === strictSubtypeRelation && s & TypeFlags.Any)) return true;
        if (t & TypeFlags.Never) return false;
        // LPC allows 0 to be assigned to anything
        if (s & TypeFlags.IntLiteral && (source as IntLiteralType).value === 0) return true;
        if (s & TypeFlags.StringLike && t & TypeFlags.String) return true;
        // if (
        //     s & TypeFlags.StringLiteral && s & TypeFlags.EnumLiteral &&
        //     t & TypeFlags.StringLiteral && !(t & TypeFlags.EnumLiteral) &&
        //     (source as StringLiteralType).value === (target as StringLiteralType).value
        // ) return true;
        if (s & TypeFlags.NumberLike && t & TypeFlags.Number) return true;                
        if (s & TypeFlags.BooleanLike && t & TypeFlags.Boolean) return true;
        if (s & TypeFlags.BooleanLike && t & TypeFlags.Number) return true;
        if (s & TypeFlags.Bytes && t & TypeFlags.Bytes) return true;
        if (s & TypeFlags.BytesLiteral && t & TypeFlags.Bytes) return true;
        // if (s & TypeFlags.ESSymbolLike && t & TypeFlags.ESSymbol) return true;                
        // In non-strictNullChecks mode, `undefined` and `null` are assignable to anything except `never`.
        // Since unions and intersections may reduce to `never`, we exclude them here.
        if (s & TypeFlags.Undefined && (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & (TypeFlags.Undefined | TypeFlags.Void))) return true;
        if (s & TypeFlags.Null && (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & TypeFlags.Null)) return true;
        if (s & TypeFlags.Object && t & TypeFlags.NonPrimitive && !(relation === strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlags.FreshLiteral))) return true;        
        if (s & TypeFlags.Object && source.symbol?.flags & SymbolFlags.Function && source.symbol?.name===InternalSymbolName.Function && t & TypeFlags.Object && target === globalClosureType) {
            return true;
        }
        if (relation === assignableRelation || relation === comparableRelation) {
            if (s & TypeFlags.Any) return true;
            // Type number is assignable to any computed numeric enum type or any numeric enum literal type, and
            // a numeric literal type is assignable any computed numeric enum type or any numeric enum literal type
            // with a matching value. These rules exist such that enums can be used for bit-flag purposes.            
            // Anything is assignable to a union containing undefined, null, and {}
            if (isUnknownLikeUnionType(target)) return true;
        }
        return false;
    }

    /**
     * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
     *
     * For a description of late-binding, see `lateBindMember`.
     */
    function getMembersOfSymbol(symbol: Symbol) {
        return symbol?.flags & SymbolFlags.LateBindingContainer
            ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedMembers)
            : symbol?.members || emptySymbols;
    }

    interface ExportCollisionTracker {
        specifierText: string;
        exportsWithDuplicate?: ExportDeclaration[];
    }
    
    type ExportCollisionTrackerTable = Map<string, ExportCollisionTracker>;

    /**
     * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
     * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
     */
    function extendExportSymbols(target: SymbolTable, source: SymbolTable | undefined, lookupTable?: ExportCollisionTrackerTable, exportNode?: ExportDeclaration) {
        if (!source) return;
        source.forEach((sourceSymbol, id) => {
            if (id === InternalSymbolName.Default) return;

            const targetSymbol = target.get(id);
            if (!targetSymbol) {
                target.set(id, sourceSymbol);
                if (lookupTable && exportNode) {
                    lookupTable.set(id, {
                        specifierText: getTextOfNode(exportNode.moduleSpecifier!),
                    });
                }
            }
            else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {
                const collisionTracker = lookupTable.get(id)!;
                if (!collisionTracker.exportsWithDuplicate) {
                    collisionTracker.exportsWithDuplicate = [exportNode];
                }
                else {
                    collisionTracker.exportsWithDuplicate.push(exportNode);
                }
            }
        });
    }

    
    function getExportsOfModuleWorker(moduleSymbol: Symbol) {
        const visitedSymbols: Symbol[] = [];
        const nonTypeOnlyNames = new Set<string>();

        // A module defined by an 'export=' consists of one export that needs to be resolved
        moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
        const exports = visit(moduleSymbol) || emptySymbols;
        
        return {
            exports,
            undefined,
        };

        // The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
        // module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
        function visit(symbol: Symbol | undefined, isTypeOnly?: boolean): SymbolTable | undefined {
            if (!isTypeOnly && symbol?.exports) {
                // Add non-type-only names before checking if we've visited this module,
                // because we might have visited it via an 'export type *', and visiting
                // again with 'export *' will override the type-onlyness of its exports.
                symbol.exports.forEach((_, name) => nonTypeOnlyNames.add(name));
            }
            if (!(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol))) {
                return;
            }
            const symbols = new Map(symbol.exports);

            // All export * declarations are collected in an __export symbol by the binder
            const exportStars = symbol.exports.get(InternalSymbolName.ExportStar);
            if (exportStars) {
                const nestedSymbols = createSymbolTable();
                const lookupTable: ExportCollisionTrackerTable = new Map();
                if (exportStars.declarations) {
                    for (const node of exportStars.declarations) {
                        const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!, undefined);
                        const exportedSymbols = visit(resolvedModule, isTypeOnly || (node as ExportDeclaration).isTypeOnly);
                        extendExportSymbols(
                            nestedSymbols,
                            exportedSymbols,
                            lookupTable,
                            node as ExportDeclaration,
                        );
                    }
                }
                lookupTable.forEach(({ exportsWithDuplicate }, id) => {
                    // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
                    if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                        return;
                    }
                    for (const node of exportsWithDuplicate) {
                        diagnostics.add(createDiagnosticForNode(
                            node,
                            Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,
                            lookupTable.get(id)!.specifierText,
                            (id),
                        ));
                    }
                });
                extendExportSymbols(symbols, nestedSymbols);
            }
            // if (exportStar?.isTypeOnly) {
            //     typeOnlyExportStarMap ??= new Map();
            //     symbols.forEach((_, name) =>
            //         typeOnlyExportStarMap!.set(
            //             name,
            //             exportStar as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; },
            //         )
            //     );
            // }
            return symbols;
        }
    }    

    function getFunctionExpressionParentSymbolOrSymbol(symbol: Symbol) {
        return symbol.valueDeclaration?.kind === SyntaxKind.InlineClosureExpression || symbol.valueDeclaration?.kind === SyntaxKind.FunctionExpression
            ? getSymbolOfNode(symbol.valueDeclaration.parent) || symbol
            : symbol;
    }

    function isPossiblyAliasedThisProperty(declaration: BinaryExpression, kind = getAssignmentDeclarationKind(declaration)) {
        if (kind === AssignmentDeclarationKind.ThisProperty) {
            return true;
        }
        if (!isInJSFile(declaration) || kind !== AssignmentDeclarationKind.Property || !isIdentifier((declaration.left as AccessExpression).expression)) {
            return false;
        }
        const name = ((declaration.left as AccessExpression).expression as Identifier).text;
        const symbol = resolveName(declaration.left, name, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true, /*excludeGlobals*/ true);
        return isThisInitializedDeclaration(symbol?.valueDeclaration);
    }

    /**
     * Indicates whether a declaration has a late-bindable dynamic name.
     */
    function hasLateBindableName(node: Declaration) : node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration {        
        const name = getNameOfDeclaration(node);
        return !!name && isLateBindableName(name);
    }
    
    function getResolvedMembersOrExportsOfSymbol(symbol: Symbol, resolutionKind: MembersOrExportsResolutionKind): Map<string, Symbol> {
        const links = getSymbolLinks(symbol);                
        if (!links[resolutionKind]) {
            // const isStatic = resolutionKind === MembersOrExportsResolutionKind.resolvedExports;
            const earlySymbols = symbol.flags & SymbolFlags.Module ? symbol.exports : symbol.members;

            // In the event we recursively resolve the members/exports of the symbol, we
            // set the initial value of resolvedMembers/resolvedExports to the early-bound
            // members/exports of the symbol.
            links[resolutionKind] = earlySymbols || emptySymbols;

            // fill in any as-yet-unresolved late-bound members.
            const lateSymbols = createSymbolTable() as Map<string, TransientSymbol>;
            for (const decl of symbol.declarations || emptyArray) {
                const members = getMembersOfDeclaration(decl);
                if (members) {
                    for (const member of members) {
                        // if (isStatic === hasStaticModifier(member)) {
                            if (hasLateBindableName(member)) {
                                lateBindMember(symbol, earlySymbols, lateSymbols, member);
                            }
                        // }
                    }
                }
            }
            const assignments = getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers;

            if (assignments) {
                const decls = arrayFrom(assignments.values());
                for (const member of decls) {
                    const assignmentKind = getAssignmentDeclarationKind(member as BinaryExpression | CallExpression);
                    const isInstanceMember = assignmentKind === AssignmentDeclarationKind.PrototypeProperty
                        || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind)
                        || assignmentKind === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
                        || assignmentKind === AssignmentDeclarationKind.Prototype; // A straight `Prototype` assignment probably can never have a computed name
                    if (!isInstanceMember) {
                        if (hasLateBindableName(member)) {
                            lateBindMember(symbol, earlySymbols, lateSymbols, member);
                        }
                    }
                }
            }

            let resolved = combineSymbolTables(earlySymbols, lateSymbols);
            if (symbol.flags & SymbolFlags.Transient && links.cjsExportMerged && symbol.declarations) {
                for (const decl of symbol.declarations) {
                    const original = getSymbolLinks(decl.symbol)[resolutionKind];
                    if (!resolved) {
                        resolved = original;
                        continue;
                    }
                    if (!original) continue;
                    original.forEach((s, name) => {
                        const existing = resolved!.get(name);
                        if (!existing) resolved!.set(name, s);
                        else if (existing === s) return;
                        else resolved!.set(name, mergeSymbol(existing, s));
                    });
                }
            }
            links[resolutionKind] = resolved || emptySymbols;
        }

        return links[resolutionKind];
    }
    
    /**
     * Performs late-binding of a dynamic member. This performs the same function for
     * late-bound members that `declareSymbol` in binder.ts performs for early-bound
     * members.
     *
     * If a symbol is a dynamic name from a computed property, we perform an additional "late"
     * binding phase to attempt to resolve the name for the symbol from the type of the computed
     * property's expression. If the type of the expression is a string-literal, numeric-literal,
     * or unique symbol type, we can use that type as the name of the symbol.
     *
     * For example, given:
     *
     *   const x = Symbol();
     *
     *   interface I {
     *     [x]: number;
     *   }
     *
     * The binder gives the property `[x]: number` a special symbol with the name "__computed".
     * In the late-binding phase we can type-check the expression `x` and see that it has a
     * unique symbol type which we can then use as the name of the member. This allows users
     * to define custom symbols that can be used in the members of an object type.
     *
     * @param parent The containing symbol for the member.
     * @param earlySymbols The early-bound symbols of the parent.
     * @param lateSymbols The late-bound symbols of the parent.
     * @param decl The member to bind.
     */
    function lateBindMember(parent: Symbol, earlySymbols: SymbolTable | undefined, lateSymbols: Map<string, TransientSymbol>, decl: LateBoundDeclaration | LateBoundBinaryExpressionDeclaration) {
        Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
        const links = getNodeLinks(decl);
        if (!links.resolvedSymbol) {
            // In the event we attempt to resolve the late-bound name of this member recursively,
            // fall back to the early-bound name of this member.
            links.resolvedSymbol = decl.symbol;
            const declName = isBinaryExpression(decl) ? decl.left : decl.name;
            const type = isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
            if (isTypeUsableAsPropertyName(type)) {
                const memberName = getPropertyNameFromType(type);
                const symbolFlags = decl.symbol.flags;

                // Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
                let lateSymbol = lateSymbols.get(memberName);
                if (!lateSymbol) lateSymbols.set(memberName, lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late));

                // Report an error if there's a symbol declaration with the same name and conflicting flags.
                const earlySymbol = earlySymbols && earlySymbols.get(memberName);
                // Duplicate property declarations of classes are checked in checkClassForDuplicateDeclarations.
                if (!(parent.flags & SymbolFlags.Class) && lateSymbol.flags & getExcludedSymbolFlags(symbolFlags)) {
                    // If we have an existing early-bound member, combine its declarations so that we can
                    // report an error at each declaration.
                    const declarations = earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
                    const name = (memberName) || declarationNameToString(declName);
                    forEach(declarations, declaration => error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name));
                    error(declName || decl, Diagnostics.Duplicate_property_0, name);
                    lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late);
                }
                lateSymbol.links.nameType = type;
                addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
                if (lateSymbol.parent) {
                    Debug.assert(lateSymbol.parent === parent, "Existing symbol parent should match new one");
                }
                else {
                    lateSymbol.parent = parent;
                }
                return links.resolvedSymbol = lateSymbol;
            }
        }
        return links.resolvedSymbol;
    }

    /**
     * Adds a declaration to a late-bound dynamic member. This performs the same function for
     * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
     * members.
     */
    function addDeclarationToLateBoundSymbol(symbol: Symbol, member: LateBoundDeclaration | BinaryExpression, symbolFlags: SymbolFlags) {
        Debug.assert(!!(getCheckFlags(symbol) & CheckFlags.Late), "Expected a late-bound symbol.");
        symbol.flags |= symbolFlags;
        getSymbolLinks(member.symbol).lateSymbol = symbol;
        if (!symbol.declarations) {
            symbol.declarations = [member];
        }
        else if (!member.symbol.isReplaceableByMethod) {
            symbol.declarations.push(member);
        }
        if (symbolFlags & SymbolFlags.Value) {
            if (!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind) {
                symbol.valueDeclaration = member;
            }
        }
    }

    /**
     * Indicates whether a declaration name is definitely late-bindable.
     * A declaration name is only late-bindable if:
     * - It is a `ComputedPropertyName`.
     * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
     * `ElementAccessExpression` consisting only of these same three types of nodes.
     * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
     */
    function isLateBindableName(node: DeclarationName): node is LateBoundName {
        if (!isComputedPropertyName(node) && !isElementAccessExpression(node)) {
            return false;
        }
        const expr = isComputedPropertyName(node) ? node.expression : node.argumentExpression;
        return isEntityNameExpression(expr)
            && isTypeUsableAsPropertyName(isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr));
    }  
    
    function checkComputedPropertyName(node: ComputedPropertyName): Type {
        const links = getNodeLinks(node.expression);
        if (!links.resolvedType) {
            if (
                (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent))// || isInterfaceDeclaration(node.parent.parent))
                && isBinaryExpression(node.expression) && node.expression.operatorToken.kind === SyntaxKind.InKeyword
                //&& node.parent.kind !== SyntaxKind.GetAccessor && node.parent.kind !== SyntaxKind.SetAccessor
            ) {
                return links.resolvedType = errorType;
            }
            links.resolvedType = checkExpression(node.expression);
            // The computed property name of a non-static class field within a loop must be stored in a block-scoped binding.
            // (It needs to be bound at class evaluation time.)
            if (isPropertyDeclaration(node.parent) && isClassExpression(node.parent.parent)) {
                const container = getEnclosingBlockScopeContainer(node.parent.parent);
                const enclosingIterationStatement = getEnclosingIterationStatement(container);
                if (enclosingIterationStatement) {
                    // The computed field name will use a block scoped binding which can be unique for each iteration of the loop.
                    getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding;
                    // The generated variable which stores the computed field name must be block-scoped.
                    getNodeLinks(node).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
                    // The generated variable which stores the class must be block-scoped.
                    getNodeLinks(node.parent.parent).flags |= NodeCheckFlags.BlockScopedBindingInLoop;
                }
            }
            // This will allow types number, string, symbol or any. It will also allow enums, the unknown
            // type, and any union of these types (like string | number).
            if (
                links.resolvedType.flags & TypeFlags.Nullable ||
                !isTypeAssignableToKind(links.resolvedType, TypeFlags.StringLike | TypeFlags.NumberLike) &&
                    !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType)
            ) {
                error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
            }
        }

        return links.resolvedType;
    }
    
    function combineSymbolTables(first: SymbolTable | undefined, second: SymbolTable | undefined): SymbolTable | undefined {
        if (!first?.size) return second;
        if (!second?.size) return first;
        const combined = createSymbolTable();
        mergeSymbolTable(combined, first);
        mergeSymbolTable(combined, second);
        return combined;
    }

    function isAnonymousObjectType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.Anonymous);
    }

    function isEmptyAnonymousObjectType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.Anonymous && (
            (type as ResolvedType).members && isEmptyResolvedType(type as ResolvedType) ||
            type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && getMembersOfSymbol(type.symbol).size === 0
        ));
    }
    
    function isEmptyResolvedType(t: ResolvedType) {
        return t !== anyFunctionType &&
            (t.properties?.length || 0) === 0 &&
            (t.callSignatures?.length || 0) === 0 &&
            (t.constructSignatures?.length || 0) === 0 &&
            (t.indexInfos?.length || 0) === 0;
    }

    function isUnknownLikeUnionType(type: Type) {
        if (strictNullChecks && type.flags & TypeFlags.Union) {
            if (!((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnionComputed)) {
                const types = (type as UnionType).types;
                (type as UnionType).objectFlags |= ObjectFlags.IsUnknownLikeUnionComputed | (types.length >= 3 && types[0].flags & TypeFlags.Undefined &&
                        types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0);
            }
            return !!((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnion);
        }
        return false;
    }

    function isTypeRelatedTo(source: Type, target: Type, relation: Map<string, RelationComparisonResult>) {
        if (isFreshLiteralType(source)) {
            source = (source as FreshableType).regularType;
        }
        if (isFreshLiteralType(target)) {
            target = (target as FreshableType).regularType;
        }
        if (source === target) {
            return true;
        }
        if (source.flags & TypeFlags.IntLiteral && (source as IntLiteralType).value === 0) {
            // in LPC, 0 can be assigned to anything
            return true;
        }
        if (relation !== identityRelation) {
            if (relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation)) {
                return true;
            }
        }
        else if (!((source.flags | target.flags) & (TypeFlags.UnionOrIntersection | TypeFlags.IndexedAccess | TypeFlags.Conditional | TypeFlags.Substitution))) {
            // We have excluded types that may simplify to other forms, so types must have identical flags
            if (source.flags !== target.flags) return false;
            if (source.flags & TypeFlags.Singleton) return true;
        }
        if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
            const related = relation.get(getRelationKey(source, target, IntersectionState.None, relation, /*ignoreConstraints*/ false));
            if (related !== undefined) {
                return !!(related & RelationComparisonResult.Succeeded);
            }
        }        
        if (source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable) {
            const related = checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined);
            // we can skip the strict check if strict object types aren't turn on and as long as one of the types is not a structured anonymouse type                        
            if (canSkipStrictObjectCheck(source, target) && !related && source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {            
                return true;
            }
            return related;
        }
        return false;
    }

    function canSkipStrictObjectCheck(source: Type, target: Type) {
        const canSkipStrictCheck = !strickObjectTypes && 
                // TODO: JC - disabling this requirement until I'm sure I want to use it
                // !(getObjectFlags(source) & ObjectFlags.Anonymous && getObjectFlags(target) & ObjectFlags.Anonymous) &&
                !(isGlobalType(source) && isGlobalType(target));
        return canSkipStrictCheck;
    }

    function isGlobalType(type: Type) {        
        return type?.symbol?.flags & SymbolFlags.FakeGlobal;
    }

    function typeCouldHaveTopLevelSingletonTypes(type: Type): boolean {
        // Okay, yes, 'boolean' is a union of 'true | false', but that's not useful
        // in error reporting scenarios. If you need to use this function but that detail matters,
        // feel free to add a flag.
        if (type.flags & TypeFlags.Boolean) {
            return false;
        }

        if (type.flags & TypeFlags.UnionOrIntersection) {
            return !!forEach((type as IntersectionType).types, typeCouldHaveTopLevelSingletonTypes);
        }

        if (type.flags & TypeFlags.Instantiable) {
            const constraint = getConstraintOfType(type);
            if (constraint && constraint !== type) {
                return typeCouldHaveTopLevelSingletonTypes(constraint);
            }
        }

        return isUnitType(type) || !!(type.flags & TypeFlags.TemplateLiteral) || !!(type.flags & TypeFlags.StringMapping);
    }

    function getConstraintOfType(type: InstantiableType | UnionOrIntersectionType): Type | undefined {
        return type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(type as TypeParameter) :
            type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(type as IndexedAccessType) :
            type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(type as ConditionalType) :
            getBaseConstraintOfType(type);
    }

    function getConstraintOfConditionalType(type: ConditionalType) {
        return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
    }

    function getConstraintOfIndexedAccess(type: IndexedAccessType) {
        return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
    }
    
    function hasNonCircularBaseConstraint(type: InstantiableType): boolean {
        return getResolvedBaseConstraint(type) !== circularConstraintType;
    }

    function getConstraintFromIndexedAccess(type: IndexedAccessType) {
        if (isMappedTypeGenericIndexedAccess(type)) {
            // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
            // we substitute an instantiation of E where P is replaced with X.
            return substituteIndexedMappedType(type.objectType as MappedType, type.indexType);
        }
        const indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
        if (indexConstraint && indexConstraint !== type.indexType) {
            const indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
            if (indexedAccess) {
                return indexedAccess;
            }
        }
        const objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
        if (objectConstraint && objectConstraint !== type.objectType) {
            return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
        }
        return undefined;
    }

    function getSimplifiedTypeOrConstraint(type: Type) {
        const simplified = getSimplifiedType(type, /*writing*/ false);
        return simplified !== type ? simplified : getConstraintOfType(type);
    }
    
    
    // The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
    // We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
    // the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
    // instantiations of that type have the same recursion identity. The default recursion identity is the object
    // identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
    // reference the type have a recursion identity that differs from the object identity.
    function getRecursionIdentity(type: Type): object {
        // Object and array literals are known not to contain recursive references and don't need a recursion identity.
        if (type.flags & TypeFlags.Object && !isObjectOrArrayLiteralType(type)) {
            if (getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).node) {
                // Deferred type references are tracked through their associated AST node. This gives us finer
                // granularity than using their associated target because each manifest type reference has a
                // unique AST node.
                return (type as TypeReference).node!;
            }
            if (type.symbol && !(getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol.flags & SymbolFlags.Class)) {
                // We track object types that have a symbol by that symbol (representing the origin of the type), but
                // exclude the static side of a class since it shares its symbol with the instance side.
                return type.symbol;
            }
            if (isTupleType(type)) {
                return type.target;
            }
        }
        if (type.flags & TypeFlags.TypeParameter) {
            // We use the symbol of the type parameter such that all "fresh" instantiations of that type parameter
            // have the same recursion identity.
            return type.symbol;
        }
        if (type.flags & TypeFlags.IndexedAccess) {
            // Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P1][P2][P3] it is A.
            do {
                type = (type as IndexedAccessType).objectType;
            }
            while (type.flags & TypeFlags.IndexedAccess);
            return type;
        }
        if (type.flags & TypeFlags.Conditional) {
            // The root object represents the origin of the conditional type
            return (type as ConditionalType).root;
        }
        return type;
    }

    // Given an indexed access on a mapped type of the form { [P in K]: E }[X], return an instantiation of E where P is
    // replaced with X. Since this simplification doesn't account for mapped type modifiers, add 'undefined' to the
    // resulting type if the mapped type includes a '?' modifier or if the modifiers type indicates that some properties
    // are optional. If the modifiers type is generic, conservatively estimate optionality by recursively looking for
    // mapped types that include '?' modifiers.
    function substituteIndexedMappedType(objectType: MappedType, index: Type) {
        const mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
        const templateMapper = combineTypeMappers(objectType.mapper, mapper);
        const instantiatedTemplateType = instantiateType(getTemplateTypeFromMappedType(objectType.target as MappedType || objectType), templateMapper);
        const isOptional = getMappedTypeOptionality(objectType) > 0 || (isGenericType(objectType) ?
            getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 :
            couldAccessOptionalProperty(objectType, index));
        return addOptionality(instantiatedTemplateType, /*isProperty*/ true, isOptional);
    }

    // Return true if an indexed access with the given object and index types could access an optional property.
    function couldAccessOptionalProperty(objectType: Type, indexType: Type) {
        const indexConstraint = getBaseConstraintOfType(indexType);
        return !!indexConstraint && some(getPropertiesOfType(objectType), p =>
            !!(p.flags & SymbolFlags.Optional) &&
            isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlags.StringOrNumberLiteralOrUnique), indexConstraint));
    }

    /**
     * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
     * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
     * circularly references the type variable.
     */
    function getResolvedBaseConstraint(type: InstantiableType | UnionOrIntersectionType): Type {
        if (type.resolvedBaseConstraint) {
            return type.resolvedBaseConstraint;
        }
        const stack: object[] = [];
        return type.resolvedBaseConstraint = getImmediateBaseConstraint(type);

        function getImmediateBaseConstraint(t: Type): Type {
            if (!t.immediateBaseConstraint) {
                if (!pushTypeResolution(t, TypeSystemPropertyName.ImmediateBaseConstraint)) {
                    return circularConstraintType;
                }
                let result;
                // We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
                // up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
                // (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
                // levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
                // yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
                // nesting, so it is effectively just a safety stop.
                const identity = getRecursionIdentity(t);
                if (stack.length < 10 || stack.length < 50 && !contains(stack, identity)) {
                    stack.push(identity);
                    result = computeBaseConstraint(getSimplifiedType(t, /*writing*/ false));
                    stack.pop();
                }
                if (!popTypeResolution()) {
                    if (t.flags & TypeFlags.TypeParameter) {
                        const errorNode = getConstraintDeclaration(t as TypeParameter);
                        if (errorNode) {
                            const diagnostic = error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                            if (currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode)) {
                                addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location));
                            }
                        }
                    }
                    result = circularConstraintType;
                }
                t.immediateBaseConstraint ??= result || noConstraintType;
            }
            return t.immediateBaseConstraint;
        }

        function getBaseConstraint(t: Type): Type | undefined {
            const c = getImmediateBaseConstraint(t);
            return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
        }

        function computeBaseConstraint(t: Type): Type | undefined {
            if (t.flags & TypeFlags.TypeParameter) {
                const constraint = getConstraintFromTypeParameter(t as TypeParameter);
                return (t as TypeParameter).isThisType || !constraint ?
                    constraint :
                    getBaseConstraint(constraint);
            }
            if (t.flags & TypeFlags.UnionOrIntersection) {
                const types = (t as UnionOrIntersectionType).types;
                const baseTypes: Type[] = [];
                let different = false;
                for (const type of types) {
                    const baseType = getBaseConstraint(type);
                    if (baseType) {
                        if (baseType !== type) {
                            different = true;
                        }
                        baseTypes.push(baseType);
                    }
                    else {
                        different = true;
                    }
                }
                if (!different) {
                    return t;
                }
                return t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(baseTypes) :
                    t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(baseTypes) :
                    undefined;
            }
            if (t.flags & TypeFlags.Index) {
                return stringNumberSymbolType;
            }
            // if (t.flags & TypeFlags.TemplateLiteral) {
            //     const types = (t as TemplateLiteralType).types;
            //     const constraints = mapDefined(types, getBaseConstraint);
            //     return constraints.length === types.length ? getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) : stringType;
            // }
            if (t.flags & TypeFlags.StringMapping) {
                const constraint = getBaseConstraint((t as StringMappingType).type);
                return constraint && constraint !== (t as StringMappingType).type ? getStringMappingType((t as StringMappingType).symbol, constraint) : stringType;
            }
            if (t.flags & TypeFlags.IndexedAccess) {
                if (isMappedTypeGenericIndexedAccess(t)) {
                    // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
                    // we substitute an instantiation of E where P is replaced with X.
                    return getBaseConstraint(substituteIndexedMappedType((t as IndexedAccessType).objectType as MappedType, (t as IndexedAccessType).indexType));
                }
                const baseObjectType = getBaseConstraint((t as IndexedAccessType).objectType);
                const baseIndexType = getBaseConstraint((t as IndexedAccessType).indexType);
                const baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t as IndexedAccessType).accessFlags);
                return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
            }
            if (t.flags & TypeFlags.Conditional) {
                const constraint = getConstraintFromConditionalType(t as ConditionalType);
                return constraint && getBaseConstraint(constraint);
            }
            if (t.flags & TypeFlags.Substitution) {
                return getBaseConstraint(getSubstitutionIntersection(t as SubstitutionType));
            }
            if (isGenericTupleType(t)) {
                // We substitute constraints for variadic elements only when the constraints are array types or
                // non-variadic tuple types as we want to avoid further (possibly unbounded) recursion.
                const newElements = map(getElementTypes(t), (v, i) => {
                    const constraint = v.flags & TypeFlags.TypeParameter && t.target.elementFlags[i] & ElementFlags.Variadic && getBaseConstraint(v) || v;
                    return constraint !== v && everyType(constraint, c => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v;
                });
                return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations);
            }
            return t;
        }
    }
    function getConstraintOfDistributiveConditionalType(type: ConditionalType): Type | undefined {
        if (type.resolvedConstraintOfDistributive !== undefined) {
            return type.resolvedConstraintOfDistributive || undefined;
        }

        // Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
        // type parameter. If so, create an instantiation of the conditional type where T is replaced
        // with its constraint. We do this because if the constraint is a union type it will be distributed
        // over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
        // removes 'undefined' from T.
        // We skip returning a distributive constraint for a restrictive instantiation of a conditional type
        // as the constraint for all type params (check type included) have been replace with `unknown`, which
        // is going to produce even more false positive/negative results than the distribute constraint already does.
        // Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
        // a union - once negated types exist and are applied to the conditional false branch, this "constraint"
        // likely doesn't need to exist.
        if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
            const simplified = getSimplifiedType(type.checkType, /*writing*/ false);
            const constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
            if (constraint && constraint !== type.checkType) {
                const instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper), /*forConstraint*/ true);
                if (!(instantiated.flags & TypeFlags.Never)) {
                    type.resolvedConstraintOfDistributive = instantiated;
                    return instantiated;
                }
            }
        }
        type.resolvedConstraintOfDistributive = false;
        return undefined;
    }
    
    function getTrueTypeFromConditionalType(type: ConditionalType) {
        return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper));
    }

    function getInferredTrueTypeFromConditionalType(type: ConditionalType) {
        return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type));
    }

    function getFalseTypeFromConditionalType(type: ConditionalType) {
        return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper));
    }

    function getDefaultConstraintOfConditionalType(type: ConditionalType) {
        if (!type.resolvedDefaultConstraint) {
            // An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
            // a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
            // just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
            // in effect treating `any` like `never` rather than `unknown` in this location.
            const trueConstraint = getInferredTrueTypeFromConditionalType(type);
            const falseConstraint = getFalseTypeFromConditionalType(type);
            type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
        }
        return type.resolvedDefaultConstraint;
    }
    
    function getConstraintFromConditionalType(type: ConditionalType) {
        return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
    }

    function getSuggestedTypeForNonexistentStringLiteralType(source: StringLiteralType, target: UnionType): StringLiteralType | undefined {
        const candidates = target.types.filter((type): type is StringLiteralType => !!(type.flags & TypeFlags.StringLiteral));
        return getSpellingSuggestion(source.value, candidates, type => type.value);
    }

    function getSingleBaseForNonAugmentingSubtype(type: Type) {
        if (!(getObjectFlags(type) & ObjectFlags.Reference) || !(getObjectFlags((type as TypeReference).target) & ObjectFlags.ClassOrInterface)) {
            return undefined;
        }
        if (getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeCalculated) {
            return getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? (type as TypeReference).cachedEquivalentBaseType : undefined;
        }
        (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeCalculated;
        const target = (type as TypeReference).target as InterfaceType;
        if (getObjectFlags(target) & ObjectFlags.Class) {
            const baseTypeNode = getBaseTypeNodeOfClass(target);
            // A base type expression may circularly reference the class itself (e.g. as an argument to function call), so we only
            // check for base types specified as simple qualified names.
            if (baseTypeNode && baseTypeNode.expression.kind !== SyntaxKind.Identifier && baseTypeNode.expression.kind !== SyntaxKind.PropertyAccessExpression) {
                return undefined;
            }
        }
        const bases = getBaseTypes(target);
        if (bases.length !== 1) {
            return undefined;
        }
        if (getMembersOfSymbol(type.symbol).size) {
            return undefined; // If the interface has any members, they may subtype members in the base, so we should do a full structural comparison
        }
        let instantiatedBase = !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length)));
        if (length(getTypeArguments(type as TypeReference)) > length(target.typeParameters)) {
            console.debug("todo - implement this - typeref");
        //     instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type as TypeReference)));
        }
        (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeExists;
        return (type as TypeReference).cachedEquivalentBaseType = instantiatedBase;
    }

    /**
     * A type is 'weak' if it is an object type with at least one optional property
     * and no required properties, call/construct signatures or index signatures
     */
    function isWeakType(type: Type): boolean {
        if (type.flags & TypeFlags.Object) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            // Debug.assertIsDefined(resolved.callSignatures);
            return resolved.callSignatures?.length === 0 && resolved.constructSignatures.length === 0 && resolved.indexInfos.length === 0 &&
                resolved.properties.length > 0 && every(resolved.properties, p => !!(p.flags & SymbolFlags.Optional));
        }
        if (type.flags & TypeFlags.Substitution) {
            return isWeakType((type as SubstitutionType).baseType);
        }
        if (type.flags & TypeFlags.Intersection) {
            return every((type as IntersectionType).types, isWeakType);
        }
        return false;
    }

    function typeHasCallOrConstructSignatures(type: Type): boolean {
        return getSignaturesOfType(type, SignatureKind.Call).length !== 0 || getSignaturesOfType(type, SignatureKind.Construct).length !== 0;
    }

    function hasCommonProperties(source: Type, target: Type, isComparingJsxAttributes: boolean) {
        for (const prop of getPropertiesOfType(source)) {
            if (isKnownProperty(target, prop.name, isComparingJsxAttributes)) {
                return true;
            }
        }
        return false;
    }

    
    /**
     * Check if a property with the given name is known anywhere in the given type. In an object type, a property
     * is considered known if
     * 1. the object type is empty and the check is for assignability, or
     * 2. if the object type has index signatures, or
     * 3. if the property is actually declared in the object type
     *    (this means that 'toString', for example, is not usually a known property).
     * 4. In a union or intersection type,
     *    a property is considered known if it is known in any constituent type.
     * @param targetType a type to search a given name in
     * @param name a property name to search
     * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
     */
    function isKnownProperty(targetType: Type, name: string, isComparingJsxAttributes: boolean): boolean {
        if (targetType.flags & TypeFlags.Object) {
            // For backwards compatibility a symbol-named property is satisfied by a string index signature. This
            // is incorrect and inconsistent with element access expressions, where it is an error, so eventually
            // we should remove this exception.
            if (
                getPropertyOfObjectType(targetType, name) ||
                getApplicableIndexInfoForName(targetType, name) ||
                isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) 
                //isComparingJsxAttributes && isHyphenatedJsxName(name)
            ) {
                // For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
                return true;
            }
        }
        // if (targetType.flags & TypeFlags.Substitution) {
        //     return isKnownProperty((targetType as SubstitutionType).baseType, name, isComparingJsxAttributes);
        // }
        if (targetType.flags & TypeFlags.UnionOrIntersection && isExcessPropertyCheckTarget(targetType)) {
            for (const t of (targetType as UnionOrIntersectionType).types) {
                if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    function isExcessPropertyCheckTarget(type: Type): boolean {
        return !!(type.flags & TypeFlags.Object && !(getObjectFlags(type) & ObjectFlags.ObjectLiteralPatternWithComputedProperties) ||
            type.flags & TypeFlags.NonPrimitive ||
            type.flags & TypeFlags.Substitution && isExcessPropertyCheckTarget((type as SubstitutionType).baseType) ||
            type.flags & TypeFlags.Union && some((type as UnionType).types, isExcessPropertyCheckTarget) || 
            type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isExcessPropertyCheckTarget));
    }

    function extractTypesOfKind(type: Type, kind: TypeFlags) {
        return filterType(type, t => (t.flags & kind) !== 0);
    }

    
    function getMatchingUnionConstituentForType(unionType: UnionType, type: Type) {        
        const keyPropertyName = getKeyPropertyName(unionType);
        const propType = keyPropertyName && getTypeOfPropertyOfType(type, keyPropertyName);
        return propType && getConstituentTypeForKeyType(unionType, propType);
    }

    function transformTypeOfMembers(type: Type, f: (propertyType: Type) => Type) {
        const members = createSymbolTable();
        for (const property of getPropertiesOfObjectType(type)) {
            const original = getTypeOfSymbol(property);
            const updated = f(original);
            members.set(property.name, updated === original ? property : createSymbolWithType(property, updated));
        }
        return members;
    }

    /**
     * If the the provided object literal is subject to the excess properties check,
     * create a new that is exempt. Recursively mark object literal members as exempt.
     * Leave signatures alone since they are not subject to the check.
     */
    function getRegularTypeOfObjectLiteral(type: Type): Type {
        if (!(isObjectLiteralType(type) && getObjectFlags(type) & ObjectFlags.FreshLiteral)) {
            return type;
        }
        const regularType = (type as FreshObjectLiteralType).regularType;
        if (regularType) {
            return regularType;
        }

        const resolved = type as ResolvedType;
        const members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
        const regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos);
        regularNew.flags = resolved.flags;
        regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlags.FreshLiteral;
        (type as FreshObjectLiteralType).regularType = regularNew;
        return regularNew;
    }

    function isTypeSubsetOfUnion(source: Type, target: UnionType) {
        if (source.flags & TypeFlags.Union) {
            for (const t of (source as UnionType).types) {
                if (!containsType(target.types, t)) {
                    return false;
                }
            }
            return true;
        }
        // if (source.flags & TypeFlags.EnumLike && getBaseTypeOfEnumLikeType(source as LiteralType) === target) {
        //     return true;
        // }
        return containsType(target.types, source);
    }


    function isTypeSubsetOf(source: Type, target: Type) {
        return !!(source === target || source.flags & TypeFlags.Never || target.flags & TypeFlags.Union && isTypeSubsetOfUnion(source, target as UnionType));
    }

    function isDiscriminantProperty(type: Type | undefined, name: string) {
        if (type && type.flags & TypeFlags.Union) {
            const prop = getUnionOrIntersectionProperty(type as UnionType, name);
            if (prop && getCheckFlags(prop) & CheckFlags.SyntheticProperty) {
                // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty
                if ((prop as TransientSymbol).links.isDiscriminantProperty === undefined) {
                    (prop as TransientSymbol).links.isDiscriminantProperty = ((prop as TransientSymbol).links.checkFlags & CheckFlags.Discriminant) === CheckFlags.Discriminant &&
                        !isGenericType(getTypeOfSymbol(prop));
                }
                return !!(prop as TransientSymbol).links.isDiscriminantProperty;
            }
        }
        return false;
    }

    function findDiscriminantProperties(sourceProperties: Symbol[], target: Type): Symbol[] | undefined {
        let result: Symbol[] | undefined;
        for (const sourceProperty of sourceProperties) {
            if (isDiscriminantProperty(target, sourceProperty.name)) {
                if (result) {
                    result.push(sourceProperty);
                    continue;
                }
                result = [sourceProperty];
            }
        }
        return result;
    }

    /**
     * Return the type of the matching property or index signature in the given type, or undefined
     * if no matching property or index signature exists. Add optionality to index signature types.
     */
    function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: string): Type | undefined {
        let propType;
        return getTypeOfPropertyOfType(type, name) ||
            (propType = getApplicableIndexInfoForName(type, name)?.type) &&
                addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);
    }


    function discriminateTypeByDiscriminableItems(target: UnionType, discriminators: (readonly [() => Type, string])[], related: (source: Type, target: Type) => boolean | Ternary) {
        const types = target.types;
        const include: Ternary[] = types.map(t => t.flags & TypeFlags.Primitive ? Ternary.False : Ternary.True);
        for (const [getDiscriminatingType, propertyName] of discriminators) {
            // If the remaining target types include at least one with a matching discriminant, eliminate those that
            // have non-matching discriminants. This ensures that we ignore erroneous discriminators and gradually
            // refine the target set without eliminating every constituent (which would lead to `never`).
            let matched = false;
            for (let i = 0; i < types.length; i++) {
                if (include[i]) {
                    const targetType = getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName);
                    if (targetType && someType(getDiscriminatingType(), t => !!related(t, targetType))) {
                        matched = true;
                    }
                    else {
                        include[i] = Ternary.Maybe;
                    }
                }
            }
            // Turn each Ternary.Maybe into Ternary.False if there was a match. Otherwise, revert to Ternary.True.
            for (let i = 0; i < types.length; i++) {
                if (include[i] === Ternary.Maybe) {
                    include[i] = matched ? Ternary.False : Ternary.True;
                }
            }
        }
        const filtered = contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target;
        return filtered.flags & TypeFlags.Never ? target : filtered;
    }

    // Keep this up-to-date with the same logic within `getApparentTypeOfContextualType`, since they should behave similarly
    function findMatchingDiscriminantType(source: Type, target: Type, isRelatedTo: (source: Type, target: Type) => Ternary) {
        if (target.flags & TypeFlags.Union && source.flags & (TypeFlags.Intersection | TypeFlags.Object)) {
            const match = getMatchingUnionConstituentForType(target as UnionType, source);
            if (match) {
                return match;
            }
            const sourceProperties = getPropertiesOfType(source);
            if (sourceProperties) {
                const sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
                if (sourcePropertiesFiltered) {
                    const discriminated = discriminateTypeByDiscriminableItems(target as UnionType, map(sourcePropertiesFiltered, p => ([() => getTypeOfSymbol(p), p.name] as [() => Type, string])), isRelatedTo);
                    if (discriminated !== target) {
                        return discriminated;
                    }
                }
            }
        }
        return undefined;
    }

    function filterPrimitivesIfContainsNonPrimitive(type: UnionType) {
        if (maybeTypeOfKind(type, TypeFlags.NonPrimitive)) {
            const result = filterType(type, t => !(t.flags & TypeFlags.Primitive));
            if (!(result.flags & TypeFlags.Never)) {
                return result;
            }
        }
        return type;
    }

    
    /**
     * Checks if a property can be accessed in a location.
     * The location is given by the `node` parameter.
     * The node does not need to be a property access.
     * @param node location where to check property accessibility
     * @param isSuper whether to consider this a `super` property access, e.g. `super.foo`.
     * @param isWrite whether this is a write access, e.g. `++foo.x`.
     * @param containingType type where the property comes from.
     * @param property property symbol.
     */
    function isPropertyAccessible(
        node: Node,
        isSuper: boolean,
        isWrite: boolean,
        containingType: Type,
        property: Symbol,
    ): boolean {
        // Short-circuiting for improved performance.
        if (isTypeAny(containingType)) {
            return true;
        }

        // A #private property access in an optional chain is an error dealt with by the parser.
        // The checker does not check for it, so we need to do our own check here.
        // if (property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration)) {
        //     const declClass = getContainingClass(property.valueDeclaration);
        //     return !isOptionalChain(node) && !!findAncestor(node, parent => parent === declClass);
        // }

        return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property);
    }
    
    /**
     * Checks if an existing property access is valid for completions purposes.
     * @param node a property access-like node where we want to check if we can access a property.
     * This node does not need to be an access of the property we are checking.
     * e.g. in completions, this node will often be an incomplete property access node, as in `foo.`.
     * Besides providing a location (i.e. scope) used to check property accessibility, we use this node for
     * computing whether this is a `super` property access.
     * @param type the type whose property we are checking.
     * @param property the accessed property's symbol.
     */
    function isValidPropertyAccessForCompletions(node: PropertyAccessExpression | QualifiedName, type: Type, property: Symbol): boolean {
        return isPropertyAccessible(node, node.kind === SyntaxKind.PropertyAccessExpression && node.expression.kind === SyntaxKind.SuperKeyword, /*isWrite*/ false, type, property);
        // Previously we validated the 'this' type of methods but this adversely affected performance. See #31377 for more context.
    }


    function getSuggestedSymbolForNonexistentProperty(name: Identifier | string, containingType: Type): Symbol | undefined {
        let props = getPropertiesOfType(containingType) ?? emptyArray;
        if (typeof name !== "string") {
            const parent = name.parent;
            if (isPropertyAccessExpression(parent)) {
                props = filter(props, prop => isValidPropertyAccessForCompletions(parent, containingType, prop));
            }
            name = idText(name);
        }
        return getSpellingSuggestionForName(name, props, SymbolFlags.Value);
    }

    function getSuggestionForNonexistentProperty(name: Identifier |  string, containingType: Type): string | undefined {
        const suggestion = getSuggestedSymbolForNonexistentProperty(name, containingType);
        return suggestion && symbolName(suggestion);
    }

    // Unwrap nested homomorphic mapped types and return the deepest target type that has a symbol. This better
    // preserves unique type identities for mapped types applied to explicitly written object literals. For example
    // in `Mapped<{ x: Mapped<{ x: Mapped<{ x: string }>}>}>`, each of the mapped type applications will have a
    // unique recursion identity (that of their target object type literal) and thus avoid appearing deeply nested.
    function getMappedTargetWithSymbol(type: Type) {
        let target;
        while (
            (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped &&
            (target = getModifiersTypeFromMappedType(type as MappedType)) &&
            (target.symbol || target.flags & TypeFlags.Intersection && some((target as IntersectionType).types, t => !!t.symbol))
        ) {
            type = target;
        }
        return type;
    }

    function hasMatchingRecursionIdentity(type: Type, identity: object): boolean {
        if ((getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped) {
            type = getMappedTargetWithSymbol(type);
        }
        if (type.flags & TypeFlags.Intersection) {
            return some((type as IntersectionType).types, t => hasMatchingRecursionIdentity(t, identity));
        }
        return getRecursionIdentity(type) === identity;
    }

    // Return true if the given type is deeply nested. We consider this to be the case when the given stack contains
    // maxDepth or more occurrences of types with the same recursion identity as the given type. The recursion identity
    // provides a shared identity for type instantiations that repeat in some (possibly infinite) pattern. For example,
    // in `type Deep<T> = { next: Deep<Deep<T>> }`, repeatedly referencing the `next` property leads to an infinite
    // sequence of ever deeper instantiations with the same recursion identity (in this case the symbol associated with
    // the object type literal).
    // A homomorphic mapped type is considered deeply nested if its target type is deeply nested, and an intersection is
    // considered deeply nested if any constituent of the intersection is deeply nested.
    // It is possible, though highly unlikely, for the deeply nested check to be true in a situation where a chain of
    // instantiations is not infinitely expanding. Effectively, we will generate a false positive when two types are
    // structurally equal to at least maxDepth levels, but unequal at some level beyond that.
    function isDeeplyNestedType(type: Type, stack: Type[], depth: number, maxDepth = 3): boolean {
        if (depth >= maxDepth) {
            if ((getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped) {
                type = getMappedTargetWithSymbol(type);
            }
            if (type.flags & TypeFlags.Intersection) {
                return some((type as IntersectionType).types, t => isDeeplyNestedType(t, stack, depth, maxDepth));
            }
            const identity = getRecursionIdentity(type);
            let count = 0;
            let lastTypeId = 0;
            for (let i = 0; i < depth; i++) {
                const t = stack[i];
                if (hasMatchingRecursionIdentity(t, identity)) {
                    // We only count occurrences with a higher type id than the previous occurrence, since higher
                    // type ids are an indicator of newer instantiations caused by recursion.
                    if (t.id >= lastTypeId) {
                        count++;
                        if (count >= maxDepth) {
                            return true;
                        }
                    }
                    lastTypeId = t.id;
                }
            }
        }
        return false;
    }

    function getNormalizedUnionOrIntersectionType(type: UnionOrIntersectionType, writing: boolean) {
        const reduced = getReducedType(type);
        if (reduced !== type) {
            return reduced;
        }
        if (type.flags & TypeFlags.Intersection && shouldNormalizeIntersection(type as IntersectionType)) {
            // Normalization handles cases like
            // Partial<T>[K] & ({} | null) ==>
            // Partial<T>[K] & {} | Partial<T>[K} & null ==>
            // (T[K] | undefined) & {} | (T[K] | undefined) & null ==>
            // T[K] & {} | undefined & {} | T[K] & null | undefined & null ==>
            // T[K] & {} | T[K] & null
            const normalizedTypes = sameMap(type.types, t => getNormalizedType(t, writing));
            if (normalizedTypes !== type.types) {
                return getIntersectionType(normalizedTypes);
            }
        }
        return type;
    }
    
    function shouldNormalizeIntersection(type: IntersectionType) {
        let hasInstantiable = false;
        let hasNullableOrEmpty = false;
        for (const t of type.types) {
            hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable);
            hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t);
            if (hasInstantiable && hasNullableOrEmpty) return true;
        }
        return false;
    }

    function getOrCreateSubstitutionType(baseType: Type, constraint: Type) {
        const id = `${getTypeId(baseType)}>${getTypeId(constraint)}`;
        const cached = substitutionTypes.get(id);
        if (cached) {
            return cached;
        }
        const result = createType(TypeFlags.Substitution) as SubstitutionType;
        result.baseType = baseType;
        result.constraint = constraint;
        substitutionTypes.set(id, result);
        return result;
    }
    
    function getNoInferType(type: Type) {
        return isNoInferTargetType(type) ? getOrCreateSubstitutionType(type, unknownType) : type;
    }

    function isNoInferTargetType(type: Type): boolean {
        // This is effectively a more conservative and predictable form of couldContainTypeVariables. We want to
        // preserve NoInfer<T> only for types that could contain type variables, but we don't want to exhaustively
        // examine all object type members.
        return !!(type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, isNoInferTargetType) ||
            type.flags & TypeFlags.Substitution && !isNoInferType(type) && isNoInferTargetType((type as SubstitutionType).baseType) ||
            type.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(type) ||
            type.flags & (TypeFlags.Instantiable & ~TypeFlags.Substitution));// && !isPatternLiteralType(type));
    }

    
    function isNoInferType(type: Type) {
        // A NoInfer<T> type is represented as a substitution type with a TypeFlags.Unknown constraint.
        return !!(type.flags & TypeFlags.Substitution && (type as SubstitutionType).constraint.flags & TypeFlags.Unknown);
    }

    function getStringMappingType(symbol: Symbol, type: Type): Type {
        Debug.fail("not implemented - getStringMappingType");
    }

    function getTypeAliasInstantiation(symbol: Symbol, typeArguments: readonly Type[] | undefined, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        const type = getDeclaredTypeOfSymbol(symbol);
        if (type === intrinsicMarkerType) {
            const typeKind = intrinsicTypeKinds.get(symbol.name as string);
            if (typeKind !== undefined && typeArguments && typeArguments.length === 1) {
                return typeKind === IntrinsicTypeKind.NoInfer ? getNoInferType(typeArguments[0]) : getStringMappingType(symbol, typeArguments[0]);
            }
        }
        const links = getSymbolLinks(symbol);
        const typeParameters = links.typeParameters!;
        const id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
        let instantiation = links.instantiations!.get(id);
        if (!instantiation) {
            links.instantiations!.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
        }
        return instantiation;
    }

    function createMarkerType(symbol: Symbol, source: TypeParameter, target: Type) {
        const mapper = makeUnaryTypeMapper(source, target);
        const type = getDeclaredTypeOfSymbol(symbol);
        if (isErrorType(type)) {
            return type;
        }
        const result = symbol.flags & SymbolFlags.TypeAlias ?
            getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) :
            createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper));
        markerTypes.add(getTypeId(result));
        return result;
    }

    function isMarkerType(type: Type) {
        return markerTypes.has(getTypeId(type));
    }

    function getEffectiveConstraintOfIntersection(types: readonly Type[], targetIsUnion: boolean) {
        let constraints: Type[] | undefined;
        let hasDisjointDomainType = false;
        for (const t of types) {
            if (t.flags & TypeFlags.Instantiable) {
                // We keep following constraints as long as we have an instantiable type that is known
                // not to be circular or infinite (hence we stop on index access types).
                let constraint = getConstraintOfType(t);
                while (constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)) {
                    constraint = getConstraintOfType(constraint);
                }
                if (constraint) {
                    constraints = append(constraints, constraint);
                    if (targetIsUnion) {
                        constraints = append(constraints, t);
                    }
                }
            }
            else if (t.flags & TypeFlags.DisjointDomains || isEmptyAnonymousObjectType(t)) {
                hasDisjointDomainType = true;
            }
        }
        // If the target is a union type or if we are intersecting with types belonging to one of the
        // disjoint domains, we may end up producing a constraint that hasn't been examined before.
        if (constraints && (targetIsUnion || hasDisjointDomainType)) {
            if (hasDisjointDomainType) {
                // We add any types belong to one of the disjoint domains because they might cause the final
                // intersection operation to reduce the union constraints.
                for (const t of types) {
                    if (t.flags & TypeFlags.DisjointDomains || isEmptyAnonymousObjectType(t)) {
                        constraints = append(constraints, t);
                    }
                }
            }
            // The source types were normalized; ensure the result is normalized too.
            return getNormalizedType(getIntersectionType(constraints, IntersectionFlags.NoConstraintReduction), /*writing*/ false);
        }
        return undefined;
    }

    // Return count of starting consecutive tuple elements of the given kind(s)
    function getStartElementCount(type: TupleType, flags: ElementFlags) {
        const index = findIndex(type.elementFlags, f => !(f & flags));
        return index >= 0 ? index : type.elementFlags.length;
    }

    // Return count of ending consecutive tuple elements of the given kind(s)
    function getEndElementCount(type: TupleType, flags: ElementFlags) {
        return type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1;
    }

    function isGenericTupleType(type: Type): type is TupleTypeReference {
        return isTupleType(type) && !!(type.target.combinedFlags & ElementFlags.Variadic);
    }

    function* getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol> {
        const properties = getPropertiesOfType(target);
        for (const targetProp of properties) {
            // TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass
            // if (isStaticPrivateIdentifierProperty(targetProp)) {
            //     continue;
            // }
            if (requireOptionalProperties || !(targetProp.flags & SymbolFlags.Optional || getCheckFlags(targetProp) & CheckFlags.Partial)) {
                const sourceProp = getPropertyOfType(source, targetProp.name);
                if (!sourceProp) {
                    yield targetProp;
                }
                else if (matchDiscriminantProperties) {
                    const targetType = getTypeOfSymbol(targetProp);
                    if (targetType.flags & TypeFlags.Unit) {
                        const sourceType = getTypeOfSymbol(sourceProp);
                        if (!(sourceType.flags & TypeFlags.Any || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType))) {
                            yield targetProp;
                        }
                    }
                }
            }
        }
    }

    function getUnmatchedProperty(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): Symbol | undefined {
        return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties));
    }
    
    // Invoke the callback for each underlying property symbol of the given symbol and return the first
    // value that isn't undefined.
    function forEachProperty<T>(prop: Symbol, callback: (p: Symbol) => T): T | undefined {
        if (getCheckFlags(prop) & CheckFlags.Synthetic) {
            // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.Synthetic
            for (const t of (prop as TransientSymbol).links.containingType!.types) {
                const p = getPropertyOfType(t, prop.name);
                const result = p && forEachProperty(p, callback);
                if (result) {
                    return result;
                }
            }
            return undefined;
        }
        return callback(prop);
    }

    // Return true if some underlying source property is declared in a class that derives
    // from the given base class.
    function isPropertyInClassDerivedFrom(prop: Symbol, baseClass: Type | undefined) {
        return forEachProperty(prop, sp => {
            const sourceClass = getDeclaringClass(sp);
            return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
        });
    }

    // Return true if source property is a valid override of protected parts of target property.
    function isValidOverrideOf(sourceProp: Symbol, targetProp: Symbol) {
        return !forEachProperty(targetProp, tp =>
            getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ?
                !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false);
    }

    /**
     * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
     * with no call or construct signatures.
     */
    function isObjectTypeWithInferableIndex(type: Type): boolean {
        const objectFlags = getObjectFlags(type);
        return type.flags & TypeFlags.Intersection
            ? every((type as IntersectionType).types, isObjectTypeWithInferableIndex)
            : !!(
                type.symbol
                && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0
                && !(type.symbol.flags & SymbolFlags.Class)
                && !typeHasCallOrConstructSignatures(type)
            ) || !!(
                objectFlags & ObjectFlags.ObjectRestType
            ) || !!(objectFlags & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source));
    }

    function isNonGenericObjectType(type: Type) {
        return !!(type.flags & TypeFlags.Object) && !isGenericMappedType(type);
    }

    function isSingleElementGenericTupleType(type: Type): type is TupleTypeReference {
        return isGenericTupleType(type) && type.target.elementFlags.length === 1;
    }

    function getConstraintTypeFromMappedType(type: MappedType) {
        return type.constraintType ||
            (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
    }

    function getKnownKeysOfTupleType(type: TupleTypeReference) {
        return getUnionType(append(arrayOf(type.target.fixedLength, i => getStringLiteralType("" + i)), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
    }
    
    function isGenericIndexType(type: Type): boolean {
        return !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericIndexType);
    }

    function intersectTypes(type1: Type, type2: Type): Type;
    function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined;
    function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined {
        return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
    }

    function getTypeWithThisArgument(type: Type, thisArgument?: Type, needApparentType?: boolean): Type {
        if (getObjectFlags(type) & ObjectFlags.Reference) {
            const target = (type as TypeReference).target;
            const typeArguments = getTypeArguments(type as TypeReference);
            return length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!])) : type;
        }
        else if (type.flags & TypeFlags.Intersection) {
            const types = sameMap((type as IntersectionType).types, t => getTypeWithThisArgument(t, thisArgument, needApparentType));
            return types !== (type as IntersectionType).types ? getIntersectionType(types) : type;
        }
        return needApparentType ? getApparentType(type) : type;
    }

    function isMappedTypeGenericIndexedAccess(type: Type) {
        let objectType;
        return !!(type.flags & TypeFlags.IndexedAccess && getObjectFlags(objectType = (type as IndexedAccessType).objectType) & ObjectFlags.Mapped &&
            !isGenericMappedType(objectType) && isGenericIndexType((type as IndexedAccessType).indexType) &&
            !(getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.ExcludeOptional) && !(objectType as MappedType).declaration.nameType);
    }

    function isPartialMappedType(type: Type) {
        return !!(getObjectFlags(type) & ObjectFlags.Mapped && getMappedTypeModifiers(type as MappedType) & MappedTypeModifiers.IncludeOptional);
    }

    // Return -1, 0, or 1, where -1 means optionality is stripped (i.e. -?), 0 means optionality is unchanged, and 1 means
    // optionality is added (i.e. +?).
    function getMappedTypeOptionality(type: MappedType): number {
        const modifiers = getMappedTypeModifiers(type);
        return modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0;
    }

    function getModifiersTypeFromMappedType(type: MappedType) {
        if (!type.modifiersType) {
            // if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
            //     // If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
            //     // AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
            //     // 'keyof T' to a literal union type and we can't recover T from that type.
            //     type.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type) as TypeOperatorNode).type), type.mapper);
            // }
            // else {
                // Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
                // get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
                // the modifiers type is T. Otherwise, the modifiers type is unknown.
                const declaredType = getTypeFromMappedTypeNode(type.declaration) as MappedType;
                const constraint = getConstraintTypeFromMappedType(declaredType);
                const extendedConstraint = constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint;
                type.modifiersType = extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType;
            // }
        }
        return type.modifiersType;
    }


    // Return -1, 0, or 1, for stripped, unchanged, or added optionality respectively. When a homomorphic mapped type doesn't
    // modify optionality, recursively consult the optionality of the type being mapped over to see if it strips or adds optionality.
    // For intersections, return -1 or 1 when all constituents strip or add optionality, otherwise return 0.
    function getCombinedMappedTypeOptionality(type: Type): number {
        if (getObjectFlags(type) & ObjectFlags.Mapped) {
            return getMappedTypeOptionality(type as MappedType) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type as MappedType));
        }
        if (type.flags & TypeFlags.Intersection) {
            const optionality = getCombinedMappedTypeOptionality((type as IntersectionType).types[0]);
            return every((type as IntersectionType).types, (t, i) => i === 0 || getCombinedMappedTypeOptionality(t) === optionality) ? optionality : 0;
        }
        return 0;
    }

    function getVariances(type: GenericType): VarianceFlags[] {
        // Arrays and tuples are known to be covariant, no need to spend time computing this.
        return type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple ?
            arrayVariances :
            getVariancesWorker(type.symbol, type.typeParameters);
    }

    function countTypes(type: Type) {
        return type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1;
    }

    // Return true if the given type reference has a 'void' type argument for a covariant type parameter.
    // See comment at call in recursiveTypeRelatedTo for when this case matters.
    function hasCovariantVoidArgument(typeArguments: readonly Type[], variances: VarianceFlags[]): boolean {
        for (let i = 0; i < variances.length; i++) {
            if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) {
                return true;
            }
        }
        return false;
    }

    function getConstraintDeclarationForMappedType(type: MappedType) {
        return getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
    }

    function isMappedTypeWithKeyofConstraintDeclaration(type: MappedType) {
        const constraintDeclaration = getConstraintDeclarationForMappedType(type)!; // TODO: GH#18217
        console.debug("todo - isMappedTypeWithKeyofConstraintDeclaration");
        return false;
        // return constraintDeclaration.kind === SyntaxKind.TypeOperator &&
        //     (constraintDeclaration as TypeOperatorNode).operator === SyntaxKind.KeyOfKeyword;
    }

    function forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(type: Type, include: TypeFlags, stringsOnly: boolean, cb: (keyType: Type) => void) {
        for (const prop of getPropertiesOfType(type)) {
            cb(getLiteralTypeFromProperty(prop, include));
        }
        if (type.flags & TypeFlags.Any) {
            cb(stringType);
        }
        else {
            for (const info of getIndexInfosOfType(type)) {
                if (!stringsOnly || info.keyType.flags & (TypeFlags.String | TypeFlags.TemplateLiteral)) {
                    cb(info.keyType);
                }
            }
        }
    }

    /**
     * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
     * @param source The left-hand-side of the relation.
     * @param target The right-hand-side of the relation.
     * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
     * Used as both to determine which checks are performed and as a cache of previously computed results.
     * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
     * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
     * @param containingMessageChain A chain of errors to prepend any new errors found.
     * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
     */
    function checkTypeRelatedTo(
        source: Type,
        target: Type,
        relation: Map<string, RelationComparisonResult>,
        errorNode: Node | undefined,
        headMessage?: DiagnosticMessage,
        containingMessageChain?: () => DiagnosticMessageChain | undefined,
        errorOutputContainer?: { errors?: Diagnostic[]; skipLogging?: boolean; },
    ): boolean {        
        let errorInfo: DiagnosticMessageChain | undefined;
        let relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined;
        let maybeKeys: string[];
        let maybeKeysSet: Set<string>;
        let sourceStack: Type[];
        let targetStack: Type[];
        let maybeCount = 0;
        let sourceDepth = 0;
        let targetDepth = 0;
        let expandingFlags = ExpandingFlags.None;
        let overflow = false;
        let overrideNextErrorInfo = 0; // How many `reportRelationError` calls should be skipped in the elaboration pyramid
        let skipParentCounter = 0; // How many errors should be skipped 'above' in the elaboration pyramid
        let lastSkippedInfo: [Type, Type] | undefined;
        let incompatibleStack: DiagnosticAndArguments[] | undefined;
        // In Node.js, the maximum number of elements in a map is 2^24. We limit the number of entries an invocation
        // of checkTypeRelatedTo can add to a relation to 1/8th of its remaining capacity.
        let relationCount = (16_000_000 - relation.size) >> 3;

        Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");

        const result = isRelatedTo(source, target, RecursionFlags.Both, /*reportErrors*/ !!errorNode, headMessage);
        if (incompatibleStack) {
            reportIncompatibleStack();
        }

        if (overflow) {
            // Record this relation as having failed such that we don't attempt the overflowing operation again.
            const id = getRelationKey(source, target, /*intersectionState*/ IntersectionState.None, relation, /*ignoreConstraints*/ false);
            relation.set(id, RelationComparisonResult.Failed | (relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow));
            tracing?.instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit", { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth });
            const message = relationCount <= 0 ?
                Diagnostics.Excessive_complexity_comparing_types_0_and_1 :
                Diagnostics.Excessive_stack_depth_comparing_types_0_and_1;
            const diag = error(errorNode || currentNode, message, typeToString(source), typeToString(target));
            if (errorOutputContainer) {
                (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
            }
        }
        else if (errorInfo) {
            if (containingMessageChain) {
                const chain = containingMessageChain();
                if (chain) {
                    concatenateDiagnosticMessageChains(chain, errorInfo);
                    errorInfo = chain;
                }
            }

            let relatedInformation: DiagnosticRelatedInformation[] | undefined;
            // Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
            // if (headMessage && errorNode && !result && source.symbol) {
            //     const links = getSymbolLinks(source.symbol);
            //     if (links.originatingImport && !isImportCall(links.originatingImport)) {
            //         const helpfulRetry = checkTypeRelatedTo(getTypeOfSymbol(links.target!), target, relation, /*errorNode*/ undefined);
            //         if (helpfulRetry) {
            //             // Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
            //             const diag = createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead);
            //             relatedInformation = append(relatedInformation, diag); // Cause the error to appear with the error that triggered it
            //         }
            //     }
            // }
            const diag = createDiagnosticForNodeFromMessageChain(getSourceFileOrIncludeOfNode(errorNode!), errorNode!, errorInfo, relatedInformation);
            if (relatedInfo) {
                addRelatedInfo(diag, ...relatedInfo);
            }
            if (errorOutputContainer) {
                (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
            }
            if (!errorOutputContainer || !errorOutputContainer.skipLogging) {
                diagnostics.add(diag);
            }
        }
        if (errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === Ternary.False) {
            Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.");
        }
        
        return result !== Ternary.False;

        function resetErrorInfo(saved: ReturnType<typeof captureErrorCalculationState>) {
            errorInfo = saved.errorInfo;
            lastSkippedInfo = saved.lastSkippedInfo;
            incompatibleStack = saved.incompatibleStack;
            overrideNextErrorInfo = saved.overrideNextErrorInfo;
            skipParentCounter = saved.skipParentCounter;
            relatedInfo = saved.relatedInfo;
        }

        function captureErrorCalculationState() {
            return {
                errorInfo,
                lastSkippedInfo,
                incompatibleStack: incompatibleStack?.slice(),
                overrideNextErrorInfo,
                skipParentCounter,
                relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined,
            };
        }


        function traceUnionsOrIntersectionsTooLarge(source: Type, target: Type): void {
            if (!tracing) {
                return;
            }

            if ((source.flags & TypeFlags.UnionOrIntersection) && (target.flags & TypeFlags.UnionOrIntersection)) {
                const sourceUnionOrIntersection = source as UnionOrIntersectionType;
                const targetUnionOrIntersection = target as UnionOrIntersectionType;

                if (sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlags.PrimitiveUnion) {
                    // There's a fast path for comparing primitive unions
                    return;
                }

                const sourceSize = sourceUnionOrIntersection.types.length;
                const targetSize = targetUnionOrIntersection.types.length;
                if (sourceSize * targetSize > 1E6) {
                    tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit", {
                        sourceId: source.id,
                        sourceSize,
                        targetId: target.id,
                        targetSize,
                        pos: errorNode?.pos,
                        end: errorNode?.end,
                    });
                }
            }
        }


        function reportIncompatibleStack() {
            const stack = incompatibleStack || [];
            incompatibleStack = undefined;
            const info = lastSkippedInfo;
            lastSkippedInfo = undefined;
            if (stack.length === 1) {
                reportError(...stack[0]);
                if (info) {
                    // Actually do the last relation error
                    reportRelationError(/*message*/ undefined, ...info);
                }
                return;
            }
            // The first error will be the innermost, while the last will be the outermost - so by popping off the end,
            // we can build from left to right
            let path = "";
            const secondaryRootErrors: DiagnosticAndArguments[] = [];
            while (stack.length) {
                const [msg, ...args] = stack.pop()!;
                switch (msg.code) {
                    case Diagnostics.Types_of_property_0_are_incompatible.code: {
                        // Parenthesize a `new` if there is one
                        if (path.indexOf("new ") === 0) {
                            path = `(${path})`;
                        }
                        const str = "" + args[0];
                        // If leading, just print back the arg (irrespective of if it's a valid identifier)
                        if (path.length === 0) {
                            path = `${str}`;
                        }
                        // Otherwise write a dotted name if possible
                        else if (isIdentifierText(str, getEmitScriptTarget(compilerOptions))) {
                            path = `${path}.${str}`;
                        }
                        // Failing that, check if the name is already a computed name
                        else if (str[0] === "[" && str[str.length - 1] === "]") {
                            path = `${path}${str}`;
                        }
                        // And finally write out a computed name as a last resort
                        else {
                            path = `${path}[${str}]`;
                        }
                        break;
                    }
                    case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
                    //case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
                    case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {
                    //case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {
                        if (path.length === 0) {
                            // Don't flatten signature compatability errors at the start of a chain - instead prefer
                            // to unify (the with no arguments bit is excessive for printback) and print them back
                            let mappedMsg = msg;
                            if (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;
                            }
                            // else if (msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                            //     mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;
                            // }
                            secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);
                        }
                        else {
                            // const prefix = (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||
                            //         msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                            //     ? "new "
                            //     : "";
                            const prefix="";
                            // const params = (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||
                            //         msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                            //     ? ""
                            //     : "...";
                            const params = "";
                            path = `${prefix}${path}(${params})`;
                        }
                        break;
                    }
                    case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {
                        secondaryRootErrors.unshift([Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);
                        break;
                    }
                    case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {
                        secondaryRootErrors.unshift([Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);
                        break;
                    }
                    default:
                        return Debug.fail(`Unhandled Diagnostic: ${msg.code}`);
                }
            }
            if (path) {
                reportError(
                    path[path.length - 1] === ")"
                        ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types
                        : Diagnostics.The_types_of_0_are_incompatible_between_these_types,
                    path,
                );
            }
            else {
                // Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
                secondaryRootErrors.shift();
            }
            for (const [msg, ...args] of secondaryRootErrors) {
                const originalValue = msg.elidedInCompatabilityPyramid;
                msg.elidedInCompatabilityPyramid = false; // Temporarily override elision to ensure error is reported
                reportError(msg, ...args);
                msg.elidedInCompatabilityPyramid = originalValue;
            }
            if (info) {
                // Actually do the last relation error
                reportRelationError(/*message*/ undefined, ...info);
            }
        }

        function reportRelationError(message: DiagnosticMessage | undefined, source: Type, target: Type) {
            if (incompatibleStack) reportIncompatibleStack();
            const [sourceType, targetType] = getTypeNamesForErrorDisplay(source, target);
            let generalizedSource = source;
            let generalizedSourceType = sourceType;

            if (isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target)) {
                generalizedSource = getBaseTypeOfLiteralType(source);
                // Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable");
                generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource);
            }

            // If `target` is of indexed access type (And `source` it is not), we use the object type of `target` for better error reporting
            const targetFlags = target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ?
                (target as IndexedAccessType).objectType.flags :
                target.flags;            
            if (targetFlags & TypeFlags.TypeParameter && target !== markerSuperTypeForCheck && target !== markerSubTypeForCheck) {
                const constraint = getBaseConstraintOfType(target);
                let needsOriginalSource;
                if (constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint)))) {
                    reportError(
                        Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2,
                        needsOriginalSource ? sourceType : generalizedSourceType,
                        targetType,
                        typeToString(constraint),
                    );
                }
                else {
                    errorInfo = undefined;
                    reportError(
                        Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1,
                        targetType,
                        generalizedSourceType,
                    );
                }
            }

            if (!message) {
                if (relation === comparableRelation) {
                    message = Diagnostics.Type_0_is_not_comparable_to_type_1;
                }
                else if (sourceType === targetType) {
                    message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
                }
                // else if (exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length) {
                //     message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
                // }
                else {
                    if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.Union) {
                        const suggestedType = getSuggestedTypeForNonexistentStringLiteralType(source as StringLiteralType, target as UnionType);
                        if (suggestedType) {
                            reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType));
                            return;
                        }
                    }
                    message = Diagnostics.Type_0_is_not_assignable_to_type_1;
                }
            }
            // else if (
            //     message === Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
            //     && exactOptionalPropertyTypes
            //     && getExactOptionalUnassignableProperties(source, target).length
            // ) {
            //     message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
            // }

            reportError(message, generalizedSourceType, targetType);
        }

        function reportError(message: DiagnosticMessage, ...args: DiagnosticArguments): void {
            Debug.assert(!!errorNode);
            if (incompatibleStack) reportIncompatibleStack();
            if (message.elidedInCompatabilityPyramid) return;
            if (skipParentCounter === 0) {
                errorInfo = chainDiagnosticMessages(errorInfo, message, ...args);
            }
            else {
                skipParentCounter--;
            }
        }

        /**
         * Try and elaborate array and tuple errors. Returns false
         * if we have found an elaboration, or we should ignore
         * any other elaborations when relating the `source` and
         * `target` types.
         */
        function tryElaborateArrayLikeErrors(source: Type, target: Type, reportErrors: boolean): boolean {
            /**
             * The spec for elaboration is:
             * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
             * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
             * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
             * - If the source an array then skip property elaborations if the target is a tuple.
             */
            if (isTupleType(source)) {
                if (source.target.readonly && isMutableArrayOrTuple(target)) {
                    if (reportErrors) {
                        reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                    }
                    return false;
                }
                return isArrayOrTupleType(target);
            }
            if (isReadonlyArrayType(source) && isMutableArrayOrTuple(target)) {
                if (reportErrors) {
                    reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                }
                return false;
            }
            if (isTupleType(target)) {
                return isArrayType(source);
            }
            return true;
        }

        function tryElaborateErrorsForPrimitivesAndObjects(source: Type, target: Type) {
            const sourceType = symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source);
            const targetType = symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target);

            if (
                (globalStringType === source && stringType === target) ||
                (globalIntType === source && intType === target) ||
                (globalFloatType === source && floatType === target) 
                //(globalBooleanType === source && booleanType === target) ||
                //(getGlobalESSymbolType() === source && esSymbolType === target)
            ) {
                reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
            }
        }


        function reportErrorResults(originalSource: Type, originalTarget: Type, source: Type, target: Type, headMessage: DiagnosticMessage | undefined) {
            const sourceHasBase = !!getSingleBaseForNonAugmentingSubtype(originalSource);
            const targetHasBase = !!getSingleBaseForNonAugmentingSubtype(originalTarget);
            source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source;
            target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target;
            let maybeSuppress = overrideNextErrorInfo > 0;
            if (maybeSuppress) {
                overrideNextErrorInfo--;
            }
            if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
                const currentError = errorInfo;
                tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ true);
                if (errorInfo !== currentError) {
                    maybeSuppress = !!errorInfo;
                }
            }
            if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Primitive) {
                tryElaborateErrorsForPrimitivesAndObjects(source, target);
            }
            else if (source.symbol && source.flags & TypeFlags.Object && globalObjectType === source) {
                reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
            }            
            else {
                errorInfo = elaborateNeverIntersection(errorInfo, originalTarget);
            }
            // Used by, eg, missing property checking to replace the top-level message with a more informative one.
            if (!headMessage && maybeSuppress) {
                // We suppress a call to `reportRelationError` or not depending on the state of the type checker, so
                // we call `reportRelationError` here and then undo its effects to figure out what would be the diagnostic
                // if we hadn't supress it, and save that as a canonical diagnostic for deduplication purposes.
                const savedErrorState = captureErrorCalculationState();
                reportRelationError(headMessage, source, target);
                let canonical;
                if (errorInfo && errorInfo !== savedErrorState.errorInfo) {
                    canonical = { code: errorInfo.code, messageText: errorInfo.messageText };
                }
                resetErrorInfo(savedErrorState);
                if (canonical && errorInfo) {
                    errorInfo.canonicalHead = canonical;
                }

                lastSkippedInfo = [source, target];
                return;
            }
            reportRelationError(headMessage, source, target);
            if (source.flags & TypeFlags.TypeParameter && source.symbol?.declarations?.[0] && !getConstraintOfType(source as TypeVariable)) {
                const syntheticParam = cloneTypeParameter(source as TypeParameter);
                syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam));
                if (hasNonCircularBaseConstraint(syntheticParam)) {
                    const targetConstraintString = typeToString(target, source.symbol.declarations[0]);
                    associateRelatedInfo(createDiagnosticForNode(source.symbol.declarations[0], Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString));
                }
            }
        }

        /**
         * Compare two types and return
         * * Ternary.True if they are related with no assumptions,
         * * Ternary.Maybe if they are related with assumptions of other relationships, or
         * * Ternary.False if they are not related.
         */
        function isRelatedTo(originalSource: Type, originalTarget: Type, recursionFlags: RecursionFlags = RecursionFlags.Both, reportErrors = false, headMessage?: DiagnosticMessage, intersectionState = IntersectionState.None): Ternary {
            if (originalSource === originalTarget) return Ternary.True;

            // Before normalization: if `source` is type an object type, and `target` is primitive,
            // skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
            if (originalSource.flags & TypeFlags.Object && originalTarget.flags & TypeFlags.Primitive) {
                if (
                    relation === comparableRelation && !(originalTarget.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) ||
                    isSimpleTypeRelatedTo(originalSource, originalTarget, relation, reportErrors ? reportError : undefined)
                ) {
                    return Ternary.True;
                }
                if (reportErrors) {
                    reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage);
                }
                return Ternary.False;
            }

            // Normalize the source and target types: Turn fresh literal types into regular literal types,
            // turn deferred type references into regular type references, simplify indexed access and
            // conditional types, and resolve substitution types to either the substitution (on the source
            // side) or the type variable (on the target side).
            const source = getNormalizedType(originalSource, /*writing*/ false);
            let target = getNormalizedType(originalTarget, /*writing*/ true);

            if (source === target) return Ternary.True;

            if (relation === identityRelation) {
                if (source.flags !== target.flags) return Ternary.False;
                if (source.flags & TypeFlags.Singleton) return Ternary.True;
                traceUnionsOrIntersectionsTooLarge(source, target);
                return recursiveTypeRelatedTo(source, target, /*reportErrors*/ false, IntersectionState.None, recursionFlags);
            }

            // We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
            // and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
            // as we break down the _target_ union first, _then_ get the source constraint - so for every
            // member of the target, we attempt to find a match in the source. This avoids that in cases where
            // the target is exactly the constraint.
            if (source.flags & TypeFlags.TypeParameter && getConstraintOfType(source) === target) {
                return Ternary.True;
            }

            // See if we're relating a definitely non-nullable type to a union that includes null and/or undefined
            // plus a single non-nullable type. If so, remove null and/or undefined from the target type.
            if (source.flags & TypeFlags.DefinitelyNonNullable && target.flags & TypeFlags.Union) {
                const types = (target as UnionType).types;
                const candidate = types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] :
                    types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] :
                    undefined;
                if (candidate && !(candidate.flags & TypeFlags.Nullable)) {
                    target = getNormalizedType(candidate, /*writing*/ true);
                    if (source === target) return Ternary.True;
                }
            }

            if (
                relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation) ||
                isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined)
            ) return Ternary.True;

            if (source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable) {
                const isPerformingExcessPropertyChecks = !(intersectionState & IntersectionState.Target) && (isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral);
                if (isPerformingExcessPropertyChecks) {
                    if (hasExcessProperties(source as FreshObjectLiteralType, target, reportErrors)) {
                        if (reportErrors) {
                            reportRelationError(headMessage, source, originalTarget.aliasSymbol ? originalTarget : target);
                        }
                        return Ternary.False;
                    }
                }

                const isPerformingCommonPropertyChecks = (relation !== comparableRelation || isUnitType(source)) &&
                    !(intersectionState & IntersectionState.Target) &&
                    source.flags & (TypeFlags.Primitive | TypeFlags.Object | TypeFlags.Intersection) && source !== globalObjectType &&
                    target.flags & (TypeFlags.Object | TypeFlags.Intersection) && isWeakType(target) &&
                    (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source));                
                if (isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, false)) {
                    if (reportErrors) {
                        const sourceString = typeToString(originalSource.aliasSymbol ? originalSource : source);
                        const targetString = typeToString(originalTarget.aliasSymbol ? originalTarget : target);
                        const calls = getSignaturesOfType(source, SignatureKind.Call);
                        const constructs = getSignaturesOfType(source, SignatureKind.Construct);
                        if (
                            calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, RecursionFlags.Source, /*reportErrors*/ false) ||
                            constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, RecursionFlags.Source, /*reportErrors*/ false)
                        ) {
                            reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString);
                        }
                        else {
                            reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString);
                        }
                    }
                    return Ternary.False;
                }

                traceUnionsOrIntersectionsTooLarge(source, target);

                const skipCaching = source.flags & TypeFlags.Union && (source as UnionType).types.length < 4 && !(target.flags & TypeFlags.Union) ||
                    target.flags & TypeFlags.Union && (target as UnionType).types.length < 4 && !(source.flags & TypeFlags.StructuredOrInstantiable);
                const result = skipCaching ?
                    unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :
                    recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags);
                if (result) {
                    return result;
                }
            }

            if (reportErrors) {
                reportErrorResults(originalSource, originalTarget, source, target, headMessage);
            }
            return Ternary.False;
        }

        function someTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const sourceTypes = source.types;
            if (source.flags & TypeFlags.Union && containsType(sourceTypes, target)) {
                return Ternary.True;
            }
            const len = sourceTypes.length;
            for (let i = 0; i < len; i++) {
                const related = isRelatedTo(sourceTypes[i], target, RecursionFlags.Source, reportErrors && i === len - 1, /*headMessage*/ undefined, intersectionState);
                if (related) {
                    return related;
                }
            }
            return Ternary.False;
        }

        function getUndefinedStrippedTargetIfNeeded(source: Type, target: Type) {
            if (
                source.flags & TypeFlags.Union && target.flags & TypeFlags.Union &&
                !((source as UnionType).types[0].flags & TypeFlags.Undefined) && (target as UnionType).types[0].flags & TypeFlags.Undefined
            ) {
                return extractTypesOfKind(target, ~TypeFlags.Undefined);
            }
            return target;
        }

        function eachTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            let result = Ternary.True;
            const sourceTypes = source.types;
            // We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
            // since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
            const undefinedStrippedTarget = getUndefinedStrippedTargetIfNeeded(source, target as UnionType);
            for (let i = 0; i < sourceTypes.length; i++) {
                const sourceType = sourceTypes[i];
                if (undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= (undefinedStrippedTarget as UnionType).types.length && sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length === 0) {
                    // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
                    // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
                    // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
                    // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
                    // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
                    const related = isRelatedTo(sourceType, (undefinedStrippedTarget as UnionType).types[i % (undefinedStrippedTarget as UnionType).types.length], RecursionFlags.Both, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                    if (related) {
                        result &= related;
                        continue;
                    }
                }
                const related = isRelatedTo(sourceType, target, RecursionFlags.Source, reportErrors, /*headMessage*/ undefined, intersectionState);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function typeRelatedToSomeType(source: Type, target: UnionOrIntersectionType, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const targetTypes = target.types;
            if (target.flags & TypeFlags.Union) {
                if (containsType(targetTypes, source)) {
                    return Ternary.True;
                }
                if (
                    relation !== comparableRelation && getObjectFlags(target) & ObjectFlags.PrimitiveUnion && !(source.flags & TypeFlags.EnumLiteral) && (
                        source.flags & (TypeFlags.StringLiteral | TypeFlags.IntLiteral | TypeFlags.FloatLiteral) ||
                        (relation === subtypeRelation || relation === strictSubtypeRelation) && source.flags & TypeFlags.IntLiteral
                    )
                ) {
                    // When relating a literal type to a union of primitive types, we know the relation is false unless
                    // the union contains the base primitive type or the literal type in one of its fresh/regular forms.
                    // We exclude numeric literals for non-subtype relations because numeric literals are assignable to
                    // numeric enum literals with the same value. Similarly, we exclude enum literal types because
                    // identically named enum types are related (see isEnumTypeRelatedTo). We exclude the comparable
                    // relation in entirety because it needs to be checked in both directions.
                    const alternateForm = source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType;
                    const primitive = source.flags & TypeFlags.StringLiteral ? stringType :
                        source.flags & TypeFlags.IntLiteral ? intType :
                        source.flags & TypeFlags.FloatLiteral ? floatType :
                        source.flags & TypeFlags.Bytes ? bytesType :
                        undefined;
                    return primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm) ? Ternary.True : Ternary.False;
                }
                const match = getMatchingUnionConstituentForType(target as UnionType, source);
                if (match) {
                    const related = isRelatedTo(source, match, RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                    if (related) {
                        return related;
                    }
                }
            }
            for (const type of targetTypes) {
                const related = isRelatedTo(source, type, RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                if (related) {
                    return related;
                }
            }
            if (reportErrors) {
                // Elaborate only if we can find a best matching type in the target union
                const bestMatchingType = getBestMatchingType(source, target, isRelatedTo);
                if (bestMatchingType) {
                    isRelatedTo(source, bestMatchingType, RecursionFlags.Target, /*reportErrors*/ true, /*headMessage*/ undefined, intersectionState);
                }
            }
            return Ternary.False;
        }

        function unionOrIntersectionRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            // Note that these checks are specifically ordered to produce correct results. In particular,
            // we need to deconstruct unions before intersections (because unions are always at the top),
            // and we need to handle "each" relations before "some" relations for the same kind of type.
            if (source.flags & TypeFlags.Union) {
                if (target.flags & TypeFlags.Union) {
                    // Intersections of union types are normalized into unions of intersection types, and such normalized
                    // unions can get very large and expensive to relate. The following fast path checks if the source union
                    // originated in an intersection. If so, and if that intersection contains the target type, then we know
                    // the result to be true (for any two types A and B, A & B is related to both A and B).
                    const sourceOrigin = (source as UnionType).origin;
                    if (sourceOrigin && sourceOrigin.flags & TypeFlags.Intersection && target.aliasSymbol && contains((sourceOrigin as IntersectionType).types, target)) {
                        return Ternary.True;
                    }
                    // Similarly, in unions of unions the we preserve the original list of unions. This original list is often
                    // much shorter than the normalized result, so we scan it in the following fast path.
                    const targetOrigin = (target as UnionType).origin;
                    if (targetOrigin && targetOrigin.flags & TypeFlags.Union && source.aliasSymbol && contains((targetOrigin as UnionType).types, source)) {
                        return Ternary.True;
                    }
                }
                return relation === comparableRelation ?
                    someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) :
                    eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState);
            }
            if (target.flags & TypeFlags.Union) {
                return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target as UnionType, reportErrors && !(source.flags & TypeFlags.Primitive) && !(target.flags & TypeFlags.Primitive), intersectionState);
            }
            if (target.flags & TypeFlags.Intersection) {
                return typeRelatedToEachType(source, target as IntersectionType, reportErrors, IntersectionState.Target);
            }
            // Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
            // constraints of all non-primitive types in the source into a new intersection. We do this because the
            // intersection may further constrain the constraints of the non-primitive types. For example, given a type
            // parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
            // appear to be comparable to '2'.
            if (relation === comparableRelation && target.flags & TypeFlags.Primitive) {
                const constraints = sameMap((source as IntersectionType).types, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(t) || unknownType : t);
                if (constraints !== (source as IntersectionType).types) {
                    source = getIntersectionType(constraints);
                    if (source.flags & TypeFlags.Never) {
                        return Ternary.False;
                    }
                    if (!(source.flags & TypeFlags.Intersection)) {
                        return isRelatedTo(source, target, RecursionFlags.Source, /*reportErrors*/ false) ||
                            isRelatedTo(target, source, RecursionFlags.Source, /*reportErrors*/ false);
                    }
                }
            }
            // Check to see if any constituents of the intersection are immediately related to the target.
            // Don't report errors though. Elaborating on whether a source constituent is related to the target is
            // not actually useful and leads to some confusing error messages. Instead, we rely on the caller
            // checking whether the full intersection viewed as an object is related to the target.
            return someTypeRelatedToType(source as IntersectionType, target, /*reportErrors*/ false, IntersectionState.Source);            
        }

        function typeRelatedToEachType(source: Type, target: IntersectionType, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            let result = Ternary.True;
            const targetTypes = target.types;
            for (const targetType of targetTypes) {
                const related = isRelatedTo(source, targetType, RecursionFlags.Target, reportErrors, /*headMessage*/ undefined, intersectionState);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function shouldCheckAsExcessProperty(prop: Symbol, container: Symbol) {
            return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration;
        }

        function reportParentSkippedError(message: DiagnosticMessage, ...args: DiagnosticArguments): void {
            reportError(message, ...args);
            skipParentCounter++;
        }

        function hasExcessProperties(source: FreshObjectLiteralType, target: Type, reportErrors: boolean): boolean {
            if (!isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target) & ObjectFlags.JSLiteral) {
                return false; // Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
            }            
            if (
                (relation === assignableRelation || relation === comparableRelation) &&
                (isTypeSubsetOf(globalObjectType, target) || (isEmptyObjectType(target)))
            ) {
                return false;
            }
            let reducedTarget = target;
            let checkTypes: Type[] | undefined;
            if (target.flags & TypeFlags.Union) {
                reducedTarget = findMatchingDiscriminantType(source, target as UnionType, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target as UnionType);
                checkTypes = reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget];
            }
            for (const prop of getPropertiesOfType(source)) {
                if (shouldCheckAsExcessProperty(prop, source.symbol)) {
                    if (!isKnownProperty(reducedTarget, prop.name, false)) {
                        if (reportErrors) {
                            // Report error in terms of object types in the target as those are the only ones
                            // we check in isKnownProperty.
                            const errorTarget = filterType(reducedTarget, isExcessPropertyCheckTarget);
                            // We know *exactly* where things went wrong when comparing the types.
                            // Use this property as the error node as this will be more helpful in
                            // reasoning about what went wrong.
                            if (!errorNode) return Debug.fail();
                            
                            
                            // use the property's value declaration if the property is assigned inside the literal itself
                            const objectLiteralDeclaration = source.symbol?.declarations && firstOrUndefined(source.symbol.declarations);
                            let suggestion: string | undefined;
                            if (prop.valueDeclaration && findAncestor(prop.valueDeclaration, d => d === objectLiteralDeclaration) && getSourceFileOfNode(objectLiteralDeclaration) === getSourceFileOfNode(errorNode)) {
                                const propDeclaration = prop.valueDeclaration as ObjectLiteralElementLike;
                                //Debug.assertNode(propDeclaration, isObjectLiteralElementLike);

                                const name = propDeclaration.name!;
                                errorNode = name;

                                if (isIdentifier(name)) {
                                    suggestion = getSuggestionForNonexistentProperty(name, errorTarget);
                                }
                            }
                            if (suggestion !== undefined) {
                                reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion);
                            }
                            else {
                                reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget));
                            }
                        
                        }
                        return true;
                    }
                    if (checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.name), RecursionFlags.Both, reportErrors)) {
                        if (reportErrors) {
                            reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop));
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        function getTypeOfPropertyInTypes(types: Type[], name: string) {
            const appendPropType = (propTypes: Type[] | undefined, type: Type) => {
                type = getApparentType(type);
                const prop = type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name);
                const propType = prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type, name)?.type || undefinedType;
                return append(propTypes, propType);
            };
            return getUnionType(reduceLeft(types, appendPropType, /*initial*/ undefined) || emptyArray);
        }

        function excludeProperties(properties: Symbol[], excludedProperties: Set<string> | undefined) {
            if (!excludedProperties || properties.length === 0) return properties;
            let result: Symbol[] | undefined;
            for (let i = 0; i < properties.length; i++) {
                if (!excludedProperties.has(properties[i].name)) {
                    if (result) {
                        result.push(properties[i]);
                    }
                }
                else if (!result) {
                    result = properties.slice(0, i);
                }
            }
            return result || properties;
        }

        function propertiesIdenticalTo(source: Type, target: Type, excludedProperties: Set<string> | undefined): Ternary {
            if (!(source.flags & TypeFlags.Object && target.flags & TypeFlags.Object)) {
                return Ternary.False;
            }
            const sourceProperties = excludeProperties(getPropertiesOfObjectType(source), excludedProperties);
            const targetProperties = excludeProperties(getPropertiesOfObjectType(target), excludedProperties);
            if (sourceProperties.length !== targetProperties.length) {
                return Ternary.False;
            }
            let result = Ternary.True;
            for (const sourceProp of sourceProperties) {
                const targetProp = getPropertyOfObjectType(target, sourceProp.name);
                if (!targetProp) {
                    return Ternary.False;
                }
                const related = compareProperties(sourceProp, targetProp, isRelatedTo);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function reportIncompatibleError(message: DiagnosticMessage, ...args: DiagnosticArguments) {
            overrideNextErrorInfo++; // Suppress the next relation error
            lastSkippedInfo = undefined; // Reset skipped info cache
            (incompatibleStack ||= []).push([message, ...args]);
        }

        function shouldReportUnmatchedPropertyError(source: Type, target: Type): boolean {
            const typeCallSignatures = getSignaturesOfStructuredType(source, SignatureKind.Call);
            const typeConstructSignatures = getSignaturesOfStructuredType(source, SignatureKind.Construct);
            const typeProperties = getPropertiesOfObjectType(source);
            if (typeProperties && (typeCallSignatures?.length || typeConstructSignatures?.length) && !typeProperties.length) {
                if (
                    (getSignaturesOfType(target, SignatureKind.Call).length && typeCallSignatures.length) ||
                    (getSignaturesOfType(target, SignatureKind.Construct).length && typeConstructSignatures.length)
                ) {
                    return true; // target has similar signature kinds to source, still focus on the unmatched property
                }
                return false;
            }
            return true;
        }
        
        function associateRelatedInfo(info: DiagnosticRelatedInformation) {
            Debug.assert(!!errorInfo);
            if (!relatedInfo) {
                relatedInfo = [info];
            }
            else {
                relatedInfo.push(info);
            }
        }
        
        function reportUnmatchedProperty(source: Type, target: Type, unmatchedProperty: Symbol, requireOptionalProperties: boolean) {
            let shouldSkipElaboration = false;           
            const props = arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, /*matchDiscriminantProperties*/ false));
            if (
                !headMessage || (headMessage.code !== Diagnostics.Class_0_incorrectly_implements_interface_1.code &&
                    headMessage.code !== Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code)
            ) {
                shouldSkipElaboration = true; // Retain top-level error for interface implementing issues, otherwise omit it
            }
            if (props.length === 1) {
                const propName = symbolToString(unmatchedProperty, /*enclosingDeclaration*/ undefined, SymbolFlags.None, SymbolFormatFlags.AllowAnyNodeKind | SymbolFormatFlags.WriteComputedProps);
                reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, ...getTypeNamesForErrorDisplay(source, target));
                if (length(unmatchedProperty.declarations)) {
                    associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations![0], Diagnostics._0_is_declared_here, propName));
                }
                if (shouldSkipElaboration && errorInfo) {
                    overrideNextErrorInfo++;
                }
            }
            else if (tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ false)) {
                if (props.length > 5) { // arbitrary cutoff for too-long list form
                    reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map(props.slice(0, 4), p => symbolToString(p)).join(", "), props.length - 4);
                }
                else {
                    reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map(props, p => symbolToString(p)).join(", "));
                }
                if (shouldSkipElaboration && errorInfo) {
                    overrideNextErrorInfo++;
                }
            }
            // No array like or unmatched property error - just issue top level error (errorInfo = undefined)
        }

        function isPropertySymbolTypeRelated(sourceProp: Symbol, targetProp: Symbol, getTypeOfSourceProperty: (sym: Symbol) => Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const targetIsOptional = strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlags.Partial);
            const effectiveTarget = addOptionality(getNonMissingTypeOfSymbol(targetProp), /*isProperty*/ false, targetIsOptional);
            const effectiveSource = getTypeOfSourceProperty(sourceProp);
            return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
        }

        function propertyRelatedTo(source: Type, target: Type, sourceProp: Symbol, targetProp: Symbol, getTypeOfSourceProperty: (sym: Symbol) => Type, reportErrors: boolean, intersectionState: IntersectionState, skipOptional: boolean): Ternary {
            const sourcePropFlags = getDeclarationModifierFlagsFromSymbol(sourceProp);
            const targetPropFlags = getDeclarationModifierFlagsFromSymbol(targetProp);
            if (sourcePropFlags & ModifierFlags.Private || targetPropFlags & ModifierFlags.Private) {
                if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                    if (reportErrors) {
                        if (sourcePropFlags & ModifierFlags.Private && targetPropFlags & ModifierFlags.Private) {
                            reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                        }
                        else {
                            reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourcePropFlags & ModifierFlags.Private ? source : target), typeToString(sourcePropFlags & ModifierFlags.Private ? target : source));
                        }
                    }
                    return Ternary.False;
                }
            }
            else if (targetPropFlags & ModifierFlags.Protected) {
                if (!isValidOverrideOf(sourceProp, targetProp)) {
                    if (reportErrors) {
                        reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target));
                    }
                    return Ternary.False;
                }
            }
            else if (sourcePropFlags & ModifierFlags.Protected) {
                if (reportErrors) {
                    reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                }
                return Ternary.False;
            }

            // Ensure {readonly a: whatever} is not a subtype of {a: whatever},
            // while {a: whatever} is a subtype of {readonly a: whatever}.
            // This ensures the subtype relationship is ordered, and preventing declaration order
            // from deciding which type "wins" in union subtype reduction.
            // They're still assignable to one another, since `readonly` doesn't affect assignability.
            // This is only applied during the strictSubtypeRelation -- currently used in subtype reduction
            if (
                relation === strictSubtypeRelation &&
                isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp)
            ) {
                return Ternary.False;
            }
            // If the target comes from a partial union prop, allow `undefined` in the target type
            const related = isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState);
            if (!related) {
                if (reportErrors) {
                    reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));
                }
                return Ternary.False;
            }
            // When checking for comparability, be more lenient with optional properties.
            if (!skipOptional && sourceProp.flags & SymbolFlags.Optional && targetProp.flags & SymbolFlags.ClassMember && !(targetProp.flags & SymbolFlags.Optional)) {
                // TypeScript 1.0 spec (April 2014): 3.8.3
                // S is a subtype of a type T, and T is a supertype of S if ...
                // S' and T are object types and, for each member M in T..
                // M is a property and S' contains a property N where
                // if M is a required property, N is also a required property
                // (M - property in T)
                // (N - property in S)
                if (reportErrors) {
                    reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                }
                return Ternary.False;
            }
            return related;
        }

        function propertiesRelatedTo(source: Type, target: Type, reportErrors: boolean, excludedProperties: Set<string> | undefined, optionalsOnly: boolean, intersectionState: IntersectionState): Ternary {
            if (relation === identityRelation) {
                return propertiesIdenticalTo(source, target, excludedProperties);
            }
            let result = Ternary.True;
            if (isTupleType(target)) {
                if (isArrayOrTupleType(source)) {
                    if (!target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly)) {
                        return Ternary.False;
                    }
                    const sourceArity = getTypeReferenceArity(source);
                    const targetArity = getTypeReferenceArity(target);
                    const sourceRestFlag = isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest;
                    const targetRestFlag = target.target.combinedFlags & ElementFlags.Rest;
                    const sourceMinLength = isTupleType(source) ? source.target.minLength : 0;
                    const targetMinLength = target.target.minLength;
                    if (!sourceRestFlag && sourceArity < targetMinLength) {
                        if (reportErrors) {
                            reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength);
                        }
                        return Ternary.False;
                    }
                    if (!targetRestFlag && targetArity < sourceMinLength) {
                        if (reportErrors) {
                            reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity);
                        }
                        return Ternary.False;
                    }
                    if (!targetRestFlag && (sourceRestFlag || targetArity < sourceArity)) {
                        if (reportErrors) {
                            if (sourceMinLength < targetMinLength) {
                                reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength);
                            }
                            else {
                                reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity);
                            }
                        }
                        return Ternary.False;
                    }
                    const sourceTypeArguments = getTypeArguments(source);
                    const targetTypeArguments = getTypeArguments(target);
                    const targetStartCount = getStartElementCount(target.target, ElementFlags.NonRest);
                    const targetEndCount = getEndElementCount(target.target, ElementFlags.NonRest);
                    const targetHasRestElement = target.target.hasRestElement;
                    let canExcludeDiscriminants = !!excludedProperties;
                    for (let sourcePosition = 0; sourcePosition < sourceArity; sourcePosition++) {
                        const sourceFlags = isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest;
                        const sourcePositionFromEnd = sourceArity - 1 - sourcePosition;

                        const targetPosition = targetHasRestElement && sourcePosition >= targetStartCount
                            ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)
                            : sourcePosition;

                        const targetFlags = target.target.elementFlags[targetPosition];

                        if (targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition);
                            }
                            return Ternary.False;
                        }
                        if (sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition);
                            }
                            return Ternary.False;
                        }
                        if (targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition);
                            }
                            return Ternary.False;
                        }
                        // We can only exclude discriminant properties if we have not yet encountered a variable-length element.
                        if (canExcludeDiscriminants) {
                            if (sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable) {
                                canExcludeDiscriminants = false;
                            }
                            if (canExcludeDiscriminants && excludedProperties?.has(("" + sourcePosition) as string)) {
                                continue;
                            }
                        }

                        const sourceType = removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlags.Optional));
                        const targetType = targetTypeArguments[targetPosition];

                        const targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) :
                            removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional));
                        const related = isRelatedTo(sourceType, targetCheckType, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        if (!related) {
                            if (reportErrors && (targetArity > 1 || sourceArity > 1)) {
                                if (targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount !== sourceArity - targetEndCount - 1) {
                                    reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity - targetEndCount - 1, targetPosition);
                                }
                                else {
                                    reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition);
                                }
                            }
                            return Ternary.False;
                        }
                        result &= related;
                    }
                    return result;
                }
                if (target.target.combinedFlags & ElementFlags.Variable) {
                    return Ternary.False;
                }
            }
            const requireOptionalProperties = (relation === subtypeRelation || relation === strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source);
            const unmatchedProperty = getUnmatchedProperty(source, target, requireOptionalProperties, /*matchDiscriminantProperties*/ false);
            if (unmatchedProperty) {
                if (reportErrors && shouldReportUnmatchedPropertyError(source, target)) {
                    reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties);
                }
                return Ternary.False;
            }
            if (isObjectLiteralType(target)) {
                for (const sourceProp of excludeProperties(getPropertiesOfType(source), excludedProperties)) {
                    if (!getPropertyOfObjectType(target, sourceProp.name)) {
                        const sourceType = getTypeOfSymbol(sourceProp);
                        if (!(sourceType.flags & TypeFlags.Undefined)) {
                            if (reportErrors) {
                                reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target));
                            }
                            return Ternary.False;
                        }
                    }
                }
            }
            // We only call this for union target types when we're attempting to do excess property checking - in those cases, we want to get _all possible props_
            // from the target union, across all members
            const properties = getPropertiesOfType(target);
            const numericNamesOnly = isTupleType(source) && isTupleType(target);
            for (const targetProp of excludeProperties(properties, excludedProperties)) {
                const name = targetProp.name;
                if (!(targetProp.flags & SymbolFlags.Prototype) && (!numericNamesOnly || isNumericLiteralName(name) || name === "length") && (!optionalsOnly || targetProp.flags & SymbolFlags.Optional)) {
                    const sourceProp = getPropertyOfType(source, name);
                    if (sourceProp && sourceProp !== targetProp) {
                        const related = propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation === comparableRelation);
                        if (!related) {
                            return Ternary.False;
                        }
                        result &= related;
                    }
                }
            }
            return result;
        }

        function indexSignaturesIdenticalTo(source: Type, target: Type): Ternary {
            const sourceInfos = getIndexInfosOfType(source);
            const targetInfos = getIndexInfosOfType(target);
            if (sourceInfos.length !== targetInfos.length) {
                return Ternary.False;
            }
            for (const targetInfo of targetInfos) {
                const sourceInfo = getIndexInfoOfType(source, targetInfo.keyType);
                if (!(sourceInfo && isRelatedTo(sourceInfo.type, targetInfo.type, RecursionFlags.Both) && sourceInfo.isReadonly === targetInfo.isReadonly)) {
                    return Ternary.False;
                }
            }
            return Ternary.True;
        }

        function indexSignaturesRelatedTo(source: Type, target: Type, sourceIsPrimitive: boolean, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            if (relation === identityRelation) {
                return indexSignaturesIdenticalTo(source, target);
            }
            const indexInfos = getIndexInfosOfType(target);
            const targetHasStringIndex = some(indexInfos, info => info.keyType === stringType);
            let result = Ternary.True;
            for (const targetInfo of indexInfos) {
                const related = relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True :
                    isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) :
                    typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function getTemplateTypeFromMappedType(type: MappedType) {
            return type.templateType ||
                (type.templateType = type.declaration.type ?
                    instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty*/ true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :
                    errorType);
        }

        function typeRelatedToIndexInfo(source: Type, targetInfo: IndexInfo, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
            if (sourceInfo) {
                return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState);
            }
            // Intersection constituents are never considered to have an inferred index signature. Also, in the strict subtype relation,
            // only fresh object literals are considered to have inferred index signatures. This ensures { [x: string]: xxx } <: {} but
            // not vice-versa. Without this rule, those types would be mutual strict subtypes.
            if (!(intersectionState & IntersectionState.Source) && (relation !== strictSubtypeRelation || getObjectFlags(source) & ObjectFlags.FreshLiteral) && isObjectTypeWithInferableIndex(source)) {
                return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState);
            }
            if (reportErrors) {
                reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source));
            }
            return Ternary.False;
        }

        function indexInfoRelatedTo(sourceInfo: IndexInfo, targetInfo: IndexInfo, reportErrors: boolean, intersectionState: IntersectionState) {
            const related = isRelatedTo(sourceInfo.type, targetInfo.type, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
            if (!related && reportErrors) {
                if (sourceInfo.keyType === targetInfo.keyType) {
                    reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType));
                }
                else {
                    reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType));
                }
            }
            return related;
        }

        function getLiteralTypeFromProperty(prop: Symbol, include: TypeFlags, includeNonPublic?: boolean) {
            if (includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier)) {
                let type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
                if (!type) {
                    const name = getNameOfDeclaration(prop.valueDeclaration) as PropertyName;
                    type = prop.name === InternalSymbolName.Default ? getStringLiteralType("default") :
                        name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined);
                }
                if (type && type.flags & include) {
                    return type;
                }
            }
            return neverType;
        }

        function membersRelatedToIndexInfo(source: Type, targetInfo: IndexInfo, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            let result = Ternary.True;
            const keyType = targetInfo.keyType;
            const props = source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source);
            for (const prop of props) {
                // Skip over ignored JSX and symbol-named members                
                if (isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), keyType)) {
                    const propType = getNonMissingTypeOfSymbol(prop);
                    const type = exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional)
                        ? propType
                        : getTypeWithFacts(propType, TypeFacts.NEUndefined);
                    const related = isRelatedTo(type, targetInfo.type, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                    if (!related) {
                        if (reportErrors) {
                            reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));
                        }
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            for (const info of getIndexInfosOfType(source)) {
                if (isApplicableIndexType(info.keyType, keyType)) {
                    const related = indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState);
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            return result;
        }

        function structuredTypeRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            const saveErrorInfo = captureErrorCalculationState();
            let result = structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo);
            if (relation !== identityRelation) {
                // The combined constraint of an intersection type is the intersection of the constraints of
                // the constituents. When an intersection type contains instantiable types with union type
                // constraints, there are situations where we need to examine the combined constraint. One is
                // when the target is a union type. Another is when the intersection contains types belonging
                // to one of the disjoint domains. For example, given type variables T and U, each with the
                // constraint 'string | number', the combined constraint of 'T & U' is 'string | number' and
                // we need to check this constraint against a union on the target side. Also, given a type
                // variable V constrained to 'string | number', 'V & number' has a combined constraint of
                // 'string & number | number & number' which reduces to just 'number'.
                // This also handles type parameters, as a type parameter with a union constraint compared against a union
                // needs to have its constraint hoisted into an intersection with said type parameter, this way
                // the type param can be compared with itself in the target (with the influence of its constraint to match other parts)
                // For example, if `T extends 1 | 2` and `U extends 2 | 3` and we compare `T & U` to `T & U & (1 | 2 | 3)`
                if (!result && (source.flags & TypeFlags.Intersection || source.flags & TypeFlags.TypeParameter && target.flags & TypeFlags.Union)) {
                    const constraint = getEffectiveConstraintOfIntersection(source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source], !!(target.flags & TypeFlags.Union));
                    if (constraint && everyType(constraint, c => c !== source)) { // Skip comparison if expansion contains the source itself
                        // TODO: Stack errors so we get a pyramid for the "normal" comparison above, _and_ a second for this
                        result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                    }
                }
                // When the target is an intersection we need an extra property check in order to detect nested excess
                // properties and nested weak types. The following are motivating examples that all should be errors, but
                // aren't without this extra property check:
                //
                //   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
                //
                //   declare let wrong: { a: { y: string } };
                //   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
                //
                if (
                    result && !(intersectionState & IntersectionState.Target) && target.flags & TypeFlags.Intersection &&
                    !isGenericObjectType(target) && source.flags & (TypeFlags.Object | TypeFlags.Intersection)
                ) {
                    result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties*/ undefined, /*optionalsOnly*/ false, IntersectionState.None);
                    if (result && isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral) {
                        result &= indexSignaturesRelatedTo(source, target, /*sourceIsPrimitive*/ false, reportErrors, IntersectionState.None);
                    }
                }
                // When the source is an intersection we need an extra check of any optional properties in the target to
                // detect possible mismatched property types. For example:
                //
                //   function foo<T extends object>(x: { a?: string }, y: T & { a: boolean }) {
                //     x = y;  // Mismatched property in source intersection
                //   }
                //
                else if (
                    result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) &&
                    source.flags & TypeFlags.Intersection && getApparentType(source).flags & TypeFlags.StructuredType &&
                    !some((source as IntersectionType).types, t => t === target || !!(getObjectFlags(t) & ObjectFlags.NonInferrableType))
                ) {
                    result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties*/ undefined, /*optionalsOnly*/ true, intersectionState);
                }
            }
            if (result) {
                resetErrorInfo(saveErrorInfo);
            }
            return result;
        }

        function eachTypeRelatedToSomeType(source: UnionOrIntersectionType, target: UnionOrIntersectionType): Ternary {
            let result = Ternary.True;
            const sourceTypes = source.types;
            for (const sourceType of sourceTypes) {
                const related = typeRelatedToSomeType(sourceType, target, /*reportErrors*/ false, IntersectionState.None);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        // A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
        // related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
        // that S and T are contra-variant whereas X and Y are co-variant.
        function mappedTypeRelatedTo(source: MappedType, target: MappedType, reportErrors: boolean): Ternary {
            const modifiersRelated = relation === comparableRelation || (relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :
                getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target));
            if (modifiersRelated) {
                let result: Ternary;
                const targetConstraint = getConstraintTypeFromMappedType(target);
                const sourceConstraint = instantiateType(getConstraintTypeFromMappedType(source), getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper);
                if (result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors)) {
                    const mapper = createTypeMapper([getTypeParameterFromMappedType(source)], [getTypeParameterFromMappedType(target)]);
                    if (instantiateType(getNameTypeFromMappedType(source), mapper) === instantiateType(getNameTypeFromMappedType(target), mapper)) {
                        return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlags.Both, reportErrors);
                    }
                }
            }
            return Ternary.False;
        }

        function signaturesIdenticalTo(source: Type, target: Type, kind: SignatureKind): Ternary {
            const sourceSignatures = getSignaturesOfType(source, kind);
            const targetSignatures = getSignaturesOfType(target, kind);
            if (sourceSignatures.length !== targetSignatures.length) {
                return Ternary.False;
            }
            let result = Ternary.True;
            for (let i = 0; i < sourceSignatures.length; i++) {
                const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, isRelatedTo);
                if (!related) {
                    return Ternary.False;
                }
                result &= related;
            }
            return result;
        }

        function reportIncompatibleCallSignatureReturn(siga: Signature, sigb: Signature) {
            if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
                return (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target));
            }
            return (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target));
        }

        /**
         * See signatureAssignableTo, compareSignaturesIdentical
         */
        function signatureRelatedTo(source: Signature, target: Signature, erase: boolean, reportErrors: boolean, intersectionState: IntersectionState, incompatibleReporter: (source: Type, target: Type) => void): Ternary {
            const checkMode = relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature :
                relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity :
                SignatureCheckMode.None;
            return compareSignaturesRelated(erase ? getErasedSignature(source) : source, erase ? getErasedSignature(target) : target, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper);
            function isRelatedToWorker(source: Type, target: Type, reportErrors?: boolean) {
                return isRelatedTo(source, target, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
            }
        }

        function signaturesRelatedTo(source: Type, target: Type, kind: SignatureKind, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            if (relation === identityRelation) {
                return signaturesIdenticalTo(source, target, kind);
            }
            if (target === anyFunctionType || source === anyFunctionType) {
                return Ternary.True;
            }

            const sourceIsJSConstructor = false;//source.symbol && isJSConstructor(source.symbol.valueDeclaration);
            const targetIsJSConstructor = false;// target.symbol && isJSConstructor(target.symbol.valueDeclaration);

            const sourceSignatures = getSignaturesOfType(
                source,
                (sourceIsJSConstructor && kind === SignatureKind.Construct) ?
                    SignatureKind.Call : kind,
            );
            const targetSignatures = getSignaturesOfType(
                target,
                (targetIsJSConstructor && kind === SignatureKind.Construct) ?
                    SignatureKind.Call : kind,
            );

            if (kind === SignatureKind.Construct && sourceSignatures.length && targetSignatures.length) {
                console.debug("todo - constructor")
                // const sourceIsAbstract = !!(sourceSignatures[0].flags & SignatureFlags.Abstract);
                // const targetIsAbstract = !!(targetSignatures[0].flags & SignatureFlags.Abstract);
                // if (sourceIsAbstract && !targetIsAbstract) {
                //     // An abstract constructor type is not assignable to a non-abstract constructor type
                //     // as it would otherwise be possible to new an abstract class. Note that the assignability
                //     // check we perform for an extends clause excludes construct signatures from the target,
                //     // so this check never proceeds.
                //     if (reportErrors) {
                //         reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
                //     }
                //     return Ternary.False;
                // }
                // if (!constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors)) {
                //     return Ternary.False;
                // }
            }

            let result = Ternary.True;
            // const incompatibleReporter = kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn;
            const incompatibleReporter = reportIncompatibleCallSignatureReturn;
            const sourceObjectFlags = getObjectFlags(source);
            const targetObjectFlags = getObjectFlags(target);
            if (
                sourceObjectFlags & ObjectFlags.Instantiated && targetObjectFlags & ObjectFlags.Instantiated && source.symbol === target.symbol ||
                sourceObjectFlags & ObjectFlags.Reference && targetObjectFlags & ObjectFlags.Reference && (source as TypeReference).target === (target as TypeReference).target
            ) {
                // We have instantiations of the same anonymous type (which typically will be the type of a
                // method). Simply do a pairwise comparison of the signatures in the two signature lists instead
                // of the much more expensive N * M comparison matrix we explore below. We erase type parameters
                // as they are known to always be the same.
                Debug.assertEqual(sourceSignatures.length, targetSignatures.length);
                for (let i = 0; i < targetSignatures.length; i++) {
                    const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase*/ true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            else if (sourceSignatures.length === 1 && targetSignatures.length === 1) {
                // For simple functions (functions with a single signature) we only erase type parameters for
                // the comparable relation. Otherwise, if the source signature is generic, we instantiate it
                // in the context of the target signature before checking the relationship. Ideally we'd do
                // this regardless of the number of signatures, but the potential costs are prohibitive due
                // to the quadratic nature of the logic below.
                const eraseGenerics = relation === comparableRelation;
                const sourceSignature = first(sourceSignatures);
                const targetSignature = first(targetSignatures);
                result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature));
                // if (
                //     !result && reportErrors && kind === SignatureKind.Construct && (sourceObjectFlags & targetObjectFlags) &&
                //     (targetSignature.declaration?.kind === SyntaxKind.Constructor || sourceSignature.declaration?.kind === SyntaxKind.Constructor)
                // ) {
                //     const constructSignatureToString = (signature: Signature) => signatureToString(signature, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrowStyleSignature, kind);
                //     reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature));
                //     reportError(Diagnostics.Types_of_construct_signatures_are_incompatible);
                //     return result;
                // }
            }
            else {
                outer:
                for (const t of targetSignatures) {
                    const saveErrorInfo = captureErrorCalculationState();
                    // Only elaborate errors from the first failure
                    let shouldElaborateErrors = reportErrors;
                    for (const s of sourceSignatures) {
                        const related = signatureRelatedTo(s, t, /*erase*/ true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t));
                        if (related) {
                            result &= related;
                            resetErrorInfo(saveErrorInfo);
                            continue outer;
                        }
                        shouldElaborateErrors = false;
                    }
                    if (shouldElaborateErrors) {
                        reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration*/ undefined, /*flags*/ undefined, kind));
                    }
                    return Ternary.False;
                }
            }
            return result;
        }

        function typeRelatedToDiscriminatedType(source: Type, target: UnionType) {
            // 1. Generate the combinations of discriminant properties & types 'source' can satisfy.
            //    a. If the number of combinations is above a set limit, the comparison is too complex.
            // 2. Filter 'target' to the subset of types whose discriminants exist in the matrix.
            //    a. If 'target' does not satisfy all discriminants in the matrix, 'source' is not related.
            // 3. For each type in the filtered 'target', determine if all non-discriminant properties of
            //    'target' are related to a property in 'source'.
            //
            // NOTE: See ~/tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts
            //       for examples.

            const sourceProperties = getPropertiesOfType(source);
            const sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
            if (!sourcePropertiesFiltered) return Ternary.False;

            // Though we could compute the number of combinations as we generate
            // the matrix, this would incur additional memory overhead due to
            // array allocations. To reduce this overhead, we first compute
            // the number of combinations to ensure we will not surpass our
            // fixed limit before incurring the cost of any allocations:
            let numCombinations = 1;
            for (const sourceProperty of sourcePropertiesFiltered) {
                numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty));
                if (numCombinations > 25) {
                    // We've reached the complexity limit.
                    tracing?.instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit", { sourceId: source.id, targetId: target.id, numCombinations });
                    return Ternary.False;
                }
            }

            // Compute the set of types for each discriminant property.
            const sourceDiscriminantTypes: Type[][] = new Array<Type[]>(sourcePropertiesFiltered.length);
            const excludedProperties = new Set<string>();
            for (let i = 0; i < sourcePropertiesFiltered.length; i++) {
                const sourceProperty = sourcePropertiesFiltered[i];
                const sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);
                sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union
                    ? (sourcePropertyType as UnionType).types
                    : [sourcePropertyType];
                excludedProperties.add(sourceProperty.name);
            }

            // Match each combination of the cartesian product of discriminant properties to one or more
            // constituents of 'target'. If any combination does not have a match then 'source' is not relatable.
            const discriminantCombinations = cartesianProduct(sourceDiscriminantTypes);
            const matchingTypes: Type[] = [];
            for (const combination of discriminantCombinations) {
                let hasMatch = false;
                outer:
                for (const type of target.types) {
                    for (let i = 0; i < sourcePropertiesFiltered.length; i++) {
                        const sourceProperty = sourcePropertiesFiltered[i];
                        const targetProperty = getPropertyOfType(type, sourceProperty.name);
                        if (!targetProperty) continue outer;
                        if (sourceProperty === targetProperty) continue;
                        // We compare the source property to the target in the context of a single discriminant type.
                        const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors*/ false, IntersectionState.None, /*skipOptional*/ strictNullChecks || relation === comparableRelation);
                        // If the target property could not be found, or if the properties were not related,
                        // then this constituent is not a match.
                        if (!related) {
                            continue outer;
                        }
                    }
                    pushIfUnique(matchingTypes, type, equateValues);
                    hasMatch = true;
                }
                if (!hasMatch) {
                    // We failed to match any type for this combination.
                    return Ternary.False;
                }
            }

            // Compare the remaining non-discriminant properties of each match.
            let result = Ternary.True;
            for (const type of matchingTypes) {
                result &= propertiesRelatedTo(source, type, /*reportErrors*/ false, excludedProperties, /*optionalsOnly*/ false, IntersectionState.None);
                if (result) {
                    result &= signaturesRelatedTo(source, type, SignatureKind.Call, /*reportErrors*/ false, IntersectionState.None);
                    if (result) {
                        result &= signaturesRelatedTo(source, type, SignatureKind.Construct, /*reportErrors*/ false, IntersectionState.None);
                        if (result && !(isTupleType(source) && isTupleType(type))) {
                            // Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the
                            // element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems
                            // with index type assignability as the types for the excluded discriminants are still included
                            // in the index type.
                            result &= indexSignaturesRelatedTo(source, type, /*sourceIsPrimitive*/ false, /*reportErrors*/ false, IntersectionState.None);
                        }
                    }
                }
                if (!result) {
                    return result;
                }
            }
            return result;
        }

        function typeArgumentsRelatedTo(sources: readonly Type[] = emptyArray, targets: readonly Type[] = emptyArray, variances: readonly VarianceFlags[] = emptyArray, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
            if (sources.length !== targets.length && relation === identityRelation) {
                return Ternary.False;
            }
            const length = sources.length <= targets.length ? sources.length : targets.length;
            let result = Ternary.True;
            for (let i = 0; i < length; i++) {
                // When variance information isn't available we default to covariance. This happens
                // in the process of computing variance information for recursive types and when
                // comparing 'this' type arguments.
                const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;
                const variance = varianceFlags & VarianceFlags.VarianceMask;
                // We ignore arguments for independent type parameters (because they're never witnessed).
                if (variance !== VarianceFlags.Independent) {
                    const s = sources[i];
                    const t = targets[i];
                    let related = Ternary.True;
                    if (varianceFlags & VarianceFlags.Unmeasurable) {
                        // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
                        // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
                        // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
                        related = relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors*/ false) : compareTypesIdentical(s, t);
                    }
                    else if (variance === VarianceFlags.Covariant) {
                        related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                    }
                    else if (variance === VarianceFlags.Contravariant) {
                        related = isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                    }
                    else if (variance === VarianceFlags.Bivariant) {
                        // In the bivariant case we first compare contravariantly without reporting
                        // errors. Then, if that doesn't succeed, we compare covariantly with error
                        // reporting. Thus, error elaboration will be based on the the covariant check,
                        // which is generally easier to reason about.
                        related = isRelatedTo(t, s, RecursionFlags.Both, /*reportErrors*/ false);
                        if (!related) {
                            related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                    }
                    else {
                        // In the invariant case we first compare covariantly, and only when that
                        // succeeds do we proceed to compare contravariantly. Thus, error elaboration
                        // will typically be based on the covariant check.
                        related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        if (related) {
                            related &= isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                    }
                    if (!related) {
                        return Ternary.False;
                    }
                    result &= related;
                }
            }
            return result;
        }

        function getApparentMappedTypeKeys(nameType: Type, targetType: MappedType) {
            const modifiersType = getApparentType(getModifiersTypeFromMappedType(targetType));
            const mappedKeys: Type[] = [];
            forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(
                modifiersType,
                TypeFlags.StringOrNumberLiteralOrUnique,
                /*stringsOnly*/ false,
                t => void mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t))),
            );
            return getUnionType(mappedKeys);
        }

        function structuredTypeRelatedToWorker(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState, saveErrorInfo: ReturnType<typeof captureErrorCalculationState>): Ternary {
            let result: Ternary;
            let originalErrorInfo: DiagnosticMessageChain | undefined;
            let varianceCheckFailed = false;
            let sourceFlags = source.flags;
            const targetFlags = target.flags;
            if (relation === identityRelation) {
                // We've already checked that source.flags and target.flags are identical
                if (sourceFlags & TypeFlags.UnionOrIntersection) {
                    let result = eachTypeRelatedToSomeType(source as UnionOrIntersectionType, target as UnionOrIntersectionType);
                    if (result) {
                        result &= eachTypeRelatedToSomeType(target as UnionOrIntersectionType, source as UnionOrIntersectionType);
                    }
                    return result;
                }
                if (sourceFlags & TypeFlags.Index) {
                    return isRelatedTo((source as IndexType).type, (target as IndexType).type, RecursionFlags.Both, /*reportErrors*/ false);
                }
                if (sourceFlags & TypeFlags.IndexedAccess) {
                    if (result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors*/ false)) {
                        if (result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors*/ false)) {
                            return result;
                        }
                    }
                }
                if (sourceFlags & TypeFlags.Conditional) {                    
                    if ((source as ConditionalType).root.isDistributive === (target as ConditionalType).root.isDistributive) {
                        if (result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors*/ false)) {
                            if (result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors*/ false)) {
                                if (result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors*/ false)) {
                                    if (result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors*/ false)) {
                                        return result;
                                    }
                                }
                            }
                        }
                    }
                }
                if (sourceFlags & TypeFlags.Substitution) {
                    if (result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors*/ false)) {
                        if (result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors*/ false)) {
                            return result;
                        }
                    }
                }
                if (!(sourceFlags & TypeFlags.Object)) {
                    return Ternary.False;
                }
            }
            else if (sourceFlags & TypeFlags.UnionOrIntersection || targetFlags & TypeFlags.UnionOrIntersection) {
                if (result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState)) {
                    return result;
                }
                // The ordered decomposition above doesn't handle all cases. Specifically, we also need to handle:
                // Source is instantiable (e.g. source has union or intersection constraint).
                // Source is an object, target is a union (e.g. { a, b: boolean } <=> { a, b: true } | { a, b: false }).
                // Source is an intersection, target is an object (e.g. { a } & { b } <=> { a, b }).
                // Source is an intersection, target is a union (e.g. { a } & { b: boolean } <=> { a, b: true } | { a, b: false }).
                // Source is an intersection, target instantiable (e.g. string & { tag } <=> T["a"] constrained to string & { tag }).
                if (
                    !(sourceFlags & TypeFlags.Instantiable ||
                        sourceFlags & TypeFlags.Object && targetFlags & TypeFlags.Union ||
                        sourceFlags & TypeFlags.Intersection && targetFlags & (TypeFlags.Object | TypeFlags.Union | TypeFlags.Instantiable))
                ) {
                    return Ternary.False;
                }
            }

            // We limit alias variance probing to only object and conditional types since their alias behavior
            // is more predictable than other, interned types, which may or may not have an alias depending on
            // the order in which things were checked.
            if (
                sourceFlags & (TypeFlags.Object | TypeFlags.Conditional) && source.aliasSymbol && source.aliasTypeArguments &&
                source.aliasSymbol === target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target))
            ) {
                const variances = getAliasVariances(source.aliasSymbol);
                if (variances === emptyArray) {
                    return Ternary.Unknown;
                }
                const params = getSymbolLinks(source.aliasSymbol).typeParameters!;
                const minParams = getMinTypeArgumentCount(params);
                const sourceTypes = fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                const targetTypes = fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                const varianceResult = relateVariances(sourceTypes, targetTypes, variances, intersectionState);
                if (varianceResult !== undefined) {
                    return varianceResult;
                }
            }

            // For a generic type T and a type U that is assignable to T, [...U] is assignable to T, U is assignable to readonly [...T],
            // and U is assignable to [...T] when U is constrained to a mutable array or tuple type.
            if (
                isSingleElementGenericTupleType(source) && !source.target.readonly && (result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source)) ||
                isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && (result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target))
            ) {
                return result;
            }

            if (targetFlags & TypeFlags.TypeParameter) {
                // A source type { [P in Q]: X } is related to a target type T if keyof T is related to Q and X is related to T[Q].
                if (getObjectFlags(source) & ObjectFlags.Mapped && !(source as MappedType).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source as MappedType), RecursionFlags.Both)) {
                    if (!(getMappedTypeModifiers(source as MappedType) & MappedTypeModifiers.IncludeOptional)) {
                        const templateType = getTemplateTypeFromMappedType(source as MappedType);
                        const indexedAccessType = getIndexedAccessType(target, getTypeParameterFromMappedType(source as MappedType));
                        if (result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors)) {
                            return result;
                        }
                    }
                }
                if (relation === comparableRelation && sourceFlags & TypeFlags.TypeParameter) {
                    // This is a carve-out in comparability to essentially forbid comparing a type parameter
                    // with another type parameter unless one extends the other. (Remember: comparability is mostly bidirectional!)
                    let constraint = getConstraintOfTypeParameter(source);
                    if (constraint) {
                        while (constraint && someType(constraint, c => !!(c.flags & TypeFlags.TypeParameter))) {
                            if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors*/ false)) {
                                return result;
                            }
                            constraint = getConstraintOfTypeParameter(constraint);
                        }
                    }
                    return Ternary.False;
                }
            }
            else if (targetFlags & TypeFlags.Index) {
                const targetType = (target as IndexType).type;
                // A keyof S is related to a keyof T if T is related to S.
                if (sourceFlags & TypeFlags.Index) {
                    if (result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors*/ false)) {
                        return result;
                    }
                }
                if (isTupleType(targetType)) {
                    // An index type can have a tuple type target when the tuple type contains variadic elements.
                    // Check if the source is related to the known keys of the tuple type.
                    if (result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors)) {
                        return result;
                    }
                }
                else {
                    // A type S is assignable to keyof T if S is assignable to keyof C, where C is the
                    // simplified form of T or, if T doesn't simplify, the constraint of T.
                    const constraint = getSimplifiedTypeOrConstraint(targetType);
                    if (constraint) {
                        // We require Ternary.True here such that circular constraints don't cause
                        // false positives. For example, given 'T extends { [K in keyof T]: string }',
                        // 'keyof T' has itself as its constraint and produces a Ternary.Maybe when
                        // related to other types.
                        if (isRelatedTo(source, getIndexType(constraint, (target as IndexType).indexFlags | IndexFlags.NoReducibleCheck), RecursionFlags.Target, reportErrors) === Ternary.True) {
                            return Ternary.True;
                        }
                    }
                    else if (isGenericMappedType(targetType)) {
                        // generic mapped types that don't simplify or have a constraint still have a very simple set of keys we can compare against
                        // - their nameType or constraintType.
                        // In many ways, this comparison is a deferred version of what `getIndexTypeForMappedType` does to actually resolve the keys for _non_-generic types

                        const nameType = getNameTypeFromMappedType(targetType);
                        const constraintType = getConstraintTypeFromMappedType(targetType);
                        let targetKeys;
                        if (nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType)) {
                            // we need to get the apparent mappings and union them with the generic mappings, since some properties may be
                            // missing from the `constraintType` which will otherwise be mapped in the object
                            const mappedKeys = getApparentMappedTypeKeys(nameType, targetType);
                            // We still need to include the non-apparent (and thus still generic) keys in the target side of the comparison (in case they're in the source side)
                            targetKeys = getUnionType([mappedKeys, nameType]);
                        }
                        else {
                            targetKeys = nameType || constraintType;
                        }
                        if (isRelatedTo(source, targetKeys, RecursionFlags.Target, reportErrors) === Ternary.True) {
                            return Ternary.True;
                        }
                    }
                }
            }
            else if (targetFlags & TypeFlags.IndexedAccess) {
                if (sourceFlags & TypeFlags.IndexedAccess) {
                    // Relate components directly before falling back to constraint relationships
                    // A type S[K] is related to a type T[J] if S is related to T and K is related to J.
                    if (result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors)) {
                        result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, reportErrors);
                    }
                    if (result) {
                        return result;
                    }
                    if (reportErrors) {
                        originalErrorInfo = errorInfo;
                    }
                }
                // A type S is related to a type T[K] if S is related to C, where C is the base
                // constraint of T[K] for writing.
                if (relation === assignableRelation || relation === comparableRelation) {
                    const objectType = (target as IndexedAccessType).objectType;
                    const indexType = (target as IndexedAccessType).indexType;
                    const baseObjectType = getBaseConstraintOfType(objectType) || objectType;
                    const baseIndexType = getBaseConstraintOfType(indexType) || indexType;
                    if (!isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType)) {
                        const accessFlags = AccessFlags.Writing | (baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0);
                        const constraint = getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags);
                        if (constraint) {
                            if (reportErrors && originalErrorInfo) {
                                // create a new chain for the constraint error
                                resetErrorInfo(saveErrorInfo);
                            }
                            if (result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage*/ undefined, intersectionState)) {
                                return result;
                            }
                            // prefer the shorter chain of the constraint comparison chain, and the direct comparison chain
                            if (reportErrors && originalErrorInfo && errorInfo) {
                                errorInfo = countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo;
                            }
                        }
                    }
                }
                if (reportErrors) {
                    originalErrorInfo = undefined;
                }
            }
            else if (isGenericMappedType(target) && relation !== identityRelation) {
                // Check if source type `S` is related to target type `{ [P in Q]: T }` or `{ [P in Q as R]: T}`.
                const keysRemapped = !!target.declaration.nameType;
                const templateType = getTemplateTypeFromMappedType(target);
                const modifiers = getMappedTypeModifiers(target);
                if (!(modifiers & MappedTypeModifiers.ExcludeOptional)) {
                    // If the mapped type has shape `{ [P in Q]: T[P] }`,
                    // source `S` is related to target if `T` = `S`, i.e. `S` is related to `{ [P in Q]: S[P] }`.
                    if (
                        !keysRemapped && templateType.flags & TypeFlags.IndexedAccess && (templateType as IndexedAccessType).objectType === source &&
                        (templateType as IndexedAccessType).indexType === getTypeParameterFromMappedType(target)
                    ) {
                        return Ternary.True;
                    }
                    if (!isGenericMappedType(source)) {
                        // If target has shape `{ [P in Q as R]: T}`, then its keys have type `R`.
                        // If target has shape `{ [P in Q]: T }`, then its keys have type `Q`.
                        const targetKeys = keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target);
                        // Type of the keys of source type `S`, i.e. `keyof S`.
                        const sourceKeys = getIndexType(source, IndexFlags.NoIndexSignatures);
                        const includeOptional = modifiers & MappedTypeModifiers.IncludeOptional;
                        const filteredByApplicability = includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined;
                        // A source type `S` is related to a target type `{ [P in Q]: T }` if `Q` is related to `keyof S` and `S[Q]` is related to `T`.
                        // A source type `S` is related to a target type `{ [P in Q as R]: T }` if `R` is related to `keyof S` and `S[R]` is related to `T.
                        // A source type `S` is related to a target type `{ [P in Q]?: T }` if some constituent `Q'` of `Q` is related to `keyof S` and `S[Q']` is related to `T`.
                        // A source type `S` is related to a target type `{ [P in Q as R]?: T }` if some constituent `R'` of `R` is related to `keyof S` and `S[R']` is related to `T`.
                        if (
                            includeOptional
                                ? !(filteredByApplicability!.flags & TypeFlags.Never)
                                : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both)
                        ) {
                            const templateType = getTemplateTypeFromMappedType(target);
                            const typeParameter = getTypeParameterFromMappedType(target);

                            // Fastpath: When the template type has the form `Obj[P]` where `P` is the mapped type parameter, directly compare source `S` with `Obj`
                            // to avoid creating the (potentially very large) number of new intermediate types made by manufacturing `S[P]`.
                            const nonNullComponent = extractTypesOfKind(templateType, ~TypeFlags.Nullable);
                            if (!keysRemapped && nonNullComponent.flags & TypeFlags.IndexedAccess && (nonNullComponent as IndexedAccessType).indexType === typeParameter) {
                                if (result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors)) {
                                    return result;
                                }
                            }
                            else {
                                // We need to compare the type of a property on the source type `S` to the type of the same property on the target type,
                                // so we need to construct an indexing type representing a property, and then use indexing type to index the source type for comparison.

                                // If the target type has shape `{ [P in Q]: T }`, then a property of the target has type `P`.
                                // If the target type has shape `{ [P in Q]?: T }`, then a property of the target has type `P`,
                                // but the property is optional, so we only want to compare properties `P` that are common between `keyof S` and `Q`.
                                // If the target type has shape `{ [P in Q as R]: T }`, then a property of the target has type `R`.
                                // If the target type has shape `{ [P in Q as R]?: T }`, then a property of the target has type `R`,
                                // but the property is optional, so we only want to compare properties `R` that are common between `keyof S` and `R`.
                                const indexingType = keysRemapped
                                    ? (filteredByApplicability || targetKeys)
                                    : filteredByApplicability
                                    ? getIntersectionType([filteredByApplicability, typeParameter])
                                    : typeParameter;
                                const indexedAccessType = getIndexedAccessType(source, indexingType);
                                // Compare `S[indexingType]` to `T`, where `T` is the type of a property of the target type.
                                if (result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors)) {
                                    return result;
                                }
                            }
                        }
                        originalErrorInfo = errorInfo;
                        resetErrorInfo(saveErrorInfo);
                    }
                }
            }
            else if (targetFlags & TypeFlags.Conditional) {
                console.debug("todo - targetFlags Conditional");
                // // If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
                // // conditional type and bail out with a Ternary.Maybe result.
                // if (isDeeplyNestedType(target, targetStack, targetDepth, 10)) {
                //     return Ternary.Maybe;
                // }
                // const c = target as ConditionalType;
                // // We check for a relationship to a conditional type target only when the conditional type has no
                // // 'infer' positions, is not distributive or is distributive but doesn't reference the check type
                // // parameter in either of the result types, and the source isn't an instantiation of the same
                // // conditional type (as happens when computing variance).
                // if (!c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags & TypeFlags.Conditional && (source as ConditionalType).root === c.root)) {
                //     // Check if the conditional is always true or always false but still deferred for distribution purposes.
                //     const skipTrue = !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType));
                //     const skipFalse = !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType));
                //     // TODO: Find a nice way to include potential conditional type breakdowns in error output, if they seem good (they usually don't)
                //     if (result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState)) {
                //         result &= skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                //         if (result) {
                //             return result;
                //         }
                //     }
                // }
            }            
            else if (target.flags & TypeFlags.StringMapping) {
                if (!(source.flags & TypeFlags.StringMapping)) {
                    console.debug("todo - targetFlags StringMapping");
                    // if (isMemberOfStringMapping(source, target)) {
                    //     return Ternary.True;
                    // }
                }
            }

            if (sourceFlags & TypeFlags.TypeVariable) {
                // IndexedAccess comparisons are handled above in the `targetFlags & TypeFlage.IndexedAccess` branch
                if (!(sourceFlags & TypeFlags.IndexedAccess && targetFlags & TypeFlags.IndexedAccess)) {
                    const constraint = getConstraintOfType(source as TypeVariable) || unknownType;
                    // hi-speed no-this-instantiation check (less accurate, but avoids costly `this`-instantiation when the constraint will suffice), see #28231 for report on why this is needed
                    if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState)) {
                        return result;
                    }
                    // slower, fuller, this-instantiated check (necessary when comparing raw `this` types from base classes), see `subclassWithPolymorphicThisIsAssignable.ts` test for example
                    else if (result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage*/ undefined, intersectionState)) {
                        return result;
                    }
                    if (isMappedTypeGenericIndexedAccess(source)) {
                        // For an indexed access type { [P in K]: E}[X], above we have already explored an instantiation of E with X
                        // substituted for P. We also want to explore type { [P in K]: E }[C], where C is the constraint of X.
                        const indexConstraint = getConstraintOfType((source as IndexedAccessType).indexType);
                        if (indexConstraint) {
                            if (result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors)) {
                                return result;
                            }
                        }
                    }
                }
            }
            else if (sourceFlags & TypeFlags.Index) {
                const isDeferredMappedIndex = shouldDeferIndexType((source as IndexType).type, (source as IndexType).indexFlags) && getObjectFlags((source as IndexType).type) & ObjectFlags.Mapped;
                if (result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex)) {
                    return result;
                }
                if (isDeferredMappedIndex) {
                    const mappedType = (source as IndexType).type as MappedType;
                    const nameType = getNameTypeFromMappedType(mappedType);
                    // Unlike on the target side, on the source side we do *not* include the generic part of the `nameType`, since that comes from a
                    // (potentially anonymous) mapped type local type parameter, so that'd never assign outside the mapped type body, but we still want to
                    // allow assignments of index types of identical (or similar enough) mapped types.
                    // eg, `keyof {[X in keyof A]: Obj[X]}` should be assignable to `keyof {[Y in keyof A]: Tup[Y]}` because both map over the same set of keys (`keyof A`).
                    // Without this source-side breakdown, a `keyof {[X in keyof A]: Obj[X]}` style type won't be assignable to anything except itself, which is much too strict.
                    const sourceMappedKeys =/* nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) :*/ (nameType || getConstraintTypeFromMappedType(mappedType));
                    if (result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors)) {
                        return result;
                    }
                }
            }
            else if (sourceFlags & TypeFlags.TemplateLiteral && !(targetFlags & TypeFlags.Object)) {
                if (!(targetFlags & TypeFlags.TemplateLiteral)) {
                    const constraint = getBaseConstraintOfType(source);
                    if (constraint && constraint !== source && (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors))) {
                        return result;
                    }
                }
            }
            else if (sourceFlags & TypeFlags.StringMapping) {
                if (targetFlags & TypeFlags.StringMapping) {
                    if ((source as StringMappingType).symbol !== (target as StringMappingType).symbol) {
                        return Ternary.False;
                    }
                    if (result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors)) {
                        return result;
                    }
                }
                else {
                    const constraint = getBaseConstraintOfType(source);
                    if (constraint && (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors))) {
                        return result;
                    }
                }
            }
            else if (sourceFlags & TypeFlags.Conditional) {
                console.debug("todo - sourceFlags Conditional");
                // // If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
                // // conditional type and bail out with a Ternary.Maybe result.
                // if (isDeeplyNestedType(source, sourceStack, sourceDepth, 10)) {
                //     return Ternary.Maybe;
                // }
                // if (targetFlags & TypeFlags.Conditional) {
                //     // Two conditional types 'T1 extends U1 ? X1 : Y1' and 'T2 extends U2 ? X2 : Y2' are related if
                //     // one of T1 and T2 is related to the other, U1 and U2 are identical types, X1 is related to X2,
                //     // and Y1 is related to Y2.
                //     const sourceParams = (source as ConditionalType).root.inferTypeParameters;
                //     let sourceExtends = (source as ConditionalType).extendsType;
                //     let mapper: TypeMapper | undefined;
                //     if (sourceParams) {
                //         // If the source has infer type parameters, we instantiate them in the context of the target
                //         const ctx = createInferenceContext(sourceParams, /*signature*/ undefined, InferenceFlags.None, isRelatedToWorker);
                //         inferTypes(ctx.inferences, (target as ConditionalType).extendsType, sourceExtends, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);
                //         sourceExtends = instantiateType(sourceExtends, ctx.mapper);
                //         mapper = ctx.mapper;
                //     }
                //     if (
                //         isTypeIdenticalTo(sourceExtends, (target as ConditionalType).extendsType) &&
                //         (isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both) || isRelatedTo((target as ConditionalType).checkType, (source as ConditionalType).checkType, RecursionFlags.Both))
                //     ) {
                //         if (result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors)) {
                //             result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors);
                //         }
                //         if (result) {
                //             return result;
                //         }
                //     }
                // }
                // // conditionals can be related to one another via normal constraint, as, eg, `A extends B ? O : never` should be assignable to `O`
                // // when `O` is a conditional (`never` is trivially assignable to `O`, as is `O`!).
                // const defaultConstraint = getDefaultConstraintOfConditionalType(source as ConditionalType);
                // if (defaultConstraint) {
                //     if (result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors)) {
                //         return result;
                //     }
                // }
                // // conditionals aren't related to one another via distributive constraint as it is much too inaccurate and allows way
                // // more assignments than are desirable (since it maps the source check type to its constraint, it loses information).
                // const distributiveConstraint = !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined;
                // if (distributiveConstraint) {
                //     resetErrorInfo(saveErrorInfo);
                //     if (result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors)) {
                //         return result;
                //     }
                // }
            }
            else {
                // An empty object type is related to any mapped type that includes a '?' modifier.
                if (relation !== subtypeRelation && relation !== strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source)) {
                    return Ternary.True;
                }
                if (isGenericMappedType(target)) {
                    if (isGenericMappedType(source)) {
                        if (result = mappedTypeRelatedTo(source, target, reportErrors)) {
                            return result;
                        }
                    }
                    return Ternary.False;
                }
                const sourceIsPrimitive = !!(sourceFlags & TypeFlags.Primitive);
                if (relation !== identityRelation) {
                    source = getApparentType(source);
                    sourceFlags = source.flags;
                }
                else if (isGenericMappedType(source)) {
                    return Ternary.False;
                }
                if (
                    getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (source as TypeReference).target === (target as TypeReference).target &&
                    !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target))
                ) {
                    // When strictNullChecks is disabled, the element type of the empty array literal is undefinedWideningType,
                    // and an empty array literal wouldn't be assignable to a `never[]` without this check.
                    if (isEmptyArrayLiteralType(source)) {
                        return Ternary.True;
                    }
                    // We have type references to the same generic type, and the type references are not marker
                    // type references (which are intended by be compared structurally). Obtain the variance
                    // information for the type parameters and relate the type arguments accordingly.
                    const variances = getVariances((source as TypeReference).target);
                    // We return Ternary.Maybe for a recursive invocation of getVariances (signalled by emptyArray). This
                    // effectively means we measure variance only from type parameter occurrences that aren't nested in
                    // recursive instantiations of the generic type.
                    if (variances === emptyArray) {
                        return Ternary.Unknown;
                    }
                    const varianceResult = relateVariances(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), variances, intersectionState);
                    if (varianceResult !== undefined) {
                        return varianceResult;
                    }
                }
                else if (isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly)) {
                    if (relation !== identityRelation) {
                        return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, RecursionFlags.Both, reportErrors);
                    }
                    else {
                        // By flags alone, we know that the `target` is a readonly array while the source is a normal array or tuple
                        // or `target` is an array and source is a tuple - in both cases the types cannot be identical, by construction
                        return Ternary.False;
                    }
                }
                else if (isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target)) {
                    const constraint = getBaseConstraintOrType(source);
                    if (constraint !== source) {
                        return isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors);
                    }
                }
                // A fresh empty object type is never a subtype of a non-empty object type. This ensures fresh({}) <: { [x: string]: xxx }
                // but not vice-versa. Without this rule, those types would be mutual subtypes.
                else if ((relation === subtypeRelation || relation === strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target) & ObjectFlags.FreshLiteral && !isEmptyObjectType(source)) {
                    return Ternary.False;
                }
                // Even if relationship doesn't hold for unions, intersections, or generic type references,
                // it may hold in a structural comparison.
                // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
                // to X. Failing both of those we want to check if the aggregation of A and B's members structurally
                // relates to X. Thus, we include intersection types on the source side here.
                if (sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) && targetFlags & TypeFlags.Object) {
                    // check if strictObjectTypes mode is on
                    const canSkipStrictCheck = canSkipStrictObjectCheck(source,target);
                    // Report structural errors only if we haven't reported any errors yet
                    const reportStructuralErrors = !canSkipStrictCheck && reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive;
                    result = propertiesRelatedTo(source, target, reportStructuralErrors, /*excludedProperties*/ undefined, /*optionalsOnly*/ false, intersectionState);
                    
                    if (result) {
                        result &= signaturesRelatedTo(source, target, SignatureKind.Call, reportStructuralErrors, intersectionState);
                        if (result) {
                            result &= signaturesRelatedTo(source, target, SignatureKind.Construct, reportStructuralErrors, intersectionState);
                            if (result) {
                                result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState);
                            }
                        }
                    }
                    if (varianceCheckFailed && result) {
                        errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo; // Use variance error (there is no structural one) and return false
                    }
                    else if (result) {
                        return result;
                    }
                    if (canSkipStrictCheck) {
                        return Ternary.True;
                    }
                }
                // If S is an object type and T is a discriminated union, S may be related to T if
                // there exists a constituent of T for every combination of the discriminants of S
                // with respect to T. We do not report errors here, as we will use the existing
                // error result from checking each constituent of the union.
                if (sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) && targetFlags & TypeFlags.Union) {
                    const objectOnlyTarget = extractTypesOfKind(target, TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Substitution);
                    if (objectOnlyTarget.flags & TypeFlags.Union) {
                        const result = typeRelatedToDiscriminatedType(source, objectOnlyTarget as UnionType);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            return Ternary.False;

            function countMessageChainBreadth(info: DiagnosticMessageChain[] | undefined): number {
                if (!info) return 0;
                return reduceLeft(info, (value, chain) => value + 1 + countMessageChainBreadth(chain.next), 0);
            }

            function relateVariances(sourceTypeArguments: readonly Type[] | undefined, targetTypeArguments: readonly Type[] | undefined, variances: VarianceFlags[], intersectionState: IntersectionState) {
                if (result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState)) {
                    return result;
                }
                if (some(variances, v => !!(v & VarianceFlags.AllowsStructuralFallback))) {
                    // If some type parameter was `Unmeasurable` or `Unreliable`, and we couldn't pass by assuming it was identical, then we
                    // have to allow a structural fallback check
                    // We elide the variance-based error elaborations, since those might not be too helpful, since we'll potentially
                    // be assuming identity of the type parameter.
                    originalErrorInfo = undefined;
                    resetErrorInfo(saveErrorInfo);
                    return undefined;
                }
                const allowStructuralFallback = targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances);
                varianceCheckFailed = !allowStructuralFallback;
                // The type arguments did not relate appropriately, but it may be because we have no variance
                // information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
                // arguments). It might also be the case that the target type has a 'void' type argument for
                // a covariant type parameter that is only used in return positions within the generic type
                // (in which case any type argument is permitted on the source side). In those cases we proceed
                // with a structural comparison. Otherwise, we know for certain the instantiations aren't
                // related and we can return here.
                if (variances !== emptyArray && !allowStructuralFallback) {
                    // In some cases generic types that are covariant in regular type checking mode become
                    // invariant in --strictFunctionTypes mode because one or more type parameters are used in
                    // both co- and contravariant positions. In order to make it easier to diagnose *why* such
                    // types are invariant, if any of the type parameters are invariant we reset the reported
                    // errors and instead force a structural comparison (which will include elaborations that
                    // reveal the reason).
                    // We can switch on `reportErrors` here, since varianceCheckFailed guarantees we return `False`,
                    // we can return `False` early here to skip calculating the structural error message we don't need.
                    if (varianceCheckFailed && !(reportErrors && some(variances, v => (v & VarianceFlags.VarianceMask) === VarianceFlags.Invariant))) {
                        return Ternary.False;
                    }
                    // We remember the original error information so we can restore it in case the structural
                    // comparison unexpectedly succeeds. This can happen when the structural comparison result
                    // is a Ternary.Maybe for example caused by the recursion depth limiter.
                    originalErrorInfo = errorInfo;
                    resetErrorInfo(saveErrorInfo);
                }
            }
        }

        // Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
        // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
        // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
        // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
        // and issue an error. Otherwise, actually compare the structure of the two types.
        function recursiveTypeRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState, recursionFlags: RecursionFlags): Ternary {
            if (overflow) {
                return Ternary.False;
            }
            const id = getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints*/ false);
            const entry = relation.get(id);
            if (entry !== undefined) {
                if (reportErrors && entry & RelationComparisonResult.Failed && !(entry & RelationComparisonResult.Overflow)) {
                    // We are elaborating errors and the cached result is a failure not due to a comparison overflow,
                    // so we will do the comparison again to generate an error message.
                }
                else {                    
                    if (outofbandVarianceMarkerHandler) {
                        // We're in the middle of variance checking - integrate any unmeasurable/unreliable flags from this cached component
                        const saved = entry & RelationComparisonResult.ReportsMask;
                        if (saved & RelationComparisonResult.ReportsUnmeasurable) {
                            instantiateType(source, reportUnmeasurableMapper);
                        }
                        if (saved & RelationComparisonResult.ReportsUnreliable) {
                            instantiateType(source, reportUnreliableMapper);
                        }
                    }
                    if (reportErrors && entry & RelationComparisonResult.Overflow) {
                        const message = entry & RelationComparisonResult.ComplexityOverflow ?
                            Diagnostics.Excessive_complexity_comparing_types_0_and_1 :
                            Diagnostics.Excessive_stack_depth_comparing_types_0_and_1;
                        reportError(message, typeToString(source), typeToString(target));
                        overrideNextErrorInfo++;
                    }
                    return entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False;
                }
            }
            if (relationCount <= 0) {
                overflow = true;
                return Ternary.False;
            }
            if (!maybeKeys) {
                maybeKeys = [];
                maybeKeysSet = new Set();
                sourceStack = [];
                targetStack = [];
            }
            else {
                // If source and target are already being compared, consider them related with assumptions
                if (maybeKeysSet.has(id)) {
                    return Ternary.Maybe;
                }

                // A key that starts with "*" is an indication that we have type references that reference constrained
                // type parameters. For such keys we also check against the key we would have gotten if all type parameters
                // were unconstrained.
                const broadestEquivalentId = id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints*/ true) : undefined;
                if (broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId)) {
                    return Ternary.Maybe;
                }

                if (sourceDepth === 100 || targetDepth === 100) {
                    overflow = true;
                    return Ternary.False;
                }
            }
            const maybeStart = maybeCount;
            maybeKeys[maybeCount] = id;
            maybeKeysSet.add(id);
            maybeCount++;
            const saveExpandingFlags = expandingFlags;
            if (recursionFlags & RecursionFlags.Source) {
                sourceStack[sourceDepth] = source;
                sourceDepth++;
                if (!(expandingFlags & ExpandingFlags.Source) && isDeeplyNestedType(source, sourceStack, sourceDepth)) expandingFlags |= ExpandingFlags.Source;
            }
            if (recursionFlags & RecursionFlags.Target) {
                targetStack[targetDepth] = target;
                targetDepth++;
                if (!(expandingFlags & ExpandingFlags.Target) && isDeeplyNestedType(target, targetStack, targetDepth)) expandingFlags |= ExpandingFlags.Target;
            }
            let originalHandler: typeof outofbandVarianceMarkerHandler;
            let propagatingVarianceFlags = 0 as RelationComparisonResult;
            if (outofbandVarianceMarkerHandler) {
                originalHandler = outofbandVarianceMarkerHandler;
                outofbandVarianceMarkerHandler = onlyUnreliable => {
                    propagatingVarianceFlags |= onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable;
                    return originalHandler!(onlyUnreliable);
                };
            }

            let result: Ternary;
            if (expandingFlags === ExpandingFlags.Both) {
                tracing?.instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit", {
                    sourceId: source.id,
                    sourceIdStack: sourceStack.map(t => t.id),
                    targetId: target.id,
                    targetIdStack: targetStack.map(t => t.id),
                    depth: sourceDepth,
                    targetDepth,
                });
                result = Ternary.Maybe;
            }
            else {
                tracing?.push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo", { sourceId: source.id, targetId: target.id });
                result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState);
                tracing?.pop();
            }

            if (outofbandVarianceMarkerHandler) {
                outofbandVarianceMarkerHandler = originalHandler;
            }
            if (recursionFlags & RecursionFlags.Source) {
                sourceDepth--;
            }
            if (recursionFlags & RecursionFlags.Target) {
                targetDepth--;
            }
            expandingFlags = saveExpandingFlags;
            if (result) {
                if (result === Ternary.True || (sourceDepth === 0 && targetDepth === 0)) {
                    if (result === Ternary.True || result === Ternary.Maybe) {
                        // If result is definitely true, record all maybe keys as having succeeded. Also, record Ternary.Maybe
                        // results as having succeeded once we reach depth 0, but never record Ternary.Unknown results.
                        resetMaybeStack(/*markAllAsSucceeded*/ true);
                    }
                    else {
                        resetMaybeStack(/*markAllAsSucceeded*/ false);
                    }
                }
                // Note: it's intentional that we don't reset in the else case;
                // we leave them on the stack such that when we hit depth zero
                // above, we can report all of them as successful.
            }
            else {
                // A false result goes straight into global cache (when something is false under
                // assumptions it will also be false without assumptions)
                relation.set(id, RelationComparisonResult.Failed | propagatingVarianceFlags);
                relationCount--;
                resetMaybeStack(/*markAllAsSucceeded*/ false);
            }
            return result;

            function resetMaybeStack(markAllAsSucceeded: boolean) {
                for (let i = maybeStart; i < maybeCount; i++) {
                    maybeKeysSet.delete(maybeKeys[i]);
                    if (markAllAsSucceeded) {
                        relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);
                        relationCount--;
                    }
                }
                maybeCount = maybeStart;
            }
        }
    }
    
    function getNormalizedType(type: Type, writing: boolean): Type {
        while (true) {
            const t = isFreshLiteralType(type) ? (type as FreshableType).regularType :
                isGenericTupleType(type) ? getNormalizedTupleType(type, writing) :
                getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type :
                type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) :
                type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) :
                type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) :
                type;
            if (t === type) return t;
            type = t;
        }
    }

    function getNormalizedTupleType(type: TupleTypeReference, writing: boolean): Type {
        const elements = getElementTypes(type);
        const normalizedElements = sameMap(elements, t => t.flags & TypeFlags.Simplifiable ? getSimplifiedType(t, writing) : t);
        return elements !== normalizedElements ? createNormalizedTupleType(type.target, normalizedElements) : type;
    }

    function getElementTypes(type: TupleTypeReference): readonly Type[] {
        const typeArguments = getTypeArguments(type);
        const arity = getTypeReferenceArity(type);
        return typeArguments.length === arity ? typeArguments : typeArguments.slice(0, arity);
    }

    function createNormalizedTupleType(target: TupleType, elementTypes: readonly Type[]): Type {
        if (!(target.combinedFlags & ElementFlags.NonRequired)) {
            // No need to normalize when we only have regular required elements
            return createTypeReference(target, elementTypes);
        }
        if (target.combinedFlags & ElementFlags.Variadic) {
            // Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
            const unionIndex = findIndex(elementTypes, (t, i) => !!(target.elementFlags[i] & ElementFlags.Variadic && t.flags & (TypeFlags.Never | TypeFlags.Union)));
            if (unionIndex >= 0) {
                return checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType)) ?
                    mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) :
                    errorType;
            }
        }
        // We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
        // elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
        // (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
        // (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
        // In either layout, zero or more generic variadic elements may be present at any location.
        const expandedTypes: Type[] = [];
        const expandedFlags: ElementFlags[] = [];
        const expandedDeclarations: (NamedTupleMember | ParameterDeclaration | undefined)[] = [];
        let lastRequiredIndex = -1;
        let firstRestIndex = -1;
        let lastOptionalOrRestIndex = -1;
        for (let i = 0; i < elementTypes.length; i++) {
            const type = elementTypes[i];
            const flags = target.elementFlags[i];
            if (flags & ElementFlags.Variadic) {
                if (type.flags & TypeFlags.Any) {
                    addElement(type, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);
                }
                else if (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type)) {
                    // Generic variadic elements stay as they are.
                    addElement(type, ElementFlags.Variadic, target.labeledElementDeclarations?.[i]);
                }
                else if (isTupleType(type)) {
                    const elements = getElementTypes(type);
                    if (elements.length + expandedTypes.length >= 10_000) {
                        error(
                            currentNode,
                            isPartOfTypeNode(currentNode!)
                                ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent
                                : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,
                        );
                        return errorType;
                    }
                    // Spread variadic elements with tuple types into the resulting tuple.
                    forEach(elements, (t, n) => addElement(t, type.target.elementFlags[n], type.target.labeledElementDeclarations?.[n]));
                }
                else {
                    // Treat everything else as an array type and create a rest element.
                    addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);
                }
            }
            else {
                // Copy other element kinds with no change.
                addElement(type, flags, target.labeledElementDeclarations?.[i]);
            }
        }
        // Turn optional elements preceding the last required element into required elements
        for (let i = 0; i < lastRequiredIndex; i++) {
            if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;
        }
        if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
            // Turn elements between first rest and last optional/rest into a single rest element
            expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), (t, i) => expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t));
            expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
        }
        const tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
        return tupleTarget === emptyGenericType ? emptyObjectType :
            expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :
            tupleTarget;

        function addElement(type: Type, flags: ElementFlags, declaration: NamedTupleMember | ParameterDeclaration | undefined) {
            if (flags & ElementFlags.Required) {
                lastRequiredIndex = expandedFlags.length;
            }
            if (flags & ElementFlags.Rest && firstRestIndex < 0) {
                firstRestIndex = expandedFlags.length;
            }
            if (flags & (ElementFlags.Optional | ElementFlags.Rest)) {
                lastOptionalOrRestIndex = expandedFlags.length;
            }
            expandedTypes.push(flags & ElementFlags.Optional ? addOptionality(type, /*isProperty*/ true) : type);
            expandedFlags.push(flags);
            expandedDeclarations.push(declaration);
        }
    }

    function distributeObjectOverIndexType(objectType: Type, indexType: Type, writing: boolean) {
        // T[A | B] -> T[A] | T[B] (reading)
        // T[A | B] -> T[A] & T[B] (writing)
        if (indexType.flags & TypeFlags.Union) {
            const types = map((indexType as UnionType).types, t => getSimplifiedType(getIndexedAccessType(objectType, t), writing));
            return writing ? getIntersectionType(types) : getUnionType(types);
        }
    }

    // Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
    // the type itself if no transformation is possible. The writing flag indicates that the type is
    // the target of an assignment.
    function getSimplifiedIndexedAccessType(type: IndexedAccessType, writing: boolean): Type {
        const cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
        if (type[cache]) {
            return type[cache] === circularConstraintType ? type : type[cache]!;
        }
        type[cache] = circularConstraintType;
        // We recursively simplify the object type as it may in turn be an indexed access type. For example, with
        // '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
        const objectType = getSimplifiedType(type.objectType, writing);
        const indexType = getSimplifiedType(type.indexType, writing);
        // T[A | B] -> T[A] | T[B] (reading)
        // T[A | B] -> T[A] & T[B] (writing)
        const distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
        if (distributedOverIndex) {
            return type[cache] = distributedOverIndex;
        }
        // Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
        if (!(indexType.flags & TypeFlags.Instantiable)) {
            // (T | U)[K] -> T[K] | U[K] (reading)
            // (T | U)[K] -> T[K] & U[K] (writing)
            // (T & U)[K] -> T[K] & U[K]
            const distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
            if (distributedOverObject) {
                return type[cache] = distributedOverObject;
            }
        }
        // So ultimately (reading):
        // ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]

        // A generic tuple type indexed by a number exists only when the index type doesn't select a
        // fixed element. We simplify to either the combined type of all elements (when the index type
        // the actual number type) or to the combined type of all non-fixed elements.
        if (isGenericTupleType(objectType) && indexType.flags & TypeFlags.NumberLike) {
            const elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength, /*endSkipCount*/ 0, writing);
            if (elementType) {
                return type[cache] = elementType;
            }
        }
        // If the object type is a mapped type { [P in K]: E }, where K is generic, or { [P in K as N]: E }, where
        // K is generic and N is assignable to P, instantiate E using a mapper that substitutes the index type for P.
        // For example, for an index access { [P in K]: Box<T[P]> }[X], we construct the type Box<T[X]>.
        if (isGenericMappedType(objectType)) {
            if (getMappedTypeNameTypeKind(objectType) !== MappedTypeNameTypeKind.Remapping) {
                return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing));
            }
        }
        return type[cache] = type;
    }

    /**
     * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
     */
    function isIntersectionEmpty(type1: Type, type2: Type) {
        return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & TypeFlags.Never);
    }

    function getSimplifiedConditionalType(type: ConditionalType, writing: boolean) {
        const checkType = type.checkType;
        const extendsType = type.extendsType;
        const trueType = getTrueTypeFromConditionalType(type);
        const falseType = getFalseTypeFromConditionalType(type);
        // Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
        if (falseType.flags & TypeFlags.Never && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
            if (checkType.flags & TypeFlags.Any || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                return getSimplifiedType(trueType, writing);
            }
            else if (isIntersectionEmpty(checkType, extendsType)) { // Always false
                return neverType;
            }
        }
        else if (trueType.flags & TypeFlags.Never && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
            if (!(checkType.flags & TypeFlags.Any) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                return neverType;
            }
            else if (checkType.flags & TypeFlags.Any || isIntersectionEmpty(checkType, extendsType)) { // Always false
                return getSimplifiedType(falseType, writing);
            }
        }
        return type;
    }

    function getSimplifiedType(type: Type, writing: boolean): Type {
        return type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(type as IndexedAccessType, writing) :
            type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(type as ConditionalType, writing) :
            type;
    }

    function getSubstitutionIntersection(substitutionType: SubstitutionType) {
        return isNoInferType(substitutionType) ? substitutionType.baseType : getIntersectionType([substitutionType.constraint, substitutionType.baseType]);
    }

    /**
     * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
     * For other cases, the types ids are used.
     */
    function getRelationKey(source: Type, target: Type, intersectionState: IntersectionState, relation: Map<string, RelationComparisonResult>, ignoreConstraints: boolean) {
        if (relation === identityRelation && source.id > target.id) {
            const temp = source;
            source = target;
            target = temp;
        }
        const postFix = intersectionState ? ":" + intersectionState : "";
        return `${source.id},${target.id}${postFix}`;
    }

    function isTypeAssignableTo(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, assignableRelation);
    }

    function isTypeAssignableToKind(source: Type, kind: TypeFlags, strict?: boolean): boolean {
        if (source.flags & kind) {
            return true;
        }
         if (strict && source.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null)) {
            return false;
        }
        return !!(kind & TypeFlags.NumberLike) && isTypeAssignableTo(source, intType) ||            
            !!(kind & TypeFlags.NumberLike) && isTypeAssignableTo(source, floatType) ||
            !!(kind & TypeFlags.StringLike) && isTypeAssignableTo(source, stringType) ||
            //!!(kind & TypeFlags.BooleanLike) && isTypeAssignableTo(source, booleanType) ||
            !!(kind & TypeFlags.BytesLike) && isTypeAssignableTo(source, bytesType) ||
            !!(kind & TypeFlags.Never) && isTypeAssignableTo(source, neverType) ||            
            !!(kind & TypeFlags.Undefined) && isTypeAssignableTo(source, undefinedType) ||            
            !!(kind & TypeFlags.NonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType);
    }


    // Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
    // 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
    function isEvolvingArrayOperationTarget(node: Node) {
        const root = getReferenceRoot(node);
        const parent = root.parent;        
        const isElementAssignment = parent.kind === SyntaxKind.ElementAccessExpression &&
            (parent as ElementAccessExpression).expression === root &&
            parent.parent.kind === SyntaxKind.BinaryExpression &&
            (parent.parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken &&
            (parent.parent as BinaryExpression).left === parent &&
            !isAssignmentTarget(parent.parent) &&
            isTypeAssignableToKind(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression), TypeFlags.NumberLike);
        return isElementAssignment;
    }

    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     */
    function getTypeOfExpression(node: Expression) {
        // Don't bother caching types that require no flow analysis and are quick to compute.
        const quickType = getQuickTypeOfExpression(node);
        if (quickType) {
            return quickType;
        }
        // If a type has been cached for the node, return it.
        if (node.flags & NodeFlags.TypeCached && flowTypeCache) {
            const cachedType = flowTypeCache[getNodeId(node)];
            if (cachedType) {
                return cachedType;
            }
        }
        const startInvocationCount = flowInvocationCount;
        const type = checkExpression(node, CheckMode.TypeOnly);
        // If control flow analysis was required to determine the type, it is worth caching.
        if (flowInvocationCount !== startInvocationCount) {
            const cache = flowTypeCache || (flowTypeCache = []);
            cache[getNodeId(node)] = type;
            setNodeFlags(node, node.flags | NodeFlags.TypeCached);
        }
        return type;
    }

    function isSymbolOrSymbolForCall(node: Node) {
        return false;
        // if (!isCallExpression(node)) return false;
        // let left = node.expression;
        // if (isPropertyAccessExpression(left) && left.name.text === "for") {
        //     left = left.expression;
        // }
        // if (!isIdentifier(left) || left.text !== "Symbol") {
        //     return false;
        // }

        // // make sure `Symbol` is the global symbol
        // // const globalESSymbol = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
        // // if (!globalESSymbol) {
        // //     return false;
        // // }

        // return globalESSymbol === resolveName(left, "Symbol" as string, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ false);
    }

    
    function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr: CallChain) {
        const funcType = checkExpression(expr.expression);
        const nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
        const returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
        return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
    }

    function getReturnTypeOfSingleNonGenericCallSignature(funcType: Type) {
        const signature = getSingleCallSignature(funcType);
        if (signature && !signature.typeParameters) {
            return getReturnTypeOfSignature(signature);
        }
    }
    
    function getQuickTypeOfExpression(node: Expression): Type | undefined {        
        if (isJSDocTypeAssertion(node)) {
            const type = getJSDocTypeAssertionType(node);
            return getTypeFromTypeNode(type);            
        }
        let expr = skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
        if (isJSDocTypeAssertion(expr)) {
            const type = getJSDocTypeAssertionType(expr);            
            return getTypeFromTypeNode(type);            
        }
        expr = skipParentheses(node);
        // if (isAwaitExpression(expr)) {
        //     const type = getQuickTypeOfExpression(expr.expression);
        //     return type ? getAwaitedType(type) : undefined;
        // }
        // Optimize for the common case of a call to a function with a single non-generic call
        // signature where we can just fetch the return type without checking the arguments.
        if (isCallExpression(expr) && expr.expression.kind !== SyntaxKind.SuperKeyword && !isSymbolOrSymbolForCall(expr)) {
            return isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :
                getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
        }
        else if (isAssertionExpression(expr)) {
            return getTypeFromTypeNode((expr as TypeAssertion).type);
        }
        else if (isLiteralExpression(node)) {
            return checkExpression(node);
        }
        return undefined;
    }

    function getTypeFromFlowType(flowType: FlowType) {
        return flowType.flags === 0 ? flowType.type : flowType as Type;
    }

    function createFinalArrayType(elementType: Type) {
        return elementType.flags & TypeFlags.Never ?
            autoArrayType :
            createArrayType(
                elementType.flags & TypeFlags.Union ?
                    getUnionType((elementType as UnionType).types, UnionReduction.Subtype) :
                    elementType,
            );
    }

    // We perform subtype reduction upon obtaining the final array type from an evolving array type.
    function getFinalArrayType(evolvingArrayType: EvolvingArrayType): Type {
        return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType));
    }

    function finalizeEvolvingArrayType(type: Type): Type {
        return getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(type as EvolvingArrayType) : type;
    }

    function getTypeWithFacts(type: Type, include: TypeFacts) {
        return filterType(type, t => hasTypeFacts(t, include));
    }

    function tryGetElementAccessExpressionName(node: ElementAccessExpression) {
        return isStringOrNumericLiteralLike(node.argumentExpression) ? (node.argumentExpression.text) :
            isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : undefined;
    }

    function tryGetNameFromEntityNameExpression(node: EntityNameOrEntityNameExpression) {        
        const symbol = resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors*/ true);
        if (!symbol || !((symbol.flags & SymbolFlags.EnumMember))) return undefined;

        const declaration = symbol.valueDeclaration;
        if (declaration === undefined) return undefined;

        const type = tryGetTypeFromEffectiveTypeNode(declaration);
        if (type) {
            const name = tryGetNameFromType(type);
            if (name !== undefined) {
                return name;
            }
        }
        if (hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node)) {
            const initializer = getEffectiveInitializer(declaration);
            if (initializer) {
                const initializerType = isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer);
                return initializerType && tryGetNameFromType(initializerType);
            }            
        }
        return undefined;
    }

    /** Return the inferred type for a binding element */
    function getTypeForBindingElement(declaration: BindingElement): Type | undefined {
        const checkMode = declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal;
        const parentType = getTypeForBindingElementParent(declaration.parent.parent, checkMode);
        return parentType && getBindingElementTypeFromParentType(declaration, parentType, /*noTupleBoundsCheck*/ false);
    }
    
    function getBindingElementTypeFromParentType(declaration: BindingElement, parentType: Type, noTupleBoundsCheck: boolean): Type {
        // If an any type was inferred for parent, infer that for the binding element
        if (isTypeAny(parentType)) {
            return parentType;
        }
        const pattern = declaration.parent;
        // Relax null check on ambient destructuring parameters, since the parameters have no implementation and are just documentation
        if (strictNullChecks && declaration.flags & NodeFlags.Ambient && isPartOfParameterDeclaration(declaration)) {
            parentType = getNonNullableType(parentType);
        }
        // Filter `undefined` from the type we check against if the parent has an initializer and that initializer is not possibly `undefined`
        else if (strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFacts.EQUndefined))) {
            parentType = getTypeWithFacts(parentType, TypeFacts.NEUndefined);
        }

        let type: Type | undefined;
        
    
        // This elementType will be used if the specific property corresponding to this index is not
        // present (aka the tuple element property). This call also checks that the parentType is in
        // fact an iterable or array (depending on target language).
        const elementType = checkIteratedTypeOrElementType(IterationUse.Destructuring | (declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds), parentType, undefinedType, pattern);
        const index = pattern.elements.indexOf(declaration);
        if (declaration.dotDotDotToken) {
            // If the parent is a tuple type, the rest element has a tuple type of the
            // remaining tuple element types. Otherwise, the rest element has an array type with same
            // element type as the parent type.
            const baseConstraint = mapType(parentType, t => t.flags & TypeFlags.InstantiableNonPrimitive ? getBaseConstraintOrType(t) : t);
            type = everyType(baseConstraint, isTupleType) ?
                mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) :
                createArrayType(elementType);
        }
        else if (isArrayLikeType(parentType)) {
            const indexType = getNumberLiteralType(index);
            const accessFlags = AccessFlags.ExpressionPosition | (noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.NoTupleBoundsCheck : 0);
            const declaredType = getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType;
            type = getFlowTypeOfDestructuring(declaration, declaredType);
        }
        else {
            type = elementType;
        }

        if (!declaration.initializer) {
            return type;
        }
        if (getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration))) {
            // In strict null checking mode, if a default value of a non-undefined type is specified, remove
            // undefined from the final type.
            return strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) ? getNonUndefinedType(type) : type;
        }
        return widenTypeInferredFromInitializer(declaration, getUnionType([getNonUndefinedType(type), checkDeclarationInitializer(declaration, CheckMode.Normal)], UnionReduction.Subtype));
    }
    
    
    // Determine the control flow type associated with a destructuring declaration or assignment. The following
    // forms of destructuring are possible:
    //   let { x } = obj;  // BindingElement
    //   let [ x ] = obj;  // BindingElement
    //   { x } = obj;      // ShorthandPropertyAssignment
    //   { x: v } = obj;   // PropertyAssignment
    //   [ x ] = obj;      // Expression
    // We construct a synthetic element access expression corresponding to 'obj.x' such that the control
    // flow analyzer doesn't have to handle all the different syntactic forms.
    function getFlowTypeOfDestructuring(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression, declaredType: Type) {
        const reference = getSyntheticElementAccess(node);
        return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
    }

    function getParentElementAccess(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression) {
        const ancestor = node.parent.parent;
        switch (ancestor.kind) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyAssignment:
                return getSyntheticElementAccess(ancestor as BindingElement | PropertyAssignment);
            case SyntaxKind.ArrayLiteralExpression:
                return getSyntheticElementAccess(node.parent as Expression);
            case SyntaxKind.VariableDeclaration:
                return (ancestor as VariableDeclaration).initializer;
            case SyntaxKind.BinaryExpression:
                return (ancestor as BinaryExpression).right;
        }
    }

    function getDestructuringPropertyName(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression) {
        const parent = node.parent;
        // if (node.kind === SyntaxKind.BindingElement && parent.kind === SyntaxKind.ObjectBindingPattern) {
        //     return getLiteralPropertyNameText((node as BindingElement).propertyName || (node as BindingElement).name as Identifier);
        // }
        if (node.kind === SyntaxKind.PropertyAssignment || node.kind === SyntaxKind.ShorthandPropertyAssignment) {
            return getLiteralPropertyNameText((node as PropertyAssignment | ShorthandPropertyAssignment).name);
        }
        return "" + ((parent as BindingPattern | ArrayLiteralExpression).elements as NodeArray<Node>).indexOf(node);
    }

    function getLiteralPropertyNameText(name: PropertyName) {
        const type = getLiteralTypeFromPropertyName(name);
        return type.flags & (TypeFlags.StringLiteral | TypeFlags.IntLiteral) ? "" + (type as StringLiteralType | IntLiteralType).value : undefined;
    }

    function getSyntheticElementAccess(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression): ElementAccessExpression | undefined {
        const parentAccess = getParentElementAccess(node);
        if (parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode) {
            const propName = getDestructuringPropertyName(node);
            if (propName) {
                const literal = setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node);
                const lhsExpr = isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess);
                const result = setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node);
                setParent(literal, result);
                setParent(result, node);
                if (lhsExpr !== parentAccess) {
                    setParent(lhsExpr, result);
                }
                result.flowNode = parentAccess.flowNode;
                return result;
            }
        }
    }

    function getTypeReferenceArity(type: TypeReference): number {
        return length(type.target.typeParameters);
    }

    function getRestArrayTypeOfTupleType(type: TupleTypeReference) {
        const restType = getRestTypeOfTupleType(type);
        return restType && createArrayType(restType);
    }

    function getRestTypeOfTupleType(type: TupleTypeReference) {
        return getElementTypeOfSliceOfTupleType(type, type.target.fixedLength);
    }

    function getElementTypeOfSliceOfTupleType(type: TupleTypeReference, index: number, endSkipCount = 0, writing = false, noReductions = false) {
        const length = getTypeReferenceArity(type) - endSkipCount;
        if (index < length) {
            const typeArguments = getTypeArguments(type);
            const elementTypes: Type[] = [];
            for (let i = index; i < length; i++) {
                const t = typeArguments[i];
                elementTypes.push(type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);
            }
            return writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? UnionReduction.None : UnionReduction.Literal);
        }
        return undefined;
    }

    function sliceTupleType(type: TupleTypeReference, index: number, endSkipCount = 0) {
        const target = type.target;
        const endIndex = getTypeReferenceArity(type) - endSkipCount;
        return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) :
            createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), /*readonly*/ false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
    }

    // Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
    // assigned by contextual typing.
    function getTypeForBindingElementParent(node: BindingElementGrandparent, checkMode: CheckMode) {
        if (checkMode !== CheckMode.Normal) {
            return getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false, checkMode);
        }
        const symbol = getSymbolOfDeclaration(node);
        return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false, checkMode);
    }

    function getAccessedPropertyName(access: AccessExpression | BindingElement | ParameterDeclaration): string | undefined {
        if (isPropertyAccessExpression(access)) {
            const propAccId = skipParentheses(access.name);
            return isIdentifier(propAccId) && propAccId.text;            
        }
        if (isElementAccessExpression(access)) {
            return tryGetElementAccessExpressionName(access);
        }
        if (isBindingElement(access)) {
            // const name = getDestructuringPropertyName(access);
            // return name ? (name) : undefined;
            return undefined;
        }
        if (isParameter(access)) {
            return ("" + access.parent.parameters.indexOf(access)) as string;
        }
        return undefined;
    }

    // Return the flow cache key for a "dotted name" (i.e. a sequence of identifiers
    // separated by dots). The key consists of the id of the symbol referenced by the
    // leftmost identifier followed by zero or more property names separated by dots.
    // The result is undefined if the reference isn't a dotted name.
    function getFlowCacheKey(node: Node, declaredType: Type, initialType: Type, flowContainer: Node | undefined): string | undefined {
        switch (node.kind) {
            case SyntaxKind.Identifier:
                
                    const symbol = getResolvedSymbol(node as Identifier);
                    return symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : undefined;
                
                // falls through
            // case SyntaxKind.ThisKeyword:
            //     return `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}`;
            // case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
                return getFlowCacheKey((node as  ParenthesizedExpression).expression, declaredType, initialType, flowContainer);
            case SyntaxKind.QualifiedName:
                const left = getFlowCacheKey((node as QualifiedName).left, declaredType, initialType, flowContainer);
                return left && `${left}.${(node as QualifiedName).right.text}`;
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                const propName = getAccessedPropertyName(node as AccessExpression);
                if (propName !== undefined) {
                    const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);
                    return key && `${key}.${propName}`;
                }
                if (isElementAccessExpression(node) && isIdentifier(node.argumentExpression)) {
                    const symbol = getResolvedSymbol(node.argumentExpression);
                    // if (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {
                    //     const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);
                    //     return key && `${key}.@${getSymbolId(symbol)}`;
                    // }
                }
                break;
            // case SyntaxKind.ObjectBindingPattern:
            case SyntaxKind.ArrayBindingPattern:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InlineClosureExpression:
            // case SyntaxKind.MethodDeclaration:
                // Handle pseudo-references originating in getNarrowedTypeOfSymbol.
                return `${getNodeId(node)}#${getTypeId(declaredType)}`;
        }
        return undefined;
    }

    function reportFlowControlError(node: Node) {
        const block = findAncestor(node, isFunctionOrModuleBlock) as Block |  SourceFile;
        const sourceFile = getSourceFileOfNode(node);
        const span = getSpanOfTokenAtPosition(sourceFile, block.statements.pos);
        diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis));
    }

    function getTypeOfInitializer(node: Expression) {
        // Return the cached type if one is available. If the type of the variable was inferred
        // from its initializer, we'll already have cached the type. Otherwise we compute it now
        // without caching such that transient types are reflected.
        const links = getNodeLinks(node);
        return links.resolvedType || getTypeOfExpression(node);
    }

    function getInitialTypeOfVariableDeclaration(node: VariableDeclaration) {
        if (node.initializer) {
            return getTypeOfInitializer(node.initializer);
        }        
        if (node.parent.parent.kind === SyntaxKind.ForEachStatement) {            
            return checkRightHandSideOfForEach(node.parent.parent) || errorType;
        }
        return errorType;
    }

    function checkRightHandSideOfForEach(statement: ForEachStatement): Type {
        const use = /*statement.awaitModifier ? IterationUse.ForAwaitOf : */IterationUse.ForOf;
        return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
    }

    function includeUndefinedInIndexSignature(type: Type | undefined): Type | undefined {
        if (!type) return type;
        return compilerOptions.noUncheckedIndexedAccess ?
            getUnionType([type, missingType]) :
            type;
    }

    function checkIteratedTypeOrElementType(use: IterationUse, inputType: Type, sentType: Type, errorNode: Node | undefined): Type {
        if (isTypeAny(inputType)) {
            return inputType;
        }
        return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, /*checkAssignability*/ true) || anyType;
    }

    
    function getTypeOfDestructuredArrayElement(type: Type, index: number) {
        return includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, /*errorNode*/ undefined)) ||
            errorType;
    }
    
    function getInitialTypeOfBindingElement(node: BindingElement): Type {
        const pattern = node.parent;
        const parentType = getInitialType(pattern.parent as VariableDeclaration | BindingElement);
        const type = getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node));
        return getTypeWithDefault(type, node.initializer!);
    }

    function getTypeWithDefault(type: Type, defaultExpression: Expression) {
        return defaultExpression ?
            getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) :
            type;
    }

    function isGenericTypeWithUndefinedConstraint(type: Type) {
        return !!(type.flags & TypeFlags.Instantiable) && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.Undefined);
    }

    function getNonUndefinedType(type: Type) {
        const typeOrConstraint = someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type;
        return getTypeWithFacts(typeOrConstraint, TypeFacts.NEUndefined);
    }

    function getInitialType(node: VariableDeclaration | BindingElement) {
        return node.kind === SyntaxKind.VariableDeclaration ?
            getInitialTypeOfVariableDeclaration(node) :
            getInitialTypeOfBindingElement(node);
    }

    function checkRightHandSideOfForOf(statement: ForEachStatement): Type {
        const use = IterationUse.ForOf;//statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf;
        return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
    }

    function getAssignedType(node: Expression): Type {
        const { parent } = node;
        switch (parent.kind) {
            // case SyntaxKind.ForInStatement:
            //     return stringType;
            case SyntaxKind.ForEachStatement:                
                return checkRightHandSideOfForOf(parent as ForEachStatement) || errorType;
            case SyntaxKind.BinaryExpression:
                return getAssignedTypeOfBinaryExpression(parent as BinaryExpression);
            // case SyntaxKind.DeleteExpression:
            //     return undefinedType;
            case SyntaxKind.ArrayLiteralExpression:
                return getAssignedTypeOfArrayLiteralElement(parent as ArrayLiteralExpression, node);
            // case SyntaxKind.SpreadElement:
            //     return getAssignedTypeOfSpreadExpression(parent as SpreadElement);
            case SyntaxKind.PropertyAssignment:
                return getAssignedTypeOfPropertyAssignment(parent as PropertyAssignment);
            case SyntaxKind.ShorthandPropertyAssignment:
                Debug.fail("implement");
                //return getAssignedTypeOfShorthandPropertyAssignment(parent as ShorthandPropertyAssignment);
        }
        return errorType;
    }

    function getTypeOfDestructuredProperty(type: Type, name: PropertyName) {
        const nameType = getLiteralTypeFromPropertyName(name);
        //if (!isTypeUsableAsPropertyName(nameType)) return errorType;
        const text = getPropertyNameFromType(nameType as StringLiteralType);
        return getTypeOfPropertyOfType(type, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type, text)?.type) || errorType;
    }

    function getAssignedTypeOfPropertyAssignment(node: PropertyAssignment | ShorthandPropertyAssignment): Type {
        return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name);
    }

    function getAssignedTypeOfArrayLiteralElement(node: ArrayLiteralExpression, element: Expression): Type {
        return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element));
    }

    function getAssignedTypeOfBinaryExpression(node: BinaryExpression): Type {
        // const isDestructuringDefaultAssignment = node.parent.kind === SyntaxKind.ArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) ||
        //     node.parent.kind === SyntaxKind.PropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent);
        // return isDestructuringDefaultAssignment ?
        //     getTypeWithDefault(getAssignedType(node), node.right) :
        //     getTypeOfExpression(node.right);
        return getTypeOfExpression(node.right)
    }

    function createFlowType(type: Type, incomplete: boolean): FlowType {
        return incomplete ? { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } : type;
    }

    function isIncomplete(flowType: FlowType) {
        return flowType.flags === 0;
    }

    function isEmptyArrayAssignment(node: VariableDeclaration | BindingElement | Expression) {
        return node.kind === SyntaxKind.VariableDeclaration && (node as VariableDeclaration).initializer &&
                isEmptyArrayLiteral((node as VariableDeclaration).initializer!) ||
            node.kind !== SyntaxKind.BindingElement && node.parent.kind === SyntaxKind.BinaryExpression &&
                isEmptyArrayLiteral((node.parent as BinaryExpression).right);
    }

    
    // An evolving array type tracks the element types that have so far been seen in an
    // 'x.push(value)' or 'x[n] = value' operation along the control flow graph. Evolving
    // array types are ultimately converted into manifest array types (using getFinalArrayType)
    // and never escape the getFlowTypeOfReference function.
    function createEvolvingArrayType(elementType: Type): EvolvingArrayType {
        const result = createObjectType(ObjectFlags.EvolvingArray) as EvolvingArrayType;
        result.elementType = elementType;
        return result;
    }

    function getEvolvingArrayType(elementType: Type): EvolvingArrayType {
        return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType));
    }
    
    // Remove those constituent types of declaredType to which no constituent type of assignedType is assignable.
    // For example, when a variable of type number | string | boolean is assigned a value of type number | boolean,
    // we remove type string.
    function getAssignmentReducedType(declaredType: UnionType, assignedType: Type) {
        if (declaredType === assignedType) {
            return declaredType;
        }
        if (assignedType.flags & TypeFlags.Never) {
            return assignedType;
        }
        const key = `A${getTypeId(declaredType)},${getTypeId(assignedType)}`;
        return getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType));
    }
    
    function getAssignmentReducedTypeWorker(declaredType: UnionType, assignedType: Type) {
        const filteredType = filterType(declaredType, t => typeMaybeAssignableTo(assignedType, t));
        // Ensure that we narrow to fresh types if the assignment is a fresh boolean literal type.
        const reducedType = assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType;
        // Our crude heuristic produces an invalid result in some cases: see GH#26130.
        // For now, when that happens, we give up and don't narrow at all.  (This also
        // means we'll never narrow for erroneous assignments where the assigned type
        // is not assignable to the declared type.)
        return isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType;
    }
    
    function typeMaybeAssignableTo(source: Type, target: Type) {
        if (!(source.flags & TypeFlags.Union)) {
            return isTypeAssignableTo(source, target);
        }
        for (const t of (source as UnionType).types) {
            if (isTypeAssignableTo(t, target)) {
                return true;
            }
        }
        return false;
    }

    function getReferenceCandidate(node: Expression): Expression {
        switch (node.kind) {
            case SyntaxKind.ParenthesizedExpression:
                return getReferenceCandidate((node as ParenthesizedExpression).expression);
            case SyntaxKind.BinaryExpression:
                switch ((node as BinaryExpression).operatorToken.kind) {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.BarBarEqualsToken:
                    case SyntaxKind.AmpersandAmpersandEqualsToken:
                    case SyntaxKind.QuestionQuestionEqualsToken:
                        return getReferenceCandidate((node as BinaryExpression).left);
                    case SyntaxKind.CommaToken:
                        return getReferenceCandidate((node as BinaryExpression).right);
                }
        }
        return node;
    }

    function isEvolvingArrayTypeList(types: Type[]) {
        let hasEvolvingArrayType = false;
        for (const t of types) {
            if (!(t.flags & TypeFlags.Never)) {
                if (!(getObjectFlags(t) & ObjectFlags.EvolvingArray)) {
                    return false;
                }
                hasEvolvingArrayType = true;
            }
        }
        return hasEvolvingArrayType;
    }

    function getElementTypeOfEvolvingArrayType(type: Type) {
        return getObjectFlags(type) & ObjectFlags.EvolvingArray ? (type as EvolvingArrayType).elementType : neverType;
    }

    function recombineUnknownType(type: Type) {
        return type === unknownUnionType ? unknownType : type;
    }

    function getGlobalNonNullableTypeInstantiation(type: Type) {        
        if (!deferredGlobalNonNullableTypeAlias) {
            deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable" as string, SymbolFlags.TypeAlias, /*diagnostic*/ undefined) || unknownSymbol;
        }
        return deferredGlobalNonNullableTypeAlias !== unknownSymbol ?
            getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :
            getIntersectionType([type, emptyObjectType]);
    }

    // This function is similar to getTypeWithFacts, except that in strictNullChecks mode it replaces type
    // unknown with the union {} | null | undefined (and reduces that accordingly), and it intersects remaining
    // instantiable types with {}, {} | null, or {} | undefined in order to remove null and/or undefined.
    function getAdjustedTypeWithFacts(type: Type, facts: TypeFacts) {
        const reduced = recombineUnknownType(getTypeWithFacts(strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type, facts));
        if (strictNullChecks) {
            switch (facts) {
                // case TypeFacts.NEUndefined:
                //     return removeNullableByIntersection(reduced, TypeFacts.EQUndefined, TypeFacts.EQNull, TypeFacts.IsNull, nullType);
                // case TypeFacts.NENull:
                //     return removeNullableByIntersection(reduced, TypeFacts.EQNull, TypeFacts.EQUndefined, TypeFacts.IsUndefined, undefinedType);
                case TypeFacts.NEUndefinedOrNull:
                case TypeFacts.Truthy:
                    return mapType(reduced, t => hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t);
                default:
                    console.debug("todo - getAdjustedTypeWithFacts");
            }
        }
        return reduced;
    }

    function optionalChainContainsReference(source: Node, target: Node) {
        // while (isOptionalChain(source)) {
        //     source = source.expression;
        //     if (isMatchingReference(source, target)) {
        //         return true;
        //     }
        // }
        return false;
    }

    // Return a new type in which occurrences of the string, number and bigint primitives and placeholder template
    // literal types in typeWithPrimitives have been replaced with occurrences of compatible and more specific types
    // from typeWithLiterals. This is essentially a limited form of intersection between the two types. We avoid a
    // true intersection because it is more costly and, when applied to union types, generates a large number of
    // types we don't actually care about.
    function replacePrimitivesWithLiterals(typeWithPrimitives: Type, typeWithLiterals: Type) {
        if (
            maybeTypeOfKind(typeWithPrimitives, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.Number | TypeFlags.Float) &&
            maybeTypeOfKind(typeWithLiterals, TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping | TypeFlags.IntLiteral | TypeFlags.FloatLiteral)
        ) {
            return mapType(typeWithPrimitives, t =>
                t.flags & TypeFlags.String ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) :
                    //isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) :
                    t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.IntLiteral) :
                    t.flags & TypeFlags.Float ? extractTypesOfKind(typeWithLiterals, TypeFlags.Float | TypeFlags.FloatLiteral) : t);
        }
        return typeWithPrimitives;
    }

    function isUnitLikeType(type: Type): boolean {
        // Intersections that reduce to 'never' (e.g. 'T & null' where 'T extends {}') are not unit types.
        const t = getBaseConstraintOrType(type);
        // Scan intersections such that tagged literal types are considered unit types.
        return t.flags & TypeFlags.Intersection ? some((t as IntersectionType).types, isUnitType) : isUnitType(t);        
    }
    
    function getTypeOfSwitchClause(clause: CaseClause | DefaultClause) {
        if (clause.kind === SyntaxKind.CaseClause) {
            return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression));
        }
        return neverType;
    }

    function getSwitchClauseTypes(switchStatement: SwitchStatement): Type[] {
        const links = getNodeLinks(switchStatement);
        if (!links.switchTypes) {
            links.switchTypes = [];
            for (const clause of switchStatement.caseBlock.clauses) {
                links.switchTypes.push(getTypeOfSwitchClause(clause));
            }
        }
        return links.switchTypes;
    }

    function extractUnitType(type: Type) {
        return type.flags & TypeFlags.Intersection ? find((type as IntersectionType).types, isUnitType) || type : type;        
    }

    function isTypeSubtypeOf(source: Type, target: Type): boolean {
        return isTypeRelatedTo(source, target, subtypeRelation);
    }

    function isFunctionType(type: Type): boolean {
        return !!(type.flags & TypeFlags.Object) && getSignaturesOfType(type, SignatureKind.Call).length > 0;
    }
    
    // An object type S is considered to be derived from an object type T if
    // S is a union type and every constituent of S is derived from T,
    // T is a union type and S is derived from at least one constituent of T, or
    // S is an intersection type and some constituent of S is derived from T, or
    // S is a type variable with a base constraint that is derived from T, or
    // T is {} and S is an object-like type (ensuring {} is less derived than Object), or
    // T is one of the global types Object and Function and S is a subtype of T, or
    // T occurs directly or indirectly in an 'extends' clause of S.
    // Note that this check ignores type parameters and only considers the
    // inheritance hierarchy.
    function isTypeDerivedFrom(source: Type, target: Type): boolean {
        return source.flags & TypeFlags.Union ? every((source as UnionType).types, t => isTypeDerivedFrom(t, target)) :
            target.flags & TypeFlags.Union ? some((target as UnionType).types, t => isTypeDerivedFrom(source, t)) :
            source.flags & TypeFlags.Intersection ? some((source as IntersectionType).types, t => isTypeDerivedFrom(t, target)) :
            source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :
            isEmptyAnonymousObjectType(target) ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) :
            target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) && !isEmptyAnonymousObjectType(source) :
            target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType) :
            hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType));
    }

    function isReadonlyArrayType(type: Type): boolean {
        return !!(getObjectFlags(type) & ObjectFlags.Reference) && (type as TypeReference).target === globalReadonlyArrayType;
    }

    function getTargetType(type: Type): Type {
        return getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target : type;
    }

    function isFunctionObjectType(type: ObjectType): boolean {
        // We do a quick check for a "bind" property before performing the more expensive subtype
        // check. This gives us a quicker out in the common case where an object type is not a function.
        const resolved = resolveStructuredTypeMembers(type);
        return !!(resolved.callSignatures.length || resolved.constructSignatures.length ||
            resolved.members.get("bind" as string) && isTypeSubtypeOf(type, globalFunctionType));
    }

    // TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
    function hasBaseType(type: Type, checkBase: Type | undefined) {
        return check(type);
        function check(type: Type): boolean {
            if (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference)) {
                const target = getTargetType(type) as InterfaceType;
                return target === checkBase || some(getBaseTypes(target), check);
            }
            else if (type.flags & TypeFlags.Intersection) {
                return some((type as IntersectionType).types, check);
            }
            return false;
        }
    }

    // Return the name of a discriminant property for which it was possible and feasible to construct a map of
    // constituent types keyed by the literal types of the property by that name in each constituent type.
    function getKeyPropertyName(unionType: UnionType): string | undefined {
        const types = unionType.types;
        // We only construct maps for unions with many non-primitive constituents.
        if (
            types.length < 10 || getObjectFlags(unionType) & ObjectFlags.PrimitiveUnion ||
            countWhere(types, t => !!(t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive))) < 10
        ) {
            return undefined;
        }
        if (unionType.keyPropertyName === undefined) {
            // The candidate key property name is the name of the first property with a unit type in one of the
            // constituent types.
            const keyPropertyName = forEach(types, t =>
                t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ?
                    forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.name : undefined) :
                    undefined);
            const mapByKeyProperty = keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName);
            unionType.keyPropertyName = mapByKeyProperty ? keyPropertyName : "" as string;
            unionType.constituentMap = mapByKeyProperty;
        }
        return (unionType.keyPropertyName as string).length ? unionType.keyPropertyName : undefined;
    }

    // Given a set of constituent types and a property name, create and return a map keyed by the literal
    // types of the property by that name in each constituent type. No map is returned if some key property
    // has a non-literal type or if less than 10 or less than 50% of the constituents have a unique key.
    // Entries with duplicate keys have unknownType as the value.
    function mapTypesByKeyProperty(types: Type[], name: string) {
        const map = new Map<TypeId, Type>();
        let count = 0;
        for (const type of types) {
            if (type.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {
                const discriminant = getTypeOfPropertyOfType(type, name);
                if (discriminant) {
                    if (!isLiteralType(discriminant)) {
                        return undefined;
                    }
                    let duplicate = false;
                    forEachType(discriminant, t => {
                        const id = getTypeId(getRegularTypeOfLiteralType(t));
                        const existing = map.get(id);
                        if (!existing) {
                            map.set(id, type);
                        }
                        else if (existing !== unknownType) {
                            map.set(id, unknownType);
                            duplicate = true;
                        }
                    });
                    if (!duplicate) count++;
                }
            }
        }
        return count >= 10 && count * 2 >= types.length ? map : undefined;
    }

    // Given a union type for which getKeyPropertyName returned a non-undefined result, return the constituent
    // that corresponds to the given key type for that property name.
    function getConstituentTypeForKeyType(unionType: UnionType, keyType: Type) {
        const result = unionType.constituentMap?.get(getTypeId(getRegularTypeOfLiteralType(keyType)));
        return result !== unknownType ? result : undefined;
    }

    function isTypeStrictSubtypeOf(source: Type, target: Type): boolean {
        // plain objects are not a subtype of named objects
        if ((source.flags & TypeFlags.Object) && isAnonymousObjectType(target)) {
            return false;
        }
        return isTypeRelatedTo(source, target, strictSubtypeRelation);
    }
    
    function getTypePredicateArgument(predicate: TypePredicate, callExpression: CallExpression) {
        if (predicate.kind === TypePredicateKind.Identifier || predicate.kind === TypePredicateKind.AssertsIdentifier) {
            return callExpression.arguments[predicate.parameterIndex];
        }
        const invokedExpression = skipParentheses(callExpression.expression);
        return isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined;
    }

    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     * It is intended for uses where you know there is no contextual type,
     * and requesting the contextual type might cause a circularity or other bad behaviour.
     * It sets the contextual type of the node to any before calling getTypeOfExpression.
     */
    function getContextFreeTypeOfExpression(node: Expression) {
        const links = getNodeLinks(node);
        if (links.contextFreeType) {
            return links.contextFreeType;
        }
        pushContextualType(node, anyType, /*isCache*/ false);
        const type = links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive);
        popContextualType();
        return type;
    }


    function getFlowTypeOfReference(reference: Node, declaredType: Type, initialType = declaredType, flowContainer?: Node, flowNode = tryCast(reference, canHaveFlowNode)?.flowNode) {
        let key: string | undefined;
        let isKeySet = false;
        let flowDepth = 0;
        if (flowAnalysisDisabled) {
            return errorType;
        }
        if (!flowNode) {
            return declaredType;
        }
        flowInvocationCount++;
        const sharedFlowStart = sharedFlowCount;
        const evolvedType =  getTypeFromFlowType(getTypeAtFlowNode(flowNode));
        sharedFlowCount = sharedFlowStart;
        // When the reference is 'x' in an 'x.length', 'x.push(value)', 'x.unshift(value)' or x[n] = value' operation,
        // we give type 'any[]' to 'x' instead of using the type determined by control flow analysis such that operations
        // on empty arrays are possible without implicit any errors and new element types can be inferred without
        // type mismatch errors.
        const resultType = getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType);
        if (resultType === unreachableNeverType && !(resultType.flags & TypeFlags.Never) && getTypeWithFacts(resultType, TypeFacts.NEUndefinedOrNull).flags & TypeFlags.Never) {
            return declaredType;
        }
        return resultType;

        function getOrSetCacheKey() {
            if (isKeySet) {
                return key;
            }
            isKeySet = true;
            return key = getFlowCacheKey(reference, declaredType, initialType, flowContainer);
        }

        function getTypeAtFlowNode(flow: FlowNode): FlowType {
            if (flowDepth === 2000) {
                // We have made 2000 recursive invocations. To avoid overflowing the call stack we report an error
                // and disable further control flow analysis in the containing function or module body.
                tracing?.instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit", { flowId: flow.id });
                flowAnalysisDisabled = true;
                reportFlowControlError(reference);
                return errorType;
            }
            flowDepth++;
            let sharedFlow: FlowNode | undefined;
            while (true) {
                const flags = flow.flags;
                if (flags & FlowFlags.Shared) {
                    // We cache results of flow type resolution for shared nodes that were previously visited in
                    // the same getFlowTypeOfReference invocation. A node is considered shared when it is the
                    // antecedent of more than one node.
                    for (let i = sharedFlowStart; i < sharedFlowCount; i++) {
                        if (sharedFlowNodes[i] === flow) {
                            flowDepth--;
                            return sharedFlowTypes[i];
                        }
                    }
                    sharedFlow = flow;
                }
                let type: FlowType | undefined;
                if (flags & FlowFlags.Assignment) {
                    type = getTypeAtFlowAssignment(flow as FlowAssignment);
                    if (!type) {
                        flow = (flow as FlowAssignment).antecedent;
                        continue;
                    }
                }
                else if (flags & FlowFlags.Call) {
                    type = getTypeAtFlowCall(flow as FlowCall);
                    if (!type) {
                        flow = (flow as FlowCall).antecedent;
                        continue;
                    }
                }
                else if (flags & FlowFlags.Condition) {
                    type = getTypeAtFlowCondition(flow as FlowCondition);
                }
                else if (flags & FlowFlags.SwitchClause) {
                    type = getTypeAtSwitchClause(flow as FlowSwitchClause);
                }
                else if (flags & FlowFlags.Label) {
                    if ((flow as FlowLabel).antecedent!.length === 1) {
                        flow = (flow as FlowLabel).antecedent![0];
                        continue;
                    }
                    type = flags & FlowFlags.BranchLabel ?
                        getTypeAtFlowBranchLabel(flow as FlowLabel) :
                        getTypeAtFlowLoopLabel(flow as FlowLabel);
                }
                else if (flags & FlowFlags.ArrayMutation) {
                    type = getTypeAtFlowArrayMutation(flow as FlowArrayMutation);
                    if (!type) {
                        flow = (flow as FlowArrayMutation).antecedent;
                        continue;
                    }
                }
                else if (flags & FlowFlags.ReduceLabel) {
                    const target = (flow as FlowReduceLabel).node.target;
                    const saveAntecedents = target.antecedent;
                    target.antecedent = (flow as FlowReduceLabel).node.antecedents;
                    type = getTypeAtFlowNode((flow as FlowReduceLabel).antecedent);
                    target.antecedent = saveAntecedents;
                }
                else if (flags & FlowFlags.Start) {
                    // Check if we should continue with the control flow of the containing function.
                    const container = (flow as FlowStart).node;
                    if (
                        container && container !== flowContainer &&
                        reference.kind !== SyntaxKind.PropertyAccessExpression &&
                        reference.kind !== SyntaxKind.ElementAccessExpression                        
                    ) {
                        flow = container.flowNode!;
                        continue;
                    }
                    // At the top of the flow we have the initial type.
                    type = initialType;
                }
                else {
                    // Unreachable code errors are reported in the binding phase. Here we
                    // simply return the non-auto declared type to reduce follow-on errors.
                    type = convertAutoToAny(declaredType);
                }
                if (sharedFlow) {
                    // Record visited node and the associated type in the cache.
                    sharedFlowNodes[sharedFlowCount] = sharedFlow;
                    sharedFlowTypes[sharedFlowCount] = type;
                    sharedFlowCount++;
                }
                flowDepth--;
                return type;
            }
        }

        function getInitialOrAssignedType(flow: FlowAssignment) {
            const node = flow.node;
            return getNarrowableTypeForReference(
                node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ?
                    getInitialType(node as VariableDeclaration | BindingElement) :
                    getAssignedType(node),
                reference,
            );
        }
        

        function getTypeAtFlowAssignment(flow: FlowAssignment) {
            const node = flow.node;
            // Assignments only narrow the computed type if the declared type is a union type. Thus, we
            // only need to evaluate the assigned type if the declared type is a union type.
            if (isMatchingReference(reference, node)) {
                if (!isReachableFlowNode(flow)) {
                    return unreachableNeverType;
                }
                if (getAssignmentTargetKind(node) === AssignmentKind.Compound) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType));
                }
                // LPC object & mixed types should act like auto here.
                if (declaredType === autoType || 
                    declaredType === autoArrayType || 
                    declaredType === objectType || 
                    declaredType === mixedType || 
                    isMappingType(declaredType) ||
                    // see https://github.com/jlchmura/lpc-language-server/issues/190
                    (isArrayType(declaredType) && declaredType.resolvedTypeArguments && !isAnonymousObjectType(first(declaredType.resolvedTypeArguments)))
                ) {
                    if (isEmptyArrayAssignment(node)) {
                        return getEvolvingArrayType(neverType);
                    }
                    const assignedType = getWidenedLiteralType(getInitialOrAssignedType(flow));
                    return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
                }
                const t = isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType;
                if (t.flags & TypeFlags.Union) {
                    return getAssignmentReducedType(t as UnionType, getInitialOrAssignedType(flow));
                }
                return t;
            }
            // We didn't have a direct match. However, if the reference is a dotted name, this
            // may be an assignment to a left hand part of the reference. For example, for a
            // reference 'x.y.z', we may be at an assignment to 'x.y' or 'x'. In that case,
            // return the declared type.
            if (containsMatchingReference(reference, node)) {
                if (!isReachableFlowNode(flow)) {
                    return unreachableNeverType;
                }
                // A matching dotted name might also be an expando property on a function *expression*,
                // in which case we continue control flow analysis back to the function's declaration
                // if (isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node))) {
                //     const init = getDeclaredExpandoInitializer(node);
                //     if (init && (init.kind === SyntaxKind.FunctionExpression || init.kind === SyntaxKind.ArrowFunction)) {
                //         return getTypeAtFlowNode(flow.antecedent);
                //     }
                // }
                return declaredType;
            }
            // for (const _ in ref) acts as a nonnull on ref
            if (
                isVariableDeclaration(node) &&
                node.parent.parent.kind === SyntaxKind.ForEachStatement &&
                (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference))
            ) {
                return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))));
            }
            // Assignment doesn't affect reference
            return undefined;
        }

        function narrowTypeByAssertion(type: Type, expr: Expression): Type {
            const node = skipParentheses(expr, /*excludeJSDocTypeAssertions*/ true);
            if (node.kind === SyntaxKind.FalseKeyword) {
                return unreachableNeverType;
            }
            if (node.kind === SyntaxKind.BinaryExpression) {
                if ((node as BinaryExpression).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {
                    return narrowTypeByAssertion(narrowTypeByAssertion(type, (node as BinaryExpression).left), (node as BinaryExpression).right);
                }
                if ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken) {
                    return getUnionType([narrowTypeByAssertion(type, (node as BinaryExpression).left), narrowTypeByAssertion(type, (node as BinaryExpression).right)]);
                }
            }
            return narrowType(type, node, /*assumeTrue*/ true);
        }

        function getTypeAtFlowCall(flow: FlowCall): FlowType | undefined {
            const signature = getEffectsSignature(flow.node);
            if (signature) {
                const predicate = getTypePredicateOfSignature(signature);
                if (predicate && (predicate.kind === TypePredicateKind.AssertsIdentifier)) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    const type = finalizeEvolvingArrayType(getTypeFromFlowType(flowType));
                    const narrowedType = predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue*/ true) :
                        predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) :
                        type;
                    return narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType));
                }
                if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {
                    return unreachableNeverType;
                }
            }
            return undefined;
        }

        function narrowTypeByTypePredicate(type: Type, predicate: TypePredicate, callExpression: CallExpression, assumeTrue: boolean): Type {
            // Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
            if (predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))) {
                const predicateArgument = getTypePredicateArgument(predicate, callExpression);
                if (predicateArgument) {
                    if (isMatchingReference(reference, predicateArgument)) {
                        // TODO - In LPC, should we always return the type predicate type?  Even if its not compatible?
                        // a better way to do this might be to adjust the isRelated tests in getNarrowType 
                        // console.debug("TODO - narrowTypeByTypePredicate is assumedTrue");
                        // return assumeTrue ? predicate.type : type;                        
                        return getNarrowedType(type, predicate.type, assumeTrue, /*checkDerived*/ false);
                    }
                    if (
                        strictNullChecks && optionalChainContainsReference(predicateArgument, reference) &&
                        (
                            assumeTrue && !(hasTypeFacts(predicate.type, TypeFacts.EQUndefined)) ||
                            !assumeTrue && everyType(predicate.type, isNullableType)
                        )
                    ) {
                        type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
                    }
                    const access = getDiscriminantPropertyAccess(predicateArgument, type);
                    if (access) {
                        return narrowTypeByDiscriminant(type, access, t => getNarrowedType(t, predicate.type!, assumeTrue, /*checkDerived*/ false));
                    }
                }
            }
            return type;
        }

        // When adding evolving array element types we do not perform subtype reduction. Instead,
        // we defer subtype reduction until the evolving array type is finalized into a manifest
        // array type.
        function addEvolvingArrayElementType(evolvingArrayType: EvolvingArrayType, node: Expression): EvolvingArrayType {
            const elementType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)));
            return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType]));
        }
        
        function getTypeAtFlowArrayMutation(flow: FlowArrayMutation): FlowType | undefined {
            if (declaredType === autoType || declaredType === autoArrayType) {
                const node = flow.node;
                const expr = node.kind === SyntaxKind.CallExpression ?
                    (node.expression as PropertyAccessExpression).expression :
                    (node.left as ElementAccessExpression).expression;
                if (isMatchingReference(reference, getReferenceCandidate(expr))) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    const type = getTypeFromFlowType(flowType);
                    if (getObjectFlags(type) & ObjectFlags.EvolvingArray) {
                        let evolvedType = type as EvolvingArrayType;
                        console.warn("TODO - getTypeAtFlowArrayMutation");
                        if (node.kind === SyntaxKind.CallExpression) {
                            for (const arg of node.arguments) {
                                evolvedType = addEvolvingArrayElementType(evolvedType, arg);
                            }
                        }
                        else {
                            // We must get the context free expression type so as to not recur in an uncached fashion on the LHS (which causes exponential blowup in compile time)
                            const indexType = getContextFreeTypeOfExpression((node.left as ElementAccessExpression).argumentExpression);
                            if (isTypeAssignableToKind(indexType, TypeFlags.NumberLike)) {
                                evolvedType = addEvolvingArrayElementType(evolvedType, node.right);
                            }
                        }
                        return evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType));
                    }
                    return flowType;
                }
            }
            return undefined;
        }

        function getTypeAtFlowCondition(flow: FlowCondition): FlowType {
            const flowType = getTypeAtFlowNode(flow.antecedent);
            const type = getTypeFromFlowType(flowType);
            if (type.flags & TypeFlags.Never) {
                return flowType;
            }
            // If we have an antecedent type (meaning we're reachable in some way), we first
            // attempt to narrow the antecedent type. If that produces the never type, and if
            // the antecedent type is incomplete (i.e. a transient type in a loop), then we
            // take the type guard as an indication that control *could* reach here once we
            // have the complete type. We proceed by switching to the silent never type which
            // doesn't report errors when operators are applied to it. Note that this is the
            // *only* place a silent never type is ever generated.
            const assumeTrue = (flow.flags & FlowFlags.TrueCondition) !== 0;
            const nonEvolvingType = finalizeEvolvingArrayType(type);
            const narrowedType = narrowType(nonEvolvingType, flow.node, assumeTrue);
            if (narrowedType === nonEvolvingType) {
                return flowType;
            }
            return createFlowType(narrowedType, isIncomplete(flowType));
        }

        function getTypeAtSwitchClause(flow: FlowSwitchClause): FlowType {
            const expr = skipParentheses(flow.node.switchStatement.expression);
            const flowType = getTypeAtFlowNode(flow.antecedent);
            let type = getTypeFromFlowType(flowType);
            if (isMatchingReference(reference, expr)) {
                type = narrowTypeBySwitchOnDiscriminant(type, flow.node);
            }
            // else if (expr.kind === SyntaxKind.TypeOfExpression && isMatchingReference(reference, (expr as TypeOfExpression).expression)) {
            //     type = narrowTypeBySwitchOnTypeOf(type, flow.node);
            // }
            else if (expr.kind === SyntaxKind.TrueKeyword) {
                type = narrowTypeBySwitchOnTrue(type, flow.node);
            }
            else {
                if (strictNullChecks) {
                    // if (optionalChainContainsReference(expr, reference)) {
                    //     type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & (TypeFlags.Undefined | TypeFlags.Never)));
                    // }
                    // else if (expr.kind === SyntaxKind.TypeOfExpression && optionalChainContainsReference((expr as TypeOfExpression).expression, reference)) {
                    //     type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & TypeFlags.Never || t.flags & TypeFlags.StringLiteral && (t as StringLiteralType).value === "undefined"));
                    // }
                }
                const access = getDiscriminantPropertyAccess(expr, type);
                if (access) {
                    type = narrowTypeBySwitchOnDiscriminantProperty(type, access, flow.node);
                }
            }
            return createFlowType(type, isIncomplete(flowType));
        }

        function getTypeAtFlowBranchLabel(flow: FlowLabel): FlowType {
            const antecedentTypes: Type[] = [];
            let subtypeReduction = false;
            let seenIncomplete = false;
            let bypassFlow: FlowSwitchClause | undefined;
            for (const antecedent of flow.antecedent!) {
                if (!bypassFlow && antecedent.flags & FlowFlags.SwitchClause && (antecedent as FlowSwitchClause).node.clauseStart === (antecedent as FlowSwitchClause).node.clauseEnd) {
                    // The antecedent is the bypass branch of a potentially exhaustive switch statement.
                    bypassFlow = antecedent as FlowSwitchClause;
                    continue;
                }
                const flowType = getTypeAtFlowNode(antecedent);
                const type = getTypeFromFlowType(flowType);
                // If the type at a particular antecedent path is the declared type and the
                // reference is known to always be assigned (i.e. when declared and initial types
                // are the same), there is no reason to process more antecedents since the only
                // possible outcome is subtypes that will be removed in the final union type anyway.
                if (type === declaredType && declaredType === initialType) {
                    return type;
                }
                pushIfUnique(antecedentTypes, type);
                // If an antecedent type is not a subset of the declared type, we need to perform
                // subtype reduction. This happens when a "foreign" type is injected into the control
                // flow using the instanceof operator or a user defined type predicate.
                if (!isTypeSubsetOf(type, initialType)) {
                    subtypeReduction = true;
                }
                if (isIncomplete(flowType)) {
                    seenIncomplete = true;
                }
            }
            if (bypassFlow) {
                const flowType = getTypeAtFlowNode(bypassFlow);
                const type = getTypeFromFlowType(flowType);
                // If the bypass flow contributes a type we haven't seen yet and the switch statement
                // isn't exhaustive, process the bypass flow type. Since exhaustiveness checks increase
                // the risk of circularities, we only want to perform them when they make a difference.
                if (!(type.flags & TypeFlags.Never) && !contains(antecedentTypes, type) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement)) {
                    if (type === declaredType && declaredType === initialType) {
                        return type;
                    }
                    antecedentTypes.push(type);
                    if (!isTypeSubsetOf(type, initialType)) {
                        subtypeReduction = true;
                    }
                    if (isIncomplete(flowType)) {
                        seenIncomplete = true;
                    }
                }
            }
            return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal), seenIncomplete);
        }

        function getTypeAtFlowLoopLabel(flow: FlowLabel): FlowType {
            // If we have previously computed the control flow type for the reference at
            // this flow loop junction, return the cached type.
            const id = getFlowNodeId(flow);
            const cache = flowLoopCaches[id] || (flowLoopCaches[id] = new Map<string, Type>());
            const key = getOrSetCacheKey();
            if (!key) {
                // No cache key is generated when binding patterns are in unnarrowable situations
                return declaredType;
            }
            const cached = cache.get(key);
            if (cached) {
                return cached;
            }
            // If this flow loop junction and reference are already being processed, return
            // the union of the types computed for each branch so far, marked as incomplete.
            // It is possible to see an empty array in cases where loops are nested and the
            // back edge of the outer loop reaches an inner loop that is already being analyzed.
            // In such cases we restart the analysis of the inner loop, which will then see
            // a non-empty in-process array for the outer loop and eventually terminate because
            // the first antecedent of a loop junction is always the non-looping control flow
            // path that leads to the top.
            for (let i = flowLoopStart; i < flowLoopCount; i++) {
                if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {
                    return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), /*incomplete*/ true);
                }
            }
            // Add the flow loop junction and reference to the in-process stack and analyze
            // each antecedent code path.
            const antecedentTypes: Type[] = [];
            let subtypeReduction = false;
            let firstAntecedentType: FlowType | undefined;
            for (const antecedent of flow.antecedent!) {
                let flowType;
                if (!firstAntecedentType) {
                    // The first antecedent of a loop junction is always the non-looping control
                    // flow path that leads to the top.
                    flowType = firstAntecedentType = getTypeAtFlowNode(antecedent);
                }
                else {
                    // All but the first antecedent are the looping control flow paths that lead
                    // back to the loop junction. We track these on the flow loop stack.
                    flowLoopNodes[flowLoopCount] = flow;
                    flowLoopKeys[flowLoopCount] = key;
                    flowLoopTypes[flowLoopCount] = antecedentTypes;
                    flowLoopCount++;
                    const saveFlowTypeCache = flowTypeCache;
                    flowTypeCache = undefined;
                    flowType = getTypeAtFlowNode(antecedent);
                    flowTypeCache = saveFlowTypeCache;
                    flowLoopCount--;
                    // If we see a value appear in the cache it is a sign that control flow analysis
                    // was restarted and completed by checkExpressionCached. We can simply pick up
                    // the resulting type and bail out.
                    const cached = cache.get(key);
                    if (cached) {
                        return cached;
                    }
                }
                const type = getTypeFromFlowType(flowType);
                pushIfUnique(antecedentTypes, type);
                // If an antecedent type is not a subset of the declared type, we need to perform
                // subtype reduction. This happens when a "foreign" type is injected into the control
                // flow using the instanceof operator or a user defined type predicate.
                if (!isTypeSubsetOf(type, initialType)) {
                    subtypeReduction = true;
                }
                // If the type at a particular antecedent path is the declared type there is no
                // reason to process more antecedents since the only possible outcome is subtypes
                // that will be removed in the final union type anyway.
                if (type === declaredType) {
                    break;
                }
            }
            // The result is incomplete if the first antecedent (the non-looping control flow path)
            // is incomplete.
            const result = getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal);
            if (isIncomplete(firstAntecedentType!)) {
                return createFlowType(result, /*incomplete*/ true);
            }
            cache.set(key, result);
            return result;
        }

        // At flow control branch or loop junctions, if the type along every antecedent code path
        // is an evolving array type, we construct a combined evolving array type. Otherwise we
        // finalize all evolving array types.
        function getUnionOrEvolvingArrayType(types: Type[], subtypeReduction: UnionReduction) {
            if (isEvolvingArrayTypeList(types)) {
                return getEvolvingArrayType(getUnionType(map(types, getElementTypeOfEvolvingArrayType)));
            }
            const result = recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction));
            if (result !== declaredType && result.flags & declaredType.flags & TypeFlags.Union && arrayIsEqualTo((result as UnionType).types, (declaredType as UnionType).types)) {
                return declaredType;
            }
            return result;
        }

        function getCandidateDiscriminantPropertyAccess(expr: Expression) {
            if (isBindingPattern(reference) || isFunctionExpressionOrInlineClosure(reference) || isObjectLiteralMethod(reference)) {
                // When the reference is a binding pattern or function or arrow expression, we are narrowing a pesudo-reference in
                // getNarrowedTypeOfSymbol. An identifier for a destructuring variable declared in the same binding pattern or
                // parameter declared in the same parameter list is a candidate.
                if (isIdentifier(expr)) {
                    const symbol = getResolvedSymbol(expr);
                    const declaration = symbol.valueDeclaration;
                    if (declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference === declaration.parent && !declaration.initializer && !declaration.dotDotDotToken) {
                        return declaration;
                    }
                }
            }
            else if (isAccessExpression(expr)) {
                // An access expression is a candidate if the reference matches the left hand expression.
                if (isMatchingReference(reference, expr.expression)) {
                    return expr;
                }
            }
            else if (isIdentifier(expr)) {
                const symbol = getResolvedSymbol(expr);
                // if (isConstantVariable(symbol)) {
                //     const declaration = symbol.valueDeclaration!;
                //     // Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'
                //     if (
                //         isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer) &&
                //         isMatchingReference(reference, declaration.initializer.expression)
                //     ) {
                //         return declaration.initializer;
                //     }
                //     // Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'
                //     if (isBindingElement(declaration) && !declaration.initializer) {
                //         const parent = declaration.parent.parent;
                //         if (
                //             isVariableDeclaration(parent) && !parent.type && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) &&
                //             isMatchingReference(reference, parent.initializer)
                //         ) {
                //             return declaration;
                //         }
                //     }
                // }
            }
            return undefined;
        }

        function getDiscriminantPropertyAccess(expr: Expression, computedType: Type) {
            // As long as the computed type is a subset of the declared type, we use the full declared type to detect
            // a discriminant property. In cases where the computed type isn't a subset, e.g because of a preceding type
            // predicate narrowing, we use the actual computed type.
            if (declaredType.flags & TypeFlags.Union || computedType.flags & TypeFlags.Union) {
                const access = getCandidateDiscriminantPropertyAccess(expr);
                if (access) {
                    const name = getAccessedPropertyName(access);
                    if (name) {
                        const type = declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType;
                        if (isDiscriminantProperty(type, name)) {
                            return access;
                        }
                    }
                }
            }
            return undefined;
        }

        function narrowTypeByDiscriminant(type: Type, access: AccessExpression | BindingElement | ParameterDeclaration, narrowType: (t: Type) => Type): Type {
            const propName = getAccessedPropertyName(access);
            if (propName === undefined) {
                return type;
            }
            const optionalChain = false;// isOptionalChain(access);
            const removeNullable = strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type, TypeFlags.Nullable);
            let propType = getTypeOfPropertyOfType(removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type, propName);
            if (!propType) {
                return type;
            }
            propType = removeNullable && optionalChain ? getOptionalType(propType) : propType;
            const narrowedPropType = narrowType(propType);
            return filterType(type, t => {
                const discriminantType = getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType;
                return !(discriminantType.flags & TypeFlags.Never) && !(narrowedPropType.flags & TypeFlags.Never) && areTypesComparable(narrowedPropType, discriminantType);
            });
        }

        function narrowTypeByDiscriminantProperty(type: Type, access: AccessExpression | BindingElement | ParameterDeclaration, operator: SyntaxKind, value: Expression, assumeTrue: boolean) {
            if ((operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) && type.flags & TypeFlags.Union) {
                const keyPropertyName = getKeyPropertyName(type as UnionType);
                if (keyPropertyName && keyPropertyName === getAccessedPropertyName(access)) {
                    const candidate = getConstituentTypeForKeyType(type as UnionType, getTypeOfExpression(value));
                    if (candidate) {
                        return operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate :
                            isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :
                            type;
                    }
                }
            }
            return narrowTypeByDiscriminant(type, access, t => narrowTypeByEquality(t, operator, value, assumeTrue));
        }

        function narrowTypeBySwitchOnDiscriminantProperty(type: Type, access: AccessExpression | BindingElement | ParameterDeclaration, data: FlowSwitchClauseData) {
            if (data.clauseStart < data.clauseEnd && type.flags & TypeFlags.Union && getKeyPropertyName(type as UnionType) === getAccessedPropertyName(access)) {
                const clauseTypes = getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd);
                const candidate = getUnionType(map(clauseTypes, t => getConstituentTypeForKeyType(type as UnionType, t) || unknownType));
                if (candidate !== unknownType) {
                    return candidate;
                }
            }
            return narrowTypeByDiscriminant(type, access, t => narrowTypeBySwitchOnDiscriminant(t, data));
        }

        function narrowTypeByTruthiness(type: Type, expr: Expression, assumeTrue: boolean): Type {
            if (isMatchingReference(reference, expr)) {
                return getAdjustedTypeWithFacts(type, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy);
            }
            if (strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference)) {
                type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
            }
            const access = getDiscriminantPropertyAccess(expr, type);
            if (access) {
                return narrowTypeByDiscriminant(type, access, t => getTypeWithFacts(t, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy));
            }
            return type;
        }

        function isTypePresencePossible(type: Type, propName: string, assumeTrue: boolean) {
            const prop = getPropertyOfType(type, propName);
            return prop ?
                !!(prop.flags & SymbolFlags.Optional || getCheckFlags(prop) & CheckFlags.Partial) || assumeTrue :
                !!getApplicableIndexInfoForName(type, propName) || !assumeTrue;
        }

        function narrowTypeByInKeyword(type: Type, nameType: StringLiteralType | IntLiteralType, assumeTrue: boolean) {
            console.debug("todo - narrowTypeByInKeyword");
            const name = getPropertyNameFromType(nameType);
            const isKnownProperty = someType(type, t => isTypePresencePossible(t, name, /*assumeTrue*/ true));
            if (isKnownProperty) {
                // If the check is for a known property (i.e. a property declared in some constituent of
                // the target type), we filter the target type by presence of absence of the property.
                return filterType(type, t => isTypePresencePossible(t, name, assumeTrue));
            }
            // if (assumeTrue) {
            //     // If the check is for an unknown property, we intersect the target type with `Record<X, unknown>`,
            //     // where X is the name of the property.
            //     const recordSymbol = getGlobalRecordSymbol();
            //     if (recordSymbol) {
            //         return getIntersectionType([type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])]);
            //     }
            // }
            return type;
        }

        function narrowTypeByBooleanComparison(type: Type, expr: Expression, bool: LiteralLikeNode, operator: BinaryOperator, assumeTrue: boolean): Type {
            const boolVal = bool.text != "0" && bool.text !== "";
            assumeTrue = (assumeTrue !== (boolVal === true)) !== (operator !== SyntaxKind.ExclamationEqualsEqualsToken && operator !== SyntaxKind.ExclamationEqualsToken);
            return narrowType(type, expr, assumeTrue);
        }

        function narrowTypeByBinaryExpression(type: Type, expr: BinaryExpression, assumeTrue: boolean): Type {
            switch (expr.operatorToken.kind) {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.BarBarEqualsToken:
                case SyntaxKind.AmpersandAmpersandEqualsToken:
                case SyntaxKind.QuestionQuestionEqualsToken:
                    return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.EqualsEqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsEqualsToken:
                    const operator = expr.operatorToken.kind;
                    const left = getReferenceCandidate(expr.left);
                    const right = getReferenceCandidate(expr.right);
                    // if (left.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(right)) {
                    //     return narrowTypeByTypeof(type, left as TypeOfExpression, operator, right, assumeTrue);
                    // }
                    // if (right.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(left)) {
                    //     return narrowTypeByTypeof(type, right as TypeOfExpression, operator, left, assumeTrue);
                    // }
                    if (isMatchingReference(reference, left)) {
                        return narrowTypeByEquality(type, operator, right, assumeTrue);
                    }
                    if (isMatchingReference(reference, right)) {
                        return narrowTypeByEquality(type, operator, left, assumeTrue);
                    }
                    if (strictNullChecks) {
                        if (optionalChainContainsReference(left, reference)) {
                            type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);
                        }
                        else if (optionalChainContainsReference(right, reference)) {
                            type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);
                        }
                    }
                    const leftAccess = getDiscriminantPropertyAccess(left, type);
                    if (leftAccess) {
                        return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);
                    }
                    const rightAccess = getDiscriminantPropertyAccess(right, type);
                    if (rightAccess) {
                        return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);
                    }
                    if (isMatchingConstructorReference(left)) {
                        return narrowTypeByConstructor(type, operator, right, assumeTrue);
                    }
                    if (isMatchingConstructorReference(right)) {
                        return narrowTypeByConstructor(type, operator, left, assumeTrue);
                    }
                    if (isLiteralLike(right) && !isAccessExpression(left)) {
                        return narrowTypeByBooleanComparison(type, left, right, operator, assumeTrue);
                    }
                    if (isLiteralLike(left) && !isAccessExpression(right)) {
                        return narrowTypeByBooleanComparison(type, right, left, operator, assumeTrue);
                    }
                    break;
                // case SyntaxKind.InstanceOfKeyword:
                //     return narrowTypeByInstanceof(type, expr as InstanceofExpression, assumeTrue);
                case SyntaxKind.InKeyword:                
                    const target = getReferenceCandidate(expr.right);
                    if (containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(reference.expression, target)) {
                        const leftType = getTypeOfExpression(expr.left);
                        if (isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) === getPropertyNameFromType(leftType)) {
                            return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);
                        }
                    }
                    if (isMatchingReference(reference, target)) {
                        const leftType = getTypeOfExpression(expr.left);
                        if (isTypeUsableAsPropertyName(leftType)) {
                            return narrowTypeByInKeyword(type, leftType, assumeTrue);
                        }
                    }
                    break;
                case SyntaxKind.CommaToken:
                    return narrowType(type, expr.right, assumeTrue);
                // Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those
                // expressions down to individual conditional control flows. However, we may encounter them when analyzing
                // aliased conditional expressions.
                case SyntaxKind.AmpersandAmpersandToken:
                    return assumeTrue ?
                        narrowType(narrowType(type, expr.left, /*assumeTrue*/ true), expr.right, /*assumeTrue*/ true) :
                        getUnionType([narrowType(type, expr.left, /*assumeTrue*/ false), narrowType(type, expr.right, /*assumeTrue*/ false)]);
                case SyntaxKind.BarBarToken:
                    return assumeTrue ?
                        getUnionType([narrowType(type, expr.left, /*assumeTrue*/ true), narrowType(type, expr.right, /*assumeTrue*/ true)]) :
                        narrowType(narrowType(type, expr.left, /*assumeTrue*/ false), expr.right, /*assumeTrue*/ false);
            }
            return type;
        }
       
        function narrowTypeByOptionalChainContainment(type: Type, operator: SyntaxKind, value: Expression, assumeTrue: boolean): Type {
            // We are in a branch of obj?.foo === value (or any one of the other equality operators). We narrow obj as follows:
            // When operator is === and type of value excludes undefined, null and undefined is removed from type of obj in true branch.
            // When operator is !== and type of value excludes undefined, null and undefined is removed from type of obj in false branch.
            // When operator is == and type of value excludes null and undefined, null and undefined is removed from type of obj in true branch.
            // When operator is != and type of value excludes null and undefined, null and undefined is removed from type of obj in false branch.
            // When operator is === and type of value is undefined, null and undefined is removed from type of obj in false branch.
            // When operator is !== and type of value is undefined, null and undefined is removed from type of obj in true branch.
            // When operator is == and type of value is null or undefined, null and undefined is removed from type of obj in false branch.
            // When operator is != and type of value is null or undefined, null and undefined is removed from type of obj in true branch.
            const equalsOperator = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;
            const nullableFlags = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined;
            const valueType = getTypeOfExpression(value);
            // Note that we include any and unknown in the exclusion test because their domain includes null and undefined.
            const removeNullable = equalsOperator !== assumeTrue && everyType(valueType, t => !!(t.flags & nullableFlags)) ||
                equalsOperator === assumeTrue && everyType(valueType, t => !(t.flags & (TypeFlags.AnyOrUnknown | nullableFlags)));
            return removeNullable ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
        }

        function narrowTypeByEquality(type: Type, operator: SyntaxKind, value: Expression, assumeTrue: boolean): Type {
            if (type.flags & TypeFlags.Any) {
                return type;
            }
            if (operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) {
                assumeTrue = !assumeTrue;
            }
            const valueType = getTypeOfExpression(value);
            const doubleEquals = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken;
            if (valueType.flags & TypeFlags.Nullable) {
                if (!strictNullChecks) {
                    return type;
                }
                const facts = doubleEquals ?
                    assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull :
                    valueType.flags & TypeFlags.Null ?
                    assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull :
                    assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined;
                return getAdjustedTypeWithFacts(type, facts);
            }
            if (assumeTrue) {
                if (!doubleEquals && (type.flags & TypeFlags.Unknown || someType(type, isEmptyAnonymousObjectType))) {
                    if (valueType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) || isEmptyAnonymousObjectType(valueType)) {
                        return valueType;
                    }
                    if (valueType.flags & TypeFlags.Object) {
                        return nonPrimitiveType;
                    }
                }
                const filteredType = filterType(type, t => areTypesComparable(t, valueType));// || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType));
                return replacePrimitivesWithLiterals(filteredType, valueType);
            }
            if (isUnitType(valueType)) {
                return filterType(type, t => !(isUnitLikeType(t) && areTypesComparable(t, valueType)));
            }
            return type;
        }

        // function narrowTypeByTypeof(type: Type, typeOfExpr: TypeOfExpression, operator: SyntaxKind, literal: LiteralExpression, assumeTrue: boolean): Type {
        //     // We have '==', '!=', '===', or !==' operator with 'typeof xxx' and string literal operands
        //     if (operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) {
        //         assumeTrue = !assumeTrue;
        //     }
        //     const target = getReferenceCandidate(typeOfExpr.expression);
        //     if (!isMatchingReference(reference, target)) {
        //         if (strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue === (literal.text !== "undefined")) {
        //             type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
        //         }
        //         const propertyAccess = getDiscriminantPropertyAccess(target, type);
        //         if (propertyAccess) {
        //             return narrowTypeByDiscriminant(type, propertyAccess, t => narrowTypeByLiteralExpression(t, literal, assumeTrue));
        //         }
        //         return type;
        //     }
        //     return narrowTypeByLiteralExpression(type, literal, assumeTrue);
        // }

        function narrowTypeByLiteralExpression(type: Type, literal: LiteralExpression, assumeTrue: boolean) {
            return assumeTrue ?
                narrowTypeByTypeName(type, literal.text) :
                getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject);
        }

        function narrowTypeBySwitchOptionalChainContainment(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData, clauseCheck: (type: Type) => boolean) {
            const everyClauseChecks = clauseStart !== clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck);
            return everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
        }

        function narrowTypeBySwitchOnDiscriminant(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData) {
            // We only narrow if all case expressions specify
            // values with unit types, except for the case where
            // `type` is unknown. In this instance we map object
            // types to the nonPrimitive type and narrow with that.
            const switchTypes = getSwitchClauseTypes(switchStatement);
            if (!switchTypes.length) {
                return type;
            }
            const clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
            const hasDefaultClause = clauseStart === clauseEnd || contains(clauseTypes, neverType);
            if ((type.flags & TypeFlags.Unknown) && !hasDefaultClause) {
                let groundClauseTypes: Type[] | undefined;
                for (let i = 0; i < clauseTypes.length; i += 1) {
                    const t = clauseTypes[i];
                    if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {
                        if (groundClauseTypes !== undefined) {
                            groundClauseTypes.push(t);
                        }
                    }
                    else if (t.flags & TypeFlags.Object) {
                        if (groundClauseTypes === undefined) {
                            groundClauseTypes = clauseTypes.slice(0, i);
                        }
                        groundClauseTypes.push(nonPrimitiveType);
                    }
                    else {
                        return type;
                    }
                }
                return getUnionType(groundClauseTypes === undefined ? clauseTypes : groundClauseTypes);
            }
            const discriminantType = getUnionType(clauseTypes);
            const caseType = discriminantType.flags & TypeFlags.Never ? neverType :
                replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType);
            if (!hasDefaultClause) {
                return caseType;
            }
            const defaultType = filterType(type, t => !(isUnitLikeType(t) && contains(switchTypes, t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)))));
            return caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]);
        }

        function narrowTypeByTypeName(type: Type, typeName: string) {
            switch (typeName) {
                case "string":
                    return narrowTypeByTypeFacts(type, stringType, TypeFacts.TypeofEQString);
                case "number":
                    return narrowTypeByTypeFacts(type, numberType, TypeFacts.TypeofEQNumber);
                case "bigint":
                    return narrowTypeByTypeFacts(type, floatType, TypeFacts.TypeofEQFloat);
                case "boolean":
                    return narrowTypeByTypeFacts(type, booleanType, TypeFacts.TypeofEQBoolean);
                // case "symbol":
                //     return narrowTypeByTypeFacts(type, esSymbolType, TypeFacts.TypeofEQSymbol);
                case "object":
                    return type.flags & TypeFlags.Any ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQObject), narrowTypeByTypeFacts(type, nullType, TypeFacts.EQNull)]);
                case "function":
                    return type.flags & TypeFlags.Any ? type : narrowTypeByTypeFacts(type, globalFunctionType, TypeFacts.TypeofEQFunction);
                case "undefined":
                    return narrowTypeByTypeFacts(type, undefinedType, TypeFacts.EQUndefined);
            }
            return narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQHostObject);
        }

        function narrowTypeByTypeFacts(type: Type, impliedType: Type, facts: TypeFacts) {
            return mapType(type, t =>
                // We first check if a constituent is a subtype of the implied type. If so, we either keep or eliminate
                // the constituent based on its type facts. We use the strict subtype relation because it treats `object`
                // as a subtype of `{}`, and we need the type facts check because function types are subtypes of `object`,
                // but are classified as "function" according to `typeof`.
                isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? hasTypeFacts(t, facts) ? t : neverType :
                    // We next check if the consituent is a supertype of the implied type. If so, we substitute the implied
                    // type. This handles top types like `unknown` and `{}`, and supertypes like `{ toString(): string }`.
                    isTypeSubtypeOf(impliedType, t) ? impliedType :
                    // Neither the constituent nor the implied type is a subtype of the other, however their domains may still
                    // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate
                    // possible overlap, we form an intersection. Otherwise, we eliminate the constituent.
                    hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) :
                    neverType);
        }

        // function narrowTypeBySwitchOnTypeOf(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData): Type {
        //     const witnesses = getSwitchClauseTypeOfWitnesses(switchStatement);
        //     if (!witnesses) {
        //         return type;
        //     }
        //     // Equal start and end denotes implicit fallthrough; undefined marks explicit default clause.
        //     const defaultIndex = findIndex(switchStatement.caseBlock.clauses, clause => clause.kind === SyntaxKind.DefaultClause);
        //     const hasDefaultClause = clauseStart === clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd);
        //     if (hasDefaultClause) {
        //         // In the default clause we filter constituents down to those that are not-equal to all handled cases.
        //         const notEqualFacts = getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses);
        //         return filterType(type, t => getTypeFacts(t, notEqualFacts) === notEqualFacts);
        //     }
        //     // In the non-default cause we create a union of the type narrowed by each of the listed cases.
        //     const clauseWitnesses = witnesses.slice(clauseStart, clauseEnd);
        //     return getUnionType(map(clauseWitnesses, text => text ? narrowTypeByTypeName(type, text) : neverType));
        // }

        function narrowTypeBySwitchOnTrue(type: Type, { switchStatement, clauseStart, clauseEnd }: FlowSwitchClauseData): Type {
            const defaultIndex = findIndex(switchStatement.caseBlock.clauses, clause => clause.kind === SyntaxKind.DefaultClause);
            const hasDefaultClause = clauseStart === clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd);

            // First, narrow away all of the cases that preceded this set of cases.
            for (let i = 0; i < clauseStart; i++) {
                const clause = switchStatement.caseBlock.clauses[i];
                if (clause.kind === SyntaxKind.CaseClause) {
                    type = narrowType(type, clause.expression, /*assumeTrue*/ false);
                }
            }

            // If our current set has a default, then none the other cases were hit either.
            // There's no point in narrowing by the the other cases in the set, since we can
            // get here through other paths.
            if (hasDefaultClause) {
                for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {
                    const clause = switchStatement.caseBlock.clauses[i];
                    if (clause.kind === SyntaxKind.CaseClause) {
                        type = narrowType(type, clause.expression, /*assumeTrue*/ false);
                    }
                }
                return type;
            }

            // Now, narrow based on the cases in this set.
            const clauses = switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd);
            return getUnionType(map(clauses, clause => clause.kind === SyntaxKind.CaseClause ? narrowType(type, clause.expression, /*assumeTrue*/ true) : neverType));
        }

        function isMatchingConstructorReference(expr: Expression) {
            return (isPropertyAccessExpression(expr) && isIdentifier(expr.name) && idText(expr.name) === "constructor" ||
                isElementAccessExpression(expr) && isStringLiteral(expr.argumentExpression) && expr.argumentExpression.text === "constructor") &&
                isMatchingReference(reference, expr.expression);
        }

        function narrowTypeByConstructor(type: Type, operator: SyntaxKind, identifier: Expression, assumeTrue: boolean): Type {
            // Do not narrow when checking inequality.
            if (assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken)) {
                return type;
            }

            // Get the type of the constructor identifier expression, if it is not a function then do not narrow.
            const identifierType = getTypeOfExpression(identifier);
            if (!isFunctionType(identifierType)) {// && !isConstructorType(identifierType)) {
                return type;
            }

            // Get the prototype property of the type identifier so we can find out its type.
            const prototypeProperty = getPropertyOfType(identifierType, "prototype" as string);
            if (!prototypeProperty) {
                return type;
            }

            // Get the type of the prototype, if it is undefined, or the global `Object` or `Function` types then do not narrow.
            const prototypeType = getTypeOfSymbol(prototypeProperty);
            const candidate = !isTypeAny(prototypeType) ? prototypeType : undefined;
            if (!candidate || candidate === globalObjectType || candidate === globalFunctionType) {
                return type;
            }

            // If the type that is being narrowed is `any` then just return the `candidate` type since every type is a subtype of `any`.
            if (isTypeAny(type)) {
                return candidate;
            }

            // Filter out types that are not considered to be "constructed by" the `candidate` type.
            return filterType(type, t => isConstructedBy(t, candidate));

            function isConstructedBy(source: Type, target: Type) {
                // If either the source or target type are a class type then we need to check that they are the same exact type.
                // This is because you may have a class `A` that defines some set of properties, and another class `B`
                // that defines the same set of properties as class `A`, in that case they are structurally the same
                // type, but when you do something like `instanceOfA.constructor === B` it will return false.
                if (
                    source.flags & TypeFlags.Object && getObjectFlags(source) & ObjectFlags.Class ||
                    target.flags & TypeFlags.Object && getObjectFlags(target) & ObjectFlags.Class
                ) {
                    return source.symbol === target.symbol;
                }

                // For all other types just check that the `source` type is a subtype of the `target` type.
                return isTypeSubtypeOf(source, target);
            }
        }

        // function narrowTypeByInstanceof(type: Type, expr: InstanceofExpression, assumeTrue: boolean): Type {
        //     const left = getReferenceCandidate(expr.left);
        //     if (!isMatchingReference(reference, left)) {
        //         if (assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference)) {
        //             return getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
        //         }
        //         return type;
        //     }
        //     const right = expr.right;
        //     const rightType = getTypeOfExpression(right);
        //     if (!isTypeDerivedFrom(rightType, globalObjectType)) {
        //         return type;
        //     }

        //     // if the right-hand side has an object type with a custom `[Symbol.hasInstance]` method, and that method
        //     // has a type predicate, use the type predicate to perform narrowing. This allows normal `object` types to
        //     // participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
        //     const signature = getEffectsSignature(expr);
        //     const predicate = signature && getTypePredicateOfSignature(signature);
        //     if (predicate && predicate.kind === TypePredicateKind.Identifier && predicate.parameterIndex === 0) {
        //         return getNarrowedType(type, predicate.type, assumeTrue, /*checkDerived*/ true);
        //     }
        //     if (!isTypeDerivedFrom(rightType, globalFunctionType)) {
        //         return type;
        //     }
        //     const instanceType = mapType(rightType, getInstanceType);
        //     // Don't narrow from `any` if the target type is exactly `Object` or `Function`, and narrow
        //     // in the false branch only if the target is a non-empty object type.
        //     if (
        //         isTypeAny(type) && (instanceType === globalObjectType || instanceType === globalFunctionType) ||
        //         !assumeTrue && !(instanceType.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(instanceType))
        //     ) {
        //         return type;
        //     }
        //     return getNarrowedType(type, instanceType, assumeTrue, /*checkDerived*/ true);
        // }

        // function getInstanceType(constructorType: Type) {
        //     const prototypePropertyType = getTypeOfPropertyOfType(constructorType, "prototype" as string);
        //     if (prototypePropertyType && !isTypeAny(prototypePropertyType)) {
        //         return prototypePropertyType;
        //     }
        //     const constructSignatures = getSignaturesOfType(constructorType, SignatureKind.Construct);
        //     if (constructSignatures.length) {
        //         return getUnionType(map(constructSignatures, signature => getReturnTypeOfSignature(getErasedSignature(signature))));
        //     }
        //     // We use the empty object type to indicate we don't know the type of objects created by
        //     // this constructor function.
        //     return emptyObjectType;
        // }

        function getNarrowedType(type: Type, candidate: Type, assumeTrue: boolean, checkDerived: boolean): Type {
            const key = type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined;
            return getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived));
        }

        function getNarrowedTypeWorker(type: Type, candidate: Type, assumeTrue: boolean, checkDerived: boolean) {
            if (!assumeTrue) {
                if (type === candidate) {
                    return neverType;
                }
                if (checkDerived) {
                    return filterType(type, t => !isTypeDerivedFrom(t, candidate));
                }
                const trueType = getNarrowedType(type, candidate, /*assumeTrue*/ true, /*checkDerived*/ false);
                return filterType(type, t => !isTypeSubsetOf(t, trueType));
            }
            if (type.flags & TypeFlags.AnyOrUnknown) {
                return candidate;
            }
            if (type === candidate) {
                return candidate;
            }

            // We first attempt to filter the current type, narrowing constituents as appropriate and removing
            // constituents that are unrelated to the candidate.
            const isRelated = checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf;
            const keyPropertyName = type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined;
            const narrowedType = mapType(candidate, c => {
                // If a discriminant property is available, use that to reduce the type.
                const discriminant = keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName);
                const matching = discriminant && getConstituentTypeForKeyType(type as UnionType, discriminant);

                // in LPC - skip the directlyRelated checks if there is no discriminant.
                // if (!discriminant && !strickObjectTypes) {
                //     return candidate;
                // }

                // For each constituent t in the current type, if t and and c are directly related, pick the most
                // specific of the two. When t and c are related in both directions, we prefer c for type predicates
                // because that is the asserted type, but t for `instanceof` because generics aren't reflected in
                // prototype object types.
                const directlyRelated = mapType(
                    matching || type,
                    checkDerived ?
                        t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType :
                        t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType,
                );
                // If no constituents are directly related, create intersections for any generic constituents that
                // are related by constraint.
                return directlyRelated.flags & TypeFlags.Never ?
                    mapType(type, t => maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) :
                    directlyRelated;                
            });
            // If filtering produced a non-empty type, return that. Otherwise, pick the most specific of the two
            // based on assignability, or as a last resort produce an intersection.
            return !(narrowedType.flags & TypeFlags.Never) ? narrowedType :
                isTypeSubtypeOf(candidate, type) ? candidate :
                isTypeAssignableTo(type, candidate) ? type :
                isTypeAssignableTo(candidate, type) ? candidate :
                getIntersectionType([type, candidate]);
        }

        function narrowTypeByCallExpression(type: Type, callExpression: CallExpression, assumeTrue: boolean): Type {
            if (hasMatchingArgument(callExpression, reference)) {
                const signature = assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined;
                const predicate = signature && getTypePredicateOfSignature(signature);
                if (predicate && (/*predicate.kind === TypePredicateKind.This ||*/ predicate.kind === TypePredicateKind.Identifier)) {
                    return narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue);
                }
            }
            if (containsMissingType(type) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression)) {
                const callAccess = callExpression.expression;
                if (
                    isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) &&
                    isIdentifier(callAccess.name) && callAccess.name.text === "hasOwnProperty" && callExpression.arguments.length === 1
                ) {
                    const argument = callExpression.arguments[0];
                    if (isStringLiteralLike(argument) && getAccessedPropertyName(reference) === (argument.text)) {
                        return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);
                    }
                }
            }
            return type;
        }        

        // Narrow the given type based on the given expression having the assumed boolean value. The returned type
        // will be a subtype or the same type as the argument.
        function narrowType(type: Type, expr: Expression, assumeTrue: boolean): Type {
            // for `a?.b`, we emulate a synthetic `a !== null && a !== undefined` condition for `a`
            // if (
            //     //isExpressionOfOptionalChainRoot(expr) ||
            //     isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionToken || expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionEqualsToken) && expr.parent.left === expr
            // ) {
            //     return narrowTypeByOptionality(type, expr, assumeTrue);
            // }
            switch (expr.kind) {
                case SyntaxKind.Identifier:
                    // When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline
                    // up to five levels of aliased conditional expressions that are themselves declared as const variables.
                    if (!isMatchingReference(reference, expr) && inlineLevel < 5) {
                        const symbol = getResolvedSymbol(expr as Identifier);
                        // if (isConstantVariable(symbol)) {
                            const declaration = symbol.valueDeclaration;
                            if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer /*&& isConstantReference(reference)*/) {
                                inlineLevel++;
                                const result = narrowType(type, declaration.initializer, assumeTrue);
                                inlineLevel--;
                                return result;
                            }
                        // }
                    }
                    // falls through
                // case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                    return narrowTypeByTruthiness(type, expr, assumeTrue);
                case SyntaxKind.CallExpression:
                    return narrowTypeByCallExpression(type, expr as CallExpression, assumeTrue);
                case SyntaxKind.ParenthesizedExpression:
                // case SyntaxKind.NonNullExpression:
                    return narrowType(type, (expr as ParenthesizedExpression ).expression, assumeTrue);
                case SyntaxKind.BinaryExpression:
                    return narrowTypeByBinaryExpression(type, expr as BinaryExpression, assumeTrue);
                case SyntaxKind.PrefixUnaryExpression:
                    if ((expr as PrefixUnaryExpression).operator === SyntaxKind.ExclamationToken) {
                        return narrowType(type, (expr as PrefixUnaryExpression).operand, !assumeTrue);
                    }
                    break;
            }
            return type;
        }

        function narrowTypeByOptionality(type: Type, expr: Expression, assumePresent: boolean): Type {
            if (isMatchingReference(reference, expr)) {
                return getAdjustedTypeWithFacts(type, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull);
            }
            const access = getDiscriminantPropertyAccess(expr, type);
            if (access) {
                return narrowTypeByDiscriminant(type, access, t => getTypeWithFacts(t, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull));
            }
            return type;
        }
    }

    function isFunctionOrSourceFile(node: Node) {
        return isFunctionLikeDeclaration(node) || isSourceFile(node);
    }

    function hasParentWithAssignmentsMarked(node: Node) {
        return !!findAncestor(node.parent, node => isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlags.AssignmentsMarked));
    }
    
    // For all assignments within the given root node, record the last assignment source position for all
    // referenced parameters and mutable local variables. When assignments occur in nested functions  or
    // references occur in export specifiers, record Number.MAX_VALUE as the assignment position. When
    // assignments occur in compound statements, record the ending source position of the compound statement
    // as the assignment position (this is more conservative than full control flow analysis, but requires
    // only a single walk over the AST).
    function markNodeAssignments(node: Node) {
        switch (node.kind) {
            case SyntaxKind.Identifier:
                if (isAssignmentTarget(node)) {
                    const symbol = getResolvedSymbol(node as Identifier);
                    if (isParameterOrMutableLocalVariable(symbol) && symbol.lastAssignmentPos !== Number.MAX_VALUE) {
                        const referencingFunction = findAncestor(node, isFunctionOrSourceFile);
                        const declaringFunction = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);
                        symbol.lastAssignmentPos = referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE;
                    }
                }
                return;                     
        }
        if (isTypeNode(node)) {
            return;
        }
        forEachChild(node, markNodeAssignments);
    }

    // Extend the position of the given assignment target node to the end of any intervening variable statement,
    // expression statement, compound statement, or class declaration occurring between the node and the given
    // declaration node.
    function extendAssignmentPosition(node: Node, declaration: Declaration) {
        let pos = node.pos;
        while (node && node.pos > declaration.pos) {
            switch (node.kind) {
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ExpressionStatement:
                case SyntaxKind.IfStatement:
                case SyntaxKind.DoWhileStatement:
                case SyntaxKind.WhileStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForEachStatement:                
                case SyntaxKind.SwitchStatement:                
                    pos = node.end;
            }
            node = node.parent;
        }
        return pos;
    }
    
    // Return true if there are no assignments to the given symbol or if the given location
    // is past the last assignment to the symbol.
    function isPastLastAssignment(symbol: Symbol, location: Node | undefined) {
        const parent = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);
        if (!parent) {
            return false;
        }
        const links = getNodeLinks(parent);
        if (!(links.flags & NodeCheckFlags.AssignmentsMarked)) {
            links.flags |= NodeCheckFlags.AssignmentsMarked;
            if (!hasParentWithAssignmentsMarked(parent)) {
                markNodeAssignments(parent);
            }
        }
        return !symbol.lastAssignmentPos || location && symbol.lastAssignmentPos < location.pos;
    }

    function isMutableLocalVariableDeclaration(declaration: VariableDeclaration) {
        // all variables are mutable in LPC
        return true;

        // // Return true if symbol is a non-exported and non-global `let` variable        
        // return !(
        //     //getCombinedModifierFlags(declaration) & ModifierFlags.Export ||
        //     declaration.parent.parent.kind === SyntaxKind.VariableStatement
        // );
    }

    function isParameterOrMutableLocalVariable(symbol: Symbol) {
        // Return true if symbol is a parameter, a catch clause variable, or a mutable local variable
        const declaration = symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration);
        return !!declaration && (
            isParameter(declaration) ||
            isVariableDeclaration(declaration) && (/*isCatchClause(declaration.parent) || */isMutableLocalVariableDeclaration(declaration))
        );
    }

    /**
     * Get the merged symbol for a node. If you know the node is a `Declaration`, it is faster and more type safe to
     * use use `getSymbolOfDeclaration` instead.
     */
    function getSymbolOfNode(node: Node): Symbol | undefined {
        return canHaveSymbol(node) ? getSymbolOfDeclaration(node) : undefined;
    }

    function isInNameOfExpressionWithTypeArguments(node: Node): boolean {
        while (node.parent.kind === SyntaxKind.PropertyAccessExpression) {
            node = node.parent;
        }

        return node.parent.kind === SyntaxKind.ExpressionWithTypeArguments;
    }

    function getSymbolOfNameOrPropertyAccessExpression(name: EntityName | PropertyAccessExpression | JSDocMemberName): Symbol | undefined {
        if (isDeclarationName(name)) {
            return getSymbolOfNode(name.parent);
        }        
        
        while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {
            name = name.parent as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName;
        }

        if (isInNameOfExpressionWithTypeArguments(name)) {
            let meaning = SymbolFlags.None;
            if (name.parent.kind === SyntaxKind.ExpressionWithTypeArguments) {
                // An 'ExpressionWithTypeArguments' may appear in type space (interface Foo extends Bar<T>),
                // value space (return foo<T>), or both(class Foo extends Bar<T>); ensure the meaning matches.
                meaning = isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value;

                // In a class 'extends' clause we are also looking for a value.
                // if (isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) {
                //     meaning |= SymbolFlags.Value;
                // }
            }
            else {
                meaning = SymbolFlags.Namespace;
            }

            meaning |= SymbolFlags.Alias;
            const entityNameSymbol = isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors*/ true) : undefined;
            if (entityNameSymbol) {
                return entityNameSymbol;
            }
        }

        if (name.parent.kind === SyntaxKind.JSDocParameterTag) {
            return getParameterSymbolFromJSDoc(name.parent as JSDocParameterTag);
        }

        if (name.parent.kind === SyntaxKind.TypeParameter && name.parent.parent.kind === SyntaxKind.JSDocTemplateTag) {
            //Debug.assert(!isInJSFile(name)); // Otherwise `isDeclarationName` would have been true.
            const typeParameter = getTypeParameterFromJsDoc(name.parent as TypeParameterDeclaration & { parent: JSDocTemplateTag; });
            return typeParameter && typeParameter.symbol;
        }

        if (isExpressionNode(name)) {
            if (nodeIsMissing(name)) {
                // Missing entity name.
                return undefined;
            }
            
            const isJSDoc = findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName));
            const meaning = isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : 
                            isStructTypeNode(name.parent) ? SymbolFlags.Type :
                            isCallExpression(name.parent) && name.parent.expression === name ? SymbolFlags.Function : 
                            isSuperAccessExpression(name.parent) ? SymbolFlags.Function :
                            SymbolFlags.Value;
            
            if (name.kind === SyntaxKind.Identifier) {
                const result = resolveEntityName(name, meaning, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, getHostSignatureFromJSDoc(name));
                if (!result && isJSDoc) {                    
                    const container = findAncestor(name, or(isClassLike, isInterfaceDeclaration));
                    if (container) {
                        return resolveJSDocMemberName(name, /*ignoreErrors*/ true, getSymbolOfDeclaration(container));
                    }
                }                
                return result;
            }           
            else if (name.kind === SyntaxKind.PropertyAccessExpression || name.kind === SyntaxKind.QualifiedName) {
                const links = getNodeLinks(name);
                if (links.resolvedSymbol) {
                    return links.resolvedSymbol;
                }

                if (name.kind === SyntaxKind.PropertyAccessExpression) {
                    checkPropertyAccessExpression(name, CheckMode.Normal);
                    if (!links.resolvedSymbol) {
                        links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression, CheckMode.StringLiteralAsObject), getLiteralTypeFromPropertyName(name.name));
                    }
                }
                else {
                    checkQualifiedName(name, CheckMode.Normal);
                }
                if (!links.resolvedSymbol && isJSDoc && isQualifiedName(name)) {
                    Debug.fail("TODO - Implement me - getSymbolOfNameOrPropertyAccessExpression");
                    //return resolveJSDocMemberName(name);
                }
                return links.resolvedSymbol;
            }
            else if (isJSDocMemberName(name)) {
                return resolveJSDocMemberName(name);
            }
            debugger;
        }
        else if (isTypeReferenceIdentifier(name as EntityName)) {
            const meaning = name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;
            const symbol = resolveEntityName(name as EntityName, meaning, /*ignoreErrors*/ false, /*dontResolveAlias*/ true);
            return symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name as EntityName);
        }
        else if (isStructTypeNode(name.parent)) {
            const symbol = resolveEntityName(name as EntityName, SymbolFlags.Type, /*ignoreErrors*/ false, /*dontResolveAlias*/ true);
            return symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name as EntityName);
        }
        if (name.parent.kind === SyntaxKind.TypePredicate) {
            return resolveEntityName(name as Identifier, /*meaning*/ SymbolFlags.FunctionScopedVariable);
        }

        return undefined;
    }

    // True if the given identifier is part of a type reference
    function isTypeReferenceIdentifier(node: EntityName): boolean {
        while (node.parent.kind === SyntaxKind.QualifiedName) {
            node = node.parent as QualifiedName;
        }

        return node.parent.kind === SyntaxKind.TypeReference;
    }
    
    function getLiteralTypeFromPropertyName(name: PropertyName) {
        if (isPrivateIdentifier(name)) {
            return neverType;
        }
        if (isIntLiteral(name)) {
            return getRegularTypeOfLiteralType(checkExpression(name));
        }
        if (isFloatLiteral(name)) {
            return getRegularTypeOfLiteralType(checkExpression(name));
        }
        if (isComputedPropertyName(name)) {                        
            return getRegularTypeOfLiteralType(checkComputedPropertyName(name));
        }
        const propertyName = getPropertyNameForPropertyNameNode(name);
        if (propertyName !== undefined) {
            return getStringLiteralType((propertyName));
        }
        if (isExpression(name)) {
            return getRegularTypeOfLiteralType(checkExpression(name));
        }
        return neverType;
    }
    
    function getApplicableIndexSymbol(type: Type, keyType: Type) {
        const infos = getApplicableIndexInfos(type, keyType);
        if (infos.length && (type as ObjectType).members) {
            const symbol = getIndexSymbolFromSymbolTable(resolveStructuredTypeMembers(type as ObjectType).members);
            if (infos === getIndexInfosOfType(type)) {
                return symbol;
            }
            else if (symbol) {
                const symbolLinks = getSymbolLinks(symbol);
                const declarationList = mapDefined(infos, i => i.declaration);
                const nodeListId = map(declarationList, getNodeId).join(",");
                if (!symbolLinks.filteredIndexSymbolCache) {
                    symbolLinks.filteredIndexSymbolCache = new Map();
                }
                if (symbolLinks.filteredIndexSymbolCache.has(nodeListId)) {
                    return symbolLinks.filteredIndexSymbolCache.get(nodeListId)!;
                }
                else {
                    const copy = createSymbol(SymbolFlags.Signature, InternalSymbolName.Index);
                    copy.declarations = mapDefined(infos, i => i.declaration);
                    copy.parent = type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent);
                    symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy);
                    return copy;
                }
            }
        }
    }
    
    function getIndexSymbolFromSymbolTable(symbolTable: SymbolTable): Symbol | undefined {
        return symbolTable.get(InternalSymbolName.Index);
    }
    
    /**
     * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
     * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
     * name resolution won't work either.
     * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
     */
    function resolveEntityNameFromAssignmentDeclaration(name: Identifier, meaning: SymbolFlags): Symbol | undefined {
        if (isJSDocTypeReference(name.parent)) {
            const secondaryLocation = getAssignmentDeclarationLocation(name.parent);
            if (secondaryLocation) {
                return resolveName(secondaryLocation, name, meaning, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
            }
        }
    }

    function getAssignmentDeclarationLocation(node: TypeReferenceNode): Node | undefined {
        const typeAlias = findAncestor(node, node => !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(node));
        if (typeAlias) {
            return;
        }
        const host = getJSDocHost(node);                
        if (
            host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) &&
            isBinaryExpression(host.parent.parent) &&
            getAssignmentDeclarationKind(host.parent.parent) === AssignmentDeclarationKind.Prototype
        ) {
            // X.prototype = { /** @param {K} p */m() { } } <-- look for K on X's declaration
            const symbol = getSymbolOfDeclaration(host.parent.parent.left as BindableStaticNameExpression);
            if (symbol) {
                console.debug("todo - getAssignmentDeclarationLocation");
                // return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        const sig = getEffectiveJSDocHost(node);
        if (sig && isFunctionLike(sig)) {
            const symbol = getSymbolOfDeclaration(sig);
            return symbol && symbol.valueDeclaration;
        }
    }
    
    /**
     * Resolves a qualified name and any involved aliases.
     */
    function resolveEntityName(name: EntityNameOrEntityNameExpression, meaning: SymbolFlags, ignoreErrors?: boolean, dontResolveAlias?: boolean, location?: Node): Symbol | undefined {
        if (nodeIsMissing(name)) {
            return undefined;
        }

        const namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(name) ? meaning & SymbolFlags.Value : 0);
        let symbol: Symbol | undefined;
        if (name.kind === SyntaxKind.Identifier) {
            const message = /*meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 :*/ getCannotFindNameDiagnosticForName(getFirstIdentifier(name));
            const symbolFromJSPrototype = isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined;
            symbol = getMergedSymbol(resolveName(location || name, name, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, /*isUse*/ true, /*excludeGlobals*/ false));
            if (!symbol) {
                return getMergedSymbol(symbolFromJSPrototype);
            }
        }
        else if (name.kind === SyntaxKind.QualifiedName || name.kind === SyntaxKind.PropertyAccessExpression) {
            const left = name.kind === SyntaxKind.QualifiedName ? name.left : name.expression;
            const right = name.kind === SyntaxKind.QualifiedName ? name.right : name.name;
            let namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, /*dontResolveAlias*/ false, location);
            if (!namespace || nodeIsMissing(right)) {
                return undefined;
            }
            else if (namespace === unknownSymbol) {
                return namespace;
            }
            if (
                namespace.valueDeclaration &&
                isInJSFile(namespace.valueDeclaration) &&
                //getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Bundler &&
                isVariableDeclaration(namespace.valueDeclaration) &&
                namespace.valueDeclaration.initializer &&
                false//isCommonJsRequire(namespace.valueDeclaration.initializer)
            ) {
                // const moduleName = (namespace.valueDeclaration.initializer as CallExpression).arguments[0] as StringLiteral;
                // const moduleSym = resolveExternalModuleName(moduleName, moduleName);
                // if (moduleSym) {
                //     const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                //     if (resolvedModuleSymbol) {
                //         namespace = resolvedModuleSymbol;
                //     }
                // }
            }
            symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.text, meaning));
            if (!symbol && (namespace.flags & SymbolFlags.Alias)) {
                // `namespace` can be resolved further if there was a symbol merge with a re-export
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.text, meaning));
            }
            if (!symbol) {
                if (!ignoreErrors) {
                    const namespaceName = getFullyQualifiedName(namespace);
                    const declarationName = declarationNameToString(right);
                    // const suggestionForNonexistentModule = getSuggestedSymbolForNonexistentModule(right, namespace);
                    // if (suggestionForNonexistentModule) {
                    //     error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule));
                    //     return undefined;
                    // }

                    const containingQualifiedName = isQualifiedName(name) && getContainingQualifiedNameNode(name);
                    const canSuggestTypeof = globalObjectType // <-- can't pull on types if global types aren't initialized yet
                        && (meaning & SymbolFlags.Type)
                        && containingQualifiedName
                        //&& !isTypeOfExpression(containingQualifiedName.parent)
                        && tryGetQualifiedNameAsValue(containingQualifiedName);
                    if (canSuggestTypeof) {
                        error(
                            containingQualifiedName,
                            Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0,
                            entityNameToString(containingQualifiedName),
                        );
                        return undefined;
                    }

                    // if (meaning & SymbolFlags.Namespace && isQualifiedName(name.parent)) {
                    //     const exportedTypeSymbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.text, SymbolFlags.Type));
                    //     if (exportedTypeSymbol) {
                    //         error(
                    //             name.parent.right,
                    //             Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,
                    //             symbolToString(exportedTypeSymbol),
                    //             unescapeLeadingUnderscores(name.parent.right.text),
                    //         );
                    //         return undefined;
                    //     }
                    // }

                    debugger;
                    //error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName);
                }
                return undefined;
            }
        }
        else {
            Debug.assertNever(name, "Unknown entity name kind.");
        }
        // if (!nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags & SymbolFlags.Alias || name.parent.kind === SyntaxKind.ExportAssignment)) {
        //     markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, /*finalTarget*/ undefined, /*overwriteEmpty*/ true);
        // }
        return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol);
    }

    function getFullyQualifiedName(symbol: Symbol, containingLocation?: Node): string {
        return symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, /*meaning*/ undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind);
    }

    function getContainingQualifiedNameNode(node: QualifiedName) {
        while (isQualifiedName(node.parent)) {
            node = node.parent;
        }
        return node;
    }

    function tryGetQualifiedNameAsValue(node: QualifiedName) {
        let left: Identifier | QualifiedName = getFirstIdentifier(node);
        let symbol = resolveName(left, left, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*isUse*/ true);
        if (!symbol) {
            return undefined;
        }
        while (isQualifiedName(left.parent)) {
            const type = getTypeOfSymbol(symbol);
            symbol = getPropertyOfType(type, left.parent.right.text);
            if (!symbol) {
                return undefined;
            }
            left = left.parent;
        }
        return symbol;
    }

    
    function checkUnusedIdentifiers(potentiallyUnusedIdentifiers: readonly PotentiallyUnusedIdentifier[], addDiagnostic: AddUnusedDiagnostic) {
        for (const node of potentiallyUnusedIdentifiers) {
            switch (node.kind) {
                // case SyntaxKind.ClassDeclaration:
                // case SyntaxKind.ClassExpression:
                //     checkUnusedClassMembers(node, addDiagnostic);
                //     checkUnusedTypeParameters(node, addDiagnostic);
                //     break;
                case SyntaxKind.SourceFile:                
                case SyntaxKind.Block:
                case SyntaxKind.CaseBlock:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForEachStatement:                               
                    checkUnusedLocalsAndParameters(node, addDiagnostic);
                    break;                                
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.InlineClosureExpression:
                case SyntaxKind.MethodDeclaration:                
                    if (node.body) { // Don't report unused parameters in overloads
                        checkUnusedLocalsAndParameters(node, addDiagnostic);
                    }                    
                    break;                
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.StructDeclaration:
                case SyntaxKind.CallSignature:                
                case SyntaxKind.FunctionType:                
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;                    
                default:
                    Debug.assertNever(node as never, "Node should not have been registered for unused identifiers check");
            }
        }
    }

    function checkUnusedTypeParameters(node: ClassLikeDeclaration | SignatureDeclaration | StructDeclaration | TypeAliasDeclaration, addDiagnostic: AddUnusedDiagnostic): void {
        // Only report errors on the last declaration for the type parameter container;
        // this ensures that all uses have been accounted for.
        const declarations = getSymbolOfDeclaration(node).declarations;
        if (!declarations || last(declarations) !== node) return;

        const typeParameters = getEffectiveTypeParameterDeclarations(node);
        const seenParentsWithEveryUnused = new Set<DeclarationWithTypeParameterChildren>();

        for (const typeParameter of typeParameters) {
            if (!isTypeParameterUnused(typeParameter)) continue;

            const name = idText(typeParameter.name);
            const { parent } = typeParameter;
            if (parent.kind !== SyntaxKind.InferType && parent.typeParameters!.every(isTypeParameterUnused)) {
                if (tryAddToSet(seenParentsWithEveryUnused, parent)) {
                    const sourceFile = getSourceFileOrIncludeOfNode(parent);
                    const range = isJSDocTemplateTag(parent)
                        // Whole @template tag
                        ? rangeOfNode(parent)
                        // Include the `<>` in the error message
                        : rangeOfTypeParameters(sourceFile, parent.typeParameters!);
                    const only = parent.typeParameters!.length === 1;
                    // TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                    const messageAndArg: DiagnosticAndArguments = only
                        ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name]
                        : [Diagnostics.All_type_parameters_are_unused];
                    addDiagnostic(typeParameter, UnusedKind.Parameter, createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, ...messageAndArg));
                }
            }
            else {
                // TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                addDiagnostic(typeParameter, UnusedKind.Parameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name));
            }
        }
    }
    function isTypeParameterUnused(typeParameter: TypeParameterDeclaration): boolean {
        return !(getMergedSymbol(typeParameter.symbol).isReferenced! & SymbolFlags.TypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
    }

    function checkUnusedClassMembers(node: ClassDeclaration | ClassExpression, addDiagnostic: AddUnusedDiagnostic): void {
        for (const member of node.members) {
            switch (member.kind) {
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.PropertyDeclaration:                                  
                    const symbol = getSymbolOfDeclaration(member);
                    if (
                        !symbol.isReferenced
                        && (hasEffectiveModifier(member, ModifierFlags.Private) || isNamedDeclaration(member) && isPrivateIdentifier(member.name))
                        && !(member.flags & NodeFlags.Ambient)
                    ) {
                        addDiagnostic(member, UnusedKind.Local, createDiagnosticForNode(member.name!, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));
                    }
                    break;
                // case SyntaxKind.Constructor:
                //     for (const parameter of (member as ConstructorDeclaration).parameters) {
                //         if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlags.Private)) {
                //             addDiagnostic(parameter, UnusedKind.Local, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));
                //         }
                //     }
                //     break;
                case SyntaxKind.IndexSignature:
                // case SyntaxKind.SemicolonClassElement:
                // case SyntaxKind.ClassStaticBlockDeclaration:
                    // Can't be private
                    break;
                default:
                    Debug.fail("Unexpected class member");
            }
        }
    }

    function isIdentifierThatStartsWithUnderscore(node: Node) {
        return isIdentifier(node) && idText(node).charCodeAt(0) === CharacterCodes._;
    }
    
    function isValidUnusedLocalDeclaration(declaration: Declaration): boolean {
        if (isBindingElement(declaration)) {
            // if (isObjectBindingPattern(declaration.parent)) {
            //     /**
            //      * ignore starts with underscore names _
            //      * const { a: _a } = { a: 1 }
            //      */
            //     return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name));
            // }
            return isIdentifierThatStartsWithUnderscore(declaration.name);
        }
        return (isVariableDeclaration(declaration) && isForEachStatement(declaration.parent.parent)) && isIdentifierThatStartsWithUnderscore(declaration.name!);
    }

    function addToGroup<K, V>(map: Map<string, [K, V[]]>, key: K, value: V, getKey: (key: K) => number | string): void {
        const keyString = String(getKey(key));
        const group = map.get(keyString);
        if (group) {
            group[1].push(value);
        }
        else {
            map.set(keyString, [key, [value]]);
        }
    }

    function tryGetRootParameterDeclaration(node: Node): ParameterDeclaration | undefined {
        return tryCast(getRootDeclaration(node), isParameter);
    }

    function errorUnusedLocal(declaration: Declaration, name: string, addDiagnostic: AddUnusedDiagnostic) {
        const node = getNameOfDeclaration(declaration) || declaration;
        const message = Diagnostics._0_is_declared_but_its_value_is_never_read;
        addDiagnostic(declaration, UnusedKind.Local, createDiagnosticForNode(node, message, name));
    }

    function checkUnusedLocalsAndParameters(nodeWithLocals: HasLocals, addDiagnostic: AddUnusedDiagnostic): void {
        // Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
        //const unusedImports = new Map<string, [ImportClause, ImportedDeclaration[]]>();
        const unusedDestructures = new Map<string, [BindingPattern, BindingElement[]]>();
        const unusedVariables = new Map<string, [VariableDeclarationList, VariableDeclaration[]]>();
        nodeWithLocals.locals!.forEach(local => {
            // If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
            // If it's a type parameter merged with a parameter, check if the parameter-side is used.
            if (local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol) {
                return;
            }

            if (local.declarations) {
                for (const declaration of local.declarations) {
                    if (isValidUnusedLocalDeclaration(declaration)) {
                        continue;
                    }

                    // if (isImportedDeclaration(declaration)) {
                    //     addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
                    // }
                    // else if (isBindingElement(declaration) && isObjectBindingPattern(declaration.parent)) {
                    //     // In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
                    //     const lastElement = last(declaration.parent.elements);
                    //     if (declaration === lastElement || !last(declaration.parent.elements).dotDotDotToken) {
                    //         addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                    //     }
                    // }
                    else if (isVariableDeclaration(declaration)) {
                        const blockScopeKind = getCombinedNodeFlagsCached(declaration) & NodeFlags.BlockScoped;
                        const name = getNameOfDeclaration(declaration);
                        if (!name || !isIdentifierThatStartsWithUnderscore(name)) {
                            addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
                        }
                    }
                    else {
                        const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
                        const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);
                        if (parameter && name) {
                            if (!isIdentifierThatStartsWithUnderscore(name)) {
                                if (isBindingElement(declaration) && isArrayBindingPattern(declaration.parent)) {
                                    addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                                }
                                else {
                                    addDiagnostic(parameter, UnusedKind.Parameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)));
                                }
                            }
                        }
                        else {
                            errorUnusedLocal(declaration, symbolName(local), addDiagnostic);
                        }
                    }
                }
            }
        });

        // unusedImports.forEach(([importClause, unuseds]) => {
        //     const importDecl = importClause.parent;
        //     const nDeclarations = (importClause.name ? 1 : 0) +
        //         (importClause.namedBindings ?
        //             (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length)
        //             : 0);
        //     if (nDeclarations === unuseds.length) {
        //         addDiagnostic(
        //             importDecl,
        //             UnusedKind.Local,
        //             unuseds.length === 1
        //                 ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))
        //                 : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused),
        //         );
        //     }
        //     else {
        //         for (const unused of unuseds) errorUnusedLocal(unused, idText(unused.name!), addDiagnostic);
        //     }
        // });
       
        unusedVariables.forEach(([declarationList, declarations]) => {
            if (declarationList.declarations?.length === declarations?.length) {
                addDiagnostic(
                    declarationList,
                    UnusedKind.Local,
                    declarations.length === 1
                        ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))
                        : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused),
                );
            }
            else {
                for (const decl of declarations) {
                    addDiagnostic(decl, UnusedKind.Local, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
                }
            }
        });
    }

    function bindingNameText(name: BindingName): string {
        switch (name.kind) {
            case SyntaxKind.Identifier:
                return idText(name);
            case SyntaxKind.ArrayBindingPattern:
            //case SyntaxKind.ObjectBindingPattern:
                return bindingNameText(cast(first(name.elements), isBindingElement).name);
            default:
                return Debug.assertNever(name);
        }
    }    

    /**
     * Resolve a signature of a given call-like expression.
     * @param node a call-like expression to try resolve a signature for
     * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
     *                           the function will fill it up with appropriate candidate signatures
     * @return a signature of the call-like expression or undefined if one can't be found
     */
    function getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[] | undefined, checkMode?: CheckMode): Signature {
        const links = getNodeLinks(node);
        // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
        // However, it is possible that either candidatesOutArray was not passed in the first time,
        // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
        // to correctly fill the candidatesOutArray.
        const cached = links.resolvedSignature;
        if (cached && cached !== resolvingSignature && !candidatesOutArray) {
            return cached;
        }
        const saveResolutionStart = resolutionStart;
        if (!cached) {
            // If we haven't already done so, temporarily reset the resolution stack. This allows us to
            // handle "inverted" situations where, for example, an API client asks for the type of a symbol
            // containined in a function call argument whose contextual type depends on the symbol itself
            // through resolution of the containing function call. By resetting the resolution stack we'll
            // retry the symbol type resolution with the resolvingSignature marker in place to suppress
            // the contextual type circularity.
            resolutionStart = resolutionTargets.length;
        }
        links.resolvedSignature = resolvingSignature;
        let result = resolveSignature(node, candidatesOutArray, checkMode || CheckMode.Normal);
        resolutionStart = saveResolutionStart;
        // When CheckMode.SkipGenericFunctions is set we use resolvingSignature to indicate that call
        // resolution should be deferred.
        if (result !== resolvingSignature) {
            // if the signature resolution originated on a node that itself depends on the contextual type
            // then it's possible that the resolved signature might not be the same as the one that would be computed in source order
            // since resolving such signature leads to resolving the potential outer signature, its arguments and thus the very same signature
            // it's possible that this inner resolution sets the resolvedSignature first.
            // In such a case we ignore the local result and reuse the correct one that was cached.
            if (links.resolvedSignature !== resolvingSignature) {
                result = links.resolvedSignature;
            }
            // If signature resolution originated in control flow type analysis (for example to compute the
            // assigned type in a flow assignment) we don't cache the result as it may be based on temporary
            // types from the control flow analysis.
            links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
        }
        return result;
    }

    function getCandidateSignaturesForStringLiteralCompletions(call: CallLikeExpression, editingArgument: Node) {
        const candidatesSet = new Set<Signature>();
        const candidates: Signature[] = [];

        // first, get candidates when inference is blocked from the source node.
        runWithInferenceBlockedFromSourceNode(editingArgument, () => getResolvedSignatureWorker(call, candidates, /*argumentCount*/ undefined, CheckMode.Normal));
        for (const candidate of candidates) {
            candidatesSet.add(candidate);
        }

        // reset candidates for second pass
        candidates.length = 0;

        // next, get candidates where the source node is considered for inference.
        runWithoutResolvedSignatureCaching(editingArgument, () => getResolvedSignatureWorker(call, candidates, /*argumentCount*/ undefined, CheckMode.Normal));
        for (const candidate of candidates) {
            candidatesSet.add(candidate);
        }

        return arrayFrom(candidatesSet);
    }
    
    function getResolvedSignatureWorker(nodeIn: CallLikeExpression, candidatesOutArray: Signature[] | undefined, argumentCount: number | undefined, checkMode: CheckMode): Signature | undefined {
        const node = getParseTreeNode(nodeIn, isCallLikeExpression);
        apparentArgumentCount = argumentCount;
        const res = !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode);
        apparentArgumentCount = undefined;
        return res;
    }

    function isTypeAny(type: Type | undefined) {
        return type && (type.flags & TypeFlags.Any) !== 0;
    }

    function getTypeFacts(type: Type, mask: TypeFacts): TypeFacts {
        return getTypeFactsWorker(type, mask) & mask;
    }

    function isEmptyObjectType(type: Type): boolean {
        return type.flags & TypeFlags.Object ? /*!isGenericMappedType(type) &&*/ isEmptyResolvedType(resolveStructuredTypeMembers(type as ObjectType)) :
            type.flags & TypeFlags.NonPrimitive ? true :
            type.flags & TypeFlags.Union ? some((type as UnionType).types, isEmptyObjectType) :
            type.flags & TypeFlags.Intersection ? every((type as UnionType).types, isEmptyObjectType) :
            false;
    }

    function getTypeFactsWorker(type: Type, callerOnlyNeeds: TypeFacts): TypeFacts {
        if (type.flags & (TypeFlags.Intersection | TypeFlags.Instantiable)) {
            type = getBaseConstraintOfType(type) || unknownType;
        }
        const flags = type.flags;
        if (flags & (TypeFlags.String | TypeFlags.StringMapping)) {
            return strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts;
        }
        if (flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral)) {
            const isEmpty = flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "";
            return strictNullChecks ?
                isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts :
                isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts;
        }
        if (flags & TypeFlags.Bytes) {
            return strictNullChecks ? TypeFacts.BytesStrictFacts : TypeFacts.BytesFacts;
        }
        if (flags & (TypeFlags.Number | TypeFlags.Enum)) {
            return strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts;
        }
        if (flags & TypeFlags.IntLiteral) {
            const isZero = (type as IntLiteralType).value === 0;
            return strictNullChecks ?
                isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts :
                isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts;
        }
        // if (flags & TypeFlags.BigInt) {
        //     return strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts;
        // }
        if (flags & TypeFlags.FloatLiteral) {
            const isZero = (type as FloatLiteralType).value === 0;
            return strictNullChecks ?
                isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts :
                isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts;
        }
        if (flags & TypeFlags.Boolean) {
            return strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts;
        }
        // if (flags & TypeFlags.BooleanLike) {
        //     return strictNullChecks ?
        //         (type === falseType || type === regularFalseType) ? TypeFacts.FalseStrictFacts : TypeFacts.TrueStrictFacts :
        //         (type === falseType || type === regularFalseType) ? TypeFacts.FalseFacts : TypeFacts.TrueFacts;
        // }
        if (flags & TypeFlags.Object) {
            const possibleFacts = strictNullChecks
                ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts
                : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts;

            if ((callerOnlyNeeds & possibleFacts) === 0) {
                // If the caller doesn't care about any of the facts that we could possibly produce,
                // return zero so we can skip resolving members.
                return 0;
            }

            return getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(type as ObjectType) ?
                strictNullChecks ? TypeFacts.EmptyObjectStrictFacts : TypeFacts.EmptyObjectFacts :
                //isFunctionObjectType(type as ObjectType) ? strictNullChecks ? TypeFacts.FunctionStrictFacts : TypeFacts.FunctionFacts :
                strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts;
        }
        if (flags & TypeFlags.Void) {
            return TypeFacts.VoidFacts;
        }
        if (flags & TypeFlags.Undefined) {
            return TypeFacts.UndefinedFacts;
        }
        if (flags & TypeFlags.Null) {
            return TypeFacts.NullFacts;
        }        
        if (flags & TypeFlags.NonPrimitive) {
            return strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts;
        }
        if (flags & TypeFlags.Never) {
            return TypeFacts.None;
        }
        if (flags & TypeFlags.Union) {
            return reduceLeft((type as UnionType).types, (facts, t) => facts | getTypeFactsWorker(t, callerOnlyNeeds), TypeFacts.None);
        }
        if (flags & TypeFlags.Intersection) {
            return getIntersectionTypeFacts(type as IntersectionType, callerOnlyNeeds);
        }
        return TypeFacts.UnknownFacts;
    }

    function getIntersectionTypeFacts(type: IntersectionType, callerOnlyNeeds: TypeFacts): TypeFacts {
        // When an intersection contains a primitive type we ignore object type constituents as they are
        // presumably type tags. For example, in string & { __kind__: "name" } we ignore the object type.
        const ignoreObjects = maybeTypeOfKind(type, TypeFlags.Primitive);
        // When computing the type facts of an intersection type, certain type facts are computed as `and`
        // and others are computed as `or`.
        let oredFacts = TypeFacts.None;
        let andedFacts = TypeFacts.All;
        for (const t of type.types) {
            if (!(ignoreObjects && t.flags & TypeFlags.Object)) {
                const f = getTypeFactsWorker(t, callerOnlyNeeds);
                oredFacts |= f;
                andedFacts &= f;
            }
        }
        return oredFacts & TypeFacts.OrFactsMask | andedFacts & TypeFacts.AndFactsMask;
    }

    function checkNonNullTypeWithReporter(
        type: Type,
        node: Node,
        reportError: (node: Node, facts: TypeFacts) => void,
    ): Type {
        if (strictNullChecks && type.flags & TypeFlags.Unknown) {
            if (isEntityNameExpression(node)) {
                const nodeText = entityNameToString(node);
                if (nodeText.length < 100) {
                    error(node, Diagnostics._0_is_of_type_unknown, nodeText);
                    return errorType;
                }
            }
            error(node, Diagnostics.Object_is_of_type_unknown);
            return errorType;
        }
        const facts = getTypeFacts(type, TypeFacts.IsUndefinedOrNull);
        if (facts & TypeFacts.IsUndefinedOrNull) {
            reportError(node, facts);
            const t = getNonNullableType(type);
            return t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t;
        }
        return type;
    }

    function reportCannotInvokePossiblyNullOrUndefinedError(node: Node, facts: TypeFacts) {
        error(
            node,
            facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?
                Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :
                Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :
                Diagnostics.Cannot_invoke_an_object_which_is_possibly_null,
        );
    }

    function isEvaluteCallExpression(node: CallExpression) {
        return node.expression.kind === SyntaxKind.Identifier && (node.expression as Identifier).text === "$";
    }

    function skippedGenericFunction(node: Node, checkMode: CheckMode) {
        if (checkMode & CheckMode.Inferential) {
            // We have skipped a generic function during inferential typing. Obtain the inference context and
            // indicate this has occurred such that we know a second pass of inference is be needed.
            const context = getInferenceContext(node)!;
            context.flags |= InferenceFlags.SkippedGenericFunction;
        }
    }

    function isGenericFunctionReturningFunction(signature: Signature) {
        return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)));
    }

    /**
     * TS 1.0 spec: 4.12
     * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
     * but is a subtype of the Function interface, the call is an untyped function call.
     */
    function isUntypedFunctionCall(funcType: Type, apparentFuncType: Type, numCallSignatures: number, numConstructSignatures: number): boolean {
        // We exclude union types because we may have a union of function types that happen to have no common signatures.
        return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & TypeFlags.TypeParameter) ||
            !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & TypeFlags.Union) && !(getReducedType(apparentFuncType).flags & TypeFlags.Never) && isTypeAssignableTo(funcType, globalFunctionType);
    }

    function resolveCallExpression(node: CallExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        // if (node.expression.kind === SyntaxKind.SuperKeyword) {
        //     const superType = checkSuperExpression(node.expression);
        //     if (isTypeAny(superType)) {
        //         for (const arg of node.arguments) {
        //             checkExpression(arg); // Still visit arguments so they get marked for visibility, etc
        //         }
        //         return anySignature;
        //     }
        //     if (!isErrorType(superType)) {
        //         // In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
        //         // with the type arguments specified in the extends clause.
        //         // const baseTypeNode = getEffectiveBaseTypeNode(getContainingClass(node)!);
        //         // if (baseTypeNode) {
        //         //     const baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
        //         //     return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlags.None);
        //         // }
        //     }
        //     return resolveUntypedCall(node);
        // }

        // this is a special case for the closure $() eval function
        // just return anySignature for now
        if (isEvaluteCallExpression(node) && languageVariant === LanguageVariant.FluffOS && findAncestor(node, isInlineClosureExpression)) {
            return anySignature;
        }

        let callChainFlags: SignatureFlags;
        let funcType = checkExpression(node.expression, undefined, undefined, SymbolFlags.Function);
        if (isCallChain(node)) {
            console.debug("todo - call chain");
            // const nonOptionalType = getOptionalExpressionType(funcType, node.expression);
            // callChainFlags = nonOptionalType === funcType ? SignatureFlags.None :
            //     isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain :
            //     SignatureFlags.IsInnerCallChain;
            // funcType = nonOptionalType;
        }
        else {
            callChainFlags = SignatureFlags.None;
        }

        funcType = checkNonNullTypeWithReporter(
            funcType,
            node.expression,
            reportCannotInvokePossiblyNullOrUndefinedError,
        );

        if (funcType === silentNeverType) {
            return silentNeverSignature;
        }

        const apparentType = getApparentType(funcType);
        if (isErrorType(apparentType)) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }

        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including call signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
        const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;

        // In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
        // types are provided for the argument expressions, and the result is always of type Any.
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
            // The unknownType indicates that an error already occurred (and was reported).  No
            // need to report another error in this case.
            if (!isErrorType(funcType) && node.typeArguments) {
                error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }
        // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
        // TypeScript employs overload resolution in typed function calls in order to support functions
        // with multiple call signatures.
        if (!callSignatures.length) {
            if (numConstructSignatures) {
                error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            }
            else {
                let relatedInformation: DiagnosticRelatedInformation | undefined;
                if (node.arguments.length === 1) {
                    const text = getSourceFileOfNode(node).text;
                    if (isLineBreak(text.charCodeAt(skipTrivia(text, node.expression.end, /*stopAfterLineBreak*/ true) - 1))) {
                        relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon);
                    }
                }
                invocationError(node.expression, apparentType, SignatureKind.Call, relatedInformation);
            }
            return resolveErrorCall(node);
        }
        // When a call to a generic function is an argument to an outer call to a generic function for which
        // inference is in process, we have a choice to make. If the inner call relies on inferences made from
        // its contextual type to its return type, deferring the inner call processing allows the best possible
        // contextual type to accumulate. But if the outer call relies on inferences made from the return type of
        // the inner call, the inner call should be processed early. There's no sure way to know which choice is
        // right (only a full unification algorithm can determine that), so we resort to the following heuristic:
        // If no type arguments are specified in the inner call and at least one call signature is generic and
        // returns a function type, we choose to defer processing. This narrowly permits function composition
        // operators to flow inferences through return types, but otherwise processes calls right away. We
        // use the resolvingSignature singleton to indicate that we deferred processing. This result will be
        // propagated out and eventually turned into silentNeverType (a type that is assignable to anything and
        // from which we never make inferences).
        if (checkMode & CheckMode.SkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction)) {
            skippedGenericFunction(node, checkMode);
            return resolvingSignature;
        }
        // If the function is explicitly marked with `@class`, then it must be constructed.
        if (callSignatures.some(sig => isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration!))) {
            error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            return resolveErrorCall(node);
        }

        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags);
    }


    function resolveInlineClosureExpression(node: InlineClosureExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        const returnType = getReturnTypeFromBody(node);
        const callSignatures = getSignaturesOfType(returnType, SignatureKind.Call);
        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
    }

    function toNodeBuilderFlags(flags = TypeFormatFlags.None): NodeBuilderFlags {
        return flags & TypeFormatFlags.NodeBuilderFlagsMask;
    }


    function typeToString(type: Type, enclosingDeclaration?: Node, flags: TypeFormatFlags = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope, writer: EmitTextWriter = createTextWriter("")): string {       
        const noTruncation = false;//compilerOptions.noErrorTruncation || flags & TypeFormatFlags.NoTruncation;
        const typeNode = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : 0));
        if (typeNode === undefined) {
            console.warn("expected a type node but didn't get one");
            const typeNode2 = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : 0));
            return "<never>";
        }
        // The unresolved type gets a synthesized comment on `any` to hint to users that it's not a plain `any`.
        // Otherwise, we always strip comments out.
        const printer = type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults();
        const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
        printer.writeNode(EmitHint.Unspecified, typeNode, /*sourceFile*/ sourceFile, writer);
        const result = writer.getText();

        const maxLength = noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2;
        if (maxLength && result && result.length >= maxLength) {
            return result.substr(0, maxLength - "...".length) + "...";
        }
        return result;
    }

    // Re-order candidate signatures into the result array. Assumes the result array to be empty.
    // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
    // A nit here is that we reorder only signatures that belong to the same symbol,
    // so order how inherited signatures are processed is still preserved.
    // interface A { (x: string): void }
    // interface B extends A { (x: 'foo'): string }
    // const b: B;
    // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
    function reorderCandidates(signatures: readonly Signature[], result: Signature[], callChainFlags: SignatureFlags): void {
        let lastParent: Node | undefined;
        let lastSymbol: Symbol | undefined;
        let cutoffIndex = 0;
        let index: number | undefined;
        let specializedIndex = -1;
        let spliceIndex: number;
        Debug.assert(!result.length);
        for (const signature of signatures) {
            const symbol = signature.declaration && getSymbolOfDeclaration(signature.declaration);
            const parent = signature.declaration && signature.declaration.parent;
            if (!lastSymbol || symbol === lastSymbol) {
                if (lastParent && parent === lastParent) {
                    index = index! + 1;
                }
                else {
                    lastParent = parent;
                    index = cutoffIndex;
                }
            }
            else {
                // current declaration belongs to a different symbol
                // set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
                index = cutoffIndex = result.length;
                lastParent = parent;
            }
            lastSymbol = symbol;

            // specialized signatures always need to be placed before non-specialized signatures regardless
            // of the cutoff position; see GH#1133
            if (signatureHasLiteralTypes(signature) || signatureHasJsDoc(signature)) {
                specializedIndex++;
                spliceIndex = specializedIndex;
                // The cutoff index always needs to be greater than or equal to the specialized signature index
                // in order to prevent non-specialized signatures from being added before a specialized
                // signature.
                cutoffIndex++;
            }
            else {
                spliceIndex = index;
            }

            result.splice(spliceIndex, 0, /*callChainFlags ? getOptionalCallSignature(signature, callChainFlags) :*/ signature);
        }
    }

    // Function and class expression bodies are checked after all statements in the enclosing body. This is
    // to ensure constructs like the following are permitted:
    //     const foo = function () {
    //        const s = foo();
    //        return "hello";
    //     }
    // Here, performing a full type check of the body of the function expression whilst in the process of
    // determining the type of foo would cause foo to be given type any because of the recursive reference.
    // Delaying the type check of the body ensures foo has been assigned a type.
    function checkNodeDeferred(node: Node) {
        const enclosingFile = getSourceFileOfNode(node);
        const links = getNodeLinks(enclosingFile);
        if (!(links.flags & NodeCheckFlags.TypeChecked)) {
            links.deferredNodes ||= new Set();
            links.deferredNodes.add(node);
        }
        else {
            Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.");
        }
    }

    // No signature was applicable. We have already reported the errors for the invalid signature.
    function getCandidateForOverloadFailure(
        node: CallLikeExpression,
        candidates: Signature[],
        args: readonly Expression[],
        hasCandidatesOutArray: boolean,
        checkMode: CheckMode,
    ): Signature {
        Debug.assert(candidates.length > 0); // Else should not have called this.
        checkNodeDeferred(node);
        // Normally we will combine overloads. Skip this if they have type parameters since that's hard to combine.
        // Don't do this if there is a `candidatesOutArray`,
        // because then we want the chosen best candidate to be one of the overloads, not a combination.
        return hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters)
            ? pickLongestCandidateSignature(node, candidates, args, checkMode)
            : createUnionOfSignaturesForOverloadFailure(candidates);
    }

    function getLongestCandidateIndex(candidates: Signature[], argsCount: number): number {
        let maxParamsIndex = -1;
        let maxParams = -1;

        for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            const paramCount = getParameterCount(candidate);
            if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {
                return i;
            }
            if (paramCount > maxParams) {
                maxParams = paramCount;
                maxParamsIndex = i;
            }
        }

        return maxParamsIndex;
    }

  
    function pickLongestCandidateSignature(node: CallLikeExpression, candidates: Signature[], args: readonly Expression[], checkMode: CheckMode): Signature {
        // Pick the longest signature. This way we can get a contextual type for cases like:
        //     declare function f(a: { xa: number; xb: number; }, b: number);
        //     f({ |
        // Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
        //     declare function f<T>(k: keyof T);
        //     f<Foo>("
        const bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === undefined ? args.length : apparentArgumentCount);
        const candidate = candidates[bestIndex];
        const { typeParameters } = candidate;
        if (!typeParameters) {
            return candidate;
        }

        const typeArgumentNodes: readonly TypeNode[] | undefined = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined;
        const instantiated = typeArgumentNodes
            ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))
            : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode);
        candidates[bestIndex] = instantiated;
        return instantiated;
    }

    function getTypeArgumentsFromNodes(typeArgumentNodes: readonly TypeNode[], typeParameters: readonly TypeParameter[], isJs: boolean): readonly Type[] {
        const typeArguments = typeArgumentNodes.map(getTypeOfNode);
        while (typeArguments.length > typeParameters.length) {
            typeArguments.pop();
        }
        while (typeArguments.length < typeParameters.length) {
            typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));
        }
        return typeArguments;
    }

    function inferSignatureInstantiationForOverloadFailure(node: CallLikeExpression, typeParameters: readonly TypeParameter[], candidate: Signature, args: readonly Expression[], checkMode: CheckMode): Signature {
        const inferenceContext = createInferenceContext(typeParameters, candidate, /*flags*/ isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);
        const typeArgumentTypes = inferTypeArguments(node, candidate, args, checkMode | CheckMode.SkipContextSensitive | CheckMode.SkipGenericFunctions, inferenceContext);
        return createSignatureInstantiation(candidate, typeArgumentTypes);
    }

    function createCombinedSymbolFromTypes(sources: readonly Symbol[], types: Type[]): Symbol {
        return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReduction.Subtype));
    }

    function createCombinedSymbolForOverloadFailure(sources: readonly Symbol[], type: Type): Symbol {
        // This function is currently only used for erroneous overloads, so it's good enough to just use the first source.
        return createSymbolWithType(first(sources), type);
    }

    function getNumNonRestParameters(signature: Signature): number {
        const numParams = signature.parameters.length;
        return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
    }
    
    function tryGetRestTypeOfSignature(signature: Signature): Type | undefined {
        if (signatureHasRestParameter(signature)) {
            const sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            const restType = /*isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) :*/ sigRestType;
            return restType && getIndexTypeOfType(restType, numberType);
        }
        return undefined;
    }

    function createUnionOfSignaturesForOverloadFailure(candidates: readonly Signature[]): Signature {
        const thisParameters = mapDefined(candidates, c => c.thisParameter);
        let thisParameter: Symbol | undefined;
        if (thisParameters.length) {
            thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter));
        }
        const { min: minArgumentCount, max: maxNonRestParam } = minAndMax(candidates, getNumNonRestParameters);
        const parameters: Symbol[] = [];
        for (let i = 0; i < maxNonRestParam; i++) {
            const symbols = mapDefined(candidates, s =>
                signatureHasRestParameter(s) ?
                    i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) :
                    i < s.parameters.length ? s.parameters[i] : undefined);
            Debug.assert(symbols.length !== 0);
            parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));
        }
        const restParameterSymbols = mapDefined(candidates, c => signatureHasRestParameter(c) ? last(c.parameters) : undefined);
        let flags = SignatureFlags.IsSignatureCandidateForOverloadFailure;
        if (restParameterSymbols.length !== 0) {
            const type = createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReduction.Subtype));
            parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type));
            flags |= SignatureFlags.HasRestParameter;
        }
        if (candidates.some(signatureHasLiteralTypes)) {
            flags |= SignatureFlags.HasLiteralTypes;
        }
        return createSignature(
            candidates[0].declaration,
            /*typeParameters*/ undefined, // Before calling this we tested for `!candidates.some(c => !!c.typeParameters)`.
            thisParameter,
            parameters,
            /*resolvedReturnType*/ getIntersectionType(candidates.map(getReturnTypeOfSignature)),
            /*resolvedTypePredicate*/ undefined,
            minArgumentCount,
            flags,
        );
    }

    function addTypeToIntersection(typeSet: Map<string, Type>, includes: TypeFlags, type: Type) {
        const flags = type.flags;
        if (flags & TypeFlags.Intersection) {
            return addTypesToIntersection(typeSet, includes, (type as IntersectionType).types);
        }
        if (isEmptyAnonymousObjectType(type)) {
            if (!(includes & TypeFlags.IncludesEmptyObject)) {
                includes |= TypeFlags.IncludesEmptyObject;
                typeSet.set(type.id.toString(), type);
            }
        }
        else {
            if (flags & TypeFlags.AnyOrUnknown) {
                if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
                if (isErrorType(type)) includes |= TypeFlags.IncludesError;
            }
            else if (strictNullChecks || !(flags & TypeFlags.Nullable)) {
                if (type === missingType) {
                    includes |= TypeFlags.IncludesMissingType;
                    type = undefinedType;
                }
                if (!typeSet.has(type.id.toString())) {
                    if (type.flags & TypeFlags.Unit && includes & TypeFlags.Unit) {
                        // We have seen two distinct unit types which means we should reduce to an
                        // empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
                        includes |= TypeFlags.NonPrimitive;
                    }
                    typeSet.set(type.id.toString(), type);
                }
            }
            includes |= flags & TypeFlags.IncludesMask;
        }
        return includes;
    }

    // Add the given types to the given type set. Order is preserved, freshness is removed from literal
    // types, duplicates are removed, and nested types of the given kind are flattened into the set.
    function addTypesToIntersection(typeSet: Map<string, Type>, includes: TypeFlags, types: readonly Type[]) {
        for (const type of types) {
            includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
        }
        return includes;
    }
    
    function removeRedundantSupertypes(types: Type[], includes: TypeFlags) {
        let i = types.length;
        while (i > 0) {
            i--;
            const t = types[i];
            const remove = t.flags & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||
                t.flags & TypeFlags.Number && includes & TypeFlags.IntLiteral ||
                t.flags & TypeFlags.Float && includes & TypeFlags.FloatLiteral ||
                t.flags & TypeFlags.Bytes && includes & TypeFlags.BytesLiteral ||
                t.flags & TypeFlags.Void && includes & TypeFlags.Undefined ||
                isEmptyAnonymousObjectType(t) && includes & TypeFlags.DefinitelyNonNullable;
            if (remove) {
                orderedRemoveItemAt(types, i);
            }
        }
    }

    // Check that the given type has a match in every union. A given type is matched by
    // an identical type, and a literal type is additionally matched by its corresponding
    // primitive type, and missingType is matched by undefinedType (and vice versa).
    function eachUnionContains(unionTypes: UnionType[], type: Type) {
        for (const u of unionTypes) {
            if (!containsType(u.types, type)) {
                if (type === missingType) {
                    return containsType(u.types, undefinedType);
                }
                if (type === undefinedType) {
                    return containsType(u.types, missingType);
                }
                const primitive = type.flags & TypeFlags.StringLiteral ? stringType :
                    type.flags & (TypeFlags.Enum | TypeFlags.IntLiteral) ? numberType :
                    type.flags & TypeFlags.FloatLiteral ? floatType :
                    //type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :
                    undefined;
                if (!primitive || !containsType(u.types, primitive)) {
                    return false;
                }
            }
        }
        return true;
    }


    // If the given list of types contains more than one union of primitive types, replace the
    // first with a union containing an intersection of those primitive types, then remove the
    // other unions and return true. Otherwise, do nothing and return false.
    function intersectUnionsOfPrimitiveTypes(types: Type[]) {
        let unionTypes: UnionType[] | undefined;
        const index = findIndex(types, t => !!(getObjectFlags(t) & ObjectFlags.PrimitiveUnion));
        if (index < 0) {
            return false;
        }
        let i = index + 1;
        // Remove all but the first union of primitive types and collect them in
        // the unionTypes array.
        while (i < types.length) {
            const t = types[i];
            if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {
                (unionTypes || (unionTypes = [types[index] as UnionType])).push(t as UnionType);
                orderedRemoveItemAt(types, i);
            }
            else {
                i++;
            }
        }
        // Return false if there was only one union of primitive types
        if (!unionTypes) {
            return false;
        }
        // We have more than one union of primitive types, now intersect them. For each
        // type in each union we check if the type is matched in every union and if so
        // we include it in the result.
        const checked: Type[] = [];
        const result: Type[] = [];
        for (const u of unionTypes) {
            for (const t of u.types) {
                if (insertType(checked, t)) {
                    if (eachUnionContains(unionTypes, t)) {
                        // undefinedType/missingType should always come sorted first so we leverage that here
                        if (t === undefinedType && result.length && result[0] === missingType) {
                            continue;
                        }
                        if (t === missingType && result.length && result[0] === undefinedType) {
                            result[0] = missingType;
                            continue;
                        }
                        insertType(result, t);
                    }
                }
            }
        }
        // Finally replace the first union with the result
        types[index] = getUnionTypeFromSortedList(result, ObjectFlags.PrimitiveUnion);
        return true;
    }

    function containsMissingType(type: Type) {
        return type === missingType || !!(type.flags & TypeFlags.Union) && (type as UnionType).types[0] === missingType;
    }

    function removeFromEach(types: Type[], flag: TypeFlags) {
        for (let i = 0; i < types.length; i++) {
            types[i] = filterType(types[i], t => !(t.flags & flag));
        }
    }

    function getCrossProductUnionSize(types: readonly Type[]) {
        return reduceLeft(types, (n, t) => t.flags & TypeFlags.Union ? n * (t as UnionType).types.length : t.flags & TypeFlags.Never ? 0 : n, 1);
    }

    function checkCrossProductUnion(types: readonly Type[]) {
        const size = getCrossProductUnionSize(types);
        if (size >= 100000) {
            tracing?.instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit", { typeIds: types.map(t => t.id), size });
            error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
            return false;
        }
        return true;
    }

    function getCrossProductIntersections(types: readonly Type[], flags: IntersectionFlags) {
        const count = getCrossProductUnionSize(types);
        const intersections: Type[] = [];
        for (let i = 0; i < count; i++) {
            const constituents = types.slice();
            let n = i;
            for (let j = types.length - 1; j >= 0; j--) {
                if (types[j].flags & TypeFlags.Union) {
                    const sourceTypes = (types[j] as UnionType).types;
                    const length = sourceTypes.length;
                    constituents[j] = sourceTypes[n % length];
                    n = Math.floor(n / length);
                }
            }
            const t = getIntersectionType(constituents, flags);
            if (!(t.flags & TypeFlags.Never)) intersections.push(t);
        }
        return intersections;
    }

    function getConstituentCount(type: Type): number {
        return !(type.flags & TypeFlags.UnionOrIntersection) || type.aliasSymbol ? 1 :
            type.flags & TypeFlags.Union && (type as UnionType).origin ? getConstituentCount((type as UnionType).origin!) :
            getConstituentCountOfTypes((type as UnionOrIntersectionType).types);
    }

    function getConstituentCountOfTypes(types: Type[]): number {
        return reduceLeft(types, (n, t) => n + getConstituentCount(t), 0);
    }

    function createIntersectionType(types: Type[], objectFlags: ObjectFlags, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]) {
        const result = createType(TypeFlags.Intersection) as IntersectionType;
        result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ TypeFlags.Nullable);
        result.types = types;
        result.aliasSymbol = aliasSymbol;
        result.aliasTypeArguments = aliasTypeArguments;
        return result;
    }

    function isGenericStringLikeType(type: Type) {
        return !!(type.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping));// && !isPatternLiteralType(type);
    }

    // We normalize combinations of intersection and union types based on the distributive property of the '&'
    // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
    // types with union type constituents into equivalent union types with intersection type constituents and
    // effectively ensure that union types are always at the top level in type representations.
    //
    // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
    // type operator and we can't reduce those because we want to support recursive intersection types. For example,
    // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
    // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
    // for intersections of types with signatures can be deterministic.
    function getIntersectionType(types: readonly Type[], flags = IntersectionFlags.None, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
        const typeMembershipMap = new Map<string, Type>();
        const includes = addTypesToIntersection(typeMembershipMap, 0 as TypeFlags, types);
        const typeSet: Type[] = arrayFrom(typeMembershipMap.values());
        let objectFlags = ObjectFlags.None;
        // An intersection type is considered empty if it contains
        // the type never, or
        // more than one unit type or,
        // an object type and a nullable type (null or undefined), or
        // a string-like type and a type known to be non-string-like, or
        // a number-like type and a type known to be non-number-like, or
        // a symbol-like type and a type known to be non-symbol-like, or
        // a void-like type and a type known to be non-void-like, or
        // a non-primitive type and a type known to be primitive.
        if (includes & TypeFlags.Never) {
            return contains(typeSet, silentNeverType) ? silentNeverType : neverType;
        }
        if (
            strictNullChecks && includes & TypeFlags.Nullable && includes & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.IncludesEmptyObject) ||
            includes & TypeFlags.NonPrimitive && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NonPrimitive) ||
            includes & TypeFlags.StringLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.StringLike) ||
            includes & TypeFlags.NumberLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike) ||
            includes & TypeFlags.Float && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike) ||
            // includes & TypeFlags.ESSymbolLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.ESSymbolLike) ||
            includes & TypeFlags.VoidLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.VoidLike)
        ) {
            return neverType;
        }
        // if (includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.StringLiteral && extractRedundantTemplateLiterals(typeSet)) {
        //     return neverType;
        // }
        if (includes & TypeFlags.Any) {
            return includes & TypeFlags.IncludesWildcard ? wildcardType : includes & TypeFlags.IncludesError ? errorType : anyType;
        }
        if (!strictNullChecks && includes & TypeFlags.Nullable) {
            return includes & TypeFlags.IncludesEmptyObject ? neverType : includes & TypeFlags.Undefined ? undefinedType : nullType;
        }
        if (
            includes & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||
            includes & TypeFlags.Number && includes & TypeFlags.IntLiteral ||
            includes & TypeFlags.Float && includes & TypeFlags.FloatLiteral ||
            includes & TypeFlags.Bytes && includes & TypeFlags.BytesLiteral ||
            includes & TypeFlags.Void && includes & TypeFlags.Undefined ||
            includes & TypeFlags.IncludesEmptyObject && includes & TypeFlags.DefinitelyNonNullable
        ) {
            if (!(flags & IntersectionFlags.NoSupertypeReduction)) removeRedundantSupertypes(typeSet, includes);
        }
        if (includes & TypeFlags.IncludesMissingType) {
            typeSet[typeSet.indexOf(undefinedType)] = missingType;
        }
        if (typeSet.length === 0) {
            return unknownType;
        }
        if (typeSet.length === 1) {
            return typeSet[0];
        }
        if (typeSet.length === 2 && !(flags & IntersectionFlags.NoConstraintReduction)) {
            const typeVarIndex = typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1;
            const typeVariable = typeSet[typeVarIndex];
            const primitiveType = typeSet[1 - typeVarIndex];
            if (
                typeVariable.flags & TypeFlags.TypeVariable &&
                (primitiveType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) && !isGenericStringLikeType(primitiveType) || includes & TypeFlags.IncludesEmptyObject)
            ) {
                // We have an intersection T & P or P & T, where T is a type variable and P is a primitive type, the object type, or {}.
                const constraint = getBaseConstraintOfType(typeVariable);
                // Check that T's constraint is similarly composed of primitive types, the object type, or {}.
                if (constraint && everyType(constraint, t => !!(t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) || isEmptyAnonymousObjectType(t))) {
                    // If T's constraint is a subtype of P, simply return T. For example, given `T extends "a" | "b"`,
                    // the intersection `T & string` reduces to just T.
                    if (isTypeStrictSubtypeOf(constraint, primitiveType)) {
                        return typeVariable;
                    }
                    if (!(constraint.flags & TypeFlags.Union && someType(constraint, c => isTypeStrictSubtypeOf(c, primitiveType)))) {
                        // No constituent of T's constraint is a subtype of P. If P is also not a subtype of T's constraint,
                        // then the constraint and P are unrelated, and the intersection reduces to never. For example, given
                        // `T extends "a" | "b"`, the intersection `T & number` reduces to never.
                        if (!isTypeStrictSubtypeOf(primitiveType, constraint)) {
                            return neverType;
                        }
                    }
                    // Some constituent of T's constraint is a subtype of P, or P is a subtype of T's constraint. Thus,
                    // the intersection further constrains the type variable. For example, given `T extends string | number`,
                    // the intersection `T & "a"` is marked as a constrained type variable. Likewise, given `T extends "a" | 1`,
                    // the intersection `T & number` is marked as a constrained type variable.
                    objectFlags = ObjectFlags.IsConstrainedTypeVariable;
                }
            }
        }
        const id = getTypeListId(typeSet) + (flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments));
        let result = intersectionTypes.get(id);
        if (!result) {
            if (includes & TypeFlags.Union) {
                if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                    // When the intersection creates a reduced set (which might mean that *all* union types have
                    // disappeared), we restart the operation to get a new set of combined flags. Once we have
                    // reduced we'll never reduce again, so this occurs at most once.
                    result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments);
                }
                else if (every(typeSet, t => !!(t.flags & TypeFlags.Union && (t as UnionType).types[0].flags & TypeFlags.Undefined))) {
                    const containedUndefinedType = some(typeSet, containsMissingType) ? missingType : undefinedType;
                    removeFromEach(typeSet, TypeFlags.Undefined);
                    result = getUnionType([getIntersectionType(typeSet, flags), containedUndefinedType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
                }
                else if (every(typeSet, t => !!(t.flags & TypeFlags.Union && ((t as UnionType).types[0].flags & TypeFlags.Null || (t as UnionType).types[1].flags & TypeFlags.Null)))) {
                    removeFromEach(typeSet, TypeFlags.Null);
                    result = getUnionType([getIntersectionType(typeSet, flags), nullType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
                }
                else if (typeSet.length >= 4) {
                    // When we have four or more constituents, some of which are unions, we employ a "divide and conquer" strategy
                    // where A & B & C & D is processed as (A & B) & (C & D). Since intersections of unions often produce far smaller
                    // unions of intersections than the full cartesian product (due to some intersections becoming `never`), this can
                    // dramatically reduce the overall work.
                    const middle = Math.floor(typeSet.length / 2);
                    result = getIntersectionType([getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)], flags, aliasSymbol, aliasTypeArguments);
                }
                else {
                    // We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
                    // the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
                    // exceeds 100000 constituents, report an error.
                    if (!checkCrossProductUnion(typeSet)) {
                        return errorType;
                    }
                    const constituents = getCrossProductIntersections(typeSet, flags);
                    // We attach a denormalized origin type when at least one constituent of the cross-product union is an
                    // intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions) and
                    // the denormalized origin has fewer constituents than the union itself.
                    const origin = some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined;
                    result = getUnionType(constituents, UnionReduction.Literal, aliasSymbol, aliasTypeArguments, origin);
                }
            }
            else {
                result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments);
            }
            intersectionTypes.set(id, result);
        }
        return result;
    }

    function getEffectiveRestType(signature: Signature) {
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            if (!isTupleType(restType)) {
                return isTypeAny(restType) ? anyArrayType : restType;
            }
            if (restType.target.combinedFlags & ElementFlags.Variable) {
                return sliceTupleType(restType, restType.target.fixedLength);
            }
        }
        return undefined;
    }

    function getNonArrayRestType(signature: Signature) {
        const restType = getEffectiveRestType(signature);
        return restType && !isArrayType(restType) && !isTypeAny(restType) ? restType : undefined;
    }

    function getEffectiveCheckNode(argument: Expression): Expression {
        argument = skipParentheses(argument);
        return argument;// isSatisfiesExpression(argument) ? skipParentheses(argument.expression) : argument;
    }

    function isArrayLikeType(type: Type): boolean {
        // A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
        // or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
        return isArrayType(type) || !(type.flags & TypeFlags.Nullable) && isTypeAssignableTo(type, anyReadonlyArrayType);
    }

    function getMutableArrayOrTupleType(type: Type) {
        return type.flags & TypeFlags.Union ? mapType(type, getMutableArrayOrTupleType) :
            type.flags & TypeFlags.Any || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :
            isTupleType(type) ? createTupleType(getElementTypes(type), type.target.elementFlags, /*readonly*/ false, type.target.labeledElementDeclarations) :
            createTupleType([type], [ElementFlags.Variadic]);
    }

    function getMapperFromContext<T extends InferenceContext | undefined>(context: T): TypeMapper | T & undefined {
        return context && context.mapper;
    }

    function cloneInferenceInfo(inference: InferenceInfo): InferenceInfo {
        return {
            typeParameter: inference.typeParameter,
            candidates: inference.candidates && inference.candidates.slice(),
            contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),
            inferredType: inference.inferredType,
            priority: inference.priority,
            topLevel: inference.topLevel,
            isFixed: inference.isFixed,
            impliedArity: inference.impliedArity,
        };
    }

    function cloneInferenceContext<T extends InferenceContext | undefined>(context: T, extraFlags: InferenceFlags = 0): InferenceContext | T & undefined {
        return context && createInferenceContextWorker(map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes);
    }

    function hasInferenceCandidates(info: InferenceInfo) {
        return !!(info.candidates || info.contraCandidates);
    }

    function cloneInferredPartOfContext(context: InferenceContext): InferenceContext | undefined {
        const inferences = filter(context.inferences, hasInferenceCandidates);
        return inferences.length ?
            createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) :
            undefined;
    }

    function inferTypeArguments(node: CallLikeExpression, signature: Signature, args: readonly Expression[], checkMode: CheckMode, context: InferenceContext): Type[] {
        // If a contextual type is available, infer from that type to the return type of the call expression. For
        // example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
        // 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
        // return type of 'wrap'.
        // if (node.kind !== SyntaxKind.BinaryExpression) {
            const skipBindingPatterns = every(signature.typeParameters, p => !!getDefaultFromTypeParameter(p));
            const contextualType = getContextualType(node, skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None);
            if (contextualType) {
                const inferenceTargetType = getReturnTypeOfSignature(signature);
                if (couldContainTypeVariables(inferenceTargetType)) {
                    const outerContext = getInferenceContext(node);
                    const isFromBindingPattern = !skipBindingPatterns && getContextualType(node, ContextFlags.SkipBindingPatterns) !== contextualType;
                    // A return type inference from a binding pattern can be used in instantiating the contextual
                    // type of an argument later in inference, but cannot stand on its own as the final return type.
                    // It is incorporated into `context.returnMapper` which is used in `instantiateContextualType`,
                    // but doesn't need to go into `context.inferences`. This allows a an array binding pattern to
                    // produce a tuple for `T` in
                    //   declare function f<T>(cb: () => T): T;
                    //   const [e1, e2, e3] = f(() => [1, "hi", true]);
                    // but does not produce any inference for `T` in
                    //   declare function f<T>(): T;
                    //   const [e1, e2, e3] = f();
                    if (!isFromBindingPattern) {
                        // We clone the inference context to avoid disturbing a resolution in progress for an
                        // outer call expression. Effectively we just want a snapshot of whatever has been
                        // inferred for any outer call expression so far.
                        const outerMapper = getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlags.NoDefault));
                        const instantiatedType = instantiateType(contextualType, outerMapper);
                        // If the contextual type is a generic function type with a single call signature, we
                        // instantiate the type with its own type parameters and type arguments. This ensures that
                        // the type parameters are not erased to type any during type inference such that they can
                        // be inferred as actual types from the contextual type. For example:
                        //   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
                        //   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
                        // Above, the type of the 'value' parameter is inferred to be 'A'.
                        const contextualSignature = getSingleCallSignature(instantiatedType);
                        const inferenceSourceType = contextualSignature && contextualSignature.typeParameters ?
                            getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :
                            instantiatedType;
                        // Inferences made from return types have lower priority than all other inferences.
                        inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriority.ReturnType);
                    }
                    // Create a type mapper for instantiating generic contextual types using the inferences made
                    // from the return type. We need a separate inference pass here because (a) instantiation of
                    // the source type uses the outer context's return mapper (which excludes inferences made from
                    // outer arguments), and (b) we don't want any further inferences going into this context.
                    const returnContext = createInferenceContext(signature.typeParameters!, signature, context.flags);
                    const returnSourceType = instantiateType(contextualType, outerContext && outerContext.returnMapper);
                    inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType);
                    context.returnMapper = some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined;
                }
            }
        // }

        const restType = getNonArrayRestType(signature);
        const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
        if (restType && restType.flags & TypeFlags.TypeParameter) {
            const info = find(context.inferences, info => info.typeParameter === restType);
            if (info) {
                info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined;
            }
        }

        const thisType = getThisTypeOfSignature(signature);
        if (thisType && couldContainTypeVariables(thisType)) {
            console.debug("todo - inferTypeArguments thisType");
            // const thisArgumentNode = getThisArgumentOfCall(node);
            // inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType);
        }

        for (let i = 0; i < argCount; i++) {
            const arg = args[i];
            if (arg.kind !== SyntaxKind.OmittedExpression) {
                const paramType = getTypeAtPosition(signature, i);
                if (couldContainTypeVariables(paramType)) {
                    const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);
                    inferTypes(context.inferences, argType, paramType);
                }
            }
        }

        if (restType && couldContainTypeVariables(restType)) {
            const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode);
            inferTypes(context.inferences, spreadType, restType);
        }

        return getInferredTypes(context);
    }


    function getSpreadArgumentType(args: readonly Expression[], index: number, argCount: number, restType: Type, context: InferenceContext | undefined, checkMode: CheckMode) {
        const inConstContext = false;//isConstTypeVariable(restType);
        
        if (index >= argCount - 1) {
            const arg = args[argCount - 1];            
            if (isSpreadArgument(arg)) {
                // We are inferring from a spread expression in the last argument position, i.e. both the parameter
                // and the argument are ...x forms.
                const spreadType = /*arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type :*/
                    checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode);

                if (isArrayLikeType(spreadType)) {
                    return getMutableArrayOrTupleType(spreadType);
                }

                return createArrayType(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg), inConstContext);
            }  else {
                return getTypeOfExpression(arg as Expression);
            }
        }

        const types = [];
        const flags = [];
        const names = [];
        for (let i = index; i < argCount; i++) {
            const arg = args[i];
            if (isSpreadArgument(arg)) {
                const spreadType =/* arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : */checkExpression((arg as SpreadElement).expression);
                if (isArrayLikeType(spreadType)) {
                    types.push(spreadType);
                    flags.push(ElementFlags.Variadic);
                }
                else {
                    types.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg));
                    flags.push(ElementFlags.Rest);
                }
            }
            else {
                const contextualType = /*isTupleType(restType) ?
                    getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType :*/
                    getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual);
                const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);
                const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);
                types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));
                flags.push(ElementFlags.Required);
            }
            if (arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).tupleNameSource) {
                names.push((arg as SyntheticExpression).tupleNameSource!);
            }
            else {
                names.push(undefined);
            }
        }
        return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names);
    }

    function createTupleType(elementTypes: readonly Type[], elementFlags?: readonly ElementFlags[], readonly = false, namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration | undefined)[] = []) {
        const tupleTarget = getTupleTargetType(elementFlags || map(elementTypes, _ => ElementFlags.Required), readonly, namedMemberDeclarations);
        return tupleTarget === emptyGenericType ? emptyObjectType :
            elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :
            tupleTarget;
    }

    function getTupleTargetType(elementFlags: readonly ElementFlags[], readonly: boolean, namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration | undefined)[]): GenericType {
        if (elementFlags.length === 1 && elementFlags[0] & ElementFlags.Rest) {
            // [...X[]] is equivalent to just X[]
            return readonly ? globalReadonlyArrayType : globalArrayType;
        }
        const key = map(elementFlags, f => f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*").join() +
            (readonly ? "R" : "") +
            (some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "");
        let type = tupleTypes.get(key);
        if (!type) {
            tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
        }
        return type;
    }

    // We represent tuple types as type references to synthesized generic interface types created by
    // this function. The types are of the form:
    //
    //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
    //
    // Note that the generic type created by this function has no symbol associated with it. The same
    // is true for each of the synthesized type parameters.
    function createTupleTargetType(elementFlags: readonly ElementFlags[], readonly: boolean, namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration | undefined)[]): TupleType {
        const arity = elementFlags.length;
        const minLength = countWhere(elementFlags, f => !!(f & (ElementFlags.Required | ElementFlags.Variadic)));
        let typeParameters: TypeParameter[] | undefined;
        const properties: Symbol[] = [];
        let combinedFlags = 0 as ElementFlags;
        if (arity) {
            typeParameters = new Array(arity);
            for (let i = 0; i < arity; i++) {
                const typeParameter = typeParameters[i] = createTypeParameter();
                const flags = elementFlags[i];
                combinedFlags |= flags;
                if (!(combinedFlags & ElementFlags.Variable)) {
                    const property = createSymbol(SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0), "" + i as string, readonly ? CheckFlags.Readonly : 0);
                    property.links.tupleLabelDeclaration = namedMemberDeclarations?.[i];
                    property.links.type = typeParameter;
                    properties.push(property);
                }
            }
        }
        const fixedLength = properties.length;
        const lengthSymbol = createSymbol(SymbolFlags.Property, "length" as string, readonly ? CheckFlags.Readonly : 0);
        if (combinedFlags & ElementFlags.Variable) {
            lengthSymbol.links.type = numberType;
        }
        else {
            const literalTypes = [];
            for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i));
            lengthSymbol.links.type = getUnionType(literalTypes);
        }
        properties.push(lengthSymbol);
        const type = createObjectType(ObjectFlags.Tuple | ObjectFlags.Reference) as TupleType & InterfaceTypeWithDeclaredMembers;
        type.typeParameters = typeParameters;
        type.outerTypeParameters = undefined;
        type.localTypeParameters = typeParameters;
        type.instantiations = new Map<string, TypeReference>();
        type.instantiations.set(getTypeListId(type.typeParameters), type as GenericType);
        type.target = type as GenericType;
        type.resolvedTypeArguments = type.typeParameters;
        type.thisType = createTypeParameter();
        type.thisType.isThisType = true;
        type.thisType.constraint = type;
        type.declaredProperties = properties;
        type.declaredCallSignatures = emptyArray;
        type.declaredConstructSignatures = emptyArray;
        type.declaredIndexInfos = emptyArray;
        type.elementFlags = elementFlags;
        type.minLength = minLength;
        type.fixedLength = fixedLength;
        type.hasRestElement = !!(combinedFlags & ElementFlags.Variable);
        type.combinedFlags = combinedFlags;
        type.readonly = readonly;
        type.labeledElementDeclarations = namedMemberDeclarations;
        return type;
    }

    function isMutableArrayLikeType(type: Type): boolean {
        // A type is mutable-array-like if it is a reference to the global Array type, or if it is not the
        // any, undefined or null type and if it is assignable to Array<any>
        return isMutableArrayOrTuple(type) || !(type.flags & (TypeFlags.Any | TypeFlags.Nullable)) && isTypeAssignableTo(type, anyArrayType);
    }
    
    function isMutableArrayOrTuple(type: Type): boolean {
        return isArrayType(type) && !isReadonlyArrayType(type) || isTupleType(type) && !type.target.readonly;
    }

    /**
     * Check if a Type was written as a tuple type literal.
     * Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
     */
    function isTupleType(type: Type): type is TupleTypeReference {
        return !!(getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target.objectFlags & ObjectFlags.Tuple);
    }

    function createSyntheticExpression(parent: Node, type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration /*| NamedTupleMember*/): Expression {
        const result = parseNodeFactory.createSyntheticExpression(type, isSpread, tupleNameSource);
        setTextRangeWorker(result, parent);
        setParent(result, parent);
        return result;
    }

    function getSignatureApplicabilityError(
        node: CallLikeExpression,
        args: readonly Expression[],
        signature: Signature,
        relation: Map<string, RelationComparisonResult>,
        checkMode: CheckMode,
        reportErrors: boolean,
        containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
        inferenceContext: InferenceContext | undefined,
    ): readonly Diagnostic[] | undefined {
        const errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean; } = { errors: undefined, skipLogging: true };        
        // const thisType = getThisTypeOfSignature(signature);
        // if (thisType && thisType !== voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression))) {
        //     // If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
        //     // If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
        //     // If the expression is a new expression or super call expression, then the check is skipped.
        //     const thisArgumentNode = getThisArgumentOfCall(node);
        //     const thisArgumentType = getThisArgumentType(thisArgumentNode);
        //     const errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
        //     const headMessage = Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
        //     if (!checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)) {
        //         Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors");
        //         return errorOutputContainer.errors || emptyArray;
        //     }
        // }    
        const isVarArgs = isSignatureVarArgs(signature);
        if (isVarArgs) {    
            const ii=0;            
        }        
        const headMessage = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
        const restType = getNonArrayRestType(signature);
        const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
        for (let i = 0; i < argCount; i++) {
            const arg = args[i];
            // if (arg.kind !== SyntaxKind.OmittedExpression) {
                const paramType = getTypeAtPosition(signature, i);
                const argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext*/ undefined, checkMode);
                // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),
                // we obtain the regular type of any object literal arguments because we may not have inferred complete
                // parameter types yet and therefore excess property checks may yield false positives (see #17041).
                const regularArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;
                // If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving
                // the type variables in the expression.
                const checkArgType = inferenceContext ? instantiateType(regularArgType, inferenceContext.nonFixingMapper) : regularArgType;
                const effectiveCheckArgumentNode = getEffectiveCheckNode(arg);
                if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? effectiveCheckArgumentNode : undefined, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer)) {
                    Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");
                    maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
                    return errorOutputContainer.errors || emptyArray;
                }
            // }
        }
        if (restType) {
            const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, /*context*/ undefined, checkMode);
            const restArgCount = args.length - argCount;
            const errorNode = !reportErrors ? undefined :
                restArgCount === 0 ? node :
                restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) :
                setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end);
            if (!checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, /*containingMessageChain*/ undefined, errorOutputContainer)) {
                Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors");
                maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
                return errorOutputContainer.errors || emptyArray;
            }
        }
        return undefined;

        function maybeAddMissingAwaitInfo(errorNode: Node | undefined, source: Type, target: Type) {
            if (errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length) {
                // TODO 
                // Bail if target is Promise-like---something else is wrong
                // if (getAwaitedTypeOfPromise(target)) {
                //     return;
                // }
                // const awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
                // if (awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation)) {
                //     addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await));
                // }
            }
        }
    }

    function getErrorNodeForCallNode(callLike: CallLikeExpression): Node {
        if (isCallOrNewExpression(callLike)) {
            return isPropertyAccessExpression(callLike.expression) ? callLike.expression.name : callLike.expression;
        }
        
        return callLike;
    }

    function isSpreadArgument(arg: Expression | undefined): arg is Expression {        
        return !!arg && (arg.kind === SyntaxKind.SpreadElement);// TODO || arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).isSpread);
    }

    function getSpreadArgumentIndex(args: readonly Expression[]): number {
        return findIndex(args, isSpreadArgument);
    }

    function getDiagnosticForCallNode(node: CallLikeExpression, message: DiagnosticMessage | DiagnosticMessageChain, ...args: DiagnosticArguments): DiagnosticWithLocation {
        if (isCallExpression(node)) {
            const { sourceFile, start, length } = getDiagnosticSpanForCallNode(node);
            if ("message" in message) { // eslint-disable-line local/no-in-operator
                return createFileDiagnostic(sourceFile, start, length, message, ...args);
            }
            return createDiagnosticForFileFromMessageChain(sourceFile, message);
        }
        else {
            if ("message" in message) { // eslint-disable-line local/no-in-operator
                return createDiagnosticForNode(node, message, ...args);
            }
            return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message);
        }
    }

    function getArgumentArityError(node: CallLikeExpression, signatures: readonly Signature[], args: readonly Expression[], headMessage?: DiagnosticMessage) {                        
        const spreadIndex = getSpreadArgumentIndex(args);
        if (spreadIndex > -1) {
            return createDiagnosticForNode(args[spreadIndex], Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter);
        }
        let min = Number.POSITIVE_INFINITY; // smallest parameter count
        let max = Number.NEGATIVE_INFINITY; // largest parameter count
        let maxBelow = Number.NEGATIVE_INFINITY; // largest parameter count that is smaller than the number of arguments
        let minAbove = Number.POSITIVE_INFINITY; // smallest parameter count that is larger than the number of arguments

        let closestSignature: Signature | undefined;
        for (const sig of signatures) {
            const minParameter = getMinArgumentCount(sig);
            const maxParameter = getParameterCount(sig);
            // smallest/largest parameter counts
            if (minParameter < min) {
                min = minParameter;
                closestSignature = sig;
            }
            max = Math.max(max, maxParameter);
            // shortest parameter count *longer than the call*/longest parameter count *shorter than the call*
            if (minParameter < args.length && minParameter > maxBelow) maxBelow = minParameter;
            if (args.length < maxParameter && maxParameter < minAbove) minAbove = maxParameter;
        }
        const hasRestParameter = some(signatures, hasEffectiveRestParameter);
        // if (hasRestParameter) min--; // in LPC, varargs params are optional
        const parameterRange = hasRestParameter ? min 
            : min < max ? min + "-" + max
            : min;
        // const isVoidPromiseError = !hasRestParameter && parameterRange === 1 && args.length === 0 && isPromiseResolveArityError(node);
        // if (isVoidPromiseError && isInJSFile(node)) {
        //     return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments);
        // }
        const error = 
            hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 :
            //isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise :
            Diagnostics.Expected_0_arguments_but_got_1;        

        if (min < args.length && args.length < max) {
            // between min and max, but with no matching overload
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
                chain = chainDiagnosticMessages(chain, headMessage);
                return getDiagnosticForCallNode(node, chain);
            }
            return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
        }
        else if (args.length < min) {
            // too short: put the error span on the call expression, not any of the args
            let diagnostic: Diagnostic;
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, error, parameterRange, args.length);
                chain = chainDiagnosticMessages(chain, headMessage);
                diagnostic = getDiagnosticForCallNode(node, chain);
            }
            else {
                diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length);
            }
            const parameter = closestSignature?.declaration?.parameters[closestSignature.thisParameter ? args.length + 1 : args.length];
            if (parameter && !(parameter.flags & NodeFlags.ExternalFile)) {
                const messageAndArgs: DiagnosticAndArguments = isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided]
                    : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))]
                    : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))];
                const parameterError = createDiagnosticForNode(parameter, ...messageAndArgs);
                return addRelatedInfo(diagnostic, parameterError);
            }
            return diagnostic;
        }
        else if (args.length) {
            // too long; error goes on the excess parameters
            const errorSpan = factory.createNodeArray(args.slice(max));
            const errorSourceFile = getSourceFileOrIncludeOfNode(first(errorSpan));
            const pos = first(errorSpan).pos;
            let end = last(errorSpan).end;
            if (end === pos) {
                end++;
            }
            setTextRangePosEnd(errorSpan, pos, end);
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, error, parameterRange, args.length);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(errorSourceFile, errorSpan, chain);
            }
            return createDiagnosticForNodeArray(errorSourceFile, errorSpan, error, parameterRange, args.length);
        }
    }

    function checkTypeArguments(signature: Signature, typeArgumentNodes: readonly TypeNode[], reportErrors: boolean, headMessage?: DiagnosticMessage): Type[] | undefined {
        const isJavascript = isInJSFile(signature.declaration);
        const typeParameters = signature.typeParameters!;
        const typeArgumentTypes = fillMissingTypeArguments(map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
        let mapper: TypeMapper | undefined;
        for (let i = 0; i < typeArgumentNodes.length; i++) {
            Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");
            const constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                const errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;
                const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                if (!mapper) {
                    mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                }
                const typeArgument = typeArgumentTypes[i];
                if (
                    !checkTypeAssignableTo(
                        typeArgument,
                        getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),
                        reportErrors ? typeArgumentNodes[i] : undefined,
                        typeArgumentHeadMessage,
                        errorInfo,
                    )
                ) {
                    return undefined;
                }
            }
        }
        return typeArgumentTypes;
    }

    function hasCorrectTypeArgumentArity(signature: Signature, typeArguments: NodeArray<TypeNode> | undefined) {
        // If the user supplied type arguments, but the number of type arguments does not match
        // the declared number of type parameters, the call has an incorrect arity.
        const numTypeParameters = length(signature.typeParameters);
        const minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
        return !some(typeArguments) ||
            (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
    }

    function acceptsVoidUndefinedUnknownOrAny(t: Type): boolean {
        return !!(t.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Unknown | TypeFlags.Any));
    }

    function hasCorrectArity(node: CallLikeExpression, args: readonly Expression[], signature: Signature, signatureHelpTrailingComma = false) {        
        let argCount: number;
        let callIsIncomplete = false; // In incomplete call we want to be lenient when we have too few arguments
        let effectiveParameterCount = getParameterCount(signature);
        let effectiveMinimumArguments = getMinArgumentCount(signature);

        // if (node.kind === SyntaxKind.TaggedTemplateExpression) {
        //     argCount = args.length;
        //     if (node.template.kind === SyntaxKind.TemplateExpression) {
        //         // If a tagged template expression lacks a tail literal, the call is incomplete.
        //         // Specifically, a template only can end in a TemplateTail or a Missing literal.
        //         const lastSpan = last(node.template.templateSpans); // we should always have at least one span.
        //         callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
        //     }
        //     else {
        //         // If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
        //         // then this might actually turn out to be a TemplateHead in the future;
        //         // so we consider the call to be incomplete.
        //         const templateLiteral = node.template as LiteralExpression;
        //         Debug.assert(templateLiteral.kind === SyntaxKind.NoSubstitutionTemplateLiteral);
        //         callIsIncomplete = !!templateLiteral.isUnterminated;
        //     }
        // }
        // else if (node.kind === SyntaxKind.Decorator) {
        //     argCount = getDecoratorArgumentCount(node, signature);
        // }        
        // if (node.kind === SyntaxKind.BinaryExpression) {
        //     argCount = 1;
        // } else
        if (!node.arguments) {
            // This only happens when we have something of the form: 'new C'
            Debug.assert(node.kind === SyntaxKind.NewExpression);
            return getMinArgumentCount(signature) === 0;
        }
        else {
            argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;

            // If we are missing the close parenthesis, the call is incomplete.                        
            
            callIsIncomplete = !node.arguments.isComplete;//node.arguments.end === node.end - 1;

            // If a spread argument is present, check that it corresponds to a rest parameter or at least that it's in the valid range.
            const spreadArgIndex = getSpreadArgumentIndex(args);
            if (spreadArgIndex >= 0) {
                return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature));
            }
        }

        // Too many arguments implies incorrect arity.
        if (!hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount) {
            return false;
        }

        // If the call is incomplete, we should skip the lower bound check.
        // JSX signatures can have extra parameters provided by the library which we don't check
        if (callIsIncomplete || argCount >= effectiveMinimumArguments) {
            return true;
        }
        for (let i = argCount; i < effectiveMinimumArguments; i++) {
            const type = getTypeAtPosition(signature, i);
            if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & TypeFlags.Never) {
                return false;
            }
        }
        return true;
    }

    function getImplementationSignature(signature: Signature) {
        return signature.typeParameters ?
            signature.implementationSignatureCache ||= createImplementationSignature(signature) :
            signature;
    }

    function createImplementationSignature(signature: Signature) {
        return signature.typeParameters ? instantiateSignature(signature, createTypeMapper([], [])) : signature;
    }

    function createInferenceInfo(typeParameter: TypeParameter): InferenceInfo {
        return {
            typeParameter,
            candidates: undefined,
            contraCandidates: undefined,
            inferredType: undefined,
            priority: undefined,
            topLevel: true,
            isFixed: false,
            impliedArity: undefined,
        };
    }
    
    function createInferenceContext(typeParameters: readonly TypeParameter[], signature: Signature | undefined, flags: InferenceFlags, compareTypes?: TypeComparer): InferenceContext {
        return createInferenceContextWorker(typeParameters.map(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable);
    }

    function isObjectOrArrayLiteralType(type: Type) {
        return !!(getObjectFlags(type) & (ObjectFlags.ObjectLiteral | ObjectFlags.ArrayLiteral));
    }
    
    function unionObjectAndArrayLiteralCandidates(candidates: Type[]): Type[] {
        if (candidates.length > 1) {
            const objectLiterals = filter(candidates, isObjectOrArrayLiteralType);
            if (objectLiterals.length) {
                const literalsType = getUnionType(objectLiterals, UnionReduction.Subtype);
                return concatenate(filter(candidates, t => !isObjectOrArrayLiteralType(t)), [literalsType]);
            }
        }
        return candidates;
    }

    function createInferenceContextWorker(inferences: InferenceInfo[], signature: Signature | undefined, flags: InferenceFlags, compareTypes: TypeComparer): InferenceContext {
        const context: InferenceContext = {
            inferences,
            signature,
            flags,
            compareTypes,
            mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction
            nonFixingMapper: reportUnmeasurableMapper,
        };
        context.mapper = makeFixingMapperForContext(context);
        context.nonFixingMapper = makeNonFixingMapperForContext(context);
        return context;
    }

    function literalTypesWithSameBaseType(types: Type[]): boolean {
        let commonBaseType: Type | undefined;
        for (const t of types) {
            if (!(t.flags & TypeFlags.Never)) {
                const baseType = getBaseTypeOfLiteralType(t);
                commonBaseType ??= baseType;
                if (baseType === t || baseType !== commonBaseType) {
                    return false;
                }
            }
        }
        return true;
    }
    
    function isNullableType(type: Type) {
        return hasTypeFacts(type, TypeFacts.IsUndefinedOrNull);
    }

    /**
     * Add undefined or null or both to a type if they are missing.
     * @param type - type to add undefined and/or null to if not present
     * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
     */
    function getNullableType(type: Type, flags: TypeFlags): Type {
        const missing = (flags & ~type.flags) & (TypeFlags.Undefined | TypeFlags.Null);
        return missing === 0 ? type :
            missing === TypeFlags.Undefined ? getUnionType([type, undefinedType]) :
            missing === TypeFlags.Null ? getUnionType([type, nullType]) :
            getUnionType([type, undefinedType, nullType]);
    }

    function getCombinedTypeFlags(types: Type[]): TypeFlags {
        return reduceLeft(types, (flags, t) => flags | (t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags), 0 as TypeFlags);
    }

    function getTypeParameterModifiers(tp: TypeParameter): ModifierFlags {
        return reduceLeft(tp.symbol?.declarations, (modifiers, d) => modifiers | getEffectiveModifierFlags(d), ModifierFlags.None) & (ModifierFlags.In | ModifierFlags.Out);
    }

    function getCommonSupertype(types: Type[]): Type {
        if (types.length === 1) {
            return types[0];
        }
        // Remove nullable types from each of the candidates.
        const primaryTypes = strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types;
        // When the candidate types are all literal types with the same base type, return a union
        // of those literal types. Otherwise, return the leftmost type for which no type to the
        // right is a supertype.
        const superTypeOrUnion = literalTypesWithSameBaseType(primaryTypes) ?
            getUnionType(primaryTypes) :
            reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s)!;
        // Add any nullable types that occurred in the candidates back to the result.
        return primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & TypeFlags.Nullable);
    }

    function getAliasVariances(symbol: Symbol) {
        return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters);
    }

    // Return an array containing the variance of each type parameter. The variance is effectively
    // a digest of the type comparisons that occur for each type argument when instantiations of the
    // generic type are structurally compared. We infer the variance information by comparing
    // instantiations of the generic type for type arguments with known relations. The function
    // returns the emptyArray singleton when invoked recursively for the given generic type.
    function getVariancesWorker(symbol: Symbol, typeParameters: readonly TypeParameter[] = emptyArray): VarianceFlags[] {
        const links = getSymbolLinks(symbol);
        if (!links.variances) {
            tracing?.push(tracing.Phase.CheckTypes, "getVariancesWorker", { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) });
            const oldVarianceComputation = inVarianceComputation;
            const saveResolutionStart = resolutionStart;
            if (!inVarianceComputation) {
                inVarianceComputation = true;
                resolutionStart = resolutionTargets.length;
            }
            links.variances = emptyArray;
            const variances = [];
            for (const tp of typeParameters) {
                const modifiers = getTypeParameterModifiers(tp);
                let variance = modifiers & ModifierFlags.Out ?
                    modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant :
                    modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined;
                if (variance === undefined) {
                    let unmeasurable = false;
                    let unreliable = false;
                    const oldHandler = outofbandVarianceMarkerHandler;
                    outofbandVarianceMarkerHandler = onlyUnreliable => onlyUnreliable ? unreliable = true : unmeasurable = true;
                    // We first compare instantiations where the type parameter is replaced with
                    // marker types that have a known subtype relationship. From this we can infer
                    // invariance, covariance, contravariance or bivariance.
                    const typeWithSuper = createMarkerType(symbol, tp, markerSuperType);
                    const typeWithSub = createMarkerType(symbol, tp, markerSubType);
                    variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0) |
                        (isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0);
                    // If the instantiations appear to be related bivariantly it may be because the
                    // type parameter is independent (i.e. it isn't witnessed anywhere in the generic
                    // type). To determine this we compare instantiations where the type parameter is
                    // replaced with marker types that are known to be unrelated.
                    if (variance === VarianceFlags.Bivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper)) {
                        variance = VarianceFlags.Independent;
                    }
                    outofbandVarianceMarkerHandler = oldHandler;
                    if (unmeasurable || unreliable) {
                        if (unmeasurable) {
                            variance |= VarianceFlags.Unmeasurable;
                        }
                        if (unreliable) {
                            variance |= VarianceFlags.Unreliable;
                        }
                    }
                }
                variances.push(variance);
            }
            if (!oldVarianceComputation) {
                inVarianceComputation = false;
                resolutionStart = saveResolutionStart;
            }
            links.variances = variances;
            tracing?.pop({ variances: variances.map(Debug.formatVariance) });
        }
        return links.variances;
    }
    
    function hasPrimitiveConstraint(type: TypeParameter): boolean {
        const constraint = getConstraintOfTypeParameter(type);
        return !!constraint && maybeTypeOfKind(constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);
    }
    
    function isTypeParameterAtTopLevelInReturnType(signature: Signature, typeParameter: TypeParameter) {
        const typePredicate = getTypePredicateOfSignature(signature);
        return typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) :
            isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter);
    }

    function getCovariantInference(inference: InferenceInfo, signature: Signature) {
        // Extract all object and array literal types and replace them with a single widened and normalized type.
        const candidates = unionObjectAndArrayLiteralCandidates(inference.candidates!);
        // We widen inferred literal types if
        // all inferences were made to top-level occurrences of the type parameter, and
        // the type parameter has no constraint or its constraint includes no primitive or literal types, and
        // the type parameter was fixed during inference or does not occur at top-level in the return type.
        const primitiveConstraint = hasPrimitiveConstraint(inference.typeParameter);// || isConstTypeVariable(inference.typeParameter);
        const widenLiteralTypes = !primitiveConstraint && inference.topLevel &&
            (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter));
        const baseCandidates = primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) :
            widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) :
            candidates;
        // If all inferences were made from a position that implies a combined result, infer a union type.
        // Otherwise, infer a common supertype.
        const unwidenedType = inference.priority! & InferencePriority.PriorityImpliesCombination ?
            getUnionType(baseCandidates, UnionReduction.Subtype) :
            getCommonSupertype(baseCandidates);
        return getWidenedType(unwidenedType);
    }

    function getContravariantInference(inference: InferenceInfo) {
        return inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!);
    }

    // Return the leftmost type for which no type to the right is a subtype.
    function getCommonSubtype(types: Type[]) {
        return reduceLeft(types, (s, t) => isTypeSubtypeOf(t, s) ? t : s)!;
    }

    function getConstraintOfTypeParameter(typeParameter: TypeParameter): Type | undefined {
        return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
    }

    function getInferredType(context: InferenceContext, index: number): Type {
        const inference = context.inferences[index];
        if (!inference.inferredType) {
            let inferredType: Type | undefined;
            let fallbackType: Type | undefined;
            if (context.signature) {
                const inferredCovariantType = inference.candidates ? getCovariantInference(inference, context.signature) : undefined;
                const inferredContravariantType = inference.contraCandidates ? getContravariantInference(inference) : undefined;
                if (inferredCovariantType || inferredContravariantType) {
                    // If we have both co- and contra-variant inferences, we prefer the co-variant inference if it is not 'never',
                    // all co-variant inferences are assignable to it (i.e. it isn't one of a conflicting set of candidates), it is
                    // assignable to some contra-variant inference, and no other type parameter is constrained to this type parameter
                    // and has inferences that would conflict. Otherwise, we prefer the contra-variant inference.
                    // Similarly ignore co-variant `any` inference when both are available as almost everything is assignable to it
                    // and it would spoil the overall inference.
                    const preferCovariantType = inferredCovariantType && (!inferredContravariantType ||
                        !(inferredCovariantType.flags & (TypeFlags.Never | TypeFlags.Any)) &&
                            some(inference.contraCandidates, t => isTypeAssignableTo(inferredCovariantType, t)) &&
                            every(context.inferences, other =>
                                other !== inference && getConstraintOfTypeParameter(other.typeParameter) !== inference.typeParameter ||
                                every(other.candidates, t => isTypeAssignableTo(t, inferredCovariantType))));
                    inferredType = preferCovariantType ? inferredCovariantType : inferredContravariantType;
                    fallbackType = preferCovariantType ? inferredContravariantType : inferredCovariantType;
                }
                else if (context.flags & InferenceFlags.NoDefault) {
                    // We use silentNeverType as the wildcard that signals no inferences.
                    inferredType = silentNeverType;
                }
                else {
                    // Infer either the default or the empty object type when no inferences were
                    // made. It is important to remember that in this case, inference still
                    // succeeds, meaning there is no error for not having inference candidates. An
                    // inference error only occurs when there are *conflicting* candidates, i.e.
                    // candidates with no common supertype.
                    const defaultType = getDefaultFromTypeParameter(inference.typeParameter);
                    if (defaultType) {
                        // Instantiate the default type. Any forward reference to a type
                        // parameter should be instantiated to the empty object type.
                        inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper));
                    }
                }
            }
            else {
                inferredType = getTypeFromInference(inference);
            }

            inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlags.AnyDefault));

            const constraint = getConstraintOfTypeParameter(inference.typeParameter);
            if (constraint) {
                const instantiatedConstraint = instantiateType(constraint, context.nonFixingMapper);
                if (!inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType))) {
                    // If the fallback type satisfies the constraint, we pick it. Otherwise, we pick the constraint.
                    inference.inferredType = fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint;
                }
            }
        }

        return inference.inferredType;
    }

    function getTypeFromInference(inference: InferenceInfo) {
        return inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) :
            inference.contraCandidates ? getIntersectionType(inference.contraCandidates) :
            undefined;
    }

    function makeDeferredTypeMapper(sources: readonly TypeParameter[], targets: (() => Type)[]) {
        return Debug.attachDebugPrototypeIfDebug({ kind: TypeMapKind.Deferred, sources, targets });
    }

    function makeNonFixingMapperForContext(context: InferenceContext) {
        return makeDeferredTypeMapper(
            map(context.inferences, i => i.typeParameter),
            map(context.inferences, (_, i) => () => {
                return getInferredType(context, i);
            }),
        );
    }

    
    // We collect intra-expression inference sites within object and array literals to handle cases where
    // inferred types flow between context sensitive element expressions. For example:
    //
    //   declare function foo<T>(arg: [(n: number) => T, (x: T) => void]): void;
    //   foo([_a => 0, n => n.toFixed()]);
    //
    // Above, both arrow functions in the tuple argument are context sensitive, thus both are omitted from the
    // pass that collects inferences from the non-context sensitive parts of the arguments. In the subsequent
    // pass where nothing is omitted, we need to commit to an inference for T in order to contextually type the
    // parameter in the second arrow function, but we want to first infer from the return type of the first
    // arrow function. This happens automatically when the arrow functions are discrete arguments (because we
    // infer from each argument before processing the next), but when the arrow functions are elements of an
    // object or array literal, we need to perform intra-expression inferences early.
    function inferFromIntraExpressionSites(context: InferenceContext) {
        if (context.intraExpressionInferenceSites) {
            for (const { node, type } of context.intraExpressionInferenceSites) {
                const contextualType = /*node.kind === SyntaxKind.MethodDeclaration ?
                    getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) :*/
                    getContextualType(node, ContextFlags.NoConstraints);
                if (contextualType) {
                    Debug.fail("implement me");
                    //inferTypes(context.inferences, type, contextualType);
                }
            }
            context.intraExpressionInferenceSites = undefined;
        }
    }

    function clearCachedInferences(inferences: InferenceInfo[]) {
        for (const inference of inferences) {
            if (!inference.isFixed) {
                inference.inferredType = undefined;
            }
        }
    }

    function makeFixingMapperForContext(context: InferenceContext) {
        return makeDeferredTypeMapper(
            map(context.inferences, i => i.typeParameter),
            map(context.inferences, (inference, i) => () => {
                if (!inference.isFixed) {
                    // Before we commit to a particular inference (and thus lock out any further inferences),
                    // we infer from any intra-expression inference sites we have collected.
                    inferFromIntraExpressionSites(context);
                    clearCachedInferences(context.inferences);
                    inference.isFixed = true;
                }
                return getInferredType(context, i);
            }),
        );
    }

    function getSignatureInstantiation(signature: Signature, typeArguments: readonly Type[] | undefined, isJavascript: boolean, inferredTypeParameters?: readonly TypeParameter[]): Signature {
        const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
        if (inferredTypeParameters) {
            const returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
            if (returnSignature) {
                const newReturnSignature = cloneSignature(returnSignature);
                newReturnSignature.typeParameters = inferredTypeParameters;
                const newInstantiatedSignature = cloneSignature(instantiatedSignature);
                newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
                return newInstantiatedSignature;
            }
        }
        return instantiatedSignature;
    }

    function getSignatureInstantiationWithoutFillingInTypeArguments(signature: Signature, typeArguments: readonly Type[] | undefined): Signature {
        const instantiations = signature.instantiations || (signature.instantiations = new Map<string, Signature>());
        const id = getTypeListId(typeArguments);
        let instantiation = instantiations.get(id);
        if (!instantiation) {
            instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
        }
        return instantiation;
    }

    function createSignatureInstantiation(signature: Signature, typeArguments: readonly Type[] | undefined): Signature {
        return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), /*eraseTypeParameters*/ true);
    }

    function createSignatureTypeMapper(signature: Signature, typeArguments: readonly Type[] | undefined): TypeMapper {
        return createTypeMapper(sameMap(signature.typeParameters!, tp => tp.mapper ? instantiateType(tp, tp.mapper) : tp), typeArguments);
    }

    function getSingleCallOrConstructSignature(type: Type): Signature | undefined {
        return getSingleSignature(type, SignatureKind.Call, /*allowMembers*/ false) ||
            getSingleSignature(type, SignatureKind.Construct, /*allowMembers*/ false);
    }

    function resolveCall(node: CallLikeExpression, signatures: readonly Signature[], candidatesOutArray: Signature[] | undefined, checkMode: CheckMode, callChainFlags: SignatureFlags, headMessage?: DiagnosticMessage): Signature {
        const isTaggedTemplate = false;
        const isDecorator = false;        
        const isInstanceof = false;// node.kind === SyntaxKind.BinaryExpression;
        const reportErrors = !isInferencePartiallyBlocked && !candidatesOutArray;
        
        let typeArguments: NodeArray<TypeNode> | undefined;

        if (!isDecorator && !isInstanceof && !isSuperCall(node)) {
            typeArguments = (node as CallExpression).typeArguments;

            // We already perform checking on the type arguments on the class declaration itself.
            if (isTaggedTemplate || (node as CallExpression).expression.kind !== SyntaxKind.SuperKeyword) {
                forEach(typeArguments, checkSourceElement);
            }
        }

        const candidates = candidatesOutArray || [];
        // reorderCandidates fills up the candidates array directly
        reorderCandidates(signatures, candidates, callChainFlags);
        Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this");

        const args = getEffectiveCallArguments(node);

        // The excludeArgument array contains true for each context sensitive argument (an argument
        // is context sensitive it is susceptible to a one-time permanent contextual typing).
        //
        // The idea is that we will perform type argument inference & assignability checking once
        // without using the susceptible parameters that are functions, and once more for those
        // parameters, contextually typing each as we go along.
        //
        // For a tagged template, then the first argument be 'undefined' if necessary because it
        // represents a TemplateStringsArray.
        //
        // For a decorator, no arguments are susceptible to contextual typing due to the fact
        // decorators are applied to a declaration by the emitter, and not to an expression.
        const isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
        let argCheckMode = !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal;

        // The following variables are captured and modified by calls to chooseOverload.
        // If overload resolution or type argument inference fails, we want to report the
        // best error possible. The best error is one which says that an argument was not
        // assignable to a parameter. This implies that everything else about the overload
        // was fine. So if there is any overload that is only incorrect because of an
        // argument, we will report an error on that one.
        //
        //     function foo(s: string): void;
        //     function foo(n: number): void; // Report argument error on this overload
        //     function foo(): void;
        //     foo(true);
        //
        // If none of the overloads even made it that far, there are two possibilities.
        // There was a problem with type arguments for some overload, in which case
        // report an error on that. Or none of the overloads even had correct arity,
        // in which case give an arity error.
        //
        //     function foo<T extends string>(x: T): void; // Report type argument error
        //     function foo(): void;
        //     foo<number>(0);
        //
        let candidatesForArgumentError: Signature[] | undefined;
        let candidateForArgumentArityError: Signature | undefined;
        let candidateForTypeArgumentError: Signature | undefined;
        let result: Signature | undefined;

        // If we are in signature help, a trailing comma indicates that we intend to provide another argument,
        // so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
        const signatureHelpTrailingComma = !!(checkMode & CheckMode.IsForSignatureHelp) && node.kind === SyntaxKind.CallExpression && node.arguments.hasTrailingComma;

        // Section 4.12.1:
        // if the candidate list contains one or more signatures for which the type of each argument
        // expression is a subtype of each corresponding parameter type, the return type of the first
        // of those signatures becomes the return type of the function call.
        // Otherwise, the return type of the first signature in the candidate list becomes the return
        // type of the function call.
        //
        // Whether the call is an error is determined by assignability of the arguments. The subtype pass
        // is just important for choosing the best signature. So in the case where there is only one
        // signature, the subtype pass is useless. So skipping it is an optimization.
        if (candidates.length > 1) {
            result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
        }
        if (!result) {
            result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
        }
        if (result) {
            return result;
        }

        result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode);
        // Preemptively cache the result; getResolvedSignature will do this after we return, but
        // we need to ensure that the result is present for the error checks below so that if
        // this signature is encountered again, we handle the circularity (rather than producing a
        // different result which may produce no errors and assert). Callers of getResolvedSignature
        // don't hit this issue because they only observe this result after it's had a chance to
        // be cached, but the error reporting code below executes before getResolvedSignature sets
        // resolvedSignature.
        getNodeLinks(node).resolvedSignature = result;

        // No signatures were applicable. Now report errors based on the last applicable signature with
        // no arguments excluded from assignability checks.
        // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
        // skip the checkApplicableSignature check.
        if (reportErrors) {
            // If the call expression is a synthetic call to a `[Symbol.hasInstance]` method then we will produce a head
            // message when reporting diagnostics that explains how we got to `right[Symbol.hasInstance](left)` from
            // `left instanceof right`, as it pertains to "Argument" related messages reported for the call.
            // if (!headMessage && isInstanceof) {
            //     headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method;
            // }
            if (candidatesForArgumentError) {
                if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
                    const last = candidatesForArgumentError[candidatesForArgumentError.length - 1];
                    let chain: DiagnosticMessageChain | undefined;
                    if (candidatesForArgumentError.length > 3) {
                        chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error);
                        chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call);
                    }
                    if (headMessage) {
                        chain = chainDiagnosticMessages(chain, headMessage);
                    }
                    const diags = getSignatureApplicabilityError(node, args, last, assignableRelation, CheckMode.Normal, /*reportErrors*/ true, () => chain, /*inferenceContext*/ undefined);
                    if (diags) {
                        for (const d of diags) {
                            if (last.declaration && candidatesForArgumentError.length > 3) {
                                addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here));
                            }
                            addImplementationSuccessElaboration(last, d);
                            diagnostics.add(d);
                        }
                    }
                    else {
                        Debug.fail("No error for last overload signature");
                    }
                }
                else {
                    const allDiagnostics: (readonly DiagnosticRelatedInformation[])[] = [];
                    let max = 0;
                    let min = Number.MAX_VALUE;
                    let minIndex = 0;
                    let i = 0;
                    for (const c of candidatesForArgumentError) {
                        const chain = () => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c));
                        const diags = getSignatureApplicabilityError(node, args, c, assignableRelation, CheckMode.Normal, /*reportErrors*/ true, chain, /*inferenceContext*/ undefined);
                        if (diags) {
                            if (diags.length <= min) {
                                min = diags.length;
                                minIndex = i;
                            }
                            max = Math.max(max, diags.length);
                            allDiagnostics.push(diags);
                        }
                        else {
                            Debug.fail("No error for 3 or fewer overload signatures");
                        }
                        i++;
                    }

                    const diags = max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics);
                    Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures");
                    let chain = chainDiagnosticMessages(
                        map(diags, createDiagnosticMessageChainFromDiagnostic),
                        Diagnostics.No_overload_matches_this_call,
                    );
                    if (headMessage) {
                        chain = chainDiagnosticMessages(chain, headMessage);
                    }
                    // The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
                    // arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
                    const related = [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]];
                    let diag: Diagnostic;
                    if (every(diags, d => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file)) {
                        const { file, start, length } = diags[0];
                        diag = { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related };
                    }
                    else {
                        diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related);
                    }
                    addImplementationSuccessElaboration(candidatesForArgumentError[0], diag);
                    diagnostics.add(diag);
                }
            }
            else if (candidateForArgumentArityError) {
                diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args, headMessage));
            }
            else if (candidateForTypeArgumentError) {
                checkTypeArguments(candidateForTypeArgumentError, (node as CallExpression).typeArguments!, /*reportErrors*/ true, headMessage);
            }
            else {                
                const signaturesWithCorrectTypeArgumentArity = filter(signatures, s => hasCorrectTypeArgumentArity(s, typeArguments));
                if (signaturesWithCorrectTypeArgumentArity.length === 0) {
                    diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments!, headMessage));
                }
                else {
                    diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage));
                }
            }
        }

        return result;

        function addImplementationSuccessElaboration(failed: Signature, diagnostic: Diagnostic) {
            const oldCandidatesForArgumentError = candidatesForArgumentError;
            const oldCandidateForArgumentArityError = candidateForArgumentArityError;
            const oldCandidateForTypeArgumentError = candidateForTypeArgumentError;

            const failedSignatureDeclarations = failed.declaration?.symbol?.declarations || emptyArray;
            const isOverload = failedSignatureDeclarations.length > 1;
            const implDecl = isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined;
            if (implDecl) {
                const candidate = getSignatureFromDeclaration(implDecl as FunctionLikeDeclaration);
                const isSingleNonGenericCandidate = !candidate.typeParameters;
                if (chooseOverload([candidate], assignableRelation, isSingleNonGenericCandidate)) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible));
                }
            }

            candidatesForArgumentError = oldCandidatesForArgumentError;
            candidateForArgumentArityError = oldCandidateForArgumentArityError;
            candidateForTypeArgumentError = oldCandidateForTypeArgumentError;
        }

        function chooseOverload(candidates: Signature[], relation: Map<string, RelationComparisonResult>, isSingleNonGenericCandidate: boolean, signatureHelpTrailingComma = false) {
            candidatesForArgumentError = undefined;
            candidateForArgumentArityError = undefined;
            candidateForTypeArgumentError = undefined;

            if (isSingleNonGenericCandidate) {
                const candidate = candidates[0];
                if (some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                    return undefined;
                }
                if (getSignatureApplicabilityError(node, args, candidate, relation, CheckMode.Normal, /*reportErrors*/ false, /*containingMessageChain*/ undefined, /*inferenceContext*/ undefined)) {
                    candidatesForArgumentError = [candidate];
                    return undefined;
                }
                return candidate;
            }

            for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {
                let candidate = candidates[candidateIndex];
                if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                    continue;
                }

                let checkCandidate: Signature;
                let inferenceContext: InferenceContext | undefined;

                if (candidate.typeParameters) {
                    // If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,
                    // so our inference results for this call doesn't pollute expression types referencing the outer type parameter!
                    const paramLocation = candidate.typeParameters[0].symbol.declarations?.[0]?.parent;
                    const candidateParameterContext = paramLocation || (candidate.declaration && isConstructorDeclaration(candidate.declaration) ? candidate.declaration.parent : candidate.declaration);
                    if (candidateParameterContext && findAncestor(node, a => a === candidateParameterContext)) {
                        candidate = getImplementationSignature(candidate);
                    }
                    let typeArgumentTypes: readonly Type[] | undefined;
                    if (some(typeArguments)) {
                        typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors*/ false);
                        if (!typeArgumentTypes) {
                            candidateForTypeArgumentError = candidate;
                            continue;
                        }
                    }
                    else {
                        inferenceContext = createInferenceContext(candidate.typeParameters!, candidate, /*flags*/ isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);
                        // The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's
                        //  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.
                        typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper);
                        argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;
                    }
                    checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                    // If the original signature has a generic rest type, instantiation may produce a
                    // signature with different arity and we need to perform another arity check.
                    if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                        candidateForArgumentArityError = checkCandidate;
                        continue;
                    }
                }
                else {
                    checkCandidate = candidate;
                }
                if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined, inferenceContext)) {
                    // Give preference to error candidates that have no rest parameters (as they are more specific)
                    (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                    continue;
                }
                if (argCheckMode) {
                    // If one or more context sensitive arguments were excluded, we start including
                    // them now (and keeping do so for any subsequent candidates) and perform a second
                    // round of type inference and applicability checking for this particular candidate.
                    argCheckMode = CheckMode.Normal;
                    if (inferenceContext) {                        
                        const typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper);
                        checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);
                        // If the original signature has a generic rest type, instantiation may produce a
                        // signature with different arity and we need to perform another arity check.
                        if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
                            candidateForArgumentArityError = checkCandidate;
                            continue;
                        }
                    }
                    if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined, inferenceContext)) {
                        // Give preference to error candidates that have no rest parameters (as they are more specific)
                        (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                        continue;
                    }
                }
                candidates[candidateIndex] = checkCandidate;
                return checkCandidate;
            }

            return undefined;
        }
    }

    function getTypeArgumentArityError(node: Node, signatures: readonly Signature[], typeArguments: NodeArray<TypeNode>, headMessage?: DiagnosticMessage) {
        const argCount = typeArguments.length;
        // No overloads exist
        if (signatures.length === 1) {
            const sig = signatures[0];
            const min = getMinTypeArgumentCount(sig.typeParameters);
            const max = length(sig.typeParameters);
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Expected_0_type_arguments_but_got_1, min < max ? min + "-" + max : min, argCount);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, min < max ? min + "-" + max : min, argCount);
        }
        // Overloads exist
        let belowArgCount = -Infinity;
        let aboveArgCount = Infinity;
        for (const sig of signatures) {
            const min = getMinTypeArgumentCount(sig.typeParameters);
            const max = length(sig.typeParameters);
            if (min > argCount) {
                aboveArgCount = Math.min(aboveArgCount, min);
            }
            else if (max < argCount) {
                belowArgCount = Math.max(belowArgCount, max);
            }
        }
        if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
            if (headMessage) {
                let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
        }
        if (headMessage) {
            let chain = chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
            chain = chainDiagnosticMessages(chain, headMessage);
            return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
        }
        return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
    }

    function invocationErrorDetails(errorTarget: Node, apparentType: Type, kind: SignatureKind): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } {
        let errorInfo: DiagnosticMessageChain | undefined;
        const isCall = kind === SignatureKind.Call;                
        if (apparentType.flags & TypeFlags.Union) {
            const types = (apparentType as UnionType).types;
            let hasSignatures = false;
            for (const constituent of types) {
                const signatures = getSignaturesOfType(constituent, kind);
                if (signatures.length !== 0) {
                    hasSignatures = true;
                    if (errorInfo) {
                        // Bail early if we already have an error, no chance of "No constituent of type is callable"
                        break;
                    }
                }
                else {
                    // Error on the first non callable constituent only
                    if (!errorInfo) {
                        errorInfo = chainDiagnosticMessages(
                            errorInfo,
                            isCall ?
                                Diagnostics.Type_0_has_no_call_signatures :
                                Diagnostics.Type_0_has_no_construct_signatures,
                            typeToString(constituent),
                        );
                        errorInfo = chainDiagnosticMessages(
                            errorInfo,
                            isCall ?
                                Diagnostics.Not_all_constituents_of_type_0_are_callable :
                                Diagnostics.Not_all_constituents_of_type_0_are_constructable,
                            typeToString(apparentType),
                        );
                    }
                    if (hasSignatures) {
                        // Bail early if we already found a siganture, no chance of "No constituent of type is callable"
                        break;
                    }
                }
            }
            if (!hasSignatures) {
                errorInfo = chainDiagnosticMessages(
                    /*details*/ undefined,
                    isCall ?
                        Diagnostics.No_constituent_of_type_0_is_callable :
                        Diagnostics.No_constituent_of_type_0_is_constructable,
                    typeToString(apparentType),
                );
            }
            if (!errorInfo) {
                errorInfo = chainDiagnosticMessages(
                    errorInfo,
                    isCall ?
                        Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :
                        Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other,
                    typeToString(apparentType),
                );
            }
        }
        else {
            errorInfo = chainDiagnosticMessages(
                errorInfo,
                isCall ?
                    Diagnostics.Type_0_has_no_call_signatures :
                    Diagnostics.Type_0_has_no_construct_signatures,
                typeToString(apparentType),
            );
        }

        let headMessage = isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable;
        
        return {
            messageChain: chainDiagnosticMessages(errorInfo, headMessage),
            relatedMessage: undefined,
        };
    }

    function getDiagnosticSpanForCallNode(node: CallExpression) {
        const sourceFile = getSourceFileOrIncludeOfNode(node);
        const { start, length } = getErrorSpanForNode(sourceFile, isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression);
        return { start, length, sourceFile };
    }

    function invocationErrorRecovery(apparentType: Type, kind: SignatureKind, diagnostic: Diagnostic) {
        if (!apparentType.symbol) {
            return;
        }
        // TODO
        // const importNode = getSymbolLinks(apparentType.symbol).originatingImport;
        // // Create a diagnostic on the originating import if possible onto which we can attach a quickfix
        // //  An import call expression cannot be rewritten into another form to correct the error - the only solution is to use `.default` at the use-site
        // if (importNode && !isImportCall(importNode)) {
        //     const sigs = getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target!), kind);
        //     if (!sigs || !sigs.length) return;

        //     addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead));
        // }
    }

    function invocationError(errorTarget: Node, apparentType: Type, kind: SignatureKind, relatedInformation?: DiagnosticRelatedInformation) {
        const { messageChain, relatedMessage: relatedInfo } = invocationErrorDetails(errorTarget, apparentType, kind);
        const diagnostic = createDiagnosticForNodeFromMessageChain(getSourceFileOrIncludeOfNode(errorTarget), errorTarget, messageChain);
        if (relatedInfo) {
            addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo));
        }
        if (isCallExpression(errorTarget.parent)) {
            const { start, length } = getDiagnosticSpanForCallNode(errorTarget.parent);
            diagnostic.start = start;
            diagnostic.length = length;
        }
        diagnostics.add(diagnostic);
        invocationErrorRecovery(apparentType, kind, relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic);
    }

    function getSignaturesOfStructuredType(type: Type, kind: SignatureKind): readonly Signature[] {
        if (type.flags & TypeFlags.StructuredType) {
            const resolved = resolveStructuredTypeMembers(type as ObjectType);
            return kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures;
        }
        return emptyArray;
    }

    
    function forEachType<T>(type: Type, f: (t: Type) => T | undefined): T | undefined {
        return type.flags & TypeFlags.Union ? forEach((type as UnionType).types, f) : f(type);
    }

    function someType(type: Type, f: (t: Type) => boolean): boolean {
        return type.flags & TypeFlags.Union ? some((type as UnionType).types, f) : f(type);
    }

    function everyType(type: Type, f: (t: Type) => boolean): boolean {
        return type.flags & TypeFlags.Union ? every((type as UnionType).types, f) : f(type);
    }

    function everyContainedType(type: Type, f: (t: Type) => boolean): boolean {
        return type.flags & TypeFlags.UnionOrIntersection ? every((type as UnionOrIntersectionType).types, f) : f(type);
    }

    function isArrayOrTupleSymbol(symbol: Symbol | undefined) {        
        if (!symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol) {
            return false;
        }
        return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol);
    }

    /**
     * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
     * maps primitive types and type parameters are to their apparent types.
     */
    function getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[] {
        const result =  getSignaturesOfStructuredType(getReducedApparentType(type), kind);
        if (kind === SignatureKind.Call && !length(result) && type.flags & TypeFlags.Union) {
            if ((type as UnionType).arrayFallbackSignatures) {
                return (type as UnionType).arrayFallbackSignatures!;
            }
            // If the union is all different instantiations of a member of the global array type...
            let memberName: string;
            // TODO not sure we need this
            if (everyType(type, t => !!t.symbol?.parent && isArrayOrTupleSymbol(t.symbol.parent) && (!memberName ? (memberName = t.symbol.name, true) : memberName === t.symbol.name))) {
                // TODO - 
                // Transform the type from `(A[] | B[])["member"]` to `(A | B)[]["member"]` (since we pretend array is covariant anyway)
                // const arrayArg = mapType(type, t => getMappedType((isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters![0], (t as AnonymousType).mapper!));
                // const arrayType = createArrayType(arrayArg, someType(type, t => isReadonlyArraySymbol(t.symbol.parent)));
                // return (type as UnionType).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName!)!, kind);
                Debug.fail("TODO - implement me - getSignaturesOfType");
            }
            (type as UnionType).arrayFallbackSignatures = result;
        }
        return result || emptyArray;
    }

    function resolveErrorCall(node: CallLikeExpression): Signature {
        resolveUntypedCall(node);
        return unknownSignature;
    }

    function resolveSignature(node: CallLikeExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        switch (node.kind as SyntaxKind) {
            case SyntaxKind.CallExpression:
                return resolveCallExpression(node as CallExpression, candidatesOutArray, checkMode);
            case SyntaxKind.NewExpression:                
                return resolveNewExpression(node as NewExpression, candidatesOutArray, checkMode);            
            case SyntaxKind.InlineClosureExpression:
                return resolveInlineClosureExpression(node as InlineClosureExpression, candidatesOutArray, checkMode);
            case SyntaxKind.BinaryExpression:
                Debug.fail("implement me");
                //return resolveInstanceofExpression(node, candidatesOutArray, checkMode);
        }
        Debug.assertNever(node as never, "Branch in 'resolveSignature' should be unreachable.");
    }

    function resolveNewExpression(node: NewExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
        let expressionType = node.expression && isExpression(node.expression) ? checkNonNullExpression(node.expression) : anyType;
        if (expressionType === silentNeverType) {
            return silentNeverSignature;
        }

        // If expressionType's apparent type(section 3.8.1) is an object type with one or
        // more construct signatures, the expression is processed in the same manner as a
        // function call, but using the construct signatures as the initial set of candidate
        // signatures for overload resolution. The result type of the function call becomes
        // the result type of the operation.
        expressionType = getApparentType(expressionType);
        if (isErrorType(expressionType)) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }

        // TS 1.0 spec: 4.11
        // If expressionType is of type Any, Args can be any argument
        // list and the result of the operation is of type Any.
        if (isTypeAny(expressionType)) {
            if (node.typeArguments) {
                error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }

        console.debug("TODO - implement me - resolveNewExpression");

        // // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // // but we are not including construct signatures that may have been added to the Object or
        // // Function interface, since they have none by default. This is a bit of a leap of faith
        // // that the user will not add any.
        // const constructSignatures = getSignaturesOfType(expressionType, SignatureKind.Construct);
        // if (constructSignatures.length) {
        //     if (!isConstructorAccessible(node, constructSignatures[0])) {
        //         return resolveErrorCall(node);
        //     }
        //     // If the expression is a class of abstract type, or an abstract construct signature,
        //     // then it cannot be instantiated.
        //     // In the case of a merged class-module or class-interface declaration,
        //     // only the class declaration node will have the Abstract flag set.
        //     if (someSignature(constructSignatures, signature => !!(signature.flags & SignatureFlags.Abstract))) {
        //         error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
        //         return resolveErrorCall(node);
        //     }
        //     const valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol);
        //     if (valueDecl && hasSyntacticModifier(valueDecl, ModifierFlags.Abstract)) {
        //         error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
        //         return resolveErrorCall(node);
        //     }

        //     return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
        // }

        // // If expressionType's apparent type is an object type with no construct signatures but
        // // one or more call signatures, the expression is processed as a function call. A compile-time
        // // error occurs if the result of the function call is not Void. The type of the result of the
        // // operation is Any. It is an error to have a Void this type.
        // const callSignatures = getSignaturesOfType(expressionType, SignatureKind.Call);
        // if (callSignatures.length) {
        //     const signature = resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
        //     if (!noImplicitAny) {
        //         if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
        //             error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
        //         }
        //         if (getThisTypeOfSignature(signature) === voidType) {
        //             error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
        //         }
        //     }
        //     return signature;
        // }

        // invocationError(node.expression, expressionType, SignatureKind.Construct);
        // return resolveErrorCall(node);
    }
    
    function getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined {
        if (location && location.kind === SyntaxKind.ShorthandPropertyAssignment) {
            return resolveEntityName((location as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Alias);
        }
        return undefined;
    }

    function runWithInferenceBlockedFromSourceNode<T>(node: Node | undefined, fn: () => T): T {
        const containingCall = findAncestor(node, isCallLikeExpression);
        if (containingCall) {
            let toMarkSkip = node!;
            do {
                getNodeLinks(toMarkSkip).skipDirectInference = true;
                toMarkSkip = toMarkSkip.parent;
            }
            while (toMarkSkip && toMarkSkip !== containingCall);
        }

        isInferencePartiallyBlocked = true;
        const result = runWithoutResolvedSignatureCaching(node, fn);
        isInferencePartiallyBlocked = false;

        if (containingCall) {
            let toMarkSkip = node!;
            do {
                getNodeLinks(toMarkSkip).skipDirectInference = undefined;
                toMarkSkip = toMarkSkip.parent;
            }
            while (toMarkSkip && toMarkSkip !== containingCall);
        }
        return result;
    }

    function runWithoutResolvedSignatureCaching<T>(node: Node | undefined, fn: () => T): T {
        node = findAncestor(node, isCallLikeOrFunctionLikeExpression);
        if (node) {
            const cachedResolvedSignatures = [];
            const cachedTypes = [];
            while (node) {
                const nodeLinks = getNodeLinks(node);
                cachedResolvedSignatures.push([nodeLinks, nodeLinks.resolvedSignature] as const);
                nodeLinks.resolvedSignature = undefined;
                if (isFunctionExpressionOrArrowFunction(node)) {
                    const symbolLinks = getSymbolLinks(getSymbolOfDeclaration(node));
                    const type = symbolLinks.type;
                    cachedTypes.push([symbolLinks, type] as const);
                    symbolLinks.type = undefined;
                }
                node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression);
            }
            const result = fn();
            for (const [nodeLinks, resolvedSignature] of cachedResolvedSignatures) {
                nodeLinks.resolvedSignature = resolvedSignature;
            }
            for (const [symbolLinks, type] of cachedTypes) {
                symbolLinks.type = type;
            }
            return result;
        }
        return fn();
    }
}

const SymbolLinks = class implements SymbolLinks {
    declare _symbolLinksBrand: any;
};

/** @internal */
export function getNodeId(node: Node): number {
    if (!node.id) {
        node.id = nextNodeId;
        nextNodeId++;
    }
    return node.id;
}

function NodeLinks(this: NodeLinks) {
    this.flags = NodeCheckFlags.None;
}

/** @internal */
export const enum CheckMode {
    Normal = 0,                                     // Normal type checking
    Contextual = 1 << 0,                            // Explicitly assigned contextual type, therefore not cacheable
    Inferential = 1 << 1,                           // Inferential typing
    SkipContextSensitive = 1 << 2,                  // Skip context sensitive function expressions
    SkipGenericFunctions = 1 << 3,                  // Skip single signature generic functions
    IsForSignatureHelp = 1 << 4,                    // Call resolution for purposes of signature help
    RestBindingElement = 1 << 5,                    // Checking a type that is going to be used to determine the type of a rest binding element
                                                    //   e.g. in `const { a, ...rest } = foo`, when checking the type of `foo` to determine the type of `rest`,
                                                    //   we need to preserve generic types instead of substituting them for constraints
    TypeOnly = 1 << 6,                              // Called from getTypeOfExpression, diagnostics may be omitted
    StringLiteralAsObject = 1 << 7,                 // Stringl literals should be resolved to an object
}

/** @internal */
export function getSymbolId(symbol: Symbol): SymbolId {
    if (!symbol.id) {
        symbol.id = nextSymbolId;
        nextSymbolId++;
    }

    return symbol.id;
}

const enum IntersectionState {
    None = 0,
    Source = 1 << 0, // Source type is a constituent of an outer intersection
    Target = 1 << 1, // Target type is a constituent of an outer intersection
}

/** Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`. */
function isDeclarationNameOrImportPropertyName(name: Node): boolean {
    if (!name.parent) return undefined;
    
    switch (name.parent.kind) {
        // case SyntaxKind.ImportSpecifier:
        // case SyntaxKind.ExportSpecifier:
        //     return isIdentifier(name) || name.kind === SyntaxKind.StringLiteral;
        default:
            return isDeclarationName(name);
    }
}

/** @param containingNode Node to check for parse error */
type AddUnusedDiagnostic = (containingNode: Node, type: UnusedKind, diagnostic: DiagnosticWithLocation) => void;

const enum UnusedKind {
    Local,
    Parameter,
}

const enum WideningKind {
    Normal,
    FunctionReturn,
    GeneratorNext,
    GeneratorYield,
}

/** @internal */
export const enum TypeFacts {
    None = 0,
    TypeofEQString = 1 << 0,      // typeof x === "string"
    TypeofEQNumber = 1 << 1,      // typeof x === "number"
    TypeofEQFloat  = 1 << 2,      // typeof x === "float"
    TypeofEQBoolean = 1 << 3,     // typeof x === "boolean"
    TypeofEQSymbol = 1 << 4,      // typeof x === "symbol"
    TypeofEQObject = 1 << 5,      // typeof x === "object"
    TypeofEQFunction = 1 << 6,    // typeof x === "function"
    TypeofEQHostObject = 1 << 7,  // typeof x === "xxx"
    TypeofNEString = 1 << 8,      // typeof x !== "string"
    TypeofNENumber = 1 << 9,      // typeof x !== "number"
    TypeofNEBigInt = 1 << 10,     // typeof x !== "bigint"
    TypeofNEBoolean = 1 << 11,    // typeof x !== "boolean"
    TypeofNESymbol = 1 << 12,     // typeof x !== "symbol"
    TypeofNEObject = 1 << 13,     // typeof x !== "object"
    TypeofNEFunction = 1 << 14,   // typeof x !== "function"
    TypeofNEHostObject = 1 << 15, // typeof x !== "xxx"
    EQUndefined = 1 << 16,        // x === undefined
    EQNull = 1 << 17,             // x === null
    EQUndefinedOrNull = 1 << 18,  // x === undefined / x === null
    NEUndefined = 1 << 19,        // x !== undefined
    NENull = 1 << 20,             // x !== null
    NEUndefinedOrNull = 1 << 21,  // x != undefined / x != null
    Truthy = 1 << 22,             // x
    Falsy = 1 << 23,              // !x
    IsUndefined = 1 << 24,        // Contains undefined or intersection with undefined
    IsNull = 1 << 25,             // Contains null or intersection with null
    IsUndefinedOrNull = IsUndefined | IsNull,
    All = (1 << 27) - 1,
    // The following members encode facts about particular kinds of types for use in the getTypeFacts function.
    // The presence of a particular fact means that the given test is true for some (and possibly all) values
    // of that kind of type.
    BaseStringStrictFacts = TypeofEQString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseStringFacts = BaseStringStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    StringStrictFacts = BaseStringStrictFacts | Truthy | Falsy,
    StringFacts = BaseStringFacts | Truthy,
    BytesStrictFacts = BaseStringStrictFacts | Truthy | Falsy,
    BytesFacts = BaseStringFacts | Truthy,
    EmptyStringStrictFacts = BaseStringStrictFacts | Falsy,
    EmptyStringFacts = BaseStringFacts,
    NonEmptyStringStrictFacts = BaseStringStrictFacts | Truthy,
    NonEmptyStringFacts = BaseStringFacts | Truthy,
    BaseNumberStrictFacts = TypeofEQNumber | TypeofNEString | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseNumberFacts = BaseNumberStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    NumberStrictFacts = BaseNumberStrictFacts | Truthy | Falsy,
    NumberFacts = BaseNumberFacts | Truthy,
    ZeroNumberStrictFacts = BaseNumberStrictFacts | Falsy,
    ZeroNumberFacts = BaseNumberFacts,
    NonZeroNumberStrictFacts = BaseNumberStrictFacts | Truthy,
    NonZeroNumberFacts = BaseNumberFacts | Truthy,
    BaseBigIntStrictFacts = TypeofEQFloat | TypeofNEString | TypeofNENumber | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseBigIntFacts = BaseBigIntStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    BigIntStrictFacts = BaseBigIntStrictFacts | Truthy | Falsy,
    BigIntFacts = BaseBigIntFacts | Truthy,
    ZeroBigIntStrictFacts = BaseBigIntStrictFacts | Falsy,
    ZeroBigIntFacts = BaseBigIntFacts,
    NonZeroBigIntStrictFacts = BaseBigIntStrictFacts | Truthy,
    NonZeroBigIntFacts = BaseBigIntFacts | Truthy,
    BaseBooleanStrictFacts = TypeofEQBoolean | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull,
    BaseBooleanFacts = BaseBooleanStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    BooleanStrictFacts = BaseBooleanStrictFacts | Truthy | Falsy,
    BooleanFacts = BaseBooleanFacts | Truthy,
    FalseStrictFacts = BaseBooleanStrictFacts | Falsy,
    FalseFacts = BaseBooleanFacts,
    TrueStrictFacts = BaseBooleanStrictFacts | Truthy,
    TrueFacts = BaseBooleanFacts | Truthy,
    SymbolStrictFacts = TypeofEQSymbol | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | NEUndefined | NENull | NEUndefinedOrNull | Truthy,
    SymbolFacts = SymbolStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    ObjectStrictFacts = TypeofEQObject | TypeofEQHostObject | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEFunction | NEUndefined | NENull | NEUndefinedOrNull | Truthy,
    ObjectFacts = ObjectStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    FunctionStrictFacts = TypeofEQFunction | TypeofEQHostObject | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | NEUndefined | NENull | NEUndefinedOrNull | Truthy,
    FunctionFacts = FunctionStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
    VoidFacts = TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | EQUndefined | EQUndefinedOrNull | NENull | Falsy,
    UndefinedFacts = TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | TypeofNEHostObject | EQUndefined | EQUndefinedOrNull | NENull | Falsy | IsUndefined,
    NullFacts = TypeofEQObject | TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEFunction | TypeofNEHostObject | EQNull | EQUndefinedOrNull | NEUndefined | Falsy | IsNull,
    EmptyObjectStrictFacts = All & ~(EQUndefined | EQNull | EQUndefinedOrNull | IsUndefinedOrNull),
    EmptyObjectFacts = All & ~IsUndefinedOrNull,
    UnknownFacts = All & ~IsUndefinedOrNull,
    AllTypeofNE = TypeofNEString | TypeofNENumber | TypeofNEBigInt | TypeofNEBoolean | TypeofNESymbol | TypeofNEObject | TypeofNEFunction | NEUndefined,
    // Masks
    OrFactsMask = TypeofEQFunction | TypeofNEObject,
    AndFactsMask = All & ~OrFactsMask,
}

interface NodeBuilderContext {
    enclosingDeclaration: Node | undefined;
    /**
     * `enclosingFile` is generated from the initial `enclosingDeclaration` and
     * is used to ensure text ranges for generated nodes are not set based on nodes from outside
     * the original input's containing file. Checking the `enclosingDeclaration` at the time of
     * `setTextRange` is not sufficient, as the `enclosingDeclaration` is modified by the node builder
     * as it decends into some types as a shortcut to making certain scopes visible, and may be modified
     * into a declaration in a different file from the original input `enclosingDeclaration`!
     */
    enclosingFile: SourceFile | undefined;
    flags: NodeBuilderFlags;
    tracker: SymbolTrackerImpl;

    // State
    encounteredError: boolean;
    reportedDiagnostic: boolean;
    trackedSymbols: TrackedSymbol[] | undefined;
    visitedTypes: Set<number> | undefined;
    symbolDepth: Map<string, number> | undefined;
    inferTypeParameters: TypeParameter[] | undefined;
    approximateLength: number;
    truncating: boolean;
    mustCreateTypeParameterSymbolList: boolean;
    typeParameterSymbolList: Set<number> | undefined;
    mustCreateTypeParametersNamesLookups: boolean;
    typeParameterNames: Map<TypeId, Identifier> | undefined;
    typeParameterNamesByText: Set<string> | undefined;
    typeParameterNamesByTextNextNameCount: Map<string, number> | undefined;
    usedSymbolNames: Set<string> | undefined;
    remappedSymbolNames: Map<SymbolId, string> | undefined;
    remappedSymbolReferences: Map<SymbolId, Symbol> | undefined;
    reverseMappedStack: ReverseMappedSymbol[] | undefined;
    bundled: boolean;
    mapper: TypeMapper | undefined;
}

class SymbolTrackerImpl implements SymbolTracker {
    moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;
    context: NodeBuilderContext;

    readonly inner: SymbolTracker | undefined = undefined;
    readonly canTrackSymbol: boolean;
    disableTrackSymbol = false;

    constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {
        while (tracker instanceof SymbolTrackerImpl) {
            tracker = tracker.inner;
        }

        this.inner = tracker;
        this.moduleResolverHost = moduleResolverHost;
        this.context = context;
        this.canTrackSymbol = !!this.inner?.trackSymbol;
    }

    trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {
        if (this.inner?.trackSymbol && !this.disableTrackSymbol) {
            if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {
                this.onDiagnosticReported();
                return true;
            }
            // Skip recording type parameters as they dont contribute to late painted statements
            if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);
        }
        return false;
    }

    reportInaccessibleThisError(): void {
        if (this.inner?.reportInaccessibleThisError) {
            this.onDiagnosticReported();
            this.inner.reportInaccessibleThisError();
        }
    }

    reportPrivateInBaseOfClassExpression(propertyName: string): void {
        if (this.inner?.reportPrivateInBaseOfClassExpression) {
            this.onDiagnosticReported();
            this.inner.reportPrivateInBaseOfClassExpression(propertyName);
        }
    }

    reportInaccessibleUniqueSymbolError(): void {
        if (this.inner?.reportInaccessibleUniqueSymbolError) {
            this.onDiagnosticReported();
            this.inner.reportInaccessibleUniqueSymbolError();
        }
    }

    reportCyclicStructureError(): void {
        if (this.inner?.reportCyclicStructureError) {
            this.onDiagnosticReported();
            this.inner.reportCyclicStructureError();
        }
    }

    reportLikelyUnsafeImportRequiredError(specifier: string): void {
        if (this.inner?.reportLikelyUnsafeImportRequiredError) {
            this.onDiagnosticReported();
            this.inner.reportLikelyUnsafeImportRequiredError(specifier);
        }
    }

    reportTruncationError(): void {
        if (this.inner?.reportTruncationError) {
            this.onDiagnosticReported();
            this.inner.reportTruncationError();
        }
    }

    reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {
        if (this.inner?.reportNonlocalAugmentation) {
            this.onDiagnosticReported();
            this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);
        }
    }

    reportNonSerializableProperty(propertyName: string): void {
        if (this.inner?.reportNonSerializableProperty) {
            this.onDiagnosticReported();
            this.inner.reportNonSerializableProperty(propertyName);
        }
    }

    private onDiagnosticReported() {
        this.context.reportedDiagnostic = true;
    }

    reportInferenceFallback(node: Node): void {
        if (this.inner?.reportInferenceFallback) {
            this.inner.reportInferenceFallback(node);
        }
    }
}

function createBasicNodeBuilderModuleSpecifierResolutionHost(host: TypeCheckerHost): ModuleSpecifierResolutionHost {
    return {
        getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "",
        getCurrentDirectory: () => host.getCurrentDirectory(),
        //getSymlinkCache: maybeBind(host, host.getSymlinkCache),
        //getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(),
        useCaseSensitiveFileNames: maybeBind(host, host.useCaseSensitiveFileNames),
        //redirectTargetsMap: host.redirectTargetsMap,
        //getProjectReferenceRedirect: fileName => host.getProjectReferenceRedirect(fileName),
        //isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName),
        fileExists: fileName => host.fileExists(fileName),
        getFileIncludeReasons: () => host.getFileIncludeReasons(),
        readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined,
    };
}

const enum MembersOrExportsResolutionKind {
    resolvedExports = "resolvedExports",
    resolvedMembers = "resolvedMembers",
}

/** @internal */
export function signatureHasRestParameter(s: Signature) {
    return !!(s.flags & SignatureFlags.HasRestParameter);
}

const enum MinArgumentCountFlags {
    None = 0,
    StrongArityForUntypedJS = 1 << 0,
    VoidIsNonOptional = 1 << 1,
}

const enum ExpandingFlags {
    None = 0,
    Source = 1,
    Target = 1 << 1,
    Both = Source | Target,
}

const enum RecursionFlags {
    None = 0,
    Source = 1 << 0,
    Target = 1 << 1,
    Both = Source | Target,
}

const typeofNEFacts: ReadonlyMap<string, TypeFacts> = new Map(Object.entries({
    string: TypeFacts.TypeofNEString,
    number: TypeFacts.TypeofNENumber,
    bigint: TypeFacts.TypeofNEBigInt,
    boolean: TypeFacts.TypeofNEBoolean,
    symbol: TypeFacts.TypeofNESymbol,
    undefined: TypeFacts.NEUndefined,
    object: TypeFacts.TypeofNEObject,
    function: TypeFacts.TypeofNEFunction,
}));

function signatureHasLiteralTypes(s: Signature) {
    return !!(s.flags & SignatureFlags.HasLiteralTypes);
}

function signatureHasJsDoc(s: Signature) {
    return !!(s.flags & SignatureFlags.HasJsDoc);
}
